erpnext\projects\report\delayed_tasks_summary\delayed_tasks_summary.py:
│def execute(filters=None):
│	columns, data = [], []
│	data = get_data(filters)
│	columns = get_columns()
│	charts = get_chart_data(data)
│	return columns, data, None, charts
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_conditions(filters):
⋮...
│def get_chart_data(data):
⋮...

erpnext\projects\report\timesheet_billing_summary\timesheet_billing_summary.py:
│def execute(filters=None):
⋮...
│def get_data(filters, group_fieldname=None):
⋮...
│def get_columns(filters, group_fieldname=None):
⋮...
│def group_by(data, fieldname):
⋮...

erpnext\projects\doctype\project\project.py:
│def get_list_context(context=None):
⋮...
│def daily_reminder():
⋮...
│def get_projects_for_collect_progress(frequency, fields):
⋮...
│def send_project_update_email_to_users(project):
⋮...
│def allow_to_make_project_update(project, time, frequency):
⋮...
│def get_users_email(doc):
│	return [d.email for d in doc.users if frappe.db.get_value("User", d.user, "enabled")]
⋮...
│def calculate_total_purchase_cost(project: str | None = None):
⋮...
│def get_timeline_data(doctype: str, name: str) -> dict[int, int]:
⋮...
│def get_project_list(doctype, txt, filters, limit_start, limit_page_length=20, order_by="creation"):
⋮...
│def twice_daily_reminder():
⋮...
│def weekly_reminder():
⋮...
│def get_holiday_list(company=None):
⋮...
│class Project(Document):
⋮...
│	def onload(self):
⋮...
│	def before_print(self, settings=None):
│		self.onload()
⋮...
│	def validate(self):
⋮...
│	def copy_from_template(self):  # nosemgrep
⋮...
│	def create_task_from_template(self, task_details):
⋮...
│	def calculate_start_date(self, task_details):
│		self.start_date = add_days(self.expected_start_date, task_details.start)
│		self.start_date = self.update_if_holiday(self.start_date)
│		return self.start_date
⋮...
│	def calculate_end_date(self, task_details):
│		self.end_date = add_days(self.start_date, task_details.duration)
│		return self.update_if_holiday(self.end_date)
⋮...
│	def update_if_holiday(self, date):
│		holiday_list = self.holiday_list or get_holiday_list(self.company)
│		while is_holiday(holiday_list, date):
│			date = add_days(date, 1)
│		return date
⋮...
│	def dependency_mapping(self, template_tasks, project_tasks):
│		for project_task in project_tasks:
│			template_task = frappe.get_doc("Task", project_task.template_task)
│
│			self.check_depends_on_value(template_task, project_task, project_tasks)
│			self.check_for_parent_tasks(template_task, project_task, project_tasks)
⋮...
│	def check_depends_on_value(self, template_task, project_task, project_tasks):
⋮...
│	def check_for_parent_tasks(self, template_task, project_task, project_tasks):
⋮...
│	def is_row_updated(self, row, existing_task_data, fields):
⋮...
│	def update_project(self):
│		"""Called externally by Task"""
│		self.update_percent_complete()
│		self.update_costing()
│		self.db_update()
⋮...
│	def after_insert(self):
│		self.copy_from_template()  # nosemgrep
│		if self.sales_order:
│			frappe.db.set_value("Sales Order", self.sales_order, "project", self.name)
⋮...
│	def on_trash(self):
│		frappe.db.set_value("Sales Order", {"project": self.name}, "project", "")
⋮...
│	def update_percent_complete(self):
⋮...
│	def update_costing(self):
⋮...
│	def calculate_gross_margin(self):
⋮...
│	def update_purchase_costing(self):
│		total_purchase_cost = calculate_total_purchase_cost(self.name)
│		self.total_purchase_cost = total_purchase_cost and total_purchase_cost[0][0] or 0
⋮...
│	def update_sales_amount(self):
⋮...
│	def update_billed_amount(self):
│		self.total_billed_amount = self.get_billed_amount_from_parent() + self.get_billed_amount_from_child()
⋮...
│	def get_billed_amount_from_parent(self):
⋮...
│	def get_billed_amount_from_child(self):
⋮...
│	def after_rename(self, old_name, new_name, merge=False):
│		if old_name == self.copied_from:
│			frappe.db.set_value("Project", new_name, "copied_from", new_name)
⋮...
│	def send_welcome_email(self):
⋮...
│def get_users_for_project(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_cost_center_name(project):
│	return frappe.db.get_value("Project", project, "cost_center")
⋮...
│def hourly_reminder():
⋮...
│def project_status_update_reminder():
│	daily_reminder()
│	twice_daily_reminder()
│	weekly_reminder()
⋮...
│def create_duplicate_project(prev_doc, project_name):
⋮...
│def collect_project_status():
⋮...
│def send_project_status_email_to_users():
⋮...
│def update_project_sales_billing():
⋮...
│def create_kanban_board_if_not_exists(project):
⋮...
│def set_project_status(project, status):
⋮...
│def recalculate_project_total_purchase_cost(project: str | None = None):
⋮...

erpnext\projects\doctype\timesheet\timesheet.py:
│def make_sales_invoice(source_name, item_code=None, customer=None, currency=None):
⋮...
│def get_list_context(context=None):
⋮...
│class OverlapError(frappe.ValidationError):
│	pass
⋮...
│def get_events(start, end, filters=None):
⋮...
│def get_projectwise_timesheet_data(project=None, parent=None, from_time=None, to_time=None):
⋮...
│def get_activity_cost(employee=None, activity_type=None, currency=None):
⋮...
│def get_timesheets_list(doctype, txt, filters, limit_start, limit_page_length=20, order_by="creation"):
⋮...
│class OverWorkLoggedError(frappe.ValidationError):
│	pass
⋮...
│class Timesheet(Document):
⋮...
│	def validate(self):
⋮...
│	def calculate_hours(self):
│		for row in self.time_logs:
│			if row.to_time and row.from_time:
│				row.calculate_hours()
│				row.validate_billing_hours()
│				row.update_billing_hours()
⋮...
│	def calculate_total_amounts(self):
⋮...
│	def calculate_percentage_billed(self):
│		self.per_billed = 0
│		if self.total_billed_amount > 0 and self.total_billable_amount > 0:
│			self.per_billed = (self.total_billed_amount * 100) / self.total_billable_amount
│		elif self.total_billed_hours > 0 and self.total_billable_hours > 0:
│			self.per_billed = (self.total_billed_hours * 100) / self.total_billable_hours
⋮...
│	def update_billing_hours(self, args: "TimesheetDetail"):
│		args.update_billing_hours()
⋮...
│	def set_status(self):
⋮...
│	def set_dates(self):
⋮...
│	def before_cancel(self):
│		self.set_status()
⋮...
│	def on_cancel(self):
│		self.update_task_and_project()
⋮...
│	def on_submit(self):
│		self.validate_mandatory_fields()
│		self.update_task_and_project()
⋮...
│	def validate_mandatory_fields(self):
⋮...
│	def update_task_and_project(self):
⋮...
│	def validate_dates(self):
│		for time_log in self.time_logs:
│			time_log.validate_dates()
⋮...
│	def validate_time_logs(self):
⋮...
│	def validate_overlap(self, data):
│		settings = frappe.get_single("Projects Settings")
│		self.validate_overlap_for("user", data, self.user, settings.ignore_user_time_overlap)
│		self.validate_overlap_for("employee", data, self.employee, settings.ignore_employee_time_overlap)
⋮...
│	def set_project(self, data: "TimesheetDetail"):
│		data.set_project()
⋮...
│	def validate_project(self, data: "TimesheetDetail"):
│		data.validate_parent_project(self.parent_project)
⋮...
│	def validate_overlap_for(self, fieldname, args, value, ignore_validation=False):
⋮...
│	def get_overlap_for(self, fieldname, args, value):
⋮...
│	def check_internal_overlap(self, fieldname, args):
⋮...
│	def update_cost(self):
│		for time_log in self.time_logs:
│			time_log.update_cost(self.employee)
⋮...
│	def update_time_rates(self, ts_detail):
│		if not ts_detail.is_billable:
│			ts_detail.billing_rate = 0.0
⋮...
│	def unlink_sales_invoice(self, sales_invoice: str):
⋮...
│def get_timesheet_detail_rate(timelog, currency):
⋮...
│def get_timesheet(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_timesheet_data(name, project):
⋮...

erpnext\projects\report\daily_timesheet_summary\daily_timesheet_summary.py:
│def execute(filters=None):
⋮...
│def get_data(conditions, filters):
⋮...
│def get_conditions(filters):
⋮...
│def get_column():
⋮...

erpnext\projects\report\project_summary\project_summary.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_chart_data(data):
⋮...
│def get_report_summary(data):
⋮...

erpnext\projects\doctype\task\task.py:
│def get_project(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def make_timesheet(source_name, target_doc=None, ignore_permissions=False):
⋮...
│def get_children(doctype, parent, task=None, project=None, is_root=False):
⋮...
│def add_node():
⋮...
│class CircularReferenceError(frappe.ValidationError):
│	pass
⋮...
│def check_if_child_exists(name):
│	child_tasks = frappe.get_all("Task", filters={"parent_task": name})
│	child_tasks = [get_link_to_form("Task", task.name) for task in child_tasks]
│	return child_tasks
⋮...
│def set_tasks_as_overdue():
⋮...
│def on_doctype_update():
│	frappe.db.add_index("Task", ["lft", "rgt"])
⋮...
│class Task(NestedSet):
⋮...
│	def get_customer_details(self):
│		cust = frappe.db.sql("select customer_name from `tabCustomer` where name=%s", self.customer)
│		if cust:
│			ret = {"customer_name": cust and cust[0][0] or ""}
│			return ret
⋮...
│	def validate(self):
⋮...
│	def validate_dates(self):
│		self.validate_from_to_dates("exp_start_date", "exp_end_date")
│		self.validate_from_to_dates("act_start_date", "act_end_date")
│		self.validate_parent_expected_end_date()
│		self.validate_parent_project_dates()
⋮...
│	def set_default_end_date_if_missing(self):
│		if self.exp_start_date and self.expected_time:
│			self.exp_end_date = add_to_date(self.exp_start_date, hours=self.expected_time)
⋮...
│	def validate_parent_expected_end_date(self):
⋮...
│	def validate_parent_project_dates(self):
⋮...
│	def validate_status(self):
⋮...
│	def validate_progress(self):
│		if flt(self.progress or 0) > 100:
│			frappe.throw(_("Progress % for a task cannot be more than 100."))
│
│		if self.status == "Completed":
│			self.progress = 100
⋮...
│	def validate_dependencies_for_template_task(self):
│		if self.is_template:
│			self.validate_parent_template_task()
│			self.validate_depends_on_tasks()
⋮...
│	def validate_parent_template_task(self):
│		if self.parent_task:
│			if not frappe.db.get_value("Task", self.parent_task, "is_template"):
│				parent_task_format = f"""<a href="/app/task/{self.parent_task}">{self.parent_task}</a>"""
│				frappe.throw(_("Parent Task {0} is not a Template Task").format(parent_task_format))
⋮...
│	def validate_depends_on_tasks(self):
│		if self.depends_on:
│			for task in self.depends_on:
│				if not frappe.db.get_value("Task", task.task, "is_template"):
│					dependent_task_format = f"""<a href="/app/task/{task.task}">{task.task}</a>"""
│					frappe.throw(_("Dependent Task {0} is not a Template Task").format(dependent_task_format))
⋮...
│	def validate_completed_on(self):
│		if self.completed_on and getdate(self.completed_on) > getdate():
│			frappe.throw(_("Completed On cannot be greater than Today"))
⋮...
│	def update_depends_on(self):
│		depends_on_tasks = ""
│		for d in self.depends_on:
│			if d.task and d.task not in depends_on_tasks:
│				depends_on_tasks += d.task + ","
│		self.depends_on_tasks = depends_on_tasks
⋮...
│	def update_nsm_model(self):
│		frappe.utils.nestedset.update_nsm(self)
⋮...
│	def on_update(self):
⋮...
│	def unassign_todo(self):
│		if self.status == "Completed":
│			close_all_assignments(self.doctype, self.name)
│		if self.status == "Cancelled":
│			clear(self.doctype, self.name)
⋮...
│	def update_time_and_costing(self):
⋮...
│	def update_project(self):
│		if self.project and not self.flags.from_project:
│			frappe.get_cached_doc("Project", self.project).update_project()
⋮...
│	def check_recursion(self):
⋮...
│	def reschedule_dependent_tasks(self):
⋮...
│	def has_webform_permission(self):
│		project_user = frappe.db.get_value(
│			"Project User", {"parent": self.project, "user": frappe.session.user}, "user"
│		)
│		if project_user:
│			return True
⋮...
│	def populate_depends_on(self):
⋮...
│	def on_trash(self):
│		if check_if_child_exists(self.name):
│			throw(_("Child Task exists for this Task. You can not delete this Task."))
│
│		self.update_nsm_model()
⋮...
│	def after_delete(self):
│		self.update_project()
⋮...
│	def update_status(self):
⋮...
│def set_multiple_status(names, status):
│	names = json.loads(names)
│	for name in names:
│		task = frappe.get_doc("Task", name)
│		task.status = status
│		task.save()
⋮...
│def add_multiple_tasks(data, parent):
⋮...

erpnext\projects\report\project_wise_stock_tracking\project_wise_stock_tracking.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_project_details():
│	return frappe.db.sql(
│		""" select name, project_name, status, company, customer, estimated_costing,
│		expected_start_date, expected_end_date from tabProject where docstatus < 2""",
│		as_dict=1,
│	)
⋮...
│def get_purchased_items_cost():
⋮...
│def get_issued_items_cost():
⋮...
│def get_delivered_items_cost():
⋮...

erpnext\projects\doctype\project\project_dashboard.py:
│def get_data():
⋮...

erpnext\projects\doctype\project_template\project_template_dashboard.py:
│def get_data():
│	return {"fieldname": "project_template", "transactions": [{"items": ["Project"]}]}
⋮...

erpnext\projects\doctype\task\task_dashboard.py:
│def get_data():
⋮...

erpnext\projects\doctype\timesheet\timesheet_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "time_sheet",
│		"transactions": [{"label": _("References"), "items": ["Sales Invoice"]}],
│	}
⋮...

erpnext\projects\doctype\project\test_project.py:
│def get_project(name, template):
⋮...
│def make_project(args):
⋮...
│def task_exists(subject):
│	result = frappe.db.get_list("Task", filters={"subject": subject}, fields=["name"])
│	if not len(result):
│		return False
│	return frappe.get_doc("Task", result[0].name)
⋮...
│def calculate_end_date(project, start, duration):
│	start = add_days(project.expected_start_date, start)
│	start = project.update_if_holiday(start)
│	end = add_days(start, duration)
│	end = project.update_if_holiday(end)
│	return getdate(end)
⋮...
│class UnitTestProject(UnitTestCase):
⋮...
│class TestProject(IntegrationTestCase):
⋮...
│	def test_project_with_template_having_no_parent_and_depend_tasks(self):
⋮...
│	def test_project_template_having_parent_child_tasks(self):
⋮...
│	def test_project_template_having_dependent_tasks(self):
⋮...
│	def test_project_linking_with_sales_order(self):
⋮...
│	def test_project_with_template_tasks_having_common_name(self):
⋮...
│	def test_project_having_no_tasks_complete(self):
⋮...

erpnext\projects\doctype\timesheet\test_timesheet.py:
│def make_timesheet(
│	employee,
│	simulate=False,
│	is_billable=0,
│	activity_type="_Test Activity Type",
│	project=None,
│	task=None,
│	company=None,
│):
⋮...
│def update_activity_type(activity_type):
│	activity_type = frappe.get_doc("Activity Type", activity_type)
│	activity_type.billing_rate = 50.0
│	activity_type.save(ignore_permissions=True)
⋮...
│class TestTimesheet(IntegrationTestCase):
⋮...
│	def setUp(self):
│		frappe.db.delete("Timesheet")
⋮...
│	def test_timesheet_billing_amount(self):
⋮...
│	def test_timesheet_billing_amount_not_billable(self):
⋮...
│	def test_sales_invoice_from_timesheet(self):
⋮...
│	def test_timesheet_billing_based_on_project(self):
⋮...
│	def test_timesheet_time_overlap(self):
⋮...
│	def test_timesheet_not_overlapping_with_continuous_timelogs(self):
⋮...
│	def test_to_time(self):
⋮...
│	def test_per_billed_hours(self):
⋮...
│	def test_per_billed_amount(self):
⋮...

erpnext\projects\doctype\timesheet_detail\timesheet_detail.py:
│class TimesheetDetail(Document):
⋮...
│	def set_to_time(self):
│		"""Set to_time based on from_time and hours."""
│		if not (self.from_time and self.hours):
│			return
│
│		self.to_time = get_datetime(add_to_date(self.from_time, hours=self.hours, as_datetime=True))
⋮...
│	def set_project(self):
│		"""Set project based on task."""
│		if self.task and not self.project:
│			self.project = frappe.db.get_value("Task", self.task, "project")
⋮...
│	def calculate_hours(self):
│		"""Calculate hours based on from_time and to_time."""
│		if self.to_time and self.from_time:
│			self.hours = time_diff_in_hours(self.to_time, self.from_time)
⋮...
│	def update_billing_hours(self):
⋮...
│	def update_cost(self, employee: str):
⋮...
│	def validate_dates(self):
│		"""Validate that to_time is not before from_time."""
│		if self.from_time and self.to_time and time_diff_in_hours(self.to_time, self.from_time) < 0:
│			frappe.throw(_("To Time cannot be before from date"))
⋮...
│	def validate_parent_project(self, parent_project: str):
⋮...
│	def validate_task_project(self):
⋮...
│	def validate_billing_hours(self):
⋮...

erpnext\projects\doctype\task\test_task.py:
│def create_task(
│	subject,
│	start=None,
│	end=None,
│	depends_on=None,
│	project=None,
│	parent_task=None,
│	is_group=0,
│	is_template=0,
│	begin=0,
│	duration=0,
│	save=True,
│	priority=None,
│):
⋮...
│class TestTask(IntegrationTestCase):
⋮...
│	def test_circular_reference(self):
⋮...
│	def test_reschedule_dependent_task(self):
⋮...
│	def test_close_assignment(self):
⋮...
│	def test_overdue(self):
⋮...

erpnext\projects\doctype\activity_cost\activity_cost.py:
│class DuplicationError(frappe.ValidationError):
│	pass
⋮...
│class ActivityCost(Document):
⋮...
│	def validate(self):
│		self.set_title()
│		self.check_unique()
⋮...
│	def set_title(self):
⋮...
│	def check_unique(self):
⋮...

erpnext\projects\doctype\project_update\project_update.py:
│def daily_reminder():
⋮...
│def email_sending(project_name, frequency, date_start, date_end, progress, number_of_drafts, update):
⋮...
│class ProjectUpdate(Document):
⋮...

erpnext\projects\doctype\project_template\project_template.py:
│class ProjectTemplate(Document):
⋮...
│	def validate(self):
│		self.validate_dependencies()
⋮...
│	def validate_dependencies(self):
⋮...
│	def check_dependent_task_presence(self, task):
│		for task_details in self.tasks:
│			if task_details.task == task:
│				return True
│		return False
⋮...

erpnext\projects\report\delayed_tasks_summary\test_delayed_tasks_summary.py:
│class TestDelayedTasksSummary(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_delayed_tasks_summary(self):
⋮...
│	def tearDown(self):
│		for task in ["_Test Task 98", "_Test Task 99"]:
│			frappe.get_doc("Task", {"subject": task}).delete()
⋮...

erpnext\projects\doctype\project_template\test_project_template.py:
│def make_project_template(project_template_name, project_tasks=None):
⋮...
│class TestProjectTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\projects\doctype\activity_cost\test_activity_cost.py:
│class TestActivityCost(IntegrationTestCase):
⋮...
│	def test_duplication(self):
⋮...

erpnext\projects\doctype\project_type\project_type.py:
│class ProjectType(Document):
⋮...
│	def on_trash(self):
│		if self.name == "External":
│			frappe.throw(_("You cannot delete Project Type 'External'"))
⋮...

erpnext\projects\web_form\tasks\tasks.py:
│def get_context(context):
⋮...

erpnext\projects\doctype\project_user\project_user.py:
│class ProjectUser(Document):
⋮...

erpnext\projects\doctype\project_template_task\project_template_task.py:
│class ProjectTemplateTask(Document):
⋮...

erpnext\projects\doctype\task_depends_on\task_depends_on.py:
│class TaskDependsOn(Document):
⋮...

erpnext\projects\utils.py:
│def query_task(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\projects\doctype\activity_type\activity_type.py:
│class ActivityType(Document):
⋮...

erpnext\projects\doctype\dependent_task\dependent_task.py:
│class DependentTask(Document):
⋮...

erpnext\projects\doctype\projects_settings\projects_settings.py:
│class ProjectsSettings(Document):
⋮...

erpnext\projects\doctype\projects_settings\test_projects_settings.py:
│class TestProjectsSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\projects\doctype\project_type\test_project_type.py:
│class TestProjectType(IntegrationTestCase):
│	pass
⋮...

erpnext\projects\doctype\project_update\test_project_update.py:
│class TestProjectUpdate(IntegrationTestCase):
│	pass
⋮...

erpnext\projects\doctype\task_type\task_type.py:
│class TaskType(Document):
⋮...

erpnext\projects\doctype\task_type\test_task_type.py:
│class TestTaskType(IntegrationTestCase):
│	pass
⋮...


--- Related Dependencies ---


erpnext\__init__.py:
│def get_company_currency(company):
⋮...
│def get_default_company(user=None):
⋮...
│def get_default_cost_center(company):
⋮...
│def get_default_currency():
│	"""Returns the currency of the default company"""
│	company = get_default_company()
│	if company:
│		return frappe.get_cached_value("Company", company, "default_currency")
⋮...
│def get_region(company=None):
⋮...
│def set_perpetual_inventory(enable=1, company=None):
⋮...
│def encode_company_abbr(name, company=None, abbr=None):
⋮...
│def is_perpetual_inventory_enabled(company):
⋮...
│def get_default_finance_book(company=None):
⋮...
│def get_party_account_type(party_type):
⋮...
│def allow_regional(fn):
⋮...
│def check_app_permission():
⋮...
│def normalize_ctx_input(T: type) -> callable:
⋮...

erpnext\deprecation_dumpster.py:
│def deprecated(original: str, marked: str, graduation: str, msg: str, stacklevel: int = 1):
⋮...
│def deprecation_warning(marked: str, graduation: str, msg: str):
⋮...
│class ERPNextDeprecationError(Warning):
│	"""Deprecated feature in current version.
│
│	Raises an error by default but can be configured via PYTHONWARNINGS in an emergency.
│	"""
⋮...
│class ERPNextDeprecationWarning(Warning):
│	"""Deprecated feature in next version"""
⋮...
│class PendingERPNextDeprecationWarning(ERPNextDeprecationWarning):
⋮...
│def __get_deprecation_class(graduation: str | None = None, class_name: str | None = None) -> type:
⋮...
│class V15ERPNextDeprecationWarning(ERPNextDeprecationError):
│	pass
⋮...
│class V16ERPNextDeprecationWarning(ERPNextDeprecationWarning):
│	pass
⋮...
│class V17ERPNextDeprecationWarning(PendingERPNextDeprecationWarning):
│	pass
⋮...
│def taxes_and_totals_get_itemised_taxable_amount(items):
⋮...
│def get_pos_profile_item_details(company, ctx, pos_profile=None, update_data=False):
│	from erpnext.stock.get_item_details import get_pos_profile_item_details_
│
│	return get_pos_profile_item_details_(ctx, company, pos_profile=pos_profile, update_data=update_data)
⋮...
│def get_item_warehouse(item, ctx, overwrite_warehouse, defaults=None):
│	from erpnext.stock.get_item_details import get_item_warehouse_
│
│	return get_item_warehouse_(ctx, item, overwrite_warehouse, defaults=defaults)
⋮...

erpnext\setup\setup_wizard\operations\install_fixtures.py:
│def _(x, *args, **kwargs):
│	"""Redefine the translation function to return the string as is.
│
│	We want to create english records but still mark the strings as translatable.
│	The respective DocTypes have 'Translate Link Fields' enabled."""
│	return x
⋮...
│def create_bank_account(args):
⋮...
│def add_uom_data():
⋮...
│def get_fy_details(fy_start_date, fy_end_date):
⋮...
│def read_lines(filename: str) -> list[str]:
│	"""Return a list of lines from a file in the data directory."""
│	return (Path(__file__).parent.parent / "data" / filename).read_text().splitlines()
⋮...
│def install(country=None):
⋮...
│def update_selling_defaults():
⋮...
│def update_buying_defaults():
⋮...
│def update_item_variant_settings():
│	# set no copy fields of an item doctype to item variant settings
│	doc = frappe.get_doc("Item Variant Settings")
│	doc.set_default_fields()
│	doc.save()
⋮...
│def add_market_segments():
⋮...
│def add_sale_stages():
⋮...
│def install_company(args):
⋮...
│def install_defaults(args=None):  # nosemgrep
⋮...
│def set_global_defaults(args):
⋮...
│def update_stock_settings():
⋮...

erpnext\exceptions.py:
│class InvalidAccountDimensionError(frappe.ValidationError):
│	pass
⋮...
│class InvalidAccountCurrency(frappe.ValidationError):
│	pass
⋮...
│class InvalidCurrency(frappe.ValidationError):
│	pass
⋮...
│class MandatoryAccountDimensionError(frappe.ValidationError):
│	pass
⋮...
│class PartyDisabled(frappe.ValidationError):
│	pass
⋮...
│class PartyFrozen(frappe.ValidationError):
│	pass
⋮...

erpnext\accounts\report\consolidated_financial_statement\consolidated_financial_statement.py:
│def get_company_currency(filters=None):
│	return filters.get("presentation_currency") or frappe.get_cached_value(
│		"Company", filters.company, "default_currency"
│	)
⋮...
│def execute(filters=None):
⋮...
│def get_data(companies, root_type, balance_must_be, fiscal_year, filters=None, ignore_closing_entries=False):
⋮...
│def get_columns(companies, filters):
⋮...
│def prepare_data(accounts, start_date, end_date, balance_must_be, companies, company_currency, filters):
⋮...
│def get_opening_balance(account_name, data, company):
│	for row in data:
│		if row.get("account_name") == account_name:
│			return row.get("company_wise_opening_bal", {}).get(company, 0.0)
⋮...
│def accumulate_values_into_parents(accounts, accounts_by_name, companies):
⋮...
│def set_gl_entries_by_account(
│	from_date,
│	to_date,
│	root_lft,
│	root_rgt,
│	filters,
│	gl_entries_by_account,
│	accounts_by_name,
│	accounts,
│	ignore_closing_entries=False,
│	root_type=None,
│):
⋮...
│def get_account_details(account):
⋮...
│def filter_accounts(accounts, depth=10):
⋮...
│def calculate_values(accounts_by_name, gl_entries_by_account, companies, filters, fiscal_year):
⋮...
│def add_total_row(out, root_type, balance_must_be, companies, company_currency):
⋮...
│def get_income_expense_data(companies, fiscal_year, filters):
⋮...
│def get_account_type_based_data(account_type, companies, fiscal_year, filters):
⋮...
│def get_subsidiary_companies(company):
⋮...
│def get_accounts(root_type, companies):
⋮...
│def get_balance_sheet_data(fiscal_year, companies, columns, filters):
⋮...
│def prepare_companywise_opening_balance(asset_data, liability_data, equity_data, companies):
⋮...
│def get_root_account_name(root_type, company):
⋮...
│def get_profit_loss_data(fiscal_year, companies, columns, filters):
⋮...
│def get_cash_flow_data(fiscal_year, companies, filters):
⋮...
│def get_account_heads(root_type, companies, filters):
⋮...
│def update_parent_account_names(accounts):
⋮...
│def get_companies(filters):
⋮...
│def validate_entries(key, entry, accounts_by_name, accounts):
⋮...
│def get_additional_conditions(from_date, ignore_closing_entries, filters, d):
⋮...

erpnext\accounts\doctype\purchase_invoice\purchase_invoice.py:
│def make_stock_entry(source_name, target_doc=None):
⋮...
│def make_purchase_receipt(source_name, target_doc=None):
⋮...
│def get_list_context(context=None):
⋮...
│class PurchaseInvoice(BuyingController):
⋮...
│def make_debit_note(source_name, target_doc=None):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("Purchase Invoice", source_name, target_doc)
⋮...
│class WarehouseMissingError(frappe.ValidationError):
│	pass
⋮...
│def get_purchase_document_details(doc):
⋮...
│def make_regional_gl_entries(gl_entries, doc):
│	return gl_entries
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def onload(self):
⋮...
│	def before_save(self):
│		if not self.on_hold:
│			self.release_date = ""
⋮...
│	def invoice_is_blocked(self):
│		return self.on_hold and (not self.release_date or self.release_date > getdate(nowdate()))
⋮...
│	def validate(self):
⋮...
│	def set_percentage_received(self):
⋮...
│	def validate_release_date(self):
│		if self.release_date and getdate(nowdate()) >= getdate(self.release_date):
│			frappe.throw(_("Release date must be in the future"))
⋮...
│	def validate_cash(self):
⋮...
│	def create_remarks(self):
⋮...
│	def set_missing_values(self, for_validate=False):
⋮...
│	def validate_credit_to_acc(self):
⋮...
│	def check_on_hold_or_closed_status(self):
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def validate_warehouse(self, for_validate=True):
⋮...
│	def validate_item_code(self):
│		for d in self.get("items"):
│			if not d.item_code:
│				frappe.msgprint(_("Item Code required at Row No {0}").format(d.idx), raise_exception=True)
⋮...
│	def set_expense_account(self, for_validate=False):
⋮...
│	def validate_expense_account(self):
│		for item in self.get("items"):
│			validate_account_head(item.idx, item.expense_account, self.company, _("Expense"))
⋮...
│	def set_against_expense_account(self, force=False):
⋮...
│	def force_set_against_expense_account(self):
│		self.set_against_expense_account()
│		frappe.db.set_value(self.doctype, self.name, "against_expense_account", self.against_expense_account)
⋮...
│	def po_required(self):
⋮...
│	def pr_required(self):
⋮...
│	def validate_write_off_account(self):
│		if self.write_off_amount and not self.write_off_account:
│			throw(_("Please enter Write Off Account"))
⋮...
│	def check_prev_docstatus(self):
⋮...
│	def update_status_updater_args(self):
⋮...
│	def validate_purchase_receipt_if_update_stock(self):
⋮...
│	def validate_for_repost(self):
│		self.validate_write_off_account()
│		self.validate_expense_account()
│		validate_docs_for_voucher_types(["Purchase Invoice"])
│		validate_docs_for_deferred_accounting([], [self.name])
⋮...
│	def before_submit(self):
│		self.create_remarks()
⋮...
│	def on_submit(self):
⋮...
│	def on_update_after_submit(self):
⋮...
│	def make_gl_entries(self, gl_entries=None, from_repost=False):
⋮...
│	def cancel_provisional_entries(self):
⋮...
│	def update_supplier_outstanding(self, update_outstanding):
⋮...
│	def get_gl_entries(self, warehouse_account=None):
⋮...
│	def check_asset_cwip_enabled(self):
⋮...
│	def make_supplier_gl_entry(self, gl_entries):
⋮...
│	def add_supplier_gl_entry(
│		self, gl_entries, base_grand_total, grand_total, against_account=None, remarks=None, skip_merge=False
│	):
⋮...
│	def make_item_gl_entries(self, gl_entries):
⋮...
│	def get_provisional_accounts(self):
⋮...
│	def make_provisional_gl_entry(self, gl_entries, item):
⋮...
│	def update_gross_purchase_amount_for_linked_assets(self, item):
⋮...
│	def make_stock_adjustment_entry(self, gl_entries, item, voucher_wise_stock_value, account_currency):
⋮...
│	def make_tax_gl_entries(self, gl_entries):
⋮...
│	def make_internal_transfer_gl_entries(self, gl_entries):
⋮...
│	def make_gl_entries_for_tax_withholding(self, gl_entries):
⋮...
│	def make_payment_gl_entries(self, gl_entries):
⋮...
│	def make_write_off_gl_entry(self, gl_entries):
⋮...
│	def make_gle_for_rounding_adjustment(self, gl_entries):
⋮...
│	def on_cancel(self):
⋮...
│	def update_project(self):
⋮...
│	def validate_supplier_invoice(self):
⋮...
│	def update_billing_status_in_pr(self, update_modified=True):
⋮...
│	def get_pr_details_billed_amt(self):
⋮...
│	def on_recurring(self, reference_doc, auto_repeat_doc):
│		self.due_date = None
⋮...
│	def block_invoice(self, hold_comment=None, release_date=None):
│		self.db_set("on_hold", 1)
│		self.db_set("hold_comment", cstr(hold_comment))
│		self.db_set("release_date", release_date)
⋮...
│	def unblock_invoice(self):
│		self.db_set("on_hold", 0)
│		self.db_set("release_date", None)
⋮...
│	def set_tax_withholding(self):
⋮...
│	def allocate_advance_tds(self, tax_withholding_details, advance_taxes):
⋮...
│	def update_advance_tax_references(self, cancel=0):
⋮...
│	def set_status(self, update=False, status=None, update_modified=True):
⋮...
│def change_release_date(name, release_date=None):
│	if frappe.db.exists("Purchase Invoice", name):
│		pi = frappe.get_doc("Purchase Invoice", name)
│		pi.db_set("release_date", release_date)
⋮...
│def unblock_invoice(name):
│	if frappe.db.exists("Purchase Invoice", name):
│		pi = frappe.get_doc("Purchase Invoice", name)
│		pi.unblock_invoice()
⋮...
│def block_invoice(name, release_date, hold_comment=None):
│	if frappe.db.exists("Purchase Invoice", name):
│		pi = frappe.get_doc("Purchase Invoice", name)
│		pi.block_invoice(hold_comment, release_date)
⋮...
│def make_inter_company_sales_invoice(source_name, target_doc=None):
│	from erpnext.accounts.doctype.sales_invoice.sales_invoice import make_inter_company_transaction
│
│	return make_inter_company_transaction("Purchase Invoice", source_name, target_doc)
⋮...

erpnext\manufacturing\doctype\work_order\work_order.py:
│def make_stock_entry(work_order_id, purpose, qty=None, target_warehouse=None):
⋮...
│def get_item_details(item, project=None, skip_bom_info=False, throw=True):
⋮...
│def create_pick_list(source_name, target_doc=None, for_qty=None):
⋮...
│def cancel_stock_reservation_entries(doc, sre_list):
⋮...
│class OverProductionError(frappe.ValidationError):
│	pass
⋮...
│class CapacityError(frappe.ValidationError):
│	pass
⋮...
│class StockOverProductionError(frappe.ValidationError):
│	pass
⋮...
│def create_job_card(work_order, row, enable_capacity_planning=False, auto_create=False):
⋮...
│def get_reserved_qty_for_production(
│	item_code: str,
⋮...
│class ItemHasVariantError(frappe.ValidationError):
│	pass
⋮...
│class WorkOrder(Document):
⋮...
│def make_stock_reservation_entries(doc, items=None, notify=False):
⋮...
│def add_variant_item(variant_items, wo_doc, bom_no, table_name="items"):
⋮...
│def check_if_scrap_warehouse_mandatory(bom_no):
⋮...
│def make_job_card(work_order, operations):
⋮...
│def close_work_order(work_order, status):
⋮...
│def split_qty_based_on_batch_size(wo_doc, row, qty):
⋮...
│def get_row_wise_serial_batch(work_order, purpose=None):
⋮...
│class OperationTooLongError(frappe.ValidationError):
│	pass
⋮...
│class SerialNoQtyError(frappe.ValidationError):
│	pass
⋮...
│	def onload(self):
⋮...
│	def show_create_job_card_button(self):
⋮...
│	def validate(self):
⋮...
│	def validate_fg_warehouse_for_reservation(self):
⋮...
│	def set_reserve_stock(self):
│		for row in self.required_items:
│			row.reserve_stock = self.reserve_stock
⋮...
│	def enable_auto_reserve_stock(self):
│		if self.is_new() and frappe.db.get_single_value("Stock Settings", "auto_reserve_stock"):
│			self.reserve_stock = 1
⋮...
│	def set_warehouses(self):
│		for row in self.required_items:
│			if not row.source_warehouse:
│				row.source_warehouse = self.source_warehouse
⋮...
│	def reset_use_multi_level_bom(self):
⋮...
│	def validate_workstation_type(self):
⋮...
│	def validate_sales_order(self):
⋮...
│	def check_sales_order_on_hold_or_close(self):
│		status = frappe.db.get_value("Sales Order", self.sales_order, "status")
│		if status in ("Closed", "On Hold"):
│			frappe.throw(_("Sales Order {0} is {1}").format(self.sales_order, status))
⋮...
│	def set_default_warehouse(self):
│		if not self.wip_warehouse and not self.skip_transfer:
│			self.wip_warehouse = frappe.db.get_single_value("Manufacturing Settings", "default_wip_warehouse")
│		if not self.fg_warehouse:
│			self.fg_warehouse = frappe.db.get_single_value("Manufacturing Settings", "default_fg_warehouse")
⋮...
│	def check_wip_warehouse_skip(self):
│		if self.skip_transfer and not self.from_wip_warehouse:
│			self.wip_warehouse = None
⋮...
│	def validate_warehouse_belongs_to_company(self):
⋮...
│	def calculate_operating_cost(self):
⋮...
│	def validate_work_order_against_so(self):
⋮...
│	def update_status(self, status=None):
⋮...
│	def get_status(self, status=None):
⋮...
│	def update_work_order_qty(self):
⋮...
│	def get_transferred_or_manufactured_qty(self, purpose):
⋮...
│	def set_process_loss_qty(self):
⋮...
│	def update_production_plan_status(self):
⋮...
│	def validate_warehouse(self):
⋮...
│	def before_submit(self):
│		self.create_serial_no_batch_no()
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def update_stock_reservation(self):
│		make_stock_reservation_entries(self)
│		self.db_set("status", self.get_status())
⋮...
│	def create_serial_no_batch_no(self):
⋮...
│	def create_batch_for_finished_good(self):
⋮...
│	def delete_auto_created_batch_and_serial_no(self):
│		for row in frappe.get_all("Serial No", filters={"work_order": self.name}):
│			frappe.delete_doc("Serial No", row.name)
│
│		for row in frappe.get_all("Batch", filters={"reference_name": self.name}):
│			frappe.delete_doc("Batch", row.name)
⋮...
│	def make_serial_nos(self, args):
⋮...
│	def create_job_card(self):
⋮...
│	def prepare_data_for_job_card(self, row, index, plan_days, enable_capacity_planning):
⋮...
│	def set_operation_start_end_time(self, idx, row):
⋮...
│	def validate_cancel(self):
⋮...
│	def update_planned_qty(self):
⋮...
│	def set_produced_qty_for_sub_assembly_item(self):
⋮...
│	def update_ordered_qty(self):
⋮...
│	def update_work_order_qty_in_so(self):
⋮...
│	def update_work_order_qty_in_combined_so(self):
⋮...
│	def update_completed_qty_in_material_request(self):
│		if self.material_request and self.material_request_item:
│			frappe.get_doc("Material Request", self.material_request).update_completed_qty(
│				[self.material_request_item]
│			)
⋮...
│	def set_work_order_operations(self):
⋮...
│	def calculate_time(self):
│		for d in self.get("operations"):
│			if not d.fixed_time:
│				d.time_in_mins = flt(d.time_in_mins) * (flt(self.qty) / flt(d.batch_size))
│
│		self.calculate_operating_cost()
⋮...
│	def get_holidays(self, workstation):
⋮...
│	def update_operation_status(self):
⋮...
│	def set_actual_dates(self):
⋮...
│	def set_lead_time(self):
│		if self.actual_start_date and self.actual_end_date:
│			self.lead_time = flt(time_diff_in_hours(self.actual_end_date, self.actual_start_date) * 60)
⋮...
│	def delete_job_card(self):
│		for d in frappe.get_all("Job Card", ["name"], {"work_order": self.name}):
│			frappe.delete_doc("Job Card", d.name)
⋮...
│	def validate_production_item(self):
│		if frappe.get_cached_value("Item", self.production_item, "has_variants"):
│			frappe.throw(_("Work Order cannot be raised against a Item Template"), ItemHasVariantError)
│
│		if self.production_item:
│			validate_end_of_life(self.production_item)
⋮...
│	def validate_qty(self):
⋮...
│	def validate_transfer_against(self):
⋮...
│	def validate_operation_time(self):
│		for d in self.operations:
│			if d.time_in_mins <= 0:
│				frappe.throw(_("Operation Time must be greater than 0 for Operation {0}").format(d.operation))
⋮...
│	def update_required_items(self):
⋮...
│	def update_reserved_qty_for_production(self, items=None):
│		"""update reserved_qty_for_production in bins"""
│		for d in self.required_items:
│			if d.source_warehouse:
│				stock_bin = get_bin(d.item_code, d.source_warehouse)
│				stock_bin.update_reserved_qty_for_production()
⋮...
│	def get_items_and_operations_from_bom(self):
│		self.set_required_items()
│		self.set_work_order_operations()
│
│		return check_if_scrap_warehouse_mandatory(self.bom_no)
⋮...
│	def set_available_qty(self):
⋮...
│	def set_required_items(self, reset_only_qty=False):
⋮...
│	def update_transferred_qty_for_required_items(self):
⋮...
│	def update_qty_in_stock_reservation(self, row, transferred_qty, row_wise_serial_batch):
⋮...
│	def update_returned_qty(self):
⋮...
│	def update_consumed_qty_for_required_items(self):
⋮...
│	def update_consumed_qty_in_stock_reservation(self, item, consumed_qty, wip_warehouse):
⋮...
│	def validate_reserved_qty(self):
⋮...
│	def make_bom(self):
⋮...
│	def set_reserved_qty_for_wip_and_fg(self, stock_entry):
⋮...
│	def get_list_of_materials_for_reservation(self, stock_entry):
⋮...
│	def get_finished_goods_for_reservation(self, stock_entry):
⋮...
│	def get_so_details(self):
⋮...
│	def get_voucher_details(self, stock_entry):
⋮...
│	def cancel_reserved_qty_for_wip_and_fg(self, ste_doc):
⋮...
│def get_sre_details(work_order):
⋮...
│def get_consumed_qty(work_order, item_code):
⋮...
│def get_bom_operations(doctype, txt, searchfield, start, page_len, filters):
│	if txt:
│		filters["operation"] = ("like", "%%%s%%" % txt)
│
│	return frappe.get_all("BOM Operation", filters=filters, fields=["operation"], as_list=1)
⋮...
│def make_work_order(bom_no, item, qty=0, project=None, variant_items=None, use_multi_level_bom=None):
⋮...
│def get_template_rm_item(wo_doc, item_code):
│	for row in wo_doc.required_items:
│		if row.item_code == item_code:
│			return row
⋮...
│def set_work_order_ops(name):
│	po = frappe.get_doc("Work Order", name)
│	po.set_work_order_operations()
│	po.save()
⋮...
│def get_default_warehouse():
⋮...
│def stop_unstop(work_order, status):
⋮...
│def query_sales_order(production_item):
⋮...
│def get_operation_details(name, work_order):
⋮...
│def get_serial_nos_for_job_card(row, wo_doc):
⋮...
│def get_serial_nos_for_work_order(work_order, production_item):
⋮...
│def validate_operation_data(row):
⋮...
│def get_work_order_operation_data(work_order, operation, workstation):
│	for d in work_order.operations:
│		if d.operation == operation and d.workstation == workstation:
│			return d
⋮...
│def make_stock_return_entry(work_order):
⋮...

erpnext\stock\get_item_details.py:
│def get_default_cost_center(ctx: ItemDetailsCtx, item=None, item_group=None, brand=None, company=None):
⋮...
│def get_item_details(
│	ctx: ItemDetailsCtx, doc=None, for_validate=False, overwrite_warehouse=True
⋮...
│def get_batch_qty(batch_no, warehouse, item_code):
│	from erpnext.stock.doctype.batch import batch
│
│	if batch_no:
│		return {"actual_batch_qty": batch.get_batch_qty(batch_no, warehouse)}
⋮...
│def get_conversion_factor(item_code, uom):
⋮...
│def get_bin_details(item_code, warehouse, company=None, include_child_warehouses=False):
⋮...
│def get_valuation_rate(item_code, company, warehouse=None):
⋮...
│def get_price_list_rate_for(ctx: ItemDetailsCtx, item_code):
⋮...
│def get_item_tax_map(*, doc: str | dict | Document, tax_template: str | None = None, as_json=True):
⋮...
│def get_default_bom(item_code=None):
⋮...
│def get_item_warehouse_(ctx: ItemDetailsCtx, item, overwrite_warehouse, defaults=None):
⋮...
│def get_price_list_rate(ctx: ItemDetailsCtx, item_doc, out: ItemDetails = None):
⋮...
│def get_item_price(
│	pctx: ItemPriceCtx | dict, item_code, ignore_party=False, force_batch_no=False
⋮...
│def get_item_tax_template(ctx: ItemDetailsCtx, item, out: ItemDetails):
⋮...
│def _get_item_tax_template(
│	ctx: ItemDetailsCtx, taxes, out: ItemDetails | None = None, for_validate=False
⋮...
│def validate_conversion_rate(ctx: ItemDetailsCtx, meta):
⋮...
│def get_pos_profile_item_details_(ctx: ItemDetailsCtx, company, pos_profile=None, update_data=False):
⋮...
│def get_pos_profile(company, pos_profile=None, user=None):
⋮...
│def _preprocess_ctx(ctx):
⋮...
│def update_stock(ctx, out, doc=None):
⋮...
│def get_filtered_serial_nos(serial_nos, doc):
⋮...
│def get_item_code(barcode=None, serial_no=None):
⋮...
│def get_barcode_data(items_list=None, item_code=None):
⋮...
│def get_default_expense_account(ctx: ItemDetailsCtx, item, item_group, brand):
⋮...
│def insert_item_price(ctx: ItemDetailsCtx):
⋮...
│def get_price_list_currency_and_exchange_rate(ctx: ItemDetailsCtx):
⋮...
│def remove_standard_fields(out: ItemDetails):
│	for key in child_table_fields + default_fields:
│		out.pop(key, None)
│	return out
⋮...
│def set_valuation_rate(out: ItemDetails | dict, ctx: ItemDetailsCtx):
⋮...
│def has_incorrect_serial_nos(ctx, out):
⋮...
│def filter_batches(batches, doc):
│	for row in doc.get("items"):
│		if row.get("batch_no") in batches:
│			batches[row.get("batch_no")] -= row.get("qty")
│			if batches[row.get("batch_no")] <= 0:
│				del batches[row.get("batch_no")]
⋮...
│def update_bin_details(ctx: ItemDetailsCtx, out: ItemDetails, doc):
⋮...
│def validate_item_details(ctx: ItemDetailsCtx, item):
⋮...
│def get_basic_details(ctx: ItemDetailsCtx, item, overwrite_warehouse=True) -> ItemDetails:
⋮...
│def update_barcode_value(out):
│	barcode_data = get_barcode_data([out])
│
│	# If item has one barcode then update the value of the barcode field
│	if barcode_data and len(barcode_data.get(out.item_code)) == 1:
│		out["barcode"] = barcode_data.get(out.item_code)[0]
⋮...
│def get_item_tax_info(doc, tax_category, item_codes, item_rates=None, item_tax_templates=None):
⋮...
│def is_within_valid_range(ctx: ItemDetailsCtx, tax) -> bool:
⋮...
│def calculate_service_end_date(ctx: ItemDetailsCtx, item=None):
⋮...
│def get_default_income_account(ctx: ItemDetailsCtx, item, item_group, brand):
⋮...
│def get_provisional_account(ctx: ItemDetailsCtx, item, item_group, brand):
⋮...
│def get_default_discount_account(ctx: ItemDetailsCtx, item, item_group, brand):
⋮...
│def get_default_deferred_account(ctx: ItemDetailsCtx, item, fieldname=None):
⋮...
│def get_default_supplier(_ctx: ItemDetailsCtx, item, item_group, brand):
│	return item.get("default_supplier") or item_group.get("default_supplier") or brand.get("default_supplier")
⋮...
│def get_batch_based_item_price(pctx: ItemPriceCtx | dict | str, item_code) -> float:
⋮...
│def check_packing_list(price_list_rate_name, desired_qty, item_code):
⋮...
│def get_party_item_code(ctx: ItemDetailsCtx, item_doc, out: ItemDetails):
⋮...
│def get_projected_qty(item_code, warehouse):
│	return {
│		"projected_qty": frappe.db.get_value(
│			"Bin", {"item_code": item_code, "warehouse": warehouse}, "projected_qty"
│		)
│	}
⋮...
│def get_company_total_stock(item_code, company):
⋮...
│def apply_price_list(ctx: ItemDetailsCtx, as_doc=False, doc=None):
⋮...
│def apply_price_list_on_item(ctx, doc=None):
│	item_doc = frappe.db.get_value("Item", ctx.item_code, ["name", "variant_of"], as_dict=1)
│	item_details = get_price_list_rate(ctx, item_doc)
│	item_details.update(get_pricing_rule_for_item(ctx, doc=doc))
│
│	return item_details
⋮...
│def get_gross_profit(out: ItemDetails):
│	if out.valuation_rate:
│		out.update({"gross_profit": ((out.base_rate - out.valuation_rate) * out.stock_qty)})
│
│	return out
⋮...
│def get_serial_no(_args, serial_nos=None, sales_order=None):
│	serial_nos = serial_nos or []
│	return serial_nos
⋮...
│def update_party_blanket_order(ctx: ItemDetailsCtx, out: ItemDetails | dict):
│	if out["against_blanket_order"]:
│		blanket_order_details = get_blanket_order_details(ctx)
│		if blanket_order_details:
│			out.update(blanket_order_details)
⋮...
│def get_blanket_order_details(ctx: ItemDetailsCtx):
⋮...

erpnext\stock\report\stock_analytics\stock_analytics.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details(items, sle):
⋮...
│def get_chart_data(columns):
│	labels = [d.get("label") for d in columns[5:]]
│	chart = {"data": {"labels": labels, "datasets": []}}
│	chart["type"] = "line"
│
│	return chart
⋮...
│def get_items(filters):
⋮...
│def get_stock_ledger_entries(filters, items):
⋮...
│def get_period_date_ranges(filters):
⋮...
│def get_period(posting_date, filters):
⋮...
│def apply_conditions(query, filters):
⋮...
│def get_periodic_data(entry, filters):
⋮...
│def round_down_to_nearest_frequency(date: str, frequency: str) -> datetime.datetime:
⋮...
│def fill_intermediate_periods(
│	periodic_data, item_code: str, current_period: str, all_periods: list[str]
⋮...

erpnext\stock\doctype\material_request\material_request.py:
│def make_stock_entry(source_name, target_doc=None):
⋮...
│def create_pick_list(source_name, target_doc=None):
⋮...
│def set_missing_values(source, target_doc):
│	if target_doc.doctype == "Purchase Order" and getdate(target_doc.schedule_date) < getdate(nowdate()):
│		target_doc.schedule_date = None
│	target_doc.run_method("set_missing_values")
│	target_doc.run_method("calculate_taxes_and_totals")
⋮...
│def update_item(obj, target, source_parent):
⋮...
│def get_list_context(context=None):
⋮...
│def make_purchase_order(source_name, target_doc=None, args=None):
⋮...
│def make_request_for_quotation(source_name, target_doc=None):
⋮...
│def update_status(name, status):
│	material_request = frappe.get_doc("Material Request", name)
│	material_request.check_permission("write")
│	material_request.update_status(status)
⋮...
│def raise_work_orders(material_request):
⋮...
│def get_items_based_on_default_supplier(supplier):
⋮...
│def make_supplier_quotation(source_name, target_doc=None):
⋮...
│class MaterialRequest(BuyingController):
⋮...
│	def check_if_already_pulled(self):
│		pass
⋮...
│	def validate_qty_against_so(self):
⋮...
│	def validate(self):
⋮...
│	def validate_pp_qty(self):
⋮...
│	def before_update_after_submit(self):
│		self.validate_schedule_date()
⋮...
│	def validate_material_request_type(self):
│		"""Validate fields in accordance with selected type"""
│
│		if self.material_request_type != "Customer Provided":
│			self.customer = None
⋮...
│	def set_title(self):
│		"""Set title as comma separated list of items"""
│		if not self.title:
│			items = ", ".join([d.item_name for d in self.items][:3])
│			self.title = _("{0} Request for {1}").format(_(self.material_request_type), items)[:100]
⋮...
│	def on_submit(self):
⋮...
│	def before_save(self):
│		self.set_status(update=True)
⋮...
│	def before_submit(self):
│		self.set_status(update=True)
⋮...
│	def before_cancel(self):
│		# if MRQ is already closed, no point saving the document
│		check_on_hold_or_closed_status(self.doctype, self.name)
│
│		self.set_status(update=True, status="Cancelled")
⋮...
│	def check_modified_date(self):
│		mod_db = frappe.db.sql("""select modified from `tabMaterial Request` where name = %s""", self.name)
│		date_diff = frappe.db.sql(f"""select TIMEDIFF('{mod_db[0][0]}', '{cstr(self.modified)}')""")
│
│		if date_diff and date_diff[0][0]:
│			frappe.throw(_("{0} {1} has been modified. Please refresh.").format(_(self.doctype), self.name))
⋮...
│	def update_status(self, status):
│		self.check_modified_date()
│		self.status_can_change(status)
│		self.set_status(update=True, status=status)
│		self.update_requested_qty()
⋮...
│	def status_can_change(self, status):
⋮...
│	def on_cancel(self):
│		self.update_requested_qty_in_production_plan(cancel=True)
│		self.update_requested_qty()
⋮...
│	def get_mr_items_ordered_qty(self, mr_items):
⋮...
│	def update_completed_qty(self, mr_items=None, update_modified=True):
⋮...
│	def update_requested_qty(self, mr_item_rows=None):
⋮...
│	def update_requested_qty_in_production_plan(self, cancel=False):
⋮...
│def update_completed_and_requested_qty(stock_entry, method):
⋮...
│def make_purchase_order_based_on_supplier(source_name, target_doc=None, args=None):
⋮...
│def get_material_requests_based_on_supplier(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_default_supplier_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def make_in_transit_stock_entry(source_name, in_transit_warehouse):
⋮...

erpnext\stock\doctype\purchase_receipt\purchase_receipt.py:
│def make_stock_entry(source_name, target_doc=None):
⋮...
│def make_purchase_invoice(source_name, target_doc=None, args=None):
⋮...
│def make_purchase_return(source_name, target_doc=None):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("Purchase Receipt", source_name, target_doc)
⋮...
│def get_stock_value_difference(voucher_no, voucher_detail_no, warehouse):
⋮...
│def make_purchase_return_against_rejected_warehouse(source_name):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("Purchase Receipt", source_name, return_against_rejected_qty=True)
⋮...
│def update_billed_amount_based_on_po(po_details, update_modified=True, pr_doc=None):
⋮...
│def update_billing_percentage(pr_doc, update_modified=True, adjust_incoming_rate=False):
⋮...
│def get_billed_qty_against_purchase_receipt(pr_doc):
⋮...
│def adjust_incoming_rate_for_pr(doc):
⋮...
│def get_invoiced_qty_map(purchase_receipt):
⋮...
│def get_returned_qty_map(purchase_receipt):
⋮...
│def get_item_account_wise_additional_cost(purchase_document):
⋮...
│class PurchaseReceipt(BuyingController):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def before_validate(self):
│		from erpnext.stock.doctype.putaway_rule.putaway_rule import apply_putaway_rule
│
│		if self.get("items") and self.apply_putaway_rule and not self.get("is_return"):
│			apply_putaway_rule(self.doctype, self.get("items"), self.company)
⋮...
│	def validate(self):
⋮...
│	def validate_uom_is_integer(self):
│		super().validate_uom_is_integer("uom", ["qty", "received_qty"], "Purchase Receipt Item")
│		super().validate_uom_is_integer("stock_uom", "stock_qty", "Purchase Receipt Item")
⋮...
│	def validate_cwip_accounts(self):
⋮...
│	def validate_provisional_expense_account(self):
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def po_required(self):
│		if frappe.db.get_single_value("Buying Settings", "po_required") == "Yes":
│			for d in self.get("items"):
│				if not d.purchase_order:
│					frappe.throw(_("Purchase Order number required for Item {0}").format(d.item_code))
⋮...
│	def validate_items_quality_inspection(self):
⋮...
│	def get_already_received_qty(self, po, po_detail):
⋮...
│	def get_po_qty_and_warehouse(self, po_detail):
│		po_qty, po_warehouse = frappe.db.get_value("Purchase Order Item", po_detail, ["qty", "warehouse"])
│		return po_qty, po_warehouse
⋮...
│	def check_on_hold_or_closed_status(self):
│		check_list = []
│		for d in self.get("items"):
│			if d.meta.get_field("purchase_order") and d.purchase_order and d.purchase_order not in check_list:
│				check_list.append(d.purchase_order)
│				check_on_hold_or_closed_status("Purchase Order", d.purchase_order)
⋮...
│	def on_submit(self):
⋮...
│	def update_received_qty_if_from_pp(self):
⋮...
│	def check_next_docstatus(self):
⋮...
│	def on_cancel(self):
⋮...
│	def before_cancel(self):
│		super().before_cancel()
│		self.remove_amount_difference_with_purchase_invoice()
⋮...
│	def remove_amount_difference_with_purchase_invoice(self):
│		for item in self.items:
│			item.amount_difference_with_purchase_invoice = 0
⋮...
│	def get_gl_entries(self, warehouse_account=None, via_landed_cost_voucher=False):
⋮...
│	def make_item_gl_entries(self, gl_entries, warehouse_account=None):
⋮...
│	def add_provisional_gl_entry(
│		self, item, gl_entries, posting_date, provisional_account, reverse=0, item_amount=None
│	):
⋮...
│	def is_landed_cost_booked_for_any_item(self) -> bool:
│		for x in self.items:
│			if x.landed_cost_voucher_amount != 0:
│				return True
│
│		return False
⋮...
│	def make_tax_gl_entries(self, gl_entries, via_landed_cost_voucher=False):
⋮...
│	def update_assets(self, item, valuation_rate):
⋮...
│	def update_status(self, status):
│		self.set_status(update=True, status=status)
│		self.notify_update()
│		clear_doctype_notifications(self)
⋮...
│	def update_billing_status(self, update_modified=True):
⋮...
│	def reserve_stock_for_sales_order(self):
⋮...
│	def enable_recalculate_rate_in_sles(self):
⋮...
│def get_purchase_receipts_against_po_details(po_details):
⋮...
│def get_billed_amount_against_pr(pr_items):
⋮...
│def get_billed_amount_against_po(po_items):
⋮...
│def get_item_wise_returned_qty(pr_doc):
⋮...
│def update_purchase_receipt_status(docname, status):
│	pr = frappe.get_doc("Purchase Receipt", docname)
│	pr.update_status(status)
⋮...
│def make_inter_company_delivery_note(source_name, target_doc=None):
│	return make_inter_company_transaction("Purchase Receipt", source_name, target_doc)
⋮...
│def update_regional_gl_entries(gl_list, doc):
│	return
⋮...
│def make_lcv(doctype, docname):
⋮...

erpnext\buying\report\item_wise_purchase_history\item_wise_purchase_history.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details():
│	details = frappe.db.get_all("Item", fields=["name", "item_name", "item_group"])
│	item_details = {}
│	for d in details:
│		item_details.setdefault(d.name, frappe._dict({"item_name": d.item_name, "item_group": d.item_group}))
│	return item_details
⋮...
│def get_chart_data(data):
⋮...
│def get_supplier_details():
⋮...
│def get_purchase_order_details(company_list, filters):
⋮...

erpnext\selling\report\item_wise_sales_history\item_wise_sales_history.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details():
│	details = frappe.db.get_all("Item", fields=["name", "item_name", "item_group"])
│	item_details = {}
│	for d in details:
│		item_details.setdefault(d.name, frappe._dict({"item_name": d.item_name, "item_group": d.item_group}))
│	return item_details
⋮...
│def get_chart_data(data):
⋮...
│def get_customer_details():
⋮...
│def get_sales_order_details(company_list, filters):
⋮...

erpnext\regional\report\uae_vat_201\uae_vat_201.py:
│def execute(filters=None):
│	columns = get_columns()
│	data, emirates, amounts_by_emirate = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters=None):
│	"""Returns the list of dictionaries. Each dictionary is a row in the datatable and chart data."""
│	data = []
│	emirates, amounts_by_emirate = append_vat_on_sales(data, filters)
│	append_vat_on_expenses(data, filters)
│	return data, emirates, amounts_by_emirate
⋮...
│def get_columns():
⋮...
│def get_conditions(filters):
⋮...
│def get_filters(filters):
⋮...
│def append_data(data, no, legend, amount, vat_amount):
│	"""Returns data with appended value."""
│	data.append({"no": no, "legend": legend, "amount": amount, "vat_amount": vat_amount})
⋮...
│def get_standard_rated_expenses_total(filters):
⋮...
│def get_standard_rated_expenses_tax(filters):
⋮...
│def get_total_emiratewise(filters):
⋮...
│def get_conditions_join(filters):
⋮...
│def get_tourist_tax_return_total(filters):
⋮...
│def get_tourist_tax_return_tax(filters):
⋮...
│def get_zero_rated_total(filters):
⋮...
│def get_exempt_total(filters):
⋮...
│def append_vat_on_sales(data, filters):
⋮...
│def standard_rated_expenses_emiratewise(data, filters):
⋮...
│def append_emiratewise_expenses(data, emirates, amounts_by_emirate):
⋮...
│def append_vat_on_expenses(data, filters):
⋮...
│def get_emirates():
│	"""Returns a List of emirates in the order that they are to be displayed."""
│	return ["Abu Dhabi", "Dubai", "Sharjah", "Ajman", "Umm Al Quwain", "Ras Al Khaimah", "Fujairah"]
⋮...
│def get_reverse_charge_total(filters):
⋮...
│def get_reverse_charge_tax(filters):
⋮...
│def get_reverse_charge_recoverable_total(filters):
⋮...
│def get_reverse_charge_recoverable_tax(filters):
⋮...

erpnext\buying\report\requested_items_to_order_and_receive\requested_items_to_order_and_receive.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters, query, mr, mr_item):
⋮...
│def validate_filters(filters):
⋮...
│def prepare_data(data, filters):
⋮...
│def prepare_chart_data(item_data):
⋮...
│def update_qty_columns(row_to_update, data_row):
│	fields = ["qty", "stock_qty", "ordered_qty", "received_qty", "qty_to_receive", "qty_to_order"]
│	for field in fields:
│		row_to_update[field] += flt(data_row[field])
⋮...

erpnext\selling\report\sales_order_analysis\sales_order_analysis.py:
│def execute(filters=None):
⋮...
│def get_data(conditions, filters):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters):
⋮...
│def validate_filters(filters):
⋮...
│def prepare_data(data, so_elapsed_time, filters):
⋮...
│def prepare_chart_data(pending, completed):
⋮...
│def get_so_elapsed_time(data):
⋮...

erpnext\stock\report\serial_and_batch_summary\serial_and_batch_summary.py:
│def execute(filters=None):
│	data = get_data(filters)
│	columns = get_columns(filters, data)
│
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters, data):
⋮...
│def get_serial_nos(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_batch_nos(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_filter_conditions(filters):
⋮...
│def get_voucher_type(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\manufacturing\doctype\job_card\job_card.py:
│def make_stock_entry(source_name, target_doc=None):
⋮...
│class OverlapError(frappe.ValidationError):
│	pass
⋮...
│def make_material_request(source_name, target_doc=None):
⋮...
│def time_diff_in_minutes(string_ed_date, string_st_date):
│	return time_diff(string_ed_date, string_st_date).total_seconds() / 60
⋮...
│class OperationSequenceError(frappe.ValidationError):
│	pass
⋮...
│def make_corrective_job_card(source_name, operation=None, for_operation=None, target_doc=None):
⋮...
│class OperationMismatchError(frappe.ValidationError):
│	pass
⋮...
│class JobCardCancelError(frappe.ValidationError):
│	pass
⋮...
│class JobCardOverTransferError(frappe.ValidationError):
│	pass
⋮...
│class JobCard(Document):
⋮...
│	def onload(self):
│		excess_transfer = frappe.db.get_single_value("Manufacturing Settings", "job_card_excess_transfer")
│		self.set_onload("job_card_excess_transfer", excess_transfer)
│		self.set_onload("work_order_closed", self.is_work_order_closed())
│		self.set_onload("has_stock_entry", self.has_stock_entry())
⋮...
│	def has_stock_entry(self):
│		return frappe.db.exists("Stock Entry", {"job_card": self.name, "docstatus": ["!=", 2]})
⋮...
│	def before_validate(self):
│		self.set_wip_warehouse()
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		self.validate_job_card_qty()
⋮...
│	def validate_on_hold(self):
│		if self.is_paused and not self.time_logs:
│			self.is_paused = 0
⋮...
│	def set_manufactured_qty(self):
⋮...
│	def validate_job_card_qty(self):
⋮...
│	def set_sub_operations(self):
⋮...
│	def validate_time_logs(self):
⋮...
│	def get_overlap_for(self, args, open_job_cards=None):
⋮...
│	def has_overlap(self, production_capacity, time_logs):
⋮...
│	def get_time_logs(self, args, doctype, open_job_cards=None):
⋮...
│	def get_open_job_cards(self, employee, workstation=None):
⋮...
│	def get_workstation_based_on_available_slot(self, existing_time_logs) -> dict:
⋮...
│	def time_slot_wise_busy_workstations(existing_time_logs) -> dict:
⋮...
│	def schedule_time_logs(self, row):
⋮...
│	def validate_overlap_for_workstation(self, args, row):
⋮...
│	def check_workstation_time(self, row):
⋮...
│	def add_time_log(self, args):
⋮...
│	def add_start_time_log(self, args):
│		if args.from_time and args.to_time:
│			args.time_in_mins = time_diff_in_minutes(args.to_time, args.from_time)
│
│		row = self.append("time_logs", args)
│		row.db_update()
⋮...
│	def set_employees(self, employees):
│		for name in employees:
│			self.append("employee", {"employee": name.get("employee"), "completed_qty": 0.0})
│			self.save()
⋮...
│	def update_sub_operation_status(self):
⋮...
│	def update_time_logs(self, row):
⋮...
│	def get_required_items(self):
⋮...
│	def before_save(self):
│		self.set_expected_and_actual_time()
│		self.set_process_loss()
⋮...
│	def on_submit(self):
│		self.validate_transfer_qty()
│		self.validate_job_card()
│		self.update_work_order()
│		self.set_transferred_qty()
⋮...
│	def on_cancel(self):
│		self.update_work_order()
│		self.set_transferred_qty()
⋮...
│	def validate_transfer_qty(self):
⋮...
│	def validate_job_card(self):
⋮...
│	def set_expected_and_actual_time(self):
⋮...
│	def set_process_loss(self):
⋮...
│	def update_work_order(self):
⋮...
│	def update_semi_finished_good_details(self):
⋮...
│	def update_corrective_in_work_order(self, wo):
⋮...
│	def validate_produced_quantity(self, for_quantity, process_loss_qty, wo):
⋮...
│	def update_work_order_data(self, for_quantity, process_loss_qty, time_in_mins, wo):
⋮...
│	def get_current_operation_data(self):
⋮...
│	def set_transferred_qty_in_job_card_item(self, ste_doc):
⋮...
│	def set_transferred_qty(self, update_status=False):
⋮...
│	def set_transferred_qty_in_work_order(self):
⋮...
│	def set_status(self, update_status=False):
⋮...
│	def set_wip_warehouse(self):
│		if not self.wip_warehouse:
│			self.wip_warehouse = frappe.db.get_single_value("Manufacturing Settings", "default_wip_warehouse")
⋮...
│	def validate_operation_id(self):
⋮...
│	def pause_job(self, **kwargs):
│		if isinstance(kwargs, dict):
│			kwargs = frappe._dict(kwargs)
│
│		self.db_set("is_paused", 1)
│		self.add_time_logs(to_time=kwargs.end_time, completed_qty=0.0, employees=self.employee)
⋮...
│	def resume_job(self, **kwargs):
⋮...
│	def validate_sequence_id(self):
⋮...
│	def validate_work_order(self):
│		if self.is_work_order_closed():
│			frappe.throw(_("You can't make any changes to Job Card since Work Order is closed."))
⋮...
│	def is_work_order_closed(self):
⋮...
│	def update_status_in_workstation(self, status):
│		if not self.workstation:
│			return
│
│		frappe.db.set_value("Workstation", self.workstation, "status", status)
⋮...
│	def add_time_logs(self, **kwargs):
⋮...
│	def update_workstation_status(self):
⋮...
│	def start_timer(self, **kwargs):
⋮...
│	def complete_job_card(self, **kwargs):
⋮...
│	def make_stock_entry_for_semi_fg_item(self, auto_submit=False):
⋮...
│def make_subcontracting_po(source_name, target_doc=None):
⋮...
│def make_time_log(kwargs):
⋮...
│def get_operation_details(work_order, operation):
⋮...
│def get_operations(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_job_details(start, end, filters=None):
⋮...

erpnext\stock\doctype\item\test_item.py:
│def make_item(item_code=None, properties=None, uoms=None, barcode=None):
⋮...
│def create_item(
│	item_code,
│	is_stock_item=1,
│	valuation_rate=0,
│	stock_uom="Nos",
│	warehouse="_Test Warehouse - _TC",
│	is_customer_provided_item=None,
│	customer=None,
│	is_purchase_item=None,
│	opening_stock=0,
│	is_fixed_asset=0,
│	asset_category=None,
│	buying_cost_center=None,
│	selling_cost_center=None,
│	company="_Test Company",
│):
⋮...
│def make_item_variant():
│	if not frappe.db.exists("Item", "_Test Variant Item-S"):
│		variant = create_variant("_Test Variant Item", """{"Test Size": "Small"}""")
│		variant.item_code = "_Test Variant Item-S"
│		variant.item_name = "_Test Variant Item-S"
│		variant.save()
⋮...
│def set_item_variant_settings(fields):
│	doc = frappe.get_doc("Item Variant Settings")
│	doc.set("fields", fields)
│	doc.save()
⋮...
│class UnitTestItem(UnitTestCase):
⋮...
│class TestItem(IntegrationTestCase):
⋮...
│	def setUp(self):
│		super().setUp()
│		frappe.flags.attribute_values = None
⋮...
│	def get_item(self, idx):
⋮...
│	def test_get_item_details(self):
⋮...
│	def test_get_asset_item_details(self):
⋮...
│	def test_item_tax_template(self):
⋮...
│	def test_item_defaults(self):
⋮...
│	def test_item_default_validations(self):
⋮...
│	def test_item_attribute_change_after_variant(self):
⋮...
│	def test_make_item_variant(self):
⋮...
│	def test_copy_fields_from_template_to_variants(self):
⋮...
│	def test_make_item_variant_with_numeric_values(self):
⋮...
│	def test_item_merging(self):
⋮...
│	def test_item_merging_with_product_bundle(self):
⋮...
│	def test_uom_conversion_factor(self):
⋮...
│	def test_uom_conv_intermediate(self):
│		factor = get_uom_conv_factor("Pound", "Gram")
│		self.assertAlmostEqual(factor, 453.592, 3)
⋮...
│	def test_uom_conv_base_case(self):
│		factor = get_uom_conv_factor("m", "m")
│		self.assertEqual(factor, 1.0)
⋮...
│	def test_item_variant_by_manufacturer(self):
⋮...
│	def test_stock_exists_against_template_item(self):
⋮...
│	def test_add_item_barcode(self):
⋮...
│	def test_heatmap_data(self):
⋮...
│	def test_index_creation(self):
⋮...
│	def test_attribute_completions(self):
⋮...
│	def test_check_stock_uom_with_bin(self):
│		# this item has opening stock and stock_uom set in self.globalTestRecords["Item"].
│		item = frappe.get_doc("Item", "_Test Item")
│		item.stock_uom = "Gram"
│		self.assertRaises(frappe.ValidationError, item.save)
⋮...
│	def test_check_stock_uom_with_bin_no_sle(self):
⋮...
│	def test_erasure_of_old_conversions(self):
⋮...
│	def test_validate_stock_item(self):
⋮...
│	def test_autoname_series(self):
│		item = frappe.new_doc("Item")
│		item.item_group = "All Item Groups"
│		item.save()  # if item code saved without item_code then series worked
⋮...
│	def test_item_wise_negative_stock(self):
⋮...
│	def test_backdated_negative_stock(self):
⋮...
│	def test_retain_sample(self):
⋮...
│	def consume_item_code_with_differet_stock_transactions(
│		self, item_code, warehouse="_Test Warehouse - _TC"
│	):
⋮...
│	def test_item_dashboard(self):
│		from erpnext.stock.dashboard.item_dashboard import get_data
│
│		self.assertTrue(get_data(item_code="_Test Item"))
│		self.assertTrue(get_data(warehouse="_Test Warehouse - _TC"))
│		self.assertTrue(get_data(item_group="All Item Groups"))
⋮...
│	def test_empty_description(self):
│		item = make_item(properties={"description": "<p></p>"})
│		self.assertEqual(item.description, item.item_name)
│		item.description = ""
│		item.save()
│		self.assertEqual(item.description, item.item_name)
⋮...
│	def test_item_type_field_change(self):
⋮...
│	def test_customer_codes_length(self):
⋮...
│	def test_update_is_stock_item(self):
⋮...
│	def test_serach_fields_for_item(self):
⋮...
│	def test_group_warehouse_for_reorder_item(self):
⋮...
│	def test_variant_uom_mismatch_throws_error(self):
⋮...

erpnext\stock\report\serial_no_ledger\serial_no_ledger.py:
│def execute(filters=None):
│	columns = get_columns(filters)
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_serial_nos(filters, serial_bundle_ids):
⋮...

erpnext\assets\report\fixed_asset_register\fixed_asset_register.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters):
⋮...
│def prepare_chart_data(data, filters):
⋮...
│def get_assets_linked_to_fb(filters):
⋮...
│def get_asset_depreciation_amount_map(filters, finance_book):
⋮...
│def get_group_by_data(group_by, conditions, assets_linked_to_fb, depreciation_amount_map):
⋮...
│def get_purchase_receipt_supplier_map():
⋮...
│def get_purchase_invoice_supplier_map():
⋮...

erpnext\manufacturing\report\work_order_summary\work_order_summary.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_chart_data(data, filters):
⋮...
│def prepare_chart_data(data, filters):
⋮...
│def get_chart_based_on_status(data):
⋮...
│def get_chart_based_on_age(data):
⋮...
│def get_chart_based_on_qty(data, filters):
⋮...

erpnext\accounts\report\trial_balance\trial_balance.py:
│def execute(filters=None):
│	validate_filters(filters)
│	data = get_data(filters)
│	columns = get_columns()
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def validate_filters(filters):
⋮...
│def prepare_data(accounts, filters, parent_children_map, company_currency):
⋮...
│def get_opening_balance(
│	doctype,
│	filters,
│	report_type,
│	accounting_dimensions,
│	period_closing_voucher=None,
│	start_date=None,
│	ignore_is_opening=0,
│):
⋮...
│def accumulate_values_into_parents(accounts, accounts_by_name):
│	for d in reversed(accounts):
│		if d.parent_account:
│			for key in value_fields:
│				accounts_by_name[d.parent_account][key] += d[key]
⋮...
│def calculate_values(accounts, gl_entries_by_account, opening_balances, show_net_values, ignore_is_opening=0):
⋮...
│def get_opening_balances(filters, ignore_is_opening):
│	balance_sheet_opening = get_rootwise_opening_balances(filters, "Balance Sheet", ignore_is_opening)
│	pl_opening = get_rootwise_opening_balances(filters, "Profit and Loss", ignore_is_opening)
│
│	balance_sheet_opening.update(pl_opening)
│	return balance_sheet_opening
⋮...
│def get_rootwise_opening_balances(filters, report_type, ignore_is_opening):
⋮...
│def prepare_opening_closing(row):
⋮...
│def calculate_total_row(accounts, company_currency):
⋮...

erpnext\manufacturing\report\job_card_summary\job_card_summary.py:
│def execute(filters=None):
│	columns, data = [], []
│	data = get_data(filters)
│	columns = get_columns(filters)
│	chart_data = get_chart_data(data, filters)
│	return columns, data, None, chart_data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_chart_data(job_card_details, filters):
⋮...
│def prepare_chart_data(job_card_details, filters):
⋮...

erpnext\manufacturing\report\production_analytics\production_analytics.py:
│def execute(filters=None):
│	columns = get_columns(filters)
│	data, chart = get_data(filters, columns)
│	return columns, data, None, chart
⋮...
│def get_data(filters, columns):
⋮...
│def get_columns(filters):
⋮...
│def get_chart_data(periodic_data, columns):
⋮...
│def update_periodic_data(periodic_data, status, period):
⋮...
│def get_periodic_data(filters, entry):
⋮...

erpnext\crm\report\lost_opportunity\lost_opportunity.py:
│def execute(filters=None):
│	columns, data = get_columns(), get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_conditions(filters):
⋮...
│def get_join(filters):
⋮...

erpnext\accounts\report\account_balance\account_balance.py:
│def execute(filters=None):
│	filters = frappe._dict(filters or {})
│	columns = get_columns(filters)
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters):
⋮...

erpnext\regional\report\uae_vat_201\test_uae_vat_201.py:
│def make_item(item_code, properties=None):
⋮...
│def create_warehouse(warehouse_name, properties=None, company=None):
⋮...
│def make_customer():
⋮...
│def make_supplier():
⋮...
│def make_company(company_name, abbr):
⋮...
│def make_sales_invoices():
⋮...
│def create_purchase_invoices():
⋮...
│class TestUaeVat201(TestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_uae_vat_201_report(self):
⋮...
│	def test_uae_vat_201_report_with_foreign_transaction(self):
⋮...
│def set_vat_accounts():
⋮...

erpnext\support\report\support_hour_distribution\support_hour_distribution.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_chart_data(timeslot_wise_count):
⋮...
│def get_hours_count(start_time, end_time):
⋮...

erpnext\manufacturing\report\downtime_analysis\downtime_analysis.py:
│def execute(filters=None):
│	columns, data = [], []
│	data = get_data(filters)
│	columns = get_columns(filters)
│	chart_data = get_chart_data(data, filters)
│	return columns, data, None, chart_data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_chart_data(data, columns):
⋮...

erpnext\manufacturing\report\quality_inspection_summary\quality_inspection_summary.py:
│def execute(filters=None):
│	columns, data = [], []
│	data = get_data(filters)
│	columns = get_columns(filters)
│	chart_data = get_chart_data(data, filters)
│	return columns, data, None, chart_data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_chart_data(periodic_data, columns):
⋮...

erpnext\stock\report\item_shortage_report\item_shortage_report.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_chart_data(data):
⋮...

erpnext\buying\report\subcontract_order_summary\subcontract_order_summary.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns(filters)
│	data = get_data(filters)
│
│	return columns, data
⋮...
│def get_data(report_filters):
⋮...
│def get_columns(filters):
⋮...
│def get_supplied_items(orders, report_filters):
⋮...
│def get_filters(report_filters):
⋮...
│def get_subcontracted_orders(report_filters):
⋮...
│def prepare_subcontracted_data(orders, supplied_items):
⋮...
│def get_subcontracted_data(order_details, data):
⋮...

erpnext\buying\report\purchase_order_analysis\purchase_order_analysis.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def validate_filters(filters):
⋮...
│def prepare_data(data, filters):
⋮...
│def prepare_chart_data(pending, completed):
⋮...
│def update_received_amount(data):
│	pr_data = get_received_amount_data(data)
│
│	for row in data:
│		row.received_qty_amount = flt(pr_data.get(row.name))
⋮...
│def get_received_amount_data(data):
⋮...

erpnext\accounts\report\dimension_wise_accounts_balance_report\dimension_wise_accounts_balance_report.py:
│def execute(filters=None):
⋮...
│def get_data(filters, dimension_list):
⋮...
│def get_columns(dimension_list):
⋮...
│def get_dimensions(filters):
⋮...
│def prepare_data(accounts, filters, company_currency, dimension_list):
⋮...
│def set_gl_entries_by_account(dimension_list, filters, account, gl_entries_by_account):
⋮...
│def accumulate_values_into_parents(accounts, accounts_by_name, dimension_list):
⋮...
│def format_gl_entries(gl_entries_by_account, accounts_by_name, dimension_list, dimension_type):
⋮...
│def get_condition(dimension):
│	conditions = []
│
│	conditions.append(f"{frappe.scrub(dimension)} in %(dimensions)s")
│
│	return " and {}".format(" and ".join(conditions)) if conditions else ""
⋮...

erpnext\stock\report\cogs_by_item_group\cogs_by_item_group.py:
│def execute(filters: Filters) -> tuple[Columns, Data]:
│	update_filters_with_account(filters)
│	validate_filters(filters)
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters: Filters) -> Data:
⋮...
│def get_columns() -> Columns:
│	return [
│		{"label": _("Item Group"), "fieldname": "item_group", "fieldtype": "Data", "width": "200"},
│		{"label": _("COGS Debit"), "fieldname": "cogs_debit", "fieldtype": "Currency", "width": "200"},
│	]
⋮...
│def validate_filters(filters: Filters) -> None:
│	if filters.from_date > filters.to_date:
│		frappe.throw(_("From Date must be before To Date"))
⋮...
│def get_row(name: str, value: float, is_bold: int, indent: int) -> Row:
│	item_group = name
│	if is_bold:
│		item_group = frappe.bold(item_group)
│	return frappe._dict(item_group=item_group, cogs_debit=value, indent=indent)
⋮...
│def update_filters_with_account(filters: Filters) -> None:
│	account = frappe.get_value("Company", filters.get("company"), "default_expense_account")
│	filters.update(dict(account=account))
⋮...
│def get_filtered_entries(filters: Filters) -> FilteredEntries:
⋮...
│def get_stock_value_difference_list(filtered_entries: FilteredEntries) -> SVDList:
⋮...
│def get_leveled_dict() -> OrderedDict:
⋮...
│def assign_self_values(leveled_dict: OrderedDict, svd_list: SVDList) -> None:
│	key_dict = {v["name"]: k for k, v in leveled_dict.items()}
│	for item in svd_list:
│		key = key_dict[item.get("item_group")]
│		leveled_dict[key]["self_value"] += -item.get("stock_value_difference")
⋮...
│def assign_agg_values(leveled_dict: OrderedDict) -> None:
⋮...
│def assign_item_groups_to_svd_list(svd_list: SVDList) -> None:
│	ig_map = get_item_groups_map(svd_list)
│	for item in svd_list:
│		item.item_group = ig_map[item.get("item_code")]
⋮...
│def get_item_groups_map(svd_list: SVDList) -> dict[str, str]:
│	item_codes = set(i["item_code"] for i in svd_list)
│	ig_list = frappe.get_list(
│		"Item", fields=["item_code", "item_group"], filters=[("item_code", "in", item_codes)]
│	)
│	return {i["item_code"]: i["item_group"] for i in ig_list}
⋮...
│def get_item_groups_dict() -> ItemGroupsDict:
│	item_groups_list = frappe.get_all("Item Group", fields=("name", "is_group", "lft", "rgt"))
│	return {(i["lft"], i["rgt"]): {"name": i["name"], "is_group": i["is_group"]} for i in item_groups_list}
⋮...
│def update_leveled_dict(leveled_dict: OrderedDict) -> None:
│	for k in leveled_dict:
│		leveled_dict[k].update({"self_value": 0, "agg_value": 0})
⋮...

erpnext\accounts\report\profitability_analysis\profitability_analysis.py:
│def execute(filters=None):
⋮...
│def get_data(accounts, filters, based_on):
⋮...
│def get_columns(filters):
⋮...
│def prepare_data(accounts, filters, total_row, parent_children_map, based_on):
⋮...
│def accumulate_values_into_parents(accounts, accounts_by_name):
│	for d in reversed(accounts):
│		if d.parent_account:
│			for key in value_fields:
│				accounts_by_name[d.parent_account][key] += d[key]
⋮...
│def set_gl_entries_by_account(
│	company, from_date, to_date, based_on, gl_entries_by_account, ignore_closing_entries=False
│):
⋮...
│def calculate_values(accounts, gl_entries_by_account, filters):
⋮...
│def get_accounts_data(based_on, company):
⋮...

erpnext\accounts\report\invalid_ledger_entries\invalid_ledger_entries.py:
│def execute(filters: dict | None = None):
⋮...
│def get_data(filters) -> list[list]:
⋮...
│def get_columns() -> list[dict]:
⋮...
│def validate_filters(filters: dict | None = None):
⋮...
│def identify_cancelled_vouchers(active_vouchers: list[dict] | list | None = None) -> list[dict]:
⋮...
│def build_query_filters(filters: dict | None = None) -> list:
⋮...
│def get_active_vouchers_for_period(filters: dict | None = None) -> list[dict]:
⋮...

erpnext\selling\report\address_and_contacts\address_and_contacts.py:
│def execute(filters=None):
│	columns, data = get_columns(filters), get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
│	party_type = filters.get("party_type")
│	party = filters.get("party_name")
│	party_group = get_party_group(party_type)
│
│	return get_party_addresses_and_contact(party_type, party, party_group, filters)
⋮...
│def get_columns(filters):
⋮...
│def get_party_details(party_type, party_list, doctype, party_details):
⋮...
│def add_blank_columns_for(doctype):
│	return ["" for field in field_map.get(doctype, [])]
⋮...
│def get_party_group(party_type):
⋮...
│def get_party_addresses_and_contact(party_type, party, party_group, filters):
⋮...

erpnext\buying\report\supplier_quotation_comparison\supplier_quotation_comparison.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def prepare_data(supplier_quotation_data, filters):
⋮...
│def prepare_chart_data(suppliers, qty_list, supplier_qty_price_map):
⋮...
│def get_message():
⋮...
│def set_default_supplier(item_code, supplier, company):
⋮...

erpnext\stock\report\batch_item_expiry_status\batch_item_expiry_status.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def validate_filters(filters):
⋮...
│def get_batch_details(filters):
⋮...

erpnext\stock\report\reserved_stock\reserved_stock.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def validate_filters(filters):
⋮...

erpnext\stock\report\stock_ledger_invariant_check\stock_ledger_invariant_check.py:
│def execute(filters=None):
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
│	sles = get_stock_ledger_entries(filters)
│	return add_invariant_check_fields(sles, filters)
⋮...
│def get_columns():
⋮...
│def get_stock_ledger_entries(filters):
⋮...
│def add_invariant_check_fields(sles, filters):
⋮...
│def is_sle_has_correct_data(sle, precision):
│	if flt(sle.difference_in_qty, precision) != 0.0 or flt(sle.diff_value_diff, precision) != 0:
│		print(flt(sle.difference_in_qty, precision), flt(sle.diff_value_diff, precision))
│		return False
│
│	return True
⋮...
│def create_reposting_entries(rows, item_code=None, warehouse=None):
⋮...

erpnext\stock\report\incorrect_serial_no_valuation\incorrect_serial_no_valuation.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
│	data = get_stock_ledger_entries(filters)
│	serial_nos_data = prepare_serial_nos(data)
│	data = get_incorrect_serial_nos(serial_nos_data)
│
│	return data
⋮...
│def get_columns():
⋮...
│def get_stock_ledger_entries(report_filters):
⋮...
│def prepare_serial_nos(data):
⋮...
│def get_incorrect_serial_nos(serial_nos_data):
⋮...
│def check_incorrect_serial_data(data, total_dict):
⋮...

erpnext\accounts\report\inactive_sales_items\inactive_sales_items.py:
│def execute(filters=None):
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_items(filters):
⋮...
│def get_sales_details(filters):
⋮...
│def get_territories(filters):
⋮...

erpnext\stock\report\incorrect_balance_qty_after_transaction\incorrect_balance_qty_after_transaction.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_stock_ledger_entries(report_filters):
⋮...
│def validate_data(itewise_balance_qty):
⋮...
│def get_incorrect_data(data):
⋮...

erpnext\stock\report\fifo_queue_vs_qty_after_transaction_comparison\fifo_queue_vs_qty_after_transaction_comparison.py:
│def execute(filters=None):
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
│	if not any([filters.warehouse, filters.item_code, filters.item_group]):
│		frappe.throw(_("Any one of following filters required: warehouse, Item Code, Item Group"))
│	sles = get_stock_ledger_entries(filters)
│	return find_first_bad_queue(sles)
⋮...
│def get_columns():
⋮...
│def get_stock_ledger_entries(filters):
⋮...
│def find_first_bad_queue(sles):
⋮...

erpnext\selling\report\territory_wise_sales\territory_wise_sales.py:
│def execute(filters=None):
│	filters = frappe._dict(filters)
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters=None):
⋮...
│def get_columns():
⋮...
│def _get_total(doclist, amount_field="base_grand_total"):
⋮...
│def get_sales_orders(quotations):
⋮...
│def get_opportunities(filters):
⋮...
│def get_quotations(opportunities):
⋮...
│def get_sales_invoice(sales_orders):
⋮...

erpnext\stock\report\warehouse_wise_stock_balance\warehouse_wise_stock_balance.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns(filters)
│	data = get_data(filters)
│
│	return columns, data
⋮...
│def get_data(filters: StockBalanceFilter):
⋮...
│def get_columns(filters: StockBalanceFilter) -> list[dict]:
⋮...
│class StockBalanceFilter(TypedDict):
│	company: str | None
│	warehouse: str | None
│	show_disabled_warehouses: int | None
⋮...
│def get_warehouse_wise_balance(filters: StockBalanceFilter) -> list[SLEntry]:
⋮...
│def get_warehouses(report_filters: StockBalanceFilter):
⋮...
│def update_indent(warehouses):
⋮...
│def set_balance_in_parent(warehouses):
⋮...

erpnext\buying\report\procurement_tracker\procurement_tracker.py:
│def execute(filters=None):
│	columns = get_columns(filters)
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def apply_filters_on_query(filters, parent, child, query):
⋮...
│def get_mapped_mr_details(filters):
⋮...
│def get_mapped_pi_records():
⋮...
│def get_mapped_pr_records():
⋮...
│def get_po_entries(filters):
⋮...

erpnext\accounts\report\trial_balance_for_party\trial_balance_for_party.py:
│def execute(filters=None):
⋮...
│def get_data(filters, show_party_name):
⋮...
│def get_columns(filters, show_party_name):
⋮...
│def get_opening_balances(filters, account_filter=None):
⋮...
│def toggle_debit_credit(debit, credit):
⋮...
│def get_balances_within_period(filters, account_filter=None):
⋮...
│def is_party_name_visible(filters):
⋮...

erpnext\accounts\report\asset_depreciations_and_balances\asset_depreciations_and_balances.py:
│def execute(filters=None):
│	filters.day_before_from_date = add_days(filters.from_date, -1)
│	columns, data = get_columns(filters), get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
│	if filters.get("group_by") == "Asset Category":
│		return get_group_by_asset_category_data(filters)
│	elif filters.get("group_by") == "Asset":
│		return get_group_by_asset_data(filters)
⋮...
│def get_columns(filters):
⋮...
│def get_group_by_asset_category_data(filters):
⋮...
│def get_asset_categories_for_grouped_by_category(filters):
⋮...
│def get_assets_for_grouped_by_category(filters):
⋮...
│def get_group_by_asset_data(filters):
⋮...
│def get_asset_details_for_grouped_by_category(filters):
⋮...
│def get_assets_for_grouped_by_asset(filters):
⋮...

erpnext\stock\report\item_variant_details\item_variant_details.py:
│def execute(filters=None):
│	columns = get_columns(filters.item)
│	data = get_data(filters.item)
│	return columns, data
⋮...
│def get_data(item):
⋮...
│def get_columns(item):
⋮...
│def get_open_sales_orders_count(variants_list):
⋮...
│def get_stock_details_map(variant_list):
⋮...
│def get_buying_price_map(variant_list):
⋮...
│def get_selling_price_map(variant_list):
⋮...
│def get_attribute_values_map(variant_list):
⋮...

erpnext\stock\report\available_batch_report\available_batch_report.py:
│def execute(filters=None):
│	columns, data = [], []
│	data = get_data(filters)
│	columns = get_columns(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_query_based_on_filters(query, batch, table, filters):
⋮...
│def parse_batchwise_data(batchwise_data):
⋮...
│def get_batchwise_data_from_stock_ledger(filters):
⋮...
│def get_batchwise_data_from_serial_batch_bundle(batchwise_data, filters):
⋮...

erpnext\manufacturing\report\bom_operations_time\bom_operations_time.py:
│def execute(filters=None):
│	data = get_data(filters)
│	columns = get_columns(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_args():
│	return frappe._dict({"name": "", "item": "", "item_name": "", "uom": ""})
⋮...
│def get_filtered_data(filters):
⋮...
│def get_bom_count(bom_data):
⋮...

erpnext\selling\report\customer_wise_item_price\customer_wise_item_price.py:
│def execute(filters=None):
⋮...
│def get_data(filters=None):
⋮...
│def get_columns(filters=None):
⋮...
│def get_customer_details(filters):
⋮...
│def fetch_item_prices(
│	customer: str | None = None,
⋮...
│def get_selling_items(filters):
⋮...

erpnext\stock\report\stock_and_account_value_comparison\stock_and_account_value_comparison.py:
│def execute(filters=None):
⋮...
│def get_data(report_filters):
⋮...
│def get_columns(filters):
⋮...
│def get_gl_data(report_filters, filters):
⋮...
│def get_stock_ledger_data(report_filters, filters):
⋮...
│def create_reposting_entries(rows, company):
⋮...

erpnext\stock\report\item_price_stock\item_price_stock.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns()
│	data = get_data(filters, columns)
│	return columns, data
⋮...
│def get_data(filters, columns):
│	item_price_qty_data = []
│	item_price_qty_data = get_item_price_qty_data(filters)
│	return item_price_qty_data
⋮...
│def get_columns():
⋮...
│def get_price_map(price_list_names, buying=0, selling=0):
⋮...
│def get_item_price_qty_data(filters):
⋮...

erpnext\manufacturing\report\bom_explorer\bom_explorer.py:
│def execute(filters=None):
│	data = []
│	columns = get_columns()
│	get_data(filters, data)
│	return columns, data
⋮...
│def get_data(filters, data):
│	get_exploded_items(filters.bom, data)
⋮...
│def get_columns():
⋮...
│def get_exploded_items(bom, data, indent=0, qty=1):
⋮...

erpnext\crm\report\prospects_engaged_but_not_converted\prospects_engaged_but_not_converted.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def set_defaut_value_for_filters(filters):
│	if not filters.get("no_of_interaction"):
│		filters["no_of_interaction"] = 1
│	if not filters.get("lead_age"):
│		filters["lead_age"] = 60
⋮...
│def get_lead_filters(filters):
⋮...
│def get_creation_date_based_on_lead_age(filters):
│	return add_days(now(), (filters.get("lead_age") * -1))
⋮...

erpnext\manufacturing\report\work_order_consumed_materials\work_order_consumed_materials.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns()
│	data = get_data(filters)
│
│	return columns, data
⋮...
│def get_data(report_filters):
⋮...
│def get_columns():
⋮...
│def get_returned_materials(work_orders):
⋮...
│def get_fields():
⋮...
│def get_filter_condition(report_filters):
⋮...

erpnext\stock\report\stock_ledger_variance\stock_ledger_variance.py:
│def execute(filters=None):
⋮...
│def get_data(filters=None):
⋮...
│def get_columns():
⋮...
│def get_item_warehouse_combinations(filters: dict | None = None) -> dict:
⋮...
│def has_difference(row, precision, difference_in, valuation_method):
⋮...

erpnext\accounts\report\billed_items_to_be_received\billed_items_to_be_received.py:
│def execute(filters=None):
│	data = get_data(filters) or []
│	columns = get_columns()
│
│	return columns, data
⋮...
│def get_data(report_filters):
│	filters = get_report_filters(report_filters)
│	fields = get_report_fields()
│
│	return frappe.get_all("Purchase Invoice", fields=fields, filters=filters)
⋮...
│def get_columns():
⋮...
│def get_report_filters(report_filters):
⋮...
│def get_report_fields():
⋮...

erpnext\buying\report\subcontracted_item_to_be_received\subcontracted_item_to_be_received.py:
│def execute(filters=None):
⋮...
│def get_data(data, filters):
⋮...
│def get_columns(filters):
⋮...
│def get_subcontract_orders(filters):
⋮...
│def get_subcontract_order_supplied_item(order_type, orders):
│	return frappe.get_all(
│		f"{order_type} Item",
│		filters=[("parent", "IN", orders)],
│		fields=["parent", "item_code", "item_name", "qty", "received_qty"],
│	)
⋮...

erpnext\selling\report\pending_so_items_for_purchase_request\pending_so_items_for_purchase_request.py:
│def execute(filters=None):
│	columns = get_columns()
│	data = get_data()
│	return columns, data
⋮...
│def get_data():
⋮...
│def get_columns():
⋮...
│def get_items_with_product_bundle(item_list):
│	bundled_items = frappe.get_all(
│		"Product Bundle", filters=[("new_item_code", "IN", item_list)], fields=["new_item_code"]
│	)
│
│	return [d.new_item_code for d in bundled_items]
⋮...
│def get_packed_items(sales_order_list):
⋮...

erpnext\manufacturing\report\bom_variance_report\bom_variance_report.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns(filters)
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_work_orders(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\buying\report\subcontracted_raw_materials_to_be_transferred\subcontracted_raw_materials_to_be_transferred.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns(filters):
⋮...
│def get_order_items_to_supply(filters):
⋮...

erpnext\stock\report\stock_qty_vs_serial_no_count\stock_qty_vs_serial_no_count.py:
│def execute(filters=None):
│	validate_warehouse(filters)
│	columns = get_columns()
│	data = get_data(filters.warehouse)
│	return columns, data
⋮...
│def get_data(warehouse):
⋮...
│def get_columns():
⋮...
│def validate_warehouse(filters):
│	company = filters.company
│	warehouse = filters.warehouse
│	if not frappe.db.exists("Warehouse", {"name": warehouse, "company": company}):
│		frappe.throw(_("Warehouse: {0} does not belong to {1}").format(warehouse, company))
⋮...

erpnext\accounts\report\voucher_wise_balance\voucher_wise_balance.py:
│def execute(filters=None):
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def apply_filters(query, filters, gle):
⋮...

erpnext\utilities\report\youtube_interactions\youtube_interactions.py:
│def execute(filters=None):
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_chart_summary_data(data):
⋮...

erpnext\manufacturing\report\process_loss_report\process_loss_report.py:
│def execute(filters: Filters) -> tuple[Columns, Data]:
│	filters = frappe._dict(filters or {})
│	columns = get_columns()
│	data = get_data(filters)
│	return columns, data
⋮...
│def get_data(filters: Filters) -> Data:
⋮...
│def get_columns() -> Columns:
⋮...
│def update_data_with_total_pl_value(data: Data) -> None:
│	for row in data:
│		value_per_unit_fg = row["total_fg_value"] / row["qty_to_manufacture"]
│		row["total_pl_value"] = row["process_loss_qty"] * value_per_unit_fg
⋮...

erpnext\stock\report\incorrect_serial_and_batch_bundle\incorrect_serial_and_batch_bundle.py:
│def execute(filters: dict | None = None):
⋮...
│def get_data(filters) -> list[list]:
⋮...
│def get_columns() -> list[dict]:
⋮...
│def remove_sabb_entry(selected_rows):
⋮...

erpnext\stock\report\incorrect_stock_value_report\incorrect_stock_value_report.py:
│def execute(filters=None):
⋮...
│def get_data(report_filters):
⋮...
│def get_columns(filters):
⋮...
│def get_unsync_date(filters):
⋮...

erpnext\manufacturing\report\cost_of_poor_quality_report\cost_of_poor_quality_report.py:
│def execute(filters=None):
│	return get_columns(filters), get_data(filters)
⋮...
│def get_data(report_filters):
⋮...
│def get_columns(filters):
⋮...
│def append_filters(query, report_filters, operations, job_card):
⋮...

erpnext\accounts\report\asset_depreciation_ledger\asset_depreciation_ledger.py:
│def execute(filters=None):
│	columns, data = get_columns(), get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...
│def get_assets_details(assets):
⋮...

erpnext\selling\report\lost_quotations\lost_quotations.py:
│def execute(filters=None):
│	columns = get_columns(filters.get("group_by"))
│	from_date, to_date = get_timespan_date_range(filters.get("timespan").lower())
│	data = get_data(filters.get("company"), from_date, to_date, filters.get("group_by"))
│	return columns, data
⋮...
│def get_data(company: str, from_date: str, to_date: str, group_by: Literal["Lost Reason", "Competitor"]):
⋮...
│def get_columns(group_by: Literal["Lost Reason", "Competitor"]):
⋮...

erpnext\crm\report\lead_details\lead_details.py:
│def execute(filters=None):
│	columns, data = get_columns(), get_data(filters)
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_columns():
⋮...

erpnext\accounts\report\general_ledger\general_ledger.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_gl_entries(filters, accounting_dimensions):
⋮...
│def get_conditions(filters):
⋮...
│def group_by_field(group_by):
⋮...
│def validate_filters(filters, account_details):
⋮...
│def get_result(filters, account_details):
⋮...
│def get_accounts_with_children(accounts):
⋮...
│def get_account_type_map(company):
│	account_type_map = frappe._dict(
│		frappe.get_all("Account", fields=["name", "account_type"], filters={"company": company}, as_list=1)
│	)
│
│	return account_type_map
⋮...
│def validate_party(filters):
⋮...
│def set_account_currency(filters):
⋮...
│def set_bill_no(gl_entries):
│	inv_details = get_supplier_invoice_details()
│	for gl in gl_entries:
│		gl["bill_no"] = inv_details.get(gl.get("against_voucher"), "")
⋮...
│def get_data_with_opening_closing(filters, account_details, accounting_dimensions, gl_entries):
⋮...
│def get_totals_dict():
⋮...
│def initialize_gle_map(gl_entries, filters, totals_dict):
⋮...
│def get_accountwise_gle(filters, accounting_dimensions, gl_entries, gle_map, totals):
⋮...
│def get_result_as_list(data, filters):
⋮...
│def get_supplier_invoice_details():
⋮...
│def get_balance(row, balance, debit_field, credit_field):
│	balance += row.get(debit_field, 0) - row.get(credit_field, 0)
│
│	return balance
⋮...

erpnext\stock\doctype\stock_entry\stock_entry_utils.py:
│def make_stock_entry(**args):
⋮...

erpnext\regional\report\vat_audit_report\test_vat_audit_report.py:
│def make_item(item_code, properties=None):
⋮...
│def make_customer():
⋮...
│def make_supplier():
⋮...
│def make_company(company_name, abbr):
⋮...
│def make_sales_invoices():
⋮...
│def create_purchase_invoices():
⋮...
│class TestVATAuditReport(TestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.sql("delete from `tabSales Invoice` where company='_Test Company SA VAT'")
│		frappe.db.sql("delete from `tabPurchase Invoice` where company='_Test Company SA VAT'")
⋮...
│	def test_vat_audit_report(self):
⋮...
│def set_sa_vat_accounts():
⋮...

erpnext\selling\report\sales_person_wise_transaction_summary\sales_person_wise_transaction_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details():
│	item_details = {}
│	for d in frappe.db.sql("""SELECT `name`, `item_group`, `brand` FROM `tabItem`""", as_dict=1):
│		item_details.setdefault(d.name, d)
│
│	return item_details
⋮...
│def get_conditions(filters, date_field):
⋮...
│def get_items(filters):
⋮...
│def get_entries(filters):
⋮...

erpnext\stock\report\stock_ledger\stock_ledger.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details(items, sl_entries, include_uom):
⋮...
│def get_stock_ledger_entries(filters, items):
⋮...
│def get_items(filters):
⋮...
│def get_opening_balance(filters, columns, sl_entries):
⋮...
│def get_item_group_condition(item_group, item_table=None):
⋮...
│def update_available_serial_nos(available_serial_nos, sle):
⋮...
│def get_opening_balance_from_batch(filters, columns, sl_entries):
⋮...
│def get_warehouse_condition(warehouse):
⋮...
│def check_inventory_dimension_filters_applied(filters) -> bool:
│	for dimension in get_inventory_dimensions():
│		if dimension.fieldname in filters and filters.get(dimension.fieldname):
│			return True
│
│	return False
⋮...
│def get_segregated_bundle_entries(sle, bundle_details, batch_balance_dict, filters):
⋮...
│def get_serial_batch_bundle_details(sl_entries, filters=None):
⋮...
│def get_serial_and_batch_bundles(filters):
⋮...
│def get_inventory_dimension_fields():
│	return [dimension.fieldname for dimension in get_inventory_dimensions()]
⋮...
│def get_sle_conditions(filters):
⋮...

erpnext\buying\doctype\purchase_order\purchase_order.py:
│def make_purchase_receipt(source_name, target_doc=None):
⋮...
│def make_purchase_invoice(source_name, target_doc=None):
│	return get_mapped_purchase_invoice(source_name, target_doc)
⋮...
│def set_missing_values(source, target):
│	target.run_method("set_missing_values")
│	target.run_method("calculate_taxes_and_totals")
⋮...
│def get_list_context(context=None):
⋮...
│def make_subcontracting_order(source_name, target_doc=None, save=False, submit=False, notify=False):
⋮...
│def update_status(status, name):
│	po = frappe.get_doc("Purchase Order", name)
│	po.update_status(status)
│	po.update_delivered_qty_in_sales_order()
⋮...
│def item_last_purchase_rate(name, conversion_rate, item_code, conversion_factor=1.0):
⋮...
│def get_mapped_purchase_invoice(source_name, target_doc=None, ignore_permissions=False):
⋮...
│def get_mapped_subcontracting_order(source_name, target_doc=None):
⋮...
│class PurchaseOrder(BuyingController):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def onload(self):
│		supplier_tds = frappe.db.get_value("Supplier", self.supplier, "tax_withholding_category")
│		self.set_onload("supplier_tds", supplier_tds)
│		self.set_onload("can_update_items", self.can_update_items())
⋮...
│	def validate(self):
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def set_tax_withholding(self):
⋮...
│	def validate_supplier(self):
⋮...
│	def validate_minimum_order_qty(self):
⋮...
│	def validate_bom_for_subcontracting_items(self):
⋮...
│	def validate_fg_item_for_subcontracting(self):
⋮...
│	def get_schedule_dates(self):
│		for d in self.get("items"):
│			if d.material_request_item and not d.schedule_date:
│				d.schedule_date = frappe.db.get_value(
│					"Material Request Item", d.material_request_item, "schedule_date"
│				)
⋮...
│	def get_last_purchase_rate(self):
⋮...
│	def check_on_hold_or_closed_status(self):
⋮...
│	def update_ordered_qty(self, po_item_rows=None):
⋮...
│	def check_modified_date(self):
⋮...
│	def update_status(self, status):
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def on_update(self):
│		pass
⋮...
│	def update_status_updater(self):
⋮...
│	def update_status_updater_if_from_pp(self):
⋮...
│	def update_delivered_qty_in_sales_order(self):
⋮...
│	def has_drop_ship_item(self):
│		return any(d.delivered_by_supplier for d in self.items)
⋮...
│	def is_against_so(self):
│		return any(d.sales_order for d in self.items if d.sales_order)
⋮...
│	def is_against_pp(self):
│		return any(d.production_plan for d in self.items if d.production_plan)
⋮...
│	def set_received_qty_for_drop_ship_items(self):
│		for item in self.items:
│			if item.delivered_by_supplier == 1:
│				item.received_qty = item.qty
⋮...
│	def update_reserved_qty_for_subcontract(self):
│		if self.is_old_subcontracting_flow:
│			for d in self.supplied_items:
│				if d.rm_item_code:
│					stock_bin = get_bin(d.rm_item_code, d.reserve_warehouse)
│					stock_bin.update_reserved_qty_for_sub_contracting(subcontract_doctype="Purchase Order")
⋮...
│	def update_receiving_percentage(self):
⋮...
│	def set_service_items_for_finished_goods(self):
⋮...
│	def can_update_items(self) -> bool:
⋮...
│	def update_ordered_qty_in_so_for_removed_items(self, removed_items):
⋮...
│	def auto_create_subcontracting_order(self):
│		if self.is_subcontracted and not self.is_old_subcontracting_flow:
│			if frappe.db.get_single_value("Buying Settings", "auto_create_subcontracting_order"):
│				make_subcontracting_order(self.name, save=True, notify=True)
⋮...
│	def update_subcontracting_order_status(self):
⋮...
│	def set_missing_values(self, for_validate=False):
│		tds_category = frappe.db.get_value("Supplier", self.supplier, "tax_withholding_category")
│		if tds_category and not for_validate:
│			self.set_onload("supplier_tds", tds_category)
│
│		super().set_missing_values(for_validate)
⋮...
│def close_or_unclose_purchase_orders(names, status):
⋮...
│def make_purchase_invoice_from_portal(purchase_order_name):
⋮...
│def make_inter_company_sales_order(source_name, target_doc=None):
│	from erpnext.accounts.doctype.sales_invoice.sales_invoice import make_inter_company_transaction
│
│	return make_inter_company_transaction("Purchase Order", source_name, target_doc)
⋮...
│def is_po_fully_subcontracted(po_name):
⋮...

erpnext\controllers\stock_controller.py:
│def get_data(raw_columns, raw_data):
⋮...
│def get_columns(raw_columns, fields):
│	return [
│		{"name": d.get("label"), "editable": False, "width": 110}
│		for d in raw_columns
│		if not d.get("hidden") and d.get("fieldname") in fields
│	]
⋮...
│class StockController(AccountsController):
⋮...
│def create_repost_item_valuation_entry(args):
⋮...
│def future_sle_exists(args, sl_entries=None, allow_force_reposting=True):
⋮...
│class QualityInspectionRejectedError(frappe.ValidationError):
│	pass
⋮...
│def create_item_wise_repost_entries(
│	voucher_type, voucher_no, allow_zero_rate=False, via_landed_cost_voucher=False
│):
⋮...
│class QualityInspectionRequiredError(frappe.ValidationError):
│	pass
⋮...
│class QualityInspectionNotSubmittedError(frappe.ValidationError):
│	pass
⋮...
│class BatchExpiredError(frappe.ValidationError):
│	pass
⋮...
│def make_bundle_for_material_transfer(**kwargs):
⋮...
│	def validate(self):
⋮...
│	def reset_conversion_factor(self):
⋮...
│	def validate_items_exist(self):
⋮...
│	def validate_duplicate_serial_and_batch_bundle(self, table_name):
⋮...
│	def make_gl_entries(self, gl_entries=None, from_repost=False, via_landed_cost_voucher=False):
⋮...
│	def validate_serialized_batch(self):
⋮...
│	def clean_serial_nos(self):
⋮...
│	def make_bundle_using_old_serial_batch_fields(self, table_name=None, via_landed_cost_voucher=False):
⋮...
│	def get_parent_details_for_packed_items(self):
│		parent_details = frappe._dict()
│		for row in self.get("items"):
│			parent_details[row.name] = row
│
│		return parent_details
⋮...
│	def make_bundle_for_sales_purchase_return(self, table_name=None):
⋮...
│	def make_bundle_for_rejected_qty(self, table_name=None):
⋮...
│	def make_bundle_for_non_rejected_qty(self, table_name):
⋮...
│	def get_reference_ids(self, table_name, qty_field=None, bundle_field=None) -> tuple[str, list[str]]:
⋮...
│	def is_serial_batch_item(self, item_code) -> bool:
⋮...
│	def update_bundle_details(self, bundle_details, table_name, row, is_rejected=False, parent_details=None):
⋮...
│	def create_serial_batch_bundle(self, bundle_details, row):
⋮...
│	def validate_serial_nos_and_batches_with_bundle(self, row):
⋮...
│	def set_use_serial_batch_fields(self):
│		if frappe.db.get_single_value("Stock Settings", "use_serial_batch_fields"):
│			for row in self.items:
│				row.use_serial_batch_fields = 1
⋮...
│	def get_gl_entries(self, warehouse_account=None, default_expense_account=None, default_cost_center=None):
⋮...
│	def get_debit_field_precision(self):
│		if not frappe.flags.debit_field_precision:
│			frappe.flags.debit_field_precision = frappe.get_precision("GL Entry", "debit_in_account_currency")
│
│		return frappe.flags.debit_field_precision
⋮...
│	def get_voucher_details(self, default_expense_account, default_cost_center, sle_map):
⋮...
│	def get_items_and_warehouses(self) -> tuple[list[str], list[str]]:
⋮...
│	def get_stock_ledger_details(self):
⋮...
│	def check_expense_account(self, item):
⋮...
│	def delete_auto_created_batches(self):
⋮...
│	def set_serial_and_batch_bundle(self, table_name=None, ignore_validate=False):
⋮...
│	def make_package_for_transfer(
│		self, serial_and_batch_bundle, warehouse, type_of_transaction=None, do_not_submit=None
│	):
⋮...
│	def get_sl_entries(self, d, args):
⋮...
│	def update_inventory_dimensions(self, row, sl_dict) -> None:
⋮...
│	def make_sl_entries(self, sl_entries, allow_negative_stock=False, via_landed_cost_voucher=False):
│		from erpnext.stock.serial_batch_bundle import update_batch_qty
│		from erpnext.stock.stock_ledger import make_sl_entries
│
│		make_sl_entries(sl_entries, allow_negative_stock, via_landed_cost_voucher)
│		update_batch_qty(self.doctype, self.name, via_landed_cost_voucher=via_landed_cost_voucher)
⋮...
│	def make_gl_entries_on_cancel(self):
⋮...
│	def get_serialized_items(self):
⋮...
│	def validate_warehouse(self):
⋮...
│	def update_billing_percentage(self, update_modified=True):
⋮...
│	def validate_inspection(self):
⋮...
│	def validate_qi_presence(self, row):
⋮...
│	def validate_qi_submission(self, row):
⋮...
│	def validate_qi_rejection(self, row):
⋮...
│	def update_blanket_order(self):
│		blanket_orders = list(set([d.blanket_order for d in self.items if d.blanket_order]))
│		for blanket_order in blanket_orders:
│			frappe.get_doc("Blanket Order", blanket_order).update_ordered_qty()
⋮...
│	def validate_customer_provided_item(self):
│		for d in self.get("items"):
│			# Customer Provided parts will have zero valuation rate
│			if frappe.get_cached_value("Item", d.item_code, "is_customer_provided_item"):
│				d.allow_zero_valuation_rate = 1
⋮...
│	def set_rate_of_stock_uom(self):
⋮...
│	def validate_internal_transfer(self):
⋮...
│	def validate_internal_transfer_warehouse(self):
⋮...
│	def validate_in_transit_warehouses(self):
⋮...
│	def validate_multi_currency(self):
│		if self.currency != self.company_currency:
│			frappe.throw(_("Internal transfers can only be done in company's default currency"))
⋮...
│	def validate_packed_items(self):
│		if self.doctype in ("Sales Invoice", "Delivery Note Item") and self.get("packed_items"):
│			frappe.throw(_("Packed Items cannot be transferred internally"))
⋮...
│	def validate_internal_transfer_qty(self):
⋮...
│	def get_item_wise_inter_transfer_qty(self):
⋮...
│	def get_item_wise_inter_received_qty(self):
⋮...
│	def validate_putaway_capacity(self):
⋮...
│	def prepare_over_receipt_message(self, rule, values):
⋮...
│	def repost_future_sle_and_gle(self, force=False, via_landed_cost_voucher=False):
⋮...
│	def add_gl_entry(
│		self,
│		gl_entries,
│		account,
│		cost_center,
│		debit,
│		credit,
│		remarks,
│		against_account,
│		debit_in_account_currency=None,
│		credit_in_account_currency=None,
│		account_currency=None,
│		project=None,
│		voucher_detail_no=None,
│		item=None,
│		posting_date=None,
│	):
⋮...
│def show_accounting_ledger_preview(company, doctype, docname):
⋮...
│def show_stock_ledger_preview(company, doctype, docname):
⋮...
│def get_accounting_ledger_preview(doc, filters):
⋮...
│def get_stock_ledger_preview(doc, filters):
⋮...
│def get_sl_entries_for_preview(doctype, docname, fields):
⋮...
│def get_gl_entries_for_preview(doctype, docname, fields):
│	return frappe.get_all("GL Entry", filters={"voucher_type": doctype, "voucher_no": docname}, fields=fields)
⋮...
│def repost_required_for_queue(doc: StockController) -> bool:
⋮...
│def check_item_quality_inspection(doctype, items):
⋮...
│def make_quality_inspections(doctype, docname, items, inspection_type):
⋮...
│def is_reposting_pending():
│	return frappe.db.exists(
│		"Repost Item Valuation", {"docstatus": 1, "status": ["in", ["Queued", "In Progress"]]}
│	)
⋮...
│def validate_future_sle_not_exists(args, key, sl_entries=None):
⋮...
│def get_cached_data(args, key):
⋮...
│def get_sle_entries_against_voucher(args):
⋮...
│def get_conditions_to_validate_future_sle(sl_entries):
⋮...

erpnext\stock\report\stock_ageing\stock_ageing.py:
│def execute(filters: Filters = None) -> tuple:
⋮...
│def get_columns(filters: Filters) -> list[dict]:
⋮...
│def get_chart_data(data: list, filters: Filters) -> dict:
⋮...
│class FIFOSlots:
⋮...
│def format_report_data(filters: Filters, item_details: dict, to_date: str) -> list[dict]:
⋮...
│def get_average_age(fifo_queue: list, to_date: str) -> float:
⋮...
│def add_column(range_columns: list, label: str, fieldname: str, fieldtype: str = "Float", width: int = 140):
│	range_columns.append(dict(label=label, fieldname=fieldname, fieldtype=fieldtype, width=width))
⋮...
│def check_and_replace_valuations_if_moving_average(range_values, item_valuation_method, valuation_rate):
⋮...
│def get_range_age(filters: Filters, fifo_queue: list, to_date: str, item_dict: dict) -> list:
⋮...
│def setup_ageing_columns(filters: Filters, range_columns: list):
⋮...
│	def __init__(self, filters: dict | None = None, sle: list | None = None):
│		self.item_details = {}
│		self.transferred_item_details = {}
│		self.serial_no_batch_purchase_details = {}
│		self.filters = filters
│		self.sle = sle
⋮...
│	def generate(self) -> dict:
⋮...
│	def __init_key_stores(self, row: dict) -> tuple:
⋮...
│	def __compute_incoming_stock(self, row: dict, fifo_queue: list, transfer_key: tuple, serial_nos: list):
⋮...
│	def __compute_outgoing_stock(self, row: dict, fifo_queue: list, transfer_key: tuple, serial_nos: list):
⋮...
│	def __adjust_incoming_transfer_qty(self, transfer_data: dict, fifo_queue: list, row: dict):
⋮...
│	def __update_balances(self, row: dict, key: tuple | str):
⋮...
│	def __aggregate_details_by_item(self, wh_wise_data: dict) -> dict:
⋮...
│	def __get_stock_ledger_entries(self) -> Iterator[dict]:
⋮...
│	def __get_bundle_wise_serial_nos(self) -> dict:
⋮...
│	def __get_item_query(self) -> str:
⋮...
│	def __get_warehouse_conditions(self, sle, sle_query) -> str:
⋮...

erpnext\accounts\report\financial_statements.py:
│def get_data(
│	company,
│	root_type,
│	balance_must_be,
│	period_list,
│	filters=None,
│	accumulated_values=1,
│	only_current_fiscal_year=True,
│	ignore_closing_entries=False,
│	ignore_accumulated_values_for_fy=False,
│	total=True,
│):
⋮...
│def get_columns(periodicity, period_list, accumulated_values=1, company=None, cash_flow=False):
⋮...
│def get_period_list(
│	from_fiscal_year,
│	to_fiscal_year,
│	period_start_date,
│	period_end_date,
│	filter_based_on,
│	periodicity,
│	accumulated_values=False,
│	company=None,
│	reset_period_on_fy_change=True,
│	ignore_fiscal_year=False,
│):
⋮...
│def prepare_data(accounts, balance_must_be, period_list, company_currency, accumulated_values):
⋮...
│def accumulate_values_into_parents(accounts, accounts_by_name, period_list):
⋮...
│def filter_out_zero_value_rows(data, parent_children_map, show_zero_values=False):
⋮...
│def filter_accounts(accounts, depth=20):
⋮...
│def set_gl_entries_by_account(
│	company,
│	from_date,
│	to_date,
│	filters,
│	gl_entries_by_account,
│	root_lft=None,
│	root_rgt=None,
│	root_type=None,
│	ignore_closing_entries=False,
│	ignore_opening_entries=False,
│	group_by_account=False,
│):
⋮...
│def validate_fiscal_year(fiscal_year, from_fiscal_year, to_fiscal_year):
│	if not fiscal_year.get("year_start_date") or not fiscal_year.get("year_end_date"):
│		frappe.throw(_("Start Year and End Year are mandatory"))
│
│	if getdate(fiscal_year.get("year_end_date")) < getdate(fiscal_year.get("year_start_date")):
│		frappe.throw(_("End Year cannot be before Start Year"))
⋮...
│def calculate_values(
│	accounts_by_name,
│	gl_entries_by_account,
│	period_list,
│	accumulated_values,
│	ignore_accumulated_values_for_fy,
│):
⋮...
│def add_total_row(out, root_type, balance_must_be, period_list, company_currency):
⋮...
│def get_cost_centers_with_children(cost_centers):
⋮...
│def get_fiscal_year_data(from_fiscal_year, to_fiscal_year):
⋮...
│def get_label(periodicity, from_date, to_date):
⋮...
│def sort_accounts(accounts, is_root=False, key="name"):
⋮...
│def get_filtered_list_for_consolidated_report(filters, period_list):
⋮...
│def get_accounts(company, root_type):
⋮...
│def get_accounting_entries(
│	doctype,
│	from_date,
│	to_date,
│	filters,
│	root_lft=None,
│	root_rgt=None,
│	root_type=None,
│	ignore_closing_entries=None,
│	period_closing_voucher=None,
│	ignore_opening_entries=False,
│	group_by_account=False,
│):
⋮...
│def compute_growth_view_data(data, columns):
⋮...
│def validate_dates(from_date, to_date):
│	if not from_date or not to_date:
│		frappe.throw(_("From Date and To Date are mandatory"))
│
│	if to_date < from_date:
│		frappe.throw(_("To Date cannot be less than From Date"))
⋮...
│def get_months(start_date, end_date):
│	diff = (12 * end_date.year + end_date.month) - (12 * start_date.year + start_date.month)
│	return diff + 1
⋮...
│def get_appropriate_currency(company, filters=None):
│	if filters and filters.get("presentation_currency"):
│		return filters["presentation_currency"]
│	else:
│		return frappe.get_cached_value("Company", company, "default_currency")
⋮...
│def get_account_filter_query(root_lft, root_rgt, root_type, gl_entry):
⋮...
│def apply_additional_conditions(doctype, query, from_date, ignore_closing_entries, filters):
⋮...
│def compute_margin_view_data(data, columns, accumulated_values):
⋮...

erpnext\accounts\report\sales_register\sales_register.py:
│def execute(filters=None):
│	return _execute(filters)
⋮...
│def get_columns(invoice_list, additional_table_columns, include_payments=False):
⋮...
│def get_conditions(filters, query, doctype):
⋮...
│def get_invoices(filters, additional_query_columns):
⋮...
│def get_mode_of_payments(invoice_list):
⋮...
│def _execute(filters, additional_table_columns=None):
⋮...
│def get_payments(filters):
⋮...
│def get_account_columns(invoice_list, include_payments):
⋮...
│def get_internal_invoice_map(invoice_list):
⋮...
│def get_invoice_tax_map(invoice_list, invoice_income_map, income_accounts, include_payments=False):
⋮...
│def get_invoice_income_map(invoice_list):
⋮...
│def get_invoice_so_dn_map(invoice_list):
⋮...
│def get_invoice_cc_wh_map(invoice_list):
⋮...

erpnext\accounts\report\payment_period_based_on_invoice_date\payment_period_based_on_invoice_date.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters):
⋮...
│def validate_filters(filters):
⋮...
│def get_entries(filters):
⋮...
│def get_invoice_posting_date_map(filters):
⋮...

erpnext\accounts\report\purchase_register\purchase_register.py:
│def execute(filters=None):
│	return _execute(filters)
⋮...
│def get_columns(invoice_list, additional_table_columns, include_payments=False):
⋮...
│def get_conditions(filters, query, doctype):
⋮...
│def get_invoices(filters, additional_query_columns):
⋮...
│def _execute(filters=None, additional_table_columns=None):
⋮...
│def get_account_details(invoice_list):
⋮...
│def get_payments(filters):
⋮...
│def get_account_columns(invoice_list, include_payments):
⋮...
│def get_internal_invoice_map(invoice_list):
⋮...
│def get_invoice_tax_map(invoice_list, invoice_expense_map, expense_accounts, include_payments=False):
⋮...
│def get_invoice_expense_map(invoice_list):
⋮...
│def get_invoice_po_pr_map(invoice_list):
⋮...

erpnext\accounts\report\pos_register\pos_register.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters):
⋮...
│def validate_filters(filters):
⋮...
│def get_pos_entries(filters, group_by_field):
⋮...
│def concat_mode_of_payments(pos_entries):
│	mode_of_payments = get_mode_of_payments(set(d.pos_invoice for d in pos_entries))
│	for entry in pos_entries:
│		if mode_of_payments.get(entry.pos_invoice):
│			entry.mode_of_payment = ", ".join(mode_of_payments.get(entry.pos_invoice, []))
⋮...
│def add_subtotal_row(data, group_invoices, group_by_field, group_by_value):
⋮...
│def get_group_by_field(group_by):
⋮...

erpnext\stock\report\batch_wise_balance_history\batch_wise_balance_history.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details(filters):
│	item_map = {}
│	for d in (frappe.qb.from_("Item").select("name", "item_name", "description", "stock_uom")).run(as_dict=1):
│		item_map.setdefault(d.name, d)
│
│	return item_map
⋮...
│def get_stock_ledger_entries(filters):
⋮...
│def get_stock_closing_balance(stk_cl_obj, filters):
⋮...
│def get_stock_ledger_entries_for_batch_no(filters):
⋮...
│def get_stock_ledger_entries_for_batch_bundle(filters):
⋮...
│def get_item_warehouse_batch_map(filters, float_precision):
⋮...

erpnext\selling\report\payment_terms_status_for_sales_order\payment_terms_status_for_sales_order.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_conditions(filters):
⋮...
│def get_descendants_of(doctype, group_name):
⋮...
│def prepare_chart(s_orders):
⋮...
│def get_customers_or_items(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def build_filter_criterions(filters):
⋮...
│def get_so_with_invoices(filters):
⋮...
│def set_payment_terms_statuses(sales_orders, invoices, filters):
⋮...
│def filter_on_calculated_status(filters, sales_orders):
│	if filters.status and sales_orders:
│		return [x for x in sales_orders if x.status in filters.status]
│	return sales_orders
⋮...
│def filter_for_immediate_upcoming_term(filters, sales_orders):
⋮...

erpnext\accounts\report\sales_payment_summary\sales_payment_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters):
⋮...
│def get_invoices(filters):
⋮...
│def get_mode_of_payments(filters):
⋮...
│def get_mode_of_payment_details(filters):
⋮...
│def get_pos_columns():
⋮...
│def get_pos_sales_payment_data(filters):
⋮...
│def get_sales_payment_data(filters, columns):
⋮...
│def get_pos_invoice_data(filters):
⋮...
│def get_sales_invoice_data(filters):
⋮...

erpnext\stock\report\item_prices\item_prices.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_item_details(filters):
⋮...
│def get_valuation_rate():
⋮...
│def get_price_list():
⋮...
│def get_last_purchase_rate():
⋮...
│def get_item_bom_rate():
⋮...

erpnext\accounts\doctype\tax_withholding_category\test_tax_withholding_category.py:
│def create_sales_invoice(**args):
⋮...
│def create_purchase_order(**args):
⋮...
│def create_payment_entry(**args):
⋮...
│def create_purchase_invoice(**args):
⋮...
│def create_tax_withholding_category(
│	category_name,
│	rate,
│	from_date,
│	to_date,
│	account,
│	single_threshold=0,
│	cumulative_threshold=0,
│	round_off_tax_amount=0,
│	consider_party_ledger_amount=0,
│	tax_on_excess_amount=0,
│):
⋮...
│def create_records():
⋮...
│def create_lower_deduction_certificate(
│	supplier, tax_withholding_category, tax_rate, certificate_no, limit, valid_from=None, valid_upto=None
│):
⋮...
│class UnitTestTaxWithholdingCategory(UnitTestCase):
⋮...
│class TestTaxWithholdingCategory(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		# create relevant supplier, etc
│		create_records()
│		create_tax_withholding_category_records()
│		make_pan_no_field()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_cumulative_threshold_tds(self):
⋮...
│	def test_tds_with_account_changed(self):
⋮...
│	def test_single_threshold_tds(self):
⋮...
│	def test_tax_withholding_category_checks(self):
⋮...
│	def test_cumulative_threshold_with_party_ledger_amount_on_net_total(self):
⋮...
│	def test_cumulative_threshold_with_tax_on_excess_amount(self):
⋮...
│	def test_cumulative_threshold_tcs(self):
⋮...
│	def test_tcs_on_unallocated_advance_payments(self):
⋮...
│	def test_tcs_on_allocated_advance_payments(self):
⋮...
│	def test_tds_calculation_on_net_total(self):
⋮...
│	def test_tds_calculation_on_net_total_partial_tds(self):
⋮...
│	def test_tds_deduction_for_po_via_payment_entry(self):
⋮...
│	def test_multi_category_single_supplier(self):
⋮...
│	def test_tax_withholding_category_voucher_display(self):
⋮...
│	def test_tax_withholding_via_payment_entry_for_advances(self):
⋮...
│	def test_lower_deduction_certificate_application(self):
⋮...
│	def test_ldc_at_0_rate(self):
⋮...
│	def set_previous_fy_and_tax_category(self):
⋮...
│	def test_tds_across_fiscal_year(self):
⋮...
│def cancel_invoices():
⋮...
│def create_tax_withholding_category_records():
⋮...
│def make_pan_no_field():
⋮...

erpnext\accounts\doctype\sales_invoice\test_sales_invoice.py:
│def create_sales_invoice(**args):
⋮...
│def check_gl_entries(doc, voucher_no, expected_gle, posting_date, voucher_type="Sales Invoice"):
⋮...
│def create_sales_invoice_against_cost_center(**args):
⋮...
│def set_advance_flag(company, flag, default_account):
⋮...
│def get_taxes_and_charges():
⋮...
│def create_internal_supplier(supplier_name, represents_company, allowed_to_interact_with):
⋮...
│def get_outstanding_amount(against_voucher_type, against_voucher, account, party, party_type):
⋮...
│def add_taxes(doc):
⋮...
│class UnitTestSalesInvoice(UnitTestCase):
⋮...
│class TestSalesInvoice(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def make(self):
│		w = frappe.copy_doc(self.globalTestRecords["Sales Invoice"][0])
│		w.is_pos = 0
│		w.insert()
│		w.submit()
│		return w
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		cls.enterClassContext(cls.change_settings("Selling Settings", validate_selling_price=0))
│		unlink_payment_on_cancel_of_invoice()
⋮...
│	def tearDownClass(self):
│		unlink_payment_on_cancel_of_invoice(0)
⋮...
│	def test_sales_invoice_qty(self):
⋮...
│	def test_timestamp_change(self):
⋮...
│	def test_sales_invoice_change_naming_series(self):
⋮...
│	def test_add_terms_after_save(self):
│		si = frappe.copy_doc(self.globalTestRecords["Sales Invoice"][2])
│		si.insert()
│
│		self.assertTrue(si.payment_schedule)
│		self.assertEqual(getdate(si.payment_schedule[0].due_date), getdate(si.due_date))
⋮...
│	def test_sales_invoice_calculation_base_currency(self):
⋮...
│	def test_payment_entry_unlink_against_invoice(self):
⋮...
│	def test_payment_entry_unlink_against_standalone_credit_note(self):
⋮...
│	def test_sales_invoice_calculation_export_currency(self):
⋮...
│	def test_sales_invoice_with_discount_and_inclusive_tax(self):
⋮...
│	def test_sales_invoice_discount_amount(self):
⋮...
│	def test_discount_amount_gl_entry(self):
⋮...
│	def test_tax_calculation_with_multiple_items(self):
⋮...
│	def test_tax_calculation_with_item_tax_template(self):
⋮...
│	def test_tax_calculation_with_multiple_items_and_discount(self):
⋮...
│	def test_inclusive_rate_validations(self):
⋮...
│	def test_sales_invoice_calculation_base_currency_with_tax_inclusive_price(self):
⋮...
│	def test_sales_invoice_calculation_export_currency_with_tax_inclusive_price(self):
⋮...
│	def test_outstanding(self):
│		w = self.make()
│		self.assertEqual(w.outstanding_amount, w.base_rounded_total)
⋮...
│	def test_rounded_total_with_cash_discount(self):
⋮...
│	def test_payment(self):
⋮...
│	def test_outstanding_on_cost_center_allocation(self):
⋮...
│	def test_sales_invoice_gl_entry_without_perpetual_inventory(self):
⋮...
│	def test_pos_gl_entry_with_perpetual_inventory(self):
⋮...
│	def test_pos_returns_with_repayment(self):
⋮...
│	def test_pos_change_amount(self):
⋮...
│	def test_auto_write_off_amount(self):
⋮...
│	def test_ledger_entries_of_return_pos_invoice(self):
⋮...
│	def test_pos_with_no_gl_entry_for_change_amount(self):
⋮...
│	def validate_pos_gl_entry(self, si, pos, cash_amount, validate_without_change_gle=False):
⋮...
│	def test_bin_details_of_packed_item(self):
⋮...
│	def test_pos_si_without_payment(self):
⋮...
│	def test_sales_invoice_gl_entry_with_perpetual_inventory_no_item_code(self):
⋮...
│	def test_sales_invoice_gl_entry_with_perpetual_inventory_non_stock_item(self):
⋮...
│	def _insert_purchase_receipt(self):
│		pr = frappe.copy_doc(self.globalTestRecords["Purchase Receipt"][0])
│		pr.naming_series = "_T-Purchase Receipt-"
│		pr.insert()
│		pr.submit()
⋮...
│	def _insert_delivery_note(self):
│		dn = frappe.copy_doc(self.globalTestRecords["Delivery Note"][0])
│		dn.naming_series = "_T-Delivery Note-"
│		dn.insert()
│		dn.submit()
│		return dn
⋮...
│	def test_sales_invoice_with_advance(self):
⋮...
│	def test_serialized(self):
⋮...
│	def test_serialized_cancel(self):
⋮...
│	def test_serial_numbers_against_delivery_note(self):
⋮...
│	def test_return_sales_invoice(self):
⋮...
│	def test_zero_qty_return_invoice_with_stock_effect(self):
│		cr_note = create_sales_invoice(qty=-1, rate=300, is_return=1, do_not_submit=True)
│		cr_note.update_stock = True
│		cr_note.items[0].qty = 0
│		self.assertRaises(frappe.ValidationError, cr_note.save)
⋮...
│	def test_return_invoice_with_account_mismatch(self):
⋮...
│	def test_gle_made_when_asset_is_returned(self):
⋮...
│	def test_incoming_rate_for_stand_alone_credit_note(self):
⋮...
│	def test_discount_on_net_total(self):
⋮...
│	def test_multi_currency_gle(self):
⋮...
│	def test_gle_in_transaction_currency(self):
⋮...
│	def test_invalid_currency(self):
⋮...
│	def test_create_so_with_margin(self):
⋮...
│	def test_outstanding_amount_after_advance_jv_cancellation(self):
⋮...
│	def test_outstanding_amount_after_advance_payment_entry_cancellation(self):
⋮...
│	def test_multiple_uom_in_selling(self):
⋮...
│	def test_item_wise_tax_breakup(self):
⋮...
│	def create_si_to_test_tax_breakup(self):
⋮...
│	def test_company_monthly_sales(self):
⋮...
│	def test_rounding_adjustment(self):
⋮...
│	def test_rounding_adjustment_2(self):
⋮...
│	def test_rounding_adjustment_3(self):
⋮...
│	def test_sales_invoice_with_shipping_rule(self):
⋮...
│	def test_create_invoice_without_terms(self):
│		si = create_sales_invoice(do_not_save=1)
│		self.assertFalse(si.get("payment_schedule"))
│
│		si.insert()
│		self.assertTrue(si.get("payment_schedule"))
⋮...
│	def test_duplicate_due_date_in_terms(self):
│		si = create_sales_invoice(do_not_save=1)
│		si.append("payment_schedule", dict(due_date="2017-01-01", invoice_portion=50.00, payment_amount=50))
│		si.append("payment_schedule", dict(due_date="2017-01-01", invoice_portion=50.00, payment_amount=50))
│
│		self.assertRaises(frappe.ValidationError, si.insert)
⋮...
│	def test_credit_note(self):
⋮...
│	def test_sales_invoice_with_cost_center(self):
⋮...
│	def test_sales_invoice_with_project_link(self):
⋮...
│	def test_sales_invoice_without_cost_center(self):
⋮...
│	def test_deferred_revenue(self):
⋮...
│	def test_deferred_revenue_missing_account(self):
⋮...
│	def test_fixed_deferred_revenue(self):
⋮...
│	def test_inter_company_transaction(self):
⋮...
│	def test_inter_company_transaction_without_default_warehouse(self):
⋮...
│	def test_sle_for_target_warehouse(self):
⋮...
│	def test_internal_transfer_gl_entry(self):
⋮...
│	def test_internal_transfer_gl_precision_issues(self):
⋮...
│	def test_item_tax_net_range(self):
⋮...
│	def test_sales_invoice_with_discount_accounting_enabled(self):
⋮...
│	def test_additional_discount_for_sales_invoice_with_discount_accounting_enabled(self):
⋮...
│	def test_asset_depreciation_on_sale_with_pro_rata(self):
⋮...
│	def test_asset_depreciation_on_sale_without_pro_rata(self):
⋮...
│	def test_depreciation_on_return_of_sold_asset(self):
⋮...
│	def test_sales_invoice_against_supplier(self):
⋮...
│	def test_sales_invoice_against_supplier_usd_with_dimensions(self):
⋮...
│	def test_sales_invoice_cancel_with_common_party_advance_jv(self):
⋮...
│	def test_payment_statuses(self):
⋮...
│	def test_update_invoice_status(self):
⋮...
│	def test_sales_commission(self):
⋮...
│	def test_sales_invoice_submission_post_account_freezing_date(self):
⋮...
│	def test_over_billing_case_against_delivery_note(self):
⋮...
│	def test_multi_currency_deferred_revenue_via_journal_entry(self):
⋮...
│	def test_standalone_serial_no_return(self):
│		si = create_sales_invoice(
│			item_code="_Test Serialized Item With Series", update_stock=True, is_return=True, qty=-1
│		)
│		si.reload()
│		self.assertTrue(get_serial_nos_from_bundle(si.items[0].serial_and_batch_bundle))
⋮...
│	def test_sales_invoice_with_disabled_account(self):
⋮...
│	def test_gain_loss_with_advance_entry(self):
⋮...
│	def test_batch_expiry_for_sales_invoice_return(self):
⋮...
│	def test_sales_invoice_with_payable_tax_account(self):
⋮...
│	def test_advance_entries_as_liability(self):
⋮...
│	def test_sales_invoice_without_customer_group_and_territory(self):
⋮...
│	def test_sales_return_negative_rate(self):
│		si = create_sales_invoice(is_return=1, qty=-2, rate=-10, do_not_save=True)
│		self.assertRaises(frappe.ValidationError, si.save)
│
│		si.items[0].rate = 10
│		si.save()
⋮...
│	def test_partial_allocation_on_advance_as_liability(self):
⋮...
│	def test_loyalty_points_redemption_with_shopping_cart(self):
⋮...
│	def test_pulling_advance_based_on_debit_to(self):
⋮...
│	def test_taxes_merging_from_delivery_note(self):
⋮...
│	def test_pos_returns_without_update_outstanding_for_self(self):
⋮...
│	def test_validation_on_opening_invoice_with_rounding(self):
│		si = create_sales_invoice(qty=1, rate=99.98, do_not_submit=True)
│		si.is_opening = "Yes"
│		si.items[0].income_account = "Temporary Opening - _TC"
│		si.save()
│		self.assertRaises(frappe.ValidationError, si.submit)
⋮...
│	def _create_opening_roundoff_account(self, company_name):
⋮...
│	def test_opening_invoice_with_rounding_adjustment(self):
⋮...
│	def _create_opening_invoice_with_inclusive_tax(self):
⋮...
│	def test_rounding_validation_for_opening_with_inclusive_tax(self):
│		si = self._create_opening_invoice_with_inclusive_tax()
│		# 'Round Off for Opening' not set in Company master
│		# Ledger level validation must be thrown
│		self.assertRaises(frappe.ValidationError, si.submit)
⋮...
│	def test_ledger_entries_on_opening_invoice_with_rounding_loss_by_inclusive_tax(self):
⋮...
│	def test_common_party_with_foreign_currency_jv(self):
⋮...
│	def test_common_party_with_different_currency_in_debtor_and_creditor(self):
⋮...
│	def test_invoice_remarks(self):
⋮...
│	def test_gl_voucher_subtype(self):
⋮...
│	def test_total_billed_amount(self):
⋮...
│	def test_total_billed_amount_with_different_projects(self):
⋮...
│	def test_pos_returns_with_party_account_currency(self):
⋮...
│	def test_create_return_invoice_for_self_update(self):
⋮...
│	def test_prevents_fully_returned_invoice_with_zero_quantity(self):
⋮...
│def create_internal_parties():
⋮...
│def setup_accounts():
⋮...

erpnext\accounts\report\budget_variance_report\budget_variance_report.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_chart_data(filters, columns, data):
⋮...
│def get_fiscal_years(filters):
⋮...
│def get_final_data(dimension, dimension_items, filters, period_month_ranges, data, DCC_allocation):
⋮...
│def get_cost_centers(filters):
⋮...
│def get_dimension_target_details(filters):
⋮...
│def get_target_distribution_details(filters):
⋮...
│def get_actual_details(name, filters):
⋮...
│def get_dimension_account_month_map(filters):
⋮...

erpnext\accounts\report\bank_clearance_summary\bank_clearance_summary.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_conditions(filters):
⋮...
│def get_entries(filters):
⋮...
│def get_entries_for_bank_clearance_summary(filters):
⋮...

erpnext\selling\report\sales_partner_transaction_summary\sales_partner_transaction_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters, date_field):
⋮...
│def get_entries(filters):
⋮...

erpnext\selling\report\sales_person_commission_summary\sales_person_commission_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters, date_field):
⋮...
│def get_entries(filters):
⋮...

erpnext\selling\report\sales_partner_commission_summary\sales_partner_commission_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_conditions(filters, date_field):
⋮...
│def get_entries(filters):
⋮...

erpnext\selling\report\available_stock_for_packing_items\available_stock_for_packing_items.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_item_details():
⋮...
│def get_item_warehouse_quantity_map():
⋮...

erpnext\stock\report\product_bundle_balance\product_bundle_balance.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_stock_balance(filters, items):
│	sle = get_stock_ledger_entries(filters, items)
│	stock_balance = frappe._dict()
│	for d in sle:
│		stock_balance.setdefault(d.item_code, frappe._dict())[d.warehouse] = d
│	return stock_balance
⋮...
│def get_items(filters):
⋮...
│def get_stock_ledger_entries(filters, items):
⋮...

erpnext\selling\doctype\sales_order\test_sales_order.py:
│def make_sales_order(**args):
⋮...
│def get_reserved_qty(item_code="_Test Item", warehouse="_Test Warehouse - _TC"):
│	return flt(frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse}, "reserved_qty"))
⋮...
│def automatically_fetch_payment_terms(enable=1):
│	accounts_settings = frappe.get_doc("Accounts Settings")
│	accounts_settings.automatically_fetch_payment_terms = enable
│	accounts_settings.save()
⋮...
│def create_dn_against_so(so, delivered_qty=0, do_not_submit=False):
⋮...
│def compare_payment_schedules(doc, doc1, doc2):
│	for index, schedule in enumerate(doc1.get("payment_schedule")):
│		doc.assertEqual(schedule.payment_term, doc2.payment_schedule[index].payment_term)
│		doc.assertEqual(getdate(schedule.due_date), doc2.payment_schedule[index].due_date)
│		doc.assertEqual(schedule.invoice_portion, doc2.payment_schedule[index].invoice_portion)
│		doc.assertEqual(schedule.payment_amount, doc2.payment_schedule[index].payment_amount)
⋮...
│class TestSalesOrder(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		cls.unlink_setting = int(
│			frappe.db.get_single_value("Accounts Settings", "unlink_advance_payment_on_cancelation_of_order")
│		)
⋮...
│	def tearDownClass(cls) -> None:
│		# reset config to previous state
│		frappe.db.set_single_value(
│			"Accounts Settings", "unlink_advance_payment_on_cancelation_of_order", cls.unlink_setting
│		)
│		super().tearDownClass()
⋮...
│	def setUp(self):
│		self.create_customer("_Test Customer Credit")
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
│		frappe.set_user("Administrator")
⋮...
│	def test_sales_order_with_negative_rate(self):
⋮...
│	def test_sales_order_qty(self):
⋮...
│	def test_make_material_request(self):
⋮...
│	def test_make_delivery_note(self):
⋮...
│	def test_make_sales_invoice(self):
⋮...
│	def test_so_billed_amount_against_return_entry(self):
⋮...
│	def test_make_sales_invoice_with_terms(self):
⋮...
│	def test_update_qty(self):
⋮...
│	def test_return_against_sales_order(self):
⋮...
│	def test_reserved_qty_for_partial_delivery(self):
⋮...
│	def test_reserved_qty_for_over_delivery(self):
⋮...
│	def test_reserved_qty_for_over_delivery_via_sales_invoice(self):
⋮...
│	def test_reserved_qty_for_partial_delivery_with_packing_list(self):
⋮...
│	def test_sales_order_on_hold(self):
│		so = make_sales_order(item_code="_Test Product Bundle Item")
│		so.db_set("status", "On Hold")
│		si = make_sales_invoice(so.name)
│		self.assertRaises(frappe.ValidationError, create_dn_against_so, so.name)
│		self.assertRaises(frappe.ValidationError, si.submit)
⋮...
│	def test_reserved_qty_for_over_delivery_with_packing_list(self):
⋮...
│	def test_update_child_adding_new_item(self):
⋮...
│	def test_update_child_removing_item(self):
⋮...
│	def test_update_child(self):
⋮...
│	def test_update_child_with_precision(self):
⋮...
│	def test_update_child_perm(self):
⋮...
│	def test_update_child_qty_rate_with_workflow(self):
⋮...
│	def test_material_request_for_product_bundle(self):
⋮...
│	def test_bin_details_of_packed_item(self):
⋮...
│	def test_update_child_product_bundle(self):
⋮...
│	def test_update_child_with_tax_template(self):
⋮...
│	def test_warehouse_user(self):
⋮...
│	def test_block_delivery_note_against_cancelled_sales_order(self):
⋮...
│	def test_service_type_product_bundle(self):
⋮...
│	def test_mix_type_product_bundle(self):
⋮...
│	def test_auto_insert_price(self):
⋮...
│	def test_drop_shipping(self):
⋮...
│	def test_drop_shipping_partial_order(self):
⋮...
│	def test_drop_shipping_full_for_default_suppliers(self):
⋮...
│	def test_product_bundles_in_so_are_replaced_with_bundle_items_in_po(self):
⋮...
│	def test_purchase_order_updates_packed_item_ordered_qty(self):
⋮...
│	def test_reserved_qty_for_closing_so(self):
⋮...
│	def test_create_so_with_margin(self):
⋮...
│	def test_terms_auto_added(self):
⋮...
│	def test_terms_not_copied(self):
│		so = make_sales_order()
│		self.assertTrue(so.get("payment_schedule"))
│
│		si = make_sales_invoice(so.name)
│		self.assertFalse(si.get("payment_schedule"))
⋮...
│	def test_terms_copied(self):
⋮...
│	def test_make_work_order(self):
⋮...
│	def test_advance_payment_entry_unlink_against_sales_order(self):
⋮...
│	def test_advance_paid_upon_payment_cancellation(self):
⋮...
│	def test_cancel_sales_order_after_cancel_payment_entry(self):
⋮...
│	def test_work_order_pop_up_from_sales_order(self):
⋮...
│	def test_request_for_raw_materials(self):
⋮...
│	def test_so_optional_blanket_order(self):
⋮...
│	def test_so_cancellation_when_si_drafted(self):
⋮...
│	def test_so_cancellation_after_si_submission(self):
⋮...
│	def test_so_cancellation_after_dn_submission(self):
⋮...
│	def test_so_cancellation_after_maintenance_schedule_submission(self):
⋮...
│	def test_so_cancellation_after_maintenance_visit_submission(self):
⋮...
│	def test_so_cancellation_after_work_order_submission(self):
⋮...
│	def test_payment_terms_are_fetched_when_creating_sales_invoice(self):
⋮...
│	def test_zero_amount_sales_order_billing_status(self):
⋮...
│	def test_so_billing_status_with_crnote_against_sales_return(self):
⋮...
│	def test_so_back_updated_from_wo_via_mr(self):
⋮...
│	def test_sales_order_with_shipping_rule(self):
⋮...
│	def test_sales_order_partial_advance_payment(self):
⋮...
│	def test_delivered_item_material_request(self):
⋮...
│	def test_packed_items_for_partial_sales_order(self):
⋮...
│	def test_expired_rate_for_packed_item(self):
⋮...
│	def test_sales_order_advance_payment_status(self, mocked_get_payment_url):
⋮...
│	def test_pick_list_without_rejected_materials(self):
⋮...
│	def test_pick_list_for_batch(self):
⋮...
│	def test_auto_update_price_list(self):
⋮...
│	def test_delivery_note_rate_on_change_of_warehouse(self):
⋮...
│	def test_credit_limit_on_so_reopning(self):
⋮...
│	def test_warehouse_mapping_based_on_stock_reservation(self):
⋮...
│	def test_item_tax_transfer_from_sales_to_purchase(self):
⋮...
│def make_sales_order_workflow():
⋮...

erpnext\accounts\report\item_wise_sales_register\item_wise_sales_register.py:
│def execute(filters=None):
│	return _execute(filters)
⋮...
│def get_columns(additional_table_columns, filters):
⋮...
│def get_items(filters, additional_query_columns, additional_conditions=None):
⋮...
│def _execute(filters=None, additional_table_columns=None, additional_conditions=None):
⋮...
│def add_sub_total_row(item, total_row_map, group_by_value, tax_columns):
⋮...
│def get_tax_accounts(
│	item_list,
│	columns,
│	company_currency,
│	doctype="Sales Invoice",
│	tax_doctype="Sales Taxes and Charges",
│):
⋮...
│def add_total_row(
│	data,
│	filters,
│	prev_group_by_value,
│	item,
│	total_row_map,
│	group_by_field,
│	subtotal_display_field,
│	grand_total,
│	tax_columns,
│):
⋮...
│def apply_conditions(query, si, sii, filters, additional_conditions=None):
⋮...
│def get_income_account(row):
⋮...
│def apply_order_by_conditions(query, si, ii, filters):
⋮...
│def get_grand_total(filters, doctype):
⋮...
│def get_group_by_and_display_fields(filters):
⋮...
│def get_delivery_notes_against_sales_order(item_list):
⋮...
│def get_display_value(filters, group_by_field, item):
⋮...

erpnext\controllers\trends.py:
│def get_data(filters, conditions):
⋮...
│def get_columns(filters, trans):
⋮...
│def validate_filters(filters):
⋮...
│def get_period_date_ranges(period, fiscal_year=None, year_start_date=None):
⋮...
│def get_mon(dt):
│	return getdate(dt).strftime("%b")
⋮...
│def period_wise_columns_query(filters, trans):
⋮...
│def get_period_wise_columns(bet_dates, period, pwc):
⋮...
│def get_period_wise_query(bet_dates, trans_date, query_details):
⋮...
│def get_period_month_ranges(period, fiscal_year):
⋮...
│def based_wise_columns_query(based_on, trans):
⋮...
│def group_wise_column(group_by):
│	if group_by:
│		return [group_by + ":Link/" + group_by + ":120"]
│	else:
│		return []
⋮...

erpnext\accounts\report\tax_withholding_details\tax_withholding_details.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def validate_filters(filters):
│	"""Validate if dates are properly set"""
│	filters = frappe._dict(filters or {})
│	if filters.from_date > filters.to_date:
│		frappe.throw(_("From Date must be before To Date"))
⋮...
│def get_doc_info(vouchers, doctype, tax_category_map, net_total_map=None):
⋮...
│def get_result(filters, tds_docs, tds_accounts, tax_category_map, journal_entry_party_map, net_total_map):
⋮...
│def get_tds_docs(filters):
⋮...
│def get_tax_withholding_rates(tax_withholding, posting_date):
⋮...
│def get_party_pan_map(party_type):
⋮...
│def get_gle_map(documents):
⋮...
│def get_tds_docs_query(filters, bank_accounts, tds_accounts):
⋮...
│def get_journal_entry_party_map(journal_entries):
⋮...
│def get_tax_rate_map(filters):
⋮...

erpnext\stock\report\warehouse_wise_item_balance_age_and_value\warehouse_wise_item_balance_age_and_value.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def validate_filters(filters):
│	if not (filters.get("item_code") or filters.get("warehouse")):
│		sle_count = flt(frappe.qb.from_("Stock Ledger Entry").select(Count("name")).run()[0][0])
│		if sle_count > 500000:
│			frappe.throw(_("Please set filter based on Item or Warehouse"))
⋮...
│def get_warehouse_list(filters):
⋮...
│def get_itemwise_brand(items):
│	return frappe.get_all("Item", filters={"name": ("in", items)}, fields=["name", "brand"], as_list=1)
⋮...
│def add_warehouse_column(columns, warehouse_list):
│	if len(warehouse_list) > 1:
│		columns += [_("Total Qty") + ":Int:120"]
│
│	for wh in warehouse_list:
│		columns += [_(wh.name) + ":Int:100"]
⋮...
│def get_item_warehouse_map(filters, sle):
⋮...
│def get_group_by_key(row) -> tuple:
│	return (row.company, row.item_code, row.warehouse)
⋮...

erpnext\accounts\report\gross_profit\gross_profit.py:
│def execute(filters=None):
⋮...
│def get_columns(group_wise_columns, filters):
⋮...
│class GrossProfitGenerator:
⋮...
│def get_data_when_grouped_by_invoice(columns, gross_profit_data, filters, group_wise_columns, data):
⋮...
│def get_data_when_not_grouped_by_invoice(gross_profit_data, filters, group_wise_columns, data):
⋮...
│def get_column_names():
⋮...
│	def __init__(self, filters=None):
⋮...
│	def process(self):
⋮...
│	def update_return_invoices(self, row):
⋮...
│	def get_average_rate_based_on_group_by(self):
⋮...
│	def set_average_based_on_payment_term_portion(self, new_row, row, invoice_portion, aggr=False):
⋮...
│	def is_not_invoice_row(self, row):
│		return (self.filters.get("group_by") == "Invoice" and row.indent != 0.0) or self.filters.get(
│			"group_by"
│		) != "Invoice"
⋮...
│	def set_average_rate(self, new_row):
⋮...
│	def set_average_gross_profit(self, new_row):
⋮...
│	def get_returned_invoice_items(self):
⋮...
│	def skip_row(self, row):
│		if self.filters.get("group_by") != "Invoice":
│			if not row.get(scrub(self.filters.get("group_by", ""))):
│				return True
│
│		return False
⋮...
│	def get_buying_amount_from_product_bundle(self, row, product_bundle):
⋮...
│	def calculate_buying_amount_from_sle(self, row, my_sle, parenttype, parent, item_row, item_code):
⋮...
│	def get_buying_amount(self, row, item_code):
⋮...
│	def get_buying_amount_from_so_dn(self, sales_order, so_detail, item_code):
⋮...
│	def get_average_buying_rate(self, row, item_code):
⋮...
│	def get_last_purchase_rate(self, item_code, row):
⋮...
│	def load_invoice_items(self):
⋮...
│	def get_delivery_notes(self):
⋮...
│	def group_items_by_invoice(self):
⋮...
│	def get_invoice_row(self, row):
⋮...
│	def get_bundle_item_row(self, row, item):
⋮...
│	def get_stock_ledger_entries(self, item_code, warehouse):
⋮...
│	def load_product_bundle(self):
⋮...
│	def load_non_stock_items(self):
│		self.non_stock_items = frappe.db.sql_list(
│			"""select name from tabItem
│			where is_stock_item=0"""
│		)
⋮...

erpnext\manufacturing\report\production_plan_summary\production_plan_summary.py:
│def execute(filters=None):
│	columns, data = [], []
│	data = get_data(filters)
│	columns = get_column(filters)
│
│	return columns, data
⋮...
│def get_data(filters):
⋮...
│def get_column(filters):
⋮...
│def get_purchase_order_details(filters, order_details):
⋮...
│def get_production_plan_item_details(filters, data, order_details):
⋮...
│def get_production_plan_sub_assembly_item_details(filters, row, production_plan_doc, data, order_details):
⋮...
│def get_work_order_details(filters, order_details):
⋮...

erpnext\accounts\report\item_wise_purchase_register\item_wise_purchase_register.py:
│def execute(filters=None):
│	return _execute(filters)
⋮...
│def get_columns(additional_table_columns, filters):
⋮...
│def get_items(filters, additional_table_columns):
⋮...
│def _execute(filters=None, additional_table_columns=None):
⋮...
│def apply_conditions(query, pi, pii, filters):
⋮...
│def get_aii_accounts():
│	return dict(frappe.db.sql("select name, stock_received_but_not_billed from tabCompany"))
⋮...
│def get_purchase_receipts_against_purchase_order(item_list):
⋮...

erpnext\accounts\report\tds_computation_summary\tds_computation_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def validate_filters(filters):
⋮...
│def group_by_party_and_category(data, filters):
⋮...
│def get_final_result(party_category_wise_map):
│	out = []
│	for _key, value in party_category_wise_map.items():
│		out.append(value)
│
│	return out
⋮...

erpnext\accounts\report\bank_reconciliation_statement\bank_reconciliation_statement.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_entries(filters):
⋮...
│def get_journal_entries(filters):
⋮...
│def get_payment_entries(filters):
⋮...
│def get_balance_row(label, amount, account_currency):
⋮...
│def get_pos_entries(filters):
⋮...
│def get_amounts_not_reflected_in_system(filters):
⋮...
│def get_entries_for_bank_reconciliation_statement(filters):
⋮...
│def get_amounts_not_reflected_in_system_for_bank_reconciliation_statement(filters):
⋮...

erpnext\stock\report\available_serial_no\available_serial_no.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_items(filters):
⋮...
│def update_available_serial_nos(available_serial_nos, sle):
⋮...
│def get_opening_balance_data(filters, columns, sl_entries):
⋮...
│def process_stock_ledger_entries(
│	filters, sl_entries, item_details, opening_row, actual_qty, stock_value, precision
│):
⋮...
│def update_stock_ledger_entry(
│	sle, item_details, filters, actual_qty, stock_value, batch_balance_dict, precision
│):
⋮...

erpnext\stock\doctype\purchase_receipt\test_purchase_receipt.py:
│def make_purchase_receipt(**args):
⋮...
│def get_gl_entries(voucher_type, voucher_no, skip_cancelled=False, as_dict=True):
⋮...
│def get_items(**args):
⋮...
│def prepare_data_for_internal_transfer():
⋮...
│def get_sl_entries(voucher_type, voucher_no):
⋮...
│def get_taxes(**args):
⋮...
│class UnitTestPurchaseReceipt(UnitTestCase):
⋮...
│class TestPurchaseReceipt(IntegrationTestCase):
⋮...
│	def setUp(self):
│		frappe.db.set_single_value("Buying Settings", "allow_multiple_items", 1)
⋮...
│	def test_purchase_receipt_qty(self):
⋮...
│	def test_purchase_receipt_received_qty(self):
⋮...
│	def test_reverse_purchase_receipt_sle(self):
⋮...
│	def test_make_purchase_invoice(self):
⋮...
│	def test_purchase_receipt_no_gl_entry(self):
⋮...
│	def test_batched_serial_no_purchase(self):
⋮...
│	def test_duplicate_serial_nos(self):
⋮...
│	def test_purchase_receipt_gl_entry(self):
⋮...
│	def test_serial_no_warehouse(self):
⋮...
│	def test_rejected_warehouse_filter(self):
⋮...
│	def test_rejected_serial_no(self):
⋮...
│	def test_purchase_return_partial(self):
⋮...
│	def test_purchase_return_full(self):
⋮...
│	def test_purchase_return_for_rejected_qty(self):
⋮...
│	def test_purchase_receipt_for_rejected_gle_without_accepted_warehouse(self):
⋮...
│	def test_purchase_return_for_serialized_items(self):
⋮...
│	def test_purchase_return_for_multi_uom(self):
⋮...
│	def test_closed_purchase_receipt(self):
⋮...
│	def test_pr_billing_status(self):
⋮...
│	def test_serial_no_against_purchase_receipt(self):
⋮...
│	def test_auto_asset_creation(self):
⋮...
│	def test_purchase_return_with_submitted_asset(self):
⋮...
│	def test_purchase_receipt_cost_center(self):
⋮...
│	def test_purchase_receipt_cost_center_with_balance_sheet_account(self):
⋮...
│	def test_make_purchase_invoice_from_pr_for_returned_qty(self):
⋮...
│	def test_make_purchase_invoice_from_pr_with_returned_qty_duplicate_items(self):
⋮...
│	def test_stock_transfer_from_purchase_receipt(self):
⋮...
│	def test_stock_transfer_from_purchase_receipt_with_valuation(self):
⋮...
│	def test_po_to_pi_and_po_to_pr_worflow_full(self):
⋮...
│	def test_po_to_pi_and_po_to_pr_worflow_partial(self):
⋮...
│	def test_purchase_receipt_with_exchange_rate_difference(self):
⋮...
│	def test_payment_terms_are_fetched_when_creating_purchase_invoice(self):
⋮...
│	def test_neg_to_positive(self):
⋮...
│	def test_backdated_transaction_for_internal_transfer(self):
⋮...
│	def test_backdated_transaction_for_internal_transfer_in_trasit_warehouse_for_purchase_receipt(
│		self,
│	):
⋮...
│	def test_backdated_transaction_for_internal_transfer_in_trasit_warehouse_for_purchase_invoice(
│		self,
│	):
⋮...
│	def test_batch_expiry_for_purchase_receipt(self):
⋮...
│	def test_disable_last_purchase_rate(self):
⋮...
│	def test_validate_received_qty_for_internal_pr(self):
⋮...
│	def test_internal_pr_gl_entries(self):
⋮...
│	def test_internal_pr_reference(self):
⋮...
│	def test_purchase_return_valuation_with_rejected_qty(self):
⋮...
│	def test_return_from_rejected_warehouse(self):
⋮...
│	def test_purchase_receipt_with_backdated_landed_cost_voucher(self):
⋮...
│	def test_purchase_receipt_provisional_accounting(self):
⋮...
│	def test_purchase_return_status_with_debit_note(self):
⋮...
│	def test_purchase_return_with_zero_rate(self):
⋮...
│	def non_internal_transfer_purchase_receipt(self):
⋮...
│	def test_use_serial_batch_fields_for_serial_nos(self):
⋮...
│	def test_sle_qty_after_transaction(self):
⋮...
│	def test_auto_set_batch_based_on_bundle(self):
⋮...
│	def test_pr_billed_amount_against_return_entry(self):
⋮...
│	def test_valuation_taxes_lcv_repost_after_billing(self):
⋮...
│	def test_purchase_receipt_with_use_serial_batch_field_for_rejected_qty(self):
⋮...
│	def test_internal_transfer_with_serial_batch_items_and_their_valuation(self):
⋮...
│	def test_internal_transfer_with_serial_batch_items_without_use_serial_batch_fields(self):
⋮...
│	def test_purchase_receipt_bill_for_rejected_quantity_in_purchase_invoice(self):
⋮...
│	def test_zero_valuation_rate_for_batched_item(self):
⋮...
│	def test_purchase_return_from_accepted_and_rejected_warehouse(self):
⋮...
│	def test_manufacturing_and_expiry_date_for_batch(self):
⋮...
│	def test_purchase_return_from_rejected_warehouse(self):
⋮...
│	def test_tax_account_heads_on_lcv_and_item_repost(self):
⋮...
│	def create_lcv(self, receipt_document_type, receipt_document, company, expense_account, charges=50):
⋮...
│	def test_tax_account_heads_on_item_repost_without_lcv(self):
⋮...
│	def test_do_not_use_batchwise_valuation_rate(self):
⋮...
│	def test_status_mapping(self):
⋮...
│	def test_internal_transfer_for_batch_items_with_cancel(self):
⋮...
│	def test_internal_transfer_for_batch_items_with_cancel_use_serial_batch_fields(self):
⋮...
│	def test_sles_with_same_posting_datetime_and_creation(self):
⋮...
│	def test_same_stock_and_transaction_uom_conversion_factor(self):
⋮...
│	def test_purchase_receipt_return_valuation_without_use_serial_batch_field(self):
⋮...
│	def test_purchase_receipt_return_valuation_with_use_serial_batch_field(self):
⋮...
│	def test_purchase_return_partial_debit_note(self):
⋮...
│	def test_do_not_allow_to_inward_same_serial_no_multiple_times(self):
⋮...
│	def test_seral_no_return_validation(self):
⋮...
│	def test_batch_no_return_validation(self):
⋮...
│	def test_pr_status_based_on_invoices_with_update_stock(self):
⋮...
│	def test_recreate_stock_ledgers(self):
⋮...

erpnext\accounts\report\financial_ratios\financial_ratios.py:
│def execute(filters=None):
⋮...
│def get_columns(period_list):
⋮...
│def calculate_ratio(value, denominator, precision):
│	if flt(denominator):
│		return flt(flt(value) / denominator, precision)
│	return 0
⋮...
│def get_gl_data(filters, period_list, years):
⋮...
│def setup_filters(filters):
⋮...
│def get_ratios_data(filters, period_list, years):
⋮...
│def add_liquidity_ratios(data, years, current_asset, current_liability, quick_asset):
⋮...
│def add_solvency_ratios(
│	data, years, total_asset, total_liability, net_sales, cogs, total_income, total_expense
│):
⋮...
│def add_turnover_ratios(data, years, period_list, filters, total_asset, net_sales, cogs, direct_expense):
⋮...
│def update_balances(
│	ratio_dict,
│	total_dict,
│	account_type,
│	year,
│	root_type_data,
│	root_type,
│	net_dict=None,
│	total_net=0,
│):
⋮...
│def avg_ratio_balance(account_type, period_list, precision, filters):
⋮...

erpnext\selling\report\sales_partner_target_variance_based_on_item_group\item_group_wise_sales_target_variance.py:
│def get_data(filters, period_list, partner_doctype):
⋮...
│def get_columns(filters, period_list, partner_doctype):
⋮...
│def prepare_data(
│	filters,
│	sales_users_data,
│	sales_user_wise_item_groups,
│	actual_data,
│	date_field,
│	period_list,
│	sales_field,
│):
⋮...
│def get_data_column(filters, partner_doctype):
⋮...
│def get_item_group_parent_child_map():
⋮...
│def get_actual_data(filters, sales_users_or_territory_data, date_field, sales_field):
⋮...
│def get_parents_data(filters, partner_doctype):
⋮...

erpnext\crm\report\campaign_efficiency\campaign_efficiency.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns("utm_campaign")
│	data = get_lead_data(filters or {}, "utm_campaign")
│	return columns, data
⋮...
│def get_columns(based_on):
⋮...
│def get_lead_data(filters, based_on):
⋮...
│def get_filter_conditions(filters):
⋮...
│def get_lead_quotation_count(leads):
⋮...
│def get_lead_opp_count(leads):
⋮...
│def get_quotation_ordered_count(leads):
⋮...
│def get_order_amount(leads):
⋮...

erpnext\stock\report\itemwise_recommended_reorder_level\itemwise_recommended_reorder_level.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_filtered_query(filters, table, query):
⋮...
│def get_item_info(filters):
⋮...
│def get_consumed_items(filters):
⋮...
│def get_delivered_items(filters):
⋮...

erpnext\patches\v14_0\migrate_gl_to_payment_ledger.py:
│def execute():
⋮...
│def get_columns():
⋮...
│def create_accounting_dimension_fields():
│	dimensions_and_defaults = get_dimensions()
│	if dimensions_and_defaults:
│		for dimension in dimensions_and_defaults[0]:
│			make_dimension_in_accounting_doctypes(dimension, ["Payment Ledger Entry"])
⋮...
│def generate_name_and_calculate_amount(gl_entries, start, receivable_accounts):
⋮...
│def build_insert_query():
⋮...
│def insert_chunk_into_payment_ledger(insert_query, gl_entries):
⋮...

erpnext\accounts\report\cheques_and_deposits_incorrectly_cleared\cheques_and_deposits_incorrectly_cleared.py:
│def execute(filters=None):
│	columns = get_columns()
│	data = build_data(filters)
│	return columns, data
⋮...
│def get_columns():
⋮...
│def build_payment_entry_dict(row: dict) -> dict:
⋮...
│def build_journal_entry_dict(row: dict) -> dict:
⋮...
│def build_data(filters):
⋮...
│def get_amounts_not_reflected_in_system_for_bank_reconciliation_statement(filters):
⋮...

erpnext\manufacturing\report\bom_stock_calculated\bom_stock_calculated.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_report_data(last_purchase_rate, required_qty, row, manufacture_details):
⋮...
│def get_bom_data(filters):
⋮...
│def get_manufacturer_records():
⋮...

erpnext\regional\report\irs_1099\irs_1099.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def irs_1099_print(filters):
⋮...
│def get_payer_address_html(company):
⋮...
│def get_street_address_html(party_type, party):
⋮...

erpnext\selling\report\inactive_customers\inactive_customers.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_sales_details(doctype):
⋮...
│def get_last_sales_amt(customer, doctype):
⋮...

erpnext\stock\report\supplier_wise_sales_analytics\supplier_wise_sales_analytics.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_consumed_details(filters):
⋮...
│def get_suppliers_details(filters):
⋮...
│def get_material_transfer_vouchers():
⋮...

erpnext\manufacturing\report\work_order_stock_report\work_order_stock_report.py:
│def execute(filters=None):
│	wo_list = get_work_orders()
│	data = get_item_list(wo_list, filters)
│	columns = get_columns()
│	return columns, data
⋮...
│def get_columns():
⋮...
│def get_item_list(wo_list, filters):
⋮...
│def get_work_orders():
⋮...

erpnext\stock\report\stock_projected_qty\stock_projected_qty.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_bin_list(filters):
⋮...
│def get_item_map(item_code, include_uom):
⋮...

erpnext\stock\report\total_stock_summary\total_stock_summary.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_total_stock(filters):
⋮...

erpnext\crm\report\lead_conversion_time\lead_conversion_time.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_communication_details(filters):
⋮...

erpnext\manufacturing\report\bom_stock_report\bom_stock_report.py:
│def execute(filters=None):
⋮...
│def get_columns():
⋮...
│def get_bom_stock(filters):
⋮...

erpnext\accounts\report\share_balance\share_balance.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_all_shares(shareholder):
│	return frappe.get_doc("Shareholder", shareholder).share_balance
⋮...

erpnext\selling\report\customer_credit_balance\customer_credit_balance.py:
│def execute(filters=None):
⋮...
│def get_columns(customer_naming_type):
⋮...
│def get_details(filters):
⋮...

erpnext\accounts\report\share_ledger\share_ledger.py:
│def execute(filters=None):
⋮...
│def get_columns(filters):
⋮...
│def get_all_transfers(date, shareholder):
⋮...

erpnext\crm\report\lead_owner_efficiency\lead_owner_efficiency.py:
│def execute(filters=None):
│	columns, data = [], []
│	columns = get_columns()
│	data = get_lead_data(filters, "Lead Owner")
│	return columns, data
⋮...
│def get_columns():
⋮...

erpnext\selling\doctype\sales_order\sales_order.py:
│def make_sales_invoice(source_name, target_doc=None, ignore_permissions=False):
⋮...
│def make_delivery_note(source_name, target_doc=None, kwargs=None):
⋮...
│def create_pick_list(source_name, target_doc=None):
⋮...
│def get_list_context(context=None):
⋮...
│def make_material_request(source_name, target_doc=None):
⋮...
│def make_project(source_name, target_doc=None):
⋮...
│def make_purchase_order(source_name, selected_items=None, target_doc=None):
⋮...
│def get_events(start, end, filters=None):
⋮...
│def make_maintenance_schedule(source_name, target_doc=None):
⋮...
│def update_status(status, name):
│	so = frappe.get_doc("Sales Order", name)
│	so.update_status(status)
⋮...
│def make_maintenance_visit(source_name, target_doc=None):
⋮...
│def make_purchase_order_for_default_supplier(source_name, selected_items=None, target_doc=None):
⋮...
│def is_product_bundle(item_code):
│	return frappe.db.exists("Product Bundle", {"name": item_code, "disabled": 0})
⋮...
│def get_work_order_items(sales_order, for_raw_material_request=0):
⋮...
│class WarehouseRequired(frappe.ValidationError):
│	pass
⋮...
│def get_unreserved_qty(item: object, reserved_qty_details: dict) -> float:
│	"""Returns the unreserved quantity for the Sales Order Item."""
│
│	existing_reserved_qty = reserved_qty_details.get(item.name, 0)
│	return item.stock_qty - flt(item.delivered_qty) * item.get("conversion_factor", 1) - existing_reserved_qty
⋮...
│def update_produced_qty_in_so_item(sales_order, sales_order_item):
⋮...
│class SalesOrder(SellingController):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
⋮...
│	def onload(self) -> None:
⋮...
│	def validate(self):
⋮...
│	def enable_auto_reserve_stock(self):
│		if self.is_new() and frappe.db.get_single_value("Stock Settings", "auto_reserve_stock"):
│			self.reserve_stock = 1
⋮...
│	def validate_po(self):
⋮...
│	def validate_for_items(self):
⋮...
│	def product_bundle_has_stock_item(self, product_bundle):
⋮...
│	def validate_sales_mntc_quotation(self):
⋮...
│	def validate_delivery_date(self):
⋮...
│	def validate_proj_cust(self):
⋮...
│	def validate_warehouse(self):
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def update_enquiry_status(self, prevdoc, flag):
⋮...
│	def update_prevdoc_status(self, flag=None):
⋮...
│	def validate_drop_ship(self):
│		for d in self.get("items"):
│			if d.delivered_by_supplier and not d.supplier:
│				frappe.throw(_("Row #{0}: Set Supplier for item {1}").format(d.idx, d.item_code))
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def update_project(self):
⋮...
│	def check_credit_limit(self):
⋮...
│	def check_nextdoc_docstatus(self):
⋮...
│	def check_modified_date(self):
│		mod_db = frappe.db.get_value("Sales Order", self.name, "modified")
│		date_diff = frappe.db.sql(f"select TIMEDIFF('{mod_db}', '{cstr(self.modified)}')")
│		if date_diff and date_diff[0][0]:
│			frappe.throw(_("{0} {1} has been modified. Please refresh.").format(self.doctype, self.name))
⋮...
│	def update_status(self, status):
⋮...
│	def update_reserved_qty(self, so_item_rows=None):
⋮...
│	def on_update(self):
│		pass
⋮...
│	def on_update_after_submit(self):
│		self.calculate_commission()
│		self.calculate_contribution()
│		self.check_credit_limit()
⋮...
│	def before_update_after_submit(self):
│		self.validate_po()
│		self.validate_drop_ship()
│		self.validate_supplier_after_submit()
│		self.validate_delivery_date()
⋮...
│	def validate_supplier_after_submit(self):
⋮...
│	def update_delivery_status(self):
⋮...
│	def update_picking_status(self):
⋮...
│	def set_indicator(self):
⋮...
│	def on_recurring(self, reference_doc, auto_repeat_doc):
⋮...
│	def validate_serial_no_based_delivery(self):
⋮...
│	def validate_reserved_stock(self):
⋮...
│	def has_unreserved_stock(self) -> bool:
⋮...
│	def create_stock_reservation_entries(
│		self,
│		items_details: list[dict] | None = None,
⋮...
│	def cancel_stock_reservation_entries(self, sre_list=None, notify=True) -> None:
⋮...
│	def set_missing_values(self, for_validate=False):
│		super().set_missing_values(for_validate)
│
│		if self.delivery_date:
│			for item in self.items:
│				item.delivery_date = self.delivery_date
⋮...
│def is_enable_cutoff_date_on_bulk_delivery_note_creation():
│	return frappe.db.get_single_value("Selling Settings", "enable_cutoff_date_on_bulk_delivery_note_creation")
⋮...
│def close_or_unclose_sales_orders(names, status):
⋮...
│def get_requested_item_qty(sales_order):
⋮...
│def set_delivery_date(items, sales_order):
⋮...
│def make_work_orders(items, sales_order, company, project=None):
⋮...
│def make_raw_material_request(items, company, sales_order, project=None):
⋮...
│def make_inter_company_purchase_order(source_name, target_doc=None):
│	from erpnext.accounts.doctype.sales_invoice.sales_invoice import make_inter_company_transaction
│
│	return make_inter_company_transaction("Sales Order", source_name, target_doc)
⋮...
│def get_stock_reservation_status():
│	return frappe.db.get_single_value("Stock Settings", "enable_stock_reservation")
⋮...

erpnext\controllers\tests\test_subcontracting_controller.py:
│def get_subcontracting_order(**args):
⋮...
│def make_stock_in_entry(**args):
⋮...
│def make_stock_transfer_entry(**args):
⋮...
│def set_backflush_based_on(based_on):
│	frappe.db.set_single_value("Buying Settings", "backflush_raw_materials_of_subcontract_based_on", based_on)
⋮...
│def get_rm_items(supplied_items):
⋮...
│def get_supplied_items(scr_doc):
⋮...
│def make_subcontracted_items():
⋮...
│def make_raw_materials():
⋮...
│def make_service_items():
⋮...
│def make_bom_for_subcontracted_items():
⋮...
│def make_service_item(item, properties=None):
│	if properties is None:
│		properties = {}
│	if not frappe.db.exists("Item", item):
│		properties.update({"is_stock_item": 0})
│		make_item(item, properties)
⋮...
│def add_second_row_in_scr(scr):
⋮...
│def make_subcontracted_item(**args):
⋮...
│def update_item_details(child_row, details):
⋮...
│class TestSubcontractingController(IntegrationTestCase):
⋮...
│	def setUp(self):
│		make_subcontracted_items()
│		make_raw_materials()
│		make_service_items()
│		make_bom_for_subcontracted_items()
⋮...
│	def test_remove_empty_rows(self):
│		sco = get_subcontracting_order()
│		len_before = len(sco.service_items)
│		sco.service_items[0].item_code = None
│		sco.remove_empty_rows()
│		self.assertEqual((len_before - 1), len(sco.service_items))
⋮...
│	def test_calculate_additional_costs(self):
⋮...
│	def test_create_raw_materials_supplied(self):
│		sco = get_subcontracting_order()
│		sco.supplied_items = None
│		sco.create_raw_materials_supplied()
│		self.assertIsNotNone(sco.supplied_items)
⋮...
│	def test_sco_with_bom(self):
⋮...
│	def test_sco_with_material_transfer(self):
⋮...
│	def test_subcontracting_with_same_components_different_fg(self):
⋮...
│	def test_return_non_consumed_batch_materials(self):
⋮...
│	def test_return_non_consumed_materials(self):
⋮...
│	def test_item_with_batch_based_on_bom(self):
⋮...
│	def test_item_with_batch_based_on_material_transfer(self):
⋮...
│	def test_partial_transfer_serial_no_components_based_on_material_transfer(self):
⋮...
│	def test_incorrect_serial_no_components_based_on_material_transfer(self):
⋮...
│	def delete_bundle_from_scr(scr):
│		for row in scr.supplied_items:
│			if not row.serial_and_batch_bundle:
│				continue
│
│			frappe.delete_doc("Serial and Batch Bundle", row.serial_and_batch_bundle)
⋮...
│	def test_partial_transfer_batch_based_on_material_transfer(self):
⋮...
│	def test_sco_supplied_qty(self):
⋮...
│	def test_sco_with_material_transfer_with_use_serial_batch_fields(self):
⋮...
│	def test_subcontracting_with_same_components_different_fg_with_serial_batch_fields(self):
⋮...
│	def test_return_non_consumed_materials_with_serial_batch_fields(self):
⋮...

erpnext\accounts\doctype\sales_invoice\sales_invoice.py:
│def make_delivery_note(source_name, target_doc=None):
⋮...
│def get_list_context(context=None):
⋮...
│def make_sales_return(source_name, target_doc=None):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("Sales Invoice", source_name, target_doc)
⋮...
│def update_address(doc, address_field, address_display_field, address_name):
⋮...
│def make_inter_company_transaction(doctype, source_name, target_doc=None):
⋮...
│def create_invoice_discounting(source_name, target_doc=None):
⋮...
│class SalesInvoice(SellingController):
⋮...
│def make_maintenance_schedule(source_name, target_doc=None):
⋮...
│def is_overdue(doc, total):
⋮...
│def validate_inter_company_party(doctype, party, company, inter_company_reference):
⋮...
│def update_linked_doc(doctype, name, inter_company_reference):
⋮...
│def unlink_inter_company_doc(doctype, name, inter_company_reference):
⋮...
│def get_bank_cash_account(mode_of_payment, company):
⋮...
│def make_inter_company_purchase_invoice(source_name, target_doc=None):
│	return make_inter_company_transaction("Sales Invoice", source_name, target_doc)
⋮...
│def update_taxes(
│	doc,
│	party=None,
│	party_type=None,
│	company=None,
│	doctype=None,
│	party_address=None,
│	company_address=None,
│	shipping_address_name=None,
│	master_doctype=None,
│):
⋮...
│def get_total_in_party_account_currency(doc):
│	total_fieldname = "grand_total" if doc.disable_rounded_total else "rounded_total"
│	if doc.party_account_currency != doc.currency:
│		total_fieldname = "base_" + total_fieldname
│
│	return flt(doc.get(total_fieldname), doc.precision(total_fieldname))
⋮...
│def get_inter_company_details(doc, doctype):
⋮...
│def update_multi_mode_option(doc, pos_profile):
⋮...
│def create_dunning(source_name, target_doc=None, ignore_permissions=False):
⋮...
│def get_internal_party(parties, link_doctype, doc):
⋮...
│def validate_inter_company_transaction(doc, doctype):
⋮...
│def make_regional_gl_entries(gl_entries, doc):
│	return gl_entries
⋮...
│def set_purchase_references(doc):
⋮...
│def get_pd_details(doctype, sd_detail_map, sd_detail_field):
⋮...
│def get_loyalty_programs(customer):
⋮...
│def check_if_return_invoice_linked_with_payment_entry(self):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def set_indicator(self):
⋮...
│	def validate(self):
⋮...
│	def validate_accounts(self):
│		self.validate_write_off_account()
│		self.validate_account_for_change_amount()
│		self.validate_income_account()
⋮...
│	def validate_for_repost(self):
│		self.validate_write_off_account()
│		self.validate_account_for_change_amount()
│		self.validate_income_account()
│		validate_docs_for_voucher_types(["Sales Invoice"])
│		validate_docs_for_deferred_accounting([self.name], [])
⋮...
│	def validate_fixed_asset(self):
⋮...
│	def validate_item_cost_centers(self):
│		for item in self.items:
│			item.validate_cost_center(self.company)
⋮...
│	def validate_income_account(self):
│		for item in self.get("items"):
│			validate_account_head(item.idx, item.income_account, self.company, _("Income"))
⋮...
│	def set_tax_withholding(self):
⋮...
│	def before_save(self):
│		self.set_account_for_mode_of_payment()
│		self.set_paid_amount()
⋮...
│	def before_submit(self):
│		self.add_remarks()
⋮...
│	def on_submit(self):
⋮...
│	def validate_pos_return(self):
⋮...
│	def validate_pos_paid_amount(self):
│		if len(self.payments) == 0 and self.is_pos and flt(self.grand_total) > 0:
│			frappe.throw(_("At least one mode of payment is required for POS invoice."))
⋮...
│	def check_if_consolidated_invoice(self):
⋮...
│	def before_cancel(self):
│		self.check_if_consolidated_invoice()
│
│		super().before_cancel()
│		self.update_time_sheet(None)
⋮...
│	def on_cancel(self):
⋮...
│	def update_status_updater_args(self):
⋮...
│	def check_credit_limit(self):
⋮...
│	def unlink_sales_invoice_from_timesheets(self):
│		for row in self.timesheets:
│			timesheet = frappe.get_doc("Timesheet", row.time_sheet)
│			timesheet.unlink_sales_invoice(self.name)
│			timesheet.flags.ignore_validate_update_after_submit = True
│			timesheet.db_update_all()
⋮...
│	def set_missing_values(self, for_validate=False):
⋮...
│	def update_time_sheet(self, sales_invoice):
⋮...
│	def update_time_sheet_detail(self, timesheet, args, sales_invoice):
⋮...
│	def on_update_after_submit(self):
⋮...
│	def set_paid_amount(self):
⋮...
│	def set_account_for_mode_of_payment(self):
│		for payment in self.payments:
│			if not payment.account:
│				payment.account = get_bank_cash_account(payment.mode_of_payment, self.company).get("account")
⋮...
│	def validate_time_sheets_are_submitted(self):
│		for data in self.timesheets:
│			if data.time_sheet:
│				status = frappe.db.get_value("Timesheet", data.time_sheet, "status")
│				if status not in ["Submitted", "Payslip"]:
│					frappe.throw(_("Timesheet {0} is already completed or cancelled").format(data.time_sheet))
⋮...
│	def set_pos_fields(self, for_validate=False):
⋮...
│	def get_company_abbr(self):
│		return frappe.db.sql("select abbr from tabCompany where name=%s", self.company)[0][0]
⋮...
│	def validate_debit_to_acc(self):
⋮...
│	def clear_unallocated_mode_of_payments(self):
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def set_against_income_account(self):
⋮...
│	def force_set_against_income_account(self):
│		self.set_against_income_account()
│		frappe.db.set_value(self.doctype, self.name, "against_income_account", self.against_income_account)
⋮...
│	def add_remarks(self):
⋮...
│	def validate_auto_set_posting_time(self):
│		# Don't auto set the posting date and time if invoice is amended
│		if self.is_new() and self.amended_from:
│			self.set_posting_time = 1
│
│		self.validate_posting_time()
⋮...
│	def so_dn_required(self):
⋮...
│	def validate_proj_cust(self):
⋮...
│	def validate_pos(self):
⋮...
│	def validate_warehouse(self):
⋮...
│	def validate_delivery_note(self):
⋮...
│	def allow_write_off_only_on_pos(self):
│		if not self.is_pos and self.write_off_account:
│			self.write_off_account = None
⋮...
│	def validate_write_off_account(self):
│		if flt(self.write_off_amount) and not self.write_off_account:
│			self.write_off_account = frappe.get_cached_value("Company", self.company, "write_off_account")
│
│		if flt(self.write_off_amount) and not self.write_off_account:
│			msgprint(_("Please enter Write Off Account"), raise_exception=1)
⋮...
│	def validate_account_for_change_amount(self):
│		if flt(self.change_amount) and not self.account_for_change_amount:
│			msgprint(_("Please enter Account for Change Amount"), raise_exception=1)
⋮...
│	def validate_dropship_item(self):
⋮...
│	def update_current_stock(self):
│		for item in self.items:
│			item.set_actual_qty()
│
│		for packed_item in self.packed_items:
│			packed_item.set_actual_and_projected_qty()
⋮...
│	def update_packing_list(self):
⋮...
│	def set_billing_hours_and_amount(self):
⋮...
│	def update_timesheet_billing_for_project(self):
│		if not self.timesheets and self.project and self.is_auto_fetch_timesheet_enabled():
│			self.add_timesheet_data()
│		else:
│			self.calculate_billing_amount_for_timesheet()
⋮...
│	def is_auto_fetch_timesheet_enabled(self):
│		return frappe.db.get_single_value("Projects Settings", "fetch_timesheet_in_sales_invoice")
⋮...
│	def add_timesheet_data(self):
⋮...
│	def calculate_billing_amount_for_timesheet(self):
│		def timesheet_sum(field):
│			return sum((ts.get(field) or 0.0) for ts in self.timesheets)
│
│		self.total_billing_amount = timesheet_sum("billing_amount")
│		self.total_billing_hours = timesheet_sum("billing_hours")
⋮...
│	def get_warehouse(self):
⋮...
│	def set_income_account_for_fixed_assets(self):
│		for item in self.items:
│			item.set_income_account_for_fixed_asset(self.company)
⋮...
│	def check_prev_docstatus(self):
⋮...
│	def make_gl_entries(self, gl_entries=None, from_repost=False):
⋮...
│	def get_gl_entries(self, warehouse_account=None):
⋮...
│	def make_customer_gl_entry(self, gl_entries):
⋮...
│	def make_tax_gl_entries(self, gl_entries):
⋮...
│	def make_internal_transfer_gl_entries(self, gl_entries):
⋮...
│	def make_item_gl_entries(self, gl_entries):
⋮...
│	def get_asset(self, item):
⋮...
│	def enable_discount_accounting(self):
⋮...
│	def set_asset_status(self, asset):
│		if self.is_return:
│			asset.set_status()
│		else:
│			asset.set_status("Sold" if self.docstatus == 1 else None)
⋮...
│	def make_loyalty_point_redemption_gle(self, gl_entries):
⋮...
│	def make_pos_gl_entries(self, gl_entries):
⋮...
│	def get_gle_for_change_amount(self) -> list[dict]:
⋮...
│	def make_write_off_gl_entry(self, gl_entries):
⋮...
│	def make_gle_for_rounding_adjustment(self, gl_entries):
⋮...
│	def update_billing_status_in_dn(self, update_modified=True):
⋮...
│	def on_recurring(self, reference_doc, auto_repeat_doc):
│		self.set("write_off_amount", reference_doc.get("write_off_amount"))
│		self.due_date = None
⋮...
│	def update_project(self):
⋮...
│	def verify_payment_amount_is_positive(self):
│		for entry in self.payments:
│			if entry.amount < 0:
│				frappe.throw(_("Row #{0} (Payment Table): Amount must be positive").format(entry.idx))
⋮...
│	def verify_payment_amount_is_negative(self):
│		for entry in self.payments:
│			if entry.amount > 0:
│				frappe.throw(_("Row #{0} (Payment Table): Amount must be negative").format(entry.idx))
⋮...
│	def make_loyalty_point_entry(self):
⋮...
│	def delete_loyalty_point_entry(self):
⋮...
│	def set_loyalty_program_tier(self):
⋮...
│	def get_returned_amount(self):
⋮...
│	def apply_loyalty_points(self):
⋮...
│	def set_status(self, update=False, status=None, update_modified=True):
⋮...
│def get_discounting_status(sales_invoice):
⋮...
│def get_received_items(reference_name, doctype, reference_fieldname):
⋮...
│def update_pi_items(
│	doc,
│	detail_field,
│	parent_field,
│	sales_item_map,
│	purchase_item_map,
│	parent_child_map,
│	warehouse_map,
│):
⋮...
│def update_pr_items(doc, sales_item_map, purchase_item_map, parent_child_map, warehouse_map):
│	for item in doc.get("items"):
│		item.warehouse = warehouse_map.get(sales_item_map.get(item.delivery_note_item))
│		if not item.warehouse and item.get("purchase_order") and item.get("purchase_order_item"):
│			item.warehouse = frappe.db.get_value("Purchase Order Item", item.purchase_order_item, "warehouse")
⋮...
│def get_delivery_note_details(internal_reference):
│	si_item_details = frappe.get_all(
│		"Delivery Note Item", fields=["name", "so_detail"], filters={"parent": internal_reference}
│	)
│
│	return {d.name: d.so_detail for d in si_item_details if d.so_detail}
⋮...
│def get_sales_invoice_details(internal_reference):
⋮...
│def get_all_mode_of_payments(doc):
⋮...
│def get_mode_of_payments_info(mode_of_payments, company):
⋮...
│def get_mode_of_payment_info(mode_of_payment, company):
⋮...

erpnext\stock\serial_batch_bundle.py:
│def get_serial_nos_from_bundle(serial_and_batch_bundle, serial_nos=None):
│	return get_serial_nos(serial_and_batch_bundle, serial_nos=serial_nos)
⋮...
│def get_serial_nos(serial_and_batch_bundle, serial_nos=None):
⋮...
│class SerialBatchCreation:
⋮...
│def is_rejected(voucher_type, voucher_detail_no, warehouse):
⋮...
│class SerialNoValuation(DeprecatedSerialNoValuation):
⋮...
│class BatchNoValuation(DeprecatedBatchNoValuation):
⋮...
│def get_batches_from_bundle(serial_and_batch_bundle, batches=None):
⋮...
│def get_batch_nos(serial_and_batch_bundle):
⋮...
│def get_serial_nos_batch(serial_nos):
⋮...
│class SerialBatchBundle:
⋮...
│	def __init__(self, **kwargs):
⋮...
│	def process_serial_and_batch_bundle(self):
│		if self.item_details.has_serial_no:
│			self.process_serial_no()
│		elif self.item_details.has_batch_no:
│			self.process_batch_no()
⋮...
│	def set_item_details(self):
⋮...
│	def process_serial_no(self):
⋮...
│	def is_material_transfer(self):
⋮...
│	def make_serial_batch_no_bundle_for_material_transfer(self):
⋮...
│	def make_serial_batch_no_bundle(self):
⋮...
│	def validate_actual_qty(self, sn_doc):
⋮...
│	def validate_item(self):
⋮...
│	def set_serial_and_batch_bundle(self, sn_doc):
⋮...
│	def child_doctype(self):
⋮...
│	def is_rejected_entry(self):
│		return is_rejected(self.sle.voucher_type, self.sle.voucher_detail_no, self.sle.warehouse)
⋮...
│	def process_batch_no(self):
⋮...
│	def validate_item_and_warehouse(self):
⋮...
│	def delink_serial_and_batch_bundle(self):
⋮...
│	def post_process(self):
⋮...
│	def cancel_serial_and_batch_bundle(self):
⋮...
│	def is_pos_transaction(self):
⋮...
│	def submit_serial_and_batch_bundle(self):
│		doc = frappe.get_doc("Serial and Batch Bundle", self.sle.serial_and_batch_bundle)
│		self.validate_actual_qty(doc)
│
│		doc.flags.ignore_voucher_validation = True
│		doc.submit()
⋮...
│	def set_warehouse_and_status_in_serial_nos(self):
⋮...
│	def set_batch_no_in_serial_nos(self):
⋮...
│def get_serial_or_batch_nos(bundle):
⋮...
│	def __init__(self, **kwargs):
│		for key, value in kwargs.items():
│			setattr(self, key, value)
│
│		self.calculate_stock_value_change()
│		self.calculate_valuation_rate()
⋮...
│	def calculate_stock_value_change(self):
⋮...
│	def get_incoming_rate_from_bundle(self, serial_no) -> float:
⋮...
│	def get_serial_nos(self):
│		if self.sle.get("serial_nos"):
│			return self.sle.serial_nos
│
│		return get_serial_nos(self.sle.serial_and_batch_bundle)
⋮...
│	def calculate_valuation_rate(self):
⋮...
│	def is_rejected_entry(self):
│		return is_rejected(self.sle.voucher_type, self.sle.voucher_detail_no, self.sle.warehouse)
⋮...
│	def get_incoming_rate(self):
│		return abs(flt(self.stock_value_change) / flt(self.sle.actual_qty))
⋮...
│	def get_incoming_rate_of_serial_no(self, serial_no):
│		return self.serial_no_incoming_rate.get(serial_no, 0.0)
⋮...
│	def __init__(self, **kwargs):
⋮...
│	def calculate_avg_rate(self):
⋮...
│	def get_batch_no_ledgers(self) -> list[dict]:
⋮...
│	def prepare_batches(self):
⋮...
│	def get_batch_nos(self) -> list:
│		if self.sle.get("batch_nos"):
│			return self.sle.batch_nos
│
│		return get_batch_nos(self.sle.serial_and_batch_bundle)
⋮...
│	def set_stock_value_difference(self):
⋮...
│	def calculate_valuation_rate(self):
⋮...
│	def get_incoming_rate(self):
│		if not self.sle.actual_qty:
│			self.sle.actual_qty = self.get_actual_qty()
│
│		return abs(flt(self.stock_value_change) / flt(self.sle.actual_qty))
⋮...
│	def get_actual_qty(self):
│		total_qty = 0.0
│		for batch_no in self.available_qty:
│			total_qty += self.available_qty[batch_no]
│
│		return total_qty
⋮...
│def get_empty_batches_based_work_order(work_order, item_code):
⋮...
│def get_batches_from_work_order(work_order, item_code):
⋮...
│def get_batches_from_stock_entries(work_order, item_code):
⋮...
│def set_batch_details_from_package(ids, batches):
⋮...
│	def __init__(self, args):
│		self.set(args)
│		self.set_item_details()
│		self.set_other_details()
⋮...
│	def set(self, args):
│		self.__dict__ = {}
│		for key, value in args.items():
│			setattr(self, key, value)
│			self.__dict__[key] = value
⋮...
│	def get(self, key):
│		return self.__dict__.get(key)
⋮...
│	def set_item_details(self):
⋮...
│	def set_other_details(self):
⋮...
│	def duplicate_package(self):
⋮...
│	def remove_returned_serial_nos(self, package):
⋮...
│	def make_serial_and_batch_bundle(self):
⋮...
│	def add_serial_nos_for_batch_item(self):
⋮...
│	def update_serial_and_batch_entries(self):
⋮...
│	def validate_qty(self, doc):
⋮...
│	def set_auto_serial_batch_entries_for_outward(self):
⋮...
│	def set_auto_serial_batch_entries_for_inward(self):
⋮...
│	def make_serial_no_if_not_exists(self):
⋮...
│	def make_serial_nos(self, serial_nos):
⋮...
│	def set_serial_batch_entries(self, doc):
⋮...
│	def create_batch(self):
⋮...
│	def get_auto_created_serial_nos(self):
⋮...
│def get_serial_or_batch_items(items):
⋮...
│def update_batch_qty(voucher_type, voucher_no, via_landed_cost_voucher=False):
⋮...
│def throw_negative_batch_validation(batch_no, warehouse, qty):
⋮...
│def get_distinct_batches(voucher_type, voucher_no):
⋮...

erpnext\accounts\doctype\payment_entry\payment_entry.py:
│def get_payment_entry(
│	dt,
│	dn,
│	party_amount=None,
│	bank_account=None,
│	bank_amount=None,
│	party_type=None,
│	payment_type=None,
│	reference_date=None,
│	ignore_permissions=False,
│	created_from_payment_request=False,
│):
⋮...
│def get_party_details(company, party_type, party, date, cost_center=None):
⋮...
│def get_account_details(account, date, cost_center=None):
⋮...
│def get_bank_cash_account(doc, bank_account, ignore_permissions=False):
⋮...
│def validate_inclusive_tax(tax, doc):
⋮...
│def get_payment_request_outstanding_set_in_references(references=None):
⋮...
│def get_outstanding_reference_documents(args, validate=False):
⋮...
│def get_reference_details(
│	reference_doctype, reference_name, party_account_currency, party_type=None, party=None
│):
⋮...
│def allocate_open_payment_requests_to_references(references=None, precision=None):
⋮...
│def update_accounting_dimensions(pe, doc):
⋮...
│class InvalidPaymentEntry(ValidationError):
│	pass
⋮...
│class PaymentEntry(AccountsController):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		if not self.is_new():
│			self.setup_party_account_field()
⋮...
│	def setup_party_account_field(self):
⋮...
│	def validate(self):
⋮...
│	def before_save(self):
│		self.set_matched_unset_payment_requests_to_response()
⋮...
│	def on_submit(self):
⋮...
│	def validate_for_repost(self):
│		validate_docs_for_voucher_types(["Payment Entry"])
│		validate_docs_for_deferred_accounting([self.name], [])
⋮...
│	def on_update_after_submit(self):
⋮...
│	def set_liability_account(self):
⋮...
│	def on_cancel(self):
⋮...
│	def update_payment_requests(self, cancel=False):
│		from erpnext.accounts.doctype.payment_request.payment_request import (
│			update_payment_requests_as_per_pe_references,
│		)
│
│		update_payment_requests_as_per_pe_references(self.references, cancel=cancel)
⋮...
│	def update_outstanding_amounts(self):
│		self.set_missing_ref_details(force=True)
⋮...
│	def validate_duplicate_entry(self):
⋮...
│	def set_bank_account_data(self):
⋮...
│	def validate_payment_type_with_outstanding(self):
⋮...
│	def validate_allocated_amount(self):
⋮...
│	def validate_allocated_amount_as_per_payment_request(self):
⋮...
│	def term_based_allocation_enabled_for_reference(
│		self, reference_doctype: str, reference_name: str
⋮...
│	def validate_allocated_amount_with_latest_data(self):
⋮...
│	def delink_advance_entry_references(self):
│		for reference in self.references:
│			if reference.reference_doctype in ("Sales Invoice", "Purchase Invoice"):
│				doc = frappe.get_doc(reference.reference_doctype, reference.reference_name)
│				doc.delink_advance_entries(self.name)
⋮...
│	def set_missing_values(self):
⋮...
│	def set_missing_ref_details(
│		self,
│		force: bool = False,
⋮...
│	def validate_payment_type(self):
│		if self.payment_type not in ("Receive", "Pay", "Internal Transfer"):
│			frappe.throw(_("Payment Type must be one of Receive, Pay and Internal Transfer"))
⋮...
│	def validate_party_details(self):
│		if self.party and not frappe.db.exists(self.party_type, self.party):
│			frappe.throw(_("{0} {1} does not exist").format(_(self.party_type), self.party))
⋮...
│	def set_exchange_rate(self, ref_doc=None):
│		self.set_source_exchange_rate(ref_doc)
│		self.set_target_exchange_rate(ref_doc)
⋮...
│	def set_source_exchange_rate(self, ref_doc=None):
⋮...
│	def set_target_exchange_rate(self, ref_doc=None):
⋮...
│	def validate_mandatory(self):
│		for field in ("paid_amount", "received_amount", "source_exchange_rate", "target_exchange_rate"):
│			if not self.get(field):
│				frappe.throw(_("{0} is mandatory").format(self.meta.get_label(field)))
⋮...
│	def validate_reference_documents(self):
⋮...
│	def get_valid_reference_doctypes(self):
⋮...
│	def validate_paid_invoices(self):
⋮...
│	def validate_journal_entry(self):
⋮...
│	def update_payment_schedule(self, cancel=0):
⋮...
│	def get_allocated_amount_in_transaction_currency(
│		self, allocated_amount, reference_doctype, reference_docname
│	):
⋮...
│	def set_status(self):
⋮...
│	def set_total_in_words(self):
⋮...
│	def set_tax_withholding(self):
⋮...
│	def calculate_tax_withholding_net_total(self):
⋮...
│	def get_order_wise_tax_withholding_net_total(self):
⋮...
│	def apply_taxes(self):
│		self.initialize_taxes()
│		self.determine_exclusive_rate()
│		self.calculate_taxes()
⋮...
│	def set_amounts(self):
⋮...
│	def validate_amounts(self):
│		self.validate_received_amount()
⋮...
│	def validate_received_amount(self):
│		if self.paid_from_account_currency == self.paid_to_account_currency:
│			if self.paid_amount < self.received_amount:
│				frappe.throw(_("Received Amount cannot be greater than Paid Amount"))
⋮...
│	def set_received_amount(self):
⋮...
│	def set_amounts_after_tax(self):
⋮...
│	def set_amounts_in_company_currency(self):
⋮...
│	def calculate_base_allocated_amount_for_reference(self, d) -> float:
⋮...
│	def set_total_allocated_amount(self):
⋮...
│	def set_unallocated_amount(self):
⋮...
│	def set_exchange_gain_loss(self):
⋮...
│	def set_difference_amount(self):
⋮...
│	def get_included_taxes(self):
⋮...
│	def clear_unallocated_reference_document_rows(self):
⋮...
│	def set_title(self):
⋮...
│	def validate_transaction_reference(self):
⋮...
│	def set_remarks(self):
⋮...
│	def set_transaction_currency_and_rate(self):
⋮...
│	def build_gl_map(self):
⋮...
│	def make_gl_entries(self, cancel=0, adv_adj=0):
⋮...
│	def add_party_gl_entries(self, gl_entries):
⋮...
│	def make_advance_gl_entries(
│		self, entry: object | dict = None, cancel: bool = 0, update_outstanding: str = "Yes"
⋮...
│	def add_advance_gl_entries(self, gl_entries: list, entry: object | dict | None):
⋮...
│	def get_dr_and_account_for_advances(self, reference):
⋮...
│	def add_advance_gl_for_reference(self, gl_entries, invoice):
⋮...
│	def add_bank_gl_entries(self, gl_entries):
⋮...
│	def add_tax_gl_entries(self, gl_entries):
⋮...
│	def add_deductions_gl_entries(self, gl_entries):
⋮...
│	def get_party_account_for_taxes(self):
│		if self.payment_type == "Receive":
│			return self.paid_to
│		elif self.payment_type in ("Pay", "Internal Transfer"):
│			return self.paid_from
⋮...
│	def get_value_in_transaction_currency(self, account_currency, gl_dict, field):
⋮...
│	def update_advance_paid(self):
⋮...
│	def on_recurring(self, reference_doc, auto_repeat_doc):
│		self.reference_no = reference_doc.name
│		self.reference_date = nowdate()
⋮...
│	def calculate_deductions(self, tax_details):
│		return {
│			"account": tax_details["tax"]["account_head"],
│			"cost_center": frappe.get_cached_value("Company", self.company, "cost_center"),
│			"amount": self.total_allocated_amount * (tax_details["tax"]["rate"] / 100),
│		}
⋮...
│	def set_gain_or_loss(self, account_details=None):
⋮...
│	def get_exchange_rate(self):
│		return self.source_exchange_rate if self.payment_type == "Receive" else self.target_exchange_rate
⋮...
│	def initialize_taxes(self):
⋮...
│	def determine_exclusive_rate(self):
⋮...
│	def calculate_taxes(self):
⋮...
│	def get_current_tax_amount(self, tax):
⋮...
│	def get_current_tax_fraction(self, tax):
⋮...
│	def set_matched_unset_payment_requests_to_response(self):
⋮...
│	def allocate_amount_to_references(self, paid_amount, paid_amount_change, allocate_payment_amount):
⋮...
│	def set_matched_payment_requests(self, matched_payment_requests):
⋮...
│def get_matched_payment_request_of_references(references=None):
⋮...
│def get_references_outstanding_amount(references=None):
⋮...
│def get_outstanding_of_references_with_payment_term(references=None):
⋮...
│def get_outstanding_of_references_with_no_payment_term(references):
⋮...
│def split_invoices_based_on_payment_terms(outstanding_invoices, company) -> list:
⋮...
│def get_currency_data(outstanding_invoices: list, company: str | None = None) -> dict:
⋮...
│def get_split_invoice_rows(invoice: dict, payment_term_template: str, exc_rates: dict) -> list:
⋮...
│def get_orders_to_be_billed(
│	posting_date,
│	party_type,
│	party,
│	company,
│	party_account_currency,
│	company_currency,
│	cost_center=None,
│	filters=None,
│):
⋮...
│def get_negative_outstanding_invoices(
│	party_type,
│	party,
│	party_account,
│	party_account_currency,
│	company_currency,
│	cost_center=None,
│	condition=None,
│):
⋮...
│def get_company_defaults(company):
│	fields = ["write_off_account", "exchange_gain_loss_account", "cost_center"]
│	return frappe.get_cached_value("Company", company, fields, as_dict=1)
⋮...
│def get_outstanding_on_journal_entry(voucher_no, party_type, party):
⋮...
│def get_open_payment_requests_for_references(references=None):
⋮...
│def set_party_type(dt):
│	if dt in ("Sales Invoice", "Sales Order", "Dunning"):
│		party_type = "Customer"
│	elif dt in ("Purchase Invoice", "Purchase Order"):
│		party_type = "Supplier"
│	return party_type
⋮...
│def set_party_account(dt, dn, doc, party_type):
⋮...
│def set_party_account_currency(dt, party_account, doc):
│	if dt not in ("Sales Invoice", "Purchase Invoice"):
│		party_account_currency = get_account_currency(party_account)
│	else:
│		party_account_currency = doc.get("party_account_currency") or get_account_currency(party_account)
│	return party_account_currency
⋮...
│def set_payment_type(dt, doc):
⋮...
│def set_grand_total_and_outstanding_amount(party_amount, dt, party_account_currency, doc):
⋮...
│def set_paid_amount_and_received_amount(
│	dt, party_account_currency, bank, outstanding_amount, payment_type, bank_amount, doc
│):
⋮...
│def apply_early_payment_discount(paid_amount, received_amount, doc, party_account_currency, reference_date):
⋮...
│def set_pending_discount_loss(pe, doc, discount_amount, base_total_discount_loss, party_account_currency):
⋮...
│def split_early_payment_discount_loss(pe, doc, valid_discounts) -> float:
⋮...
│def get_total_discount_percent(doc, valid_discounts) -> float:
⋮...
│def add_income_discount_loss(pe, doc, total_discount_percent) -> float:
⋮...
│def add_tax_discount_loss(pe, doc, total_discount_percentage) -> float:
⋮...
│def get_reference_as_per_payment_terms(
│	payment_schedule, dt, dn, doc, grand_total, outstanding_amount, party_account_currency
│):
⋮...
│def get_paid_amount(dt, dn, party_type, party, account, due_date):
⋮...
│def make_payment_order(source_name, target_doc=None):
⋮...
│def add_regional_gl_entries(gl_entries, doc):
│	return
⋮...

erpnext\stock\doctype\pick_list\pick_list.py:
│def create_delivery_note(source_name, target_doc=None):
⋮...
│def get_item_details(item_code, uom=None):
⋮...
│def get_cost_center(for_item, from_doctype, company):
⋮...
│def update_common_item_properties(item, location):
⋮...
│def get_rejected_warehouses():
⋮...
│def update_pick_list_status(pick_list):
│	if pick_list:
│		doc = frappe.get_doc("Pick List", pick_list)
│		doc.run_method("update_status")
⋮...
│def get_picked_items_qty(items) -> list[dict]:
⋮...
│def validate_item_locations(pick_list):
│	if not pick_list.locations:
│		frappe.throw(_("Add items in the Item Locations table"))
⋮...
│def get_available_item_locations(
│	item_code,
│	from_warehouses,
│	required_qty,
│	company,
│	ignore_validation=False,
│	picked_item_details=None,
│	consider_rejected_warehouses=False,
│):
⋮...
│def get_available_item_locations_for_batched_item(
│	item_code,
│	from_warehouses,
│	consider_rejected_warehouses=False,
│):
⋮...
│def map_pl_locations(pick_list, item_mapper, delivery_note, sales_order=None):
⋮...
│def update_delivery_note_item(source, target, delivery_note):
⋮...
│def stock_entry_exists(pick_list_name):
│	return frappe.db.exists("Stock Entry", {"pick_list": pick_list_name})
⋮...
│class PickList(Document):
⋮...
│	def onload(self) -> None:
⋮...
│	def validate(self):
│		self.validate_expired_batches()
│		self.validate_for_qty()
│		self.validate_stock_qty()
│		self.check_serial_no_status()
⋮...
│	def before_save(self):
⋮...
│	def validate_stock_qty(self):
⋮...
│	def check_serial_no_status(self):
⋮...
│	def validate_sales_order_percentage(self):
⋮...
│	def before_submit(self):
│		self.validate_sales_order()
│		self.validate_picked_items()
⋮...
│	def validate_sales_order(self):
⋮...
│	def validate_picked_items(self):
⋮...
│	def on_submit(self):
⋮...
│	def validate_expired_batches(self):
⋮...
│	def make_bundle_using_old_serial_batch_fields(self):
⋮...
│	def on_update_after_submit(self) -> None:
│		if self.has_reserved_stock():
│			msg = _(
│				"The Pick List having Stock Reservation Entries cannot be updated. If you need to make changes, we recommend canceling the existing Stock Reservation Entries before updating the Pick List."
│			)
│			frappe.throw(msg)
⋮...
│	def on_cancel(self):
⋮...
│	def delink_serial_and_batch_bundle(self):
⋮...
│	def on_update(self):
│		if self.get("locations"):
│			self.linked_serial_and_batch_bundle()
⋮...
│	def linked_serial_and_batch_bundle(self):
│		for row in self.get("locations"):
│			if row.serial_and_batch_bundle:
│				frappe.get_doc(
│					"Serial and Batch Bundle", row.serial_and_batch_bundle
│				).set_serial_and_batch_values(self, row)
⋮...
│	def on_trash(self):
│		self.remove_serial_and_batch_bundle()
⋮...
│	def remove_serial_and_batch_bundle(self):
│		for row in self.locations:
│			if row.serial_and_batch_bundle:
│				frappe.delete_doc("Serial and Batch Bundle", row.serial_and_batch_bundle)
⋮...
│	def validate_serial_and_batch_bundle(self):
│		for row in self.locations:
│			if row.serial_and_batch_bundle:
│				doc = frappe.get_doc("Serial and Batch Bundle", row.serial_and_batch_bundle)
│				if doc.docstatus == 0:
│					doc.submit()
⋮...
│	def update_status(self, status=None, update_modified=True):
⋮...
│	def update_reference_qty(self):
⋮...
│	def update_packed_items_qty(self, packed_items):
⋮...
│	def update_sales_order_item_qty(self, so_items):
⋮...
│	def update_sales_order_picking_status(self) -> None:
⋮...
│	def create_stock_reservation_entries(self, notify=True) -> None:
⋮...
│	def cancel_stock_reservation_entries(self, notify=True) -> None:
⋮...
│	def validate_picked_qty(self, data):
⋮...
│	def set_item_locations(self, save=False):
⋮...
│	def aggregate_item_qty(self):
⋮...
│	def validate_for_qty(self):
│		if self.purpose == "Material Transfer for Manufacture" and (
│			self.for_qty is None or self.for_qty == 0
│		):
│			frappe.throw(_("Qty of Finished Goods Item should be greater than 0."))
⋮...
│	def before_print(self, settings=None):
│		if self.group_same_items:
│			self.group_similar_items()
⋮...
│	def group_similar_items(self):
⋮...
│	def update_bundle_picked_qty(self):
⋮...
│	def get_picked_items_details(self, items):
⋮...
│	def update_picked_item_from_current_pick_list(self, picked_items):
⋮...
│	def _get_pick_list_items(self, items):
⋮...
│	def _get_product_bundles(self) -> dict[str, str]:
⋮...
│	def _get_product_bundle_qty_map(self, bundles: list[str]) -> dict[str, dict[str, float]]:
⋮...
│	def _compute_picked_qty_for_bundle(self, bundle_row, bundle_items) -> int:
⋮...
│	def has_unreserved_stock(self):
⋮...
│	def has_reserved_stock(self):
⋮...
│def get_items_with_location_and_quantity(item_doc, item_location_map, docstatus):
⋮...
│def get_locations_based_on_required_qty(locations, required_qty):
⋮...
│def validate_picked_materials(item_code, required_qty, locations, picked_item_details=None):
⋮...
│def filter_locations_by_picked_materials(locations, picked_item_details) -> list[dict]:
⋮...
│def get_available_item_locations_for_serial_and_batched_item(
│	item_code,
│	from_warehouses,
│	required_qty,
│	company,
│	consider_rejected_warehouses=False,
│):
⋮...
│def get_available_item_locations_for_serialized_item(
│	item_code,
│	from_warehouses,
│	company,
│	consider_rejected_warehouses=False,
│):
⋮...
│def get_available_item_locations_for_other_item(
│	item_code,
│	from_warehouses,
│	company,
│	consider_rejected_warehouses=False,
│):
⋮...
│def create_dn_wo_so(pick_list):
⋮...
│def create_dn_with_so(sales_dict, pick_list):
⋮...
│def add_product_bundles_to_delivery_note(pick_list: "PickList", delivery_note, item_mapper) -> None:
⋮...
│def update_packed_item_details(pick_list: "PickList", delivery_note) -> None:
⋮...
│def create_stock_entry(pick_list):
⋮...
│def get_pending_work_orders(doctype, txt, searchfield, start, page_length, filters, as_dict):
⋮...
│def target_document_exists(pick_list_name, purpose):
│	if purpose == "Delivery":
│		return frappe.db.exists("Delivery Note", {"pick_list": pick_list_name, "docstatus": 1})
│
│	return stock_entry_exists(pick_list_name)
⋮...
│def set_delivery_note_missing_values(target):
│	target.run_method("set_missing_values")
│	target.run_method("set_po_nos")
│	target.run_method("calculate_taxes_and_totals")
⋮...
│def update_stock_entry_based_on_work_order(pick_list, stock_entry):
⋮...
│def update_stock_entry_based_on_material_request(pick_list, stock_entry):
⋮...
│def update_stock_entry_items_with_no_reference(pick_list, stock_entry):
⋮...

erpnext\stock\doctype\serial_and_batch_bundle\test_serial_and_batch_bundle.py:
│def get_batch_from_bundle(bundle):
│	from erpnext.stock.serial_batch_bundle import get_batch_nos
│
│	batches = get_batch_nos(bundle)
│
│	return next(iter(batches.keys()))
⋮...
│def get_serial_nos_from_bundle(bundle):
│	from erpnext.stock.serial_batch_bundle import get_serial_nos
│
│	serial_nos = get_serial_nos(bundle)
│	return sorted(serial_nos) if serial_nos else []
⋮...
│def make_serial_batch_bundle(kwargs):
⋮...
│class UnitTestSerialAndBatchBundle(UnitTestCase):
⋮...
│class TestSerialandBatchBundle(IntegrationTestCase):
⋮...
│	def test_naming_for_sabb(self):
⋮...
│	def test_inward_outward_serial_valuation(self):
⋮...
│	def test_inward_outward_batch_valuation(self):
⋮...
│	def test_old_batch_valuation(self):
⋮...
│	def test_old_serial_no_valuation(self):
⋮...
│	def test_batch_not_belong_to_serial_no(self):
⋮...
│	def test_auto_delete_draft_serial_and_batch_bundle(self):
⋮...
│	def test_serial_and_batch_bundle_company(self):
⋮...
│	def test_auto_cancel_serial_and_batch(self):
⋮...
│	def test_batch_duplicate_entry(self):
⋮...
│	def test_serial_no_duplicate_entry(self):
⋮...
│	def test_duplicate_serial_and_batch_bundle(self):
⋮...
│	def test_serial_no_valuation_for_legacy_ledgers(self):
⋮...
│	def test_pick_serial_nos_for_batch_item(self):
⋮...
│	def test_auto_create_serial_and_batch_bundle_for_outward_for_batch_item(self):
⋮...
│	def test_voucher_detail_no(self):
⋮...

erpnext\accounts\doctype\purchase_invoice\test_purchase_invoice.py:
│def make_purchase_invoice(**args):
⋮...
│def check_gl_entries(
│	doc,
│	voucher_no,
│	expected_gle,
│	posting_date,
│	voucher_type="Purchase Invoice",
│	additional_columns=None,
│):
⋮...
│def unlink_payment_on_cancel_of_invoice(enable=1):
│	accounts_settings = frappe.get_doc("Accounts Settings")
│	accounts_settings.unlink_payment_on_cancellation_of_invoice = enable
│	accounts_settings.save()
⋮...
│def set_advance_flag(company, flag, default_account):
⋮...
│def toggle_provisional_accounting_setting(**args):
│	args = frappe._dict(args)
│	company = frappe.get_doc("Company", args.company or "_Test Company")
│	company.enable_provisional_accounting_for_non_stock_items = args.enable or 0
│	company.default_provisional_account = args.provisional_account
│	company.save()
⋮...
│def setup_provisional_accounting(**args):
⋮...
│def create_tax_witholding_category(category_name, company, account):
⋮...
│def make_purchase_invoice_against_cost_center(**args):
⋮...
│class TestPurchaseInvoice(IntegrationTestCase, StockTestMixin):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		unlink_payment_on_cancel_of_invoice()
│		frappe.db.set_single_value("Buying Settings", "allow_multiple_items", 1)
⋮...
│	def tearDownClass(cls):
│		unlink_payment_on_cancel_of_invoice(0)
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_purchase_invoice_qty(self):
⋮...
│	def test_purchase_invoice_received_qty(self):
⋮...
│	def test_update_received_qty_in_material_request(self):
⋮...
│	def test_gl_entries_without_perpetual_inventory(self):
⋮...
│	def test_gl_entries_with_perpetual_inventory(self):
⋮...
│	def test_terms_added_after_save(self):
│		pi = frappe.copy_doc(self.globalTestRecords["Purchase Invoice"][1])
│		pi.insert()
│		self.assertTrue(pi.payment_schedule)
│		self.assertEqual(pi.payment_schedule[0].due_date, pi.due_date)
⋮...
│	def test_payment_entry_unlink_against_purchase_invoice(self):
⋮...
│	def test_purchase_invoice_for_blocked_supplier(self):
⋮...
│	def test_purchase_invoice_for_blocked_supplier_invoice(self):
⋮...
│	def test_purchase_invoice_for_blocked_supplier_payment(self):
⋮...
│	def test_purchase_invoice_for_blocked_supplier_payment_today_date(self):
⋮...
│	def test_purchase_invoice_for_blocked_supplier_payment_past_date(self):
⋮...
│	def test_purchase_invoice_blocked_invoice_must_be_in_future(self):
⋮...
│	def test_purchase_invoice_temporary_blocked(self):
⋮...
│	def test_purchase_invoice_explicit_block(self):
⋮...
│	def test_gl_entries_with_perpetual_inventory_against_pr(self):
⋮...
│	def check_gle_for_pi(self, pi):
⋮...
│	def test_purchase_invoice_with_exchange_rate_difference(self):
⋮...
│	def test_purchase_invoice_with_exchange_rate_difference_for_non_stock_item(self):
⋮...
│	def test_purchase_invoice_change_naming_series(self):
⋮...
│	def test_gl_entries_for_non_stock_items_with_perpetual_inventory(self):
⋮...
│	def test_purchase_invoice_calculation(self):
⋮...
│	def test_purchase_invoice_with_advance(self):
⋮...
│	def test_invoice_with_advance_and_multi_payment_terms(self):
⋮...
│	def test_total_purchase_cost_for_project(self):
⋮...
│	def test_return_purchase_invoice_with_perpetual_inventory(self):
⋮...
│	def test_standalone_return_using_pi(self):
⋮...
│	def test_return_with_lcv(self):
⋮...
│	def test_multi_currency_gle(self):
⋮...
│	def test_purchase_invoice_update_stock_gl_entry_with_perpetual_inventory(self):
⋮...
│	def test_purchase_invoice_for_is_paid_and_update_stock_gl_entry_with_perpetual_inventory(self):
⋮...
│	def test_auto_batch(self):
⋮...
│	def test_update_stock_and_purchase_return(self):
⋮...
│	def test_rejected_serial_no(self):
⋮...
│	def test_outstanding_amount_after_advance_jv_cancelation(self):
⋮...
│	def test_outstanding_amount_after_advance_payment_entry_cancelation(self):
⋮...
│	def test_purchase_invoice_with_shipping_rule(self):
⋮...
│	def test_make_pi_without_terms(self):
⋮...
│	def test_duplicate_due_date_in_terms(self):
│		pi = make_purchase_invoice(do_not_save=1)
│		pi.append("payment_schedule", dict(due_date="2017-01-01", invoice_portion=50.00, payment_amount=50))
│		pi.append("payment_schedule", dict(due_date="2017-01-01", invoice_portion=50.00, payment_amount=50))
│
│		self.assertRaises(frappe.ValidationError, pi.insert)
⋮...
│	def test_debit_note(self):
⋮...
│	def test_purchase_invoice_with_cost_center(self):
⋮...
│	def test_purchase_invoice_without_cost_center(self):
⋮...
│	def test_purchase_invoice_with_project_link(self):
⋮...
│	def test_deferred_expense_via_journal_entry(self):
⋮...
│	def test_gain_loss_with_advance_entry(self):
⋮...
│	def test_purchase_invoice_advance_taxes(self):
⋮...
│	def test_purchase_gl_with_tax_withholding_tax(self):
⋮...
│	def test_provisional_accounting_entry(self):
⋮...
│	def test_provisional_accounting_entry_for_over_billing(self):
⋮...
│	def test_provisional_accounting_entry_for_partial_billing(self):
⋮...
│	def test_adjust_incoming_rate(self):
⋮...
│	def test_adjust_incoming_rate_for_rejected_item(self):
⋮...
│	def test_item_less_defaults(self):
⋮...
│	def test_batch_expiry_for_purchase_invoice(self):
⋮...
│	def test_advance_entries_as_asset(self):
⋮...
│	def test_gl_entries_for_standalone_debit_note(self):
⋮...
│	def test_payment_allocation_for_payment_terms(self):
⋮...
│	def test_offsetting_entries_for_accounting_dimensions(self):
⋮...
│	def test_repost_accounting_entries(self):
⋮...
│	def test_create_purchase_invoice_without_mandatory(self):
⋮...
│	def test_purchase_invoice_without_supplier_group(self):
⋮...
│	def test_default_cost_center_for_purchase(self):
⋮...
│	def test_debit_note_with_account_mismatch(self):
⋮...
│	def test_debit_note_without_item(self):
⋮...
│	def test_purchase_invoice_with_use_serial_batch_field_for_rejected_qty(self):
⋮...
│	def test_make_pr_and_pi_from_po(self):
⋮...
│	def test_adjust_incoming_rate_from_pi_with_multi_currency(self):
⋮...
│	def test_adjust_incoming_rate_from_pi_with_multi_currency_and_partial_billing(self):
⋮...
│	def test_opening_invoice_rounding_adjustment_validation(self):
⋮...
│	def _create_opening_roundoff_account(self, company_name):
⋮...
│	def test_ledger_entries_of_opening_invoice_with_rounding_adjustment(self):
⋮...
│	def test_last_purchase_rate(self):
⋮...
│	def test_invoice_against_returned_pr(self):
⋮...
│	def test_trx_currency_debit_credit_for_high_precision(self):
⋮...
│	def test_prevents_fully_returned_invoice_with_zero_quantity(self):
⋮...
│	def test_apply_discount_on_grand_total(self):
⋮...
│	def test_apply_discount_on_grand_total_with_previous_row_total_tax(self):
⋮...

erpnext\accounts\utils.py:
│def get_fiscal_year(
│	date=None,
│	fiscal_year=None,
│	label="Date",
│	verbose=1,
│	company=None,
│	as_dict=False,
│	boolean=None,
│	raise_on_missing=True,
│):
⋮...
│def get_balance_on(
│	account=None,
│	date=None,
│	party_type=None,
│	party=None,
│	company=None,
│	in_account_currency=True,
│	cost_center=None,
│	ignore_account_permission=False,
│	account_type=None,
│	start_date=None,
│):
⋮...
│def get_children(doctype, parent, company, is_root=False, include_disabled=False):
⋮...
│def get_currency_precision():
⋮...
│def get_fiscal_years(
│	transaction_date=None,
│	fiscal_year=None,
│	label="Date",
│	verbose=1,
│	company=None,
│	as_dict=False,
│	boolean=None,
│	raise_on_missing=True,
│):
⋮...
│def cancel_exchange_gain_loss_journal(
│	parent_doc: dict | object, referenced_dt: str | None = None, referenced_dn: str | None = None
⋮...
│def update_voucher_outstanding(voucher_type, voucher_no, account, party_type, party):
⋮...
│class FiscalYearError(frappe.ValidationError):
│	pass
⋮...
│def get_count_on(account, fieldname, date):
⋮...
│def validate_fiscal_year(date, fiscal_year, company, label="Date", doc=None):
⋮...
│def repost_gle_for_stock_vouchers(
│	stock_vouchers: list[tuple[str, str]],
⋮...
│def get_stock_and_account_balance(account=None, posting_date=None, company=None):
⋮...
│def create_payment_ledger_entry(
│	gl_entries, cancel=0, adv_adj=0, update_outstanding="Yes", from_repost=0, partial_cancel=False
│):
⋮...
│def unlink_ref_doc_from_payment_entries(ref_doc: object = None, payment_name: str | None = None):
│	remove_ref_doc_link_from_jv(ref_doc.doctype, ref_doc.name, payment_name)
│	remove_ref_doc_link_from_pe(ref_doc.doctype, ref_doc.name, payment_name)
│	update_accounting_ledgers_after_reference_removal(ref_doc.doctype, ref_doc.name, payment_name)
│	remove_ref_from_advance_section(ref_doc)
⋮...
│def get_autoname_with_number(number_value, doc_title, company):
⋮...
│def _delete_pl_entries(voucher_type, voucher_no):
│	ple = qb.DocType("Payment Ledger Entry")
│	qb.from_(ple).delete().where((ple.voucher_type == voucher_type) & (ple.voucher_no == voucher_no)).run()
⋮...
│def get_future_stock_vouchers(posting_date, posting_time, for_warehouses=None, for_items=None, company=None):
⋮...
│def create_err_and_its_journals(companies: list | None = None) -> None:
⋮...
│class QueryPaymentLedger:
⋮...
│def create_gain_loss_journal(
│	company,
│	posting_date,
│	party_type,
│	party,
│	party_account,
│	gain_loss_account,
│	exc_gain_loss,
│	dr_or_cr,
│	reverse_dr_or_cr,
│	ref1_dt,
│	ref1_dn,
│	ref1_detail_no,
│	ref2_dt,
│	ref2_dn,
│	ref2_detail_no,
│	cost_center,
│	dimensions,
│) -> str:
⋮...
│class PaymentEntryUnlinkError(frappe.ValidationError):
│	pass
⋮...
│def reconcile_against_document(
│	args, skip_ref_details_update_for_pe=False, active_dimensions=None
│):  # nosemgrep
⋮...
│def get_linked_exchange_gain_loss_journal(referenced_dt: str, referenced_dn: str, je_docstatus: int) -> list:
⋮...
│def convert_to_list(result):
│	"""
│	Convert tuple to list
│	"""
│	return [x[0] for x in result]
⋮...
│def get_company_default(company, fieldname, ignore_validation=False):
⋮...
│def get_outstanding_invoices(
│	party_type,
│	party,
│	account,
│	common_filter=None,
│	posting_date=None,
│	min_outstanding=None,
│	max_outstanding=None,
│	accounting_dimensions=None,
│	vouchers=None,  # list of dicts [{'voucher_type': '', 'voucher_no': ''}] for filtering
⋮...
│def validate_field_number(doctype_name, docname, number_value, company, field_name):
⋮...
│def update_gl_entries_after(
│	posting_date,
│	posting_time,
│	for_warehouses=None,
│	for_items=None,
│	warehouse_account=None,
│	company=None,
│):
⋮...
│def _delete_accounting_ledger_entries(voucher_type, voucher_no):
│	"""
│	Remove entries from both General and Payment Ledger for specified Voucher
│	"""
│	_delete_gl_entries(voucher_type, voucher_no)
│	_delete_pl_entries(voucher_type, voucher_no)
⋮...
│def sort_stock_vouchers_by_posting_date(
│	stock_vouchers: list[tuple[str, str]], company=None
⋮...
│def get_voucherwise_gl_entries(future_stock_vouchers, posting_date):
⋮...
│def get_stock_accounts(company, voucher_type=None, voucher_no=None, accounts=None):
⋮...
│def check_and_delete_linked_reports(report):
│	"""Check if reports are referenced in Desktop Icon"""
│	icons = frappe.get_all("Desktop Icon", fields=["name"], filters={"_report": report})
│	if icons:
│		for icon in icons:
│			frappe.delete_doc("Desktop Icon", icon)
⋮...
│def get_party_types_from_account_type(account_type):
│	return frappe.db.get_all("Party Type", {"account_type": account_type}, pluck="name")
⋮...
│def run_ledger_health_checks():
⋮...
│def sync_auto_reconcile_config(auto_reconciliation_job_trigger: int = 15):
⋮...
│def _get_fiscal_years(company=None):
⋮...
│def get_fiscal_year_filter_field(company=None):
⋮...
│def add_ac(args=None):
⋮...
│def add_cc(args=None):
⋮...
│def _build_dimensions_dict_for_exc_gain_loss(
│	entry: dict | object = None, active_dimensions: list | None = None
⋮...
│def check_if_advance_entry_modified(args):
⋮...
│def validate_allocated_amount(args):
│	precision = args.get("precision") or frappe.db.get_single_value("System Settings", "currency_precision")
│	if args.get("allocated_amount") < 0:
│		throw(_("Allocated amount cannot be negative"))
│	elif flt(args.get("allocated_amount"), precision) > flt(args.get("unadjusted_amount"), precision):
│		throw(_("Allocated amount cannot be greater than unadjusted amount"))
⋮...
│def update_reference_in_journal_entry(d, journal_entry, do_not_save=False):
⋮...
│def update_reference_in_payment_entry(
│	d, payment_entry, do_not_save=False, skip_ref_details_update_for_pe=False, dimensions_dict=None
│):
⋮...
│def delete_exchange_gain_loss_journal(
│	parent_doc: dict | object, referenced_dt: str | None = None, referenced_dn: str | None = None
⋮...
│def cancel_common_party_journal(self):
⋮...
│def update_accounting_ledgers_after_reference_removal(
│	ref_type: str | None = None, ref_no: str | None = None, payment_name: str | None = None
⋮...
│def remove_ref_from_advance_section(ref_doc: object = None):
│	# TODO: this might need some testing
│	if ref_doc.doctype in ("Sales Invoice", "Purchase Invoice"):
│		ref_doc.set("advances", [])
│		adv_type = qb.DocType(f"{ref_doc.doctype} Advance")
│		qb.from_(adv_type).delete().where(adv_type.parent == ref_doc.name).run()
⋮...
│def remove_ref_doc_link_from_jv(
│	ref_type: str | None = None, ref_no: str | None = None, payment_name: str | None = None
⋮...
│def remove_ref_doc_link_from_pe(
│	ref_type: str | None = None, ref_no: str | None = None, payment_name: str | None = None
⋮...
│def fix_total_debit_credit():
⋮...
│def get_held_invoices(party_type, party):
⋮...
│def get_account_name(account_type=None, root_type=None, is_group=None, account_currency=None, company=None):
⋮...
│def get_companies():
│	"""get a list of companies based on permission"""
│	return [d.name for d in frappe.get_list("Company", fields=["name"], order_by="name")]
⋮...
│def get_account_balances(accounts, company):
⋮...
│def create_payment_gateway_account(gateway, payment_channel="Email", company=None):
⋮...
│def update_cost_center(docname, cost_center_name, cost_center_number, company, merge):
⋮...
│def parse_naming_series_variable(doc, variable):
⋮...
│def get_coa(doctype, parent, is_root=None, chart=None):
⋮...
│def _delete_gl_entries(voucher_type, voucher_no):
│	gle = qb.DocType("GL Entry")
│	qb.from_(gle).delete().where((gle.voucher_type == voucher_type) & (gle.voucher_no == voucher_no)).run()
⋮...
│def compare_existing_and_expected_gle(existing_gle, expected_gle, precision):
⋮...
│def get_journal_entry(account, stock_adjustment_account, amount):
⋮...
│def auto_create_exchange_rate_revaluation_daily() -> None:
⋮...
│def auto_create_exchange_rate_revaluation_weekly() -> None:
⋮...
│def auto_create_exchange_rate_revaluation_monthly() -> None:
⋮...
│def get_payment_ledger_entries(gl_entries, cancel=0):
⋮...
│def delink_original_entry(pl_entry, partial_cancel=False):
⋮...
│	def __init__(self):
⋮...
│	def reset(self):
⋮...
│	def query_for_outstanding(self):
⋮...
│	def get_voucher_outstandings(
│		self,
│		vouchers=None,
│		common_filter=None,
│		posting_date=None,
│		min_outstanding=None,
│		max_outstanding=None,
│		get_payments=False,
│		get_invoices=False,
│		accounting_dimensions=None,
│		limit=None,
│		voucher_no=None,
│	):
⋮...

erpnext\accounts\report\cash_flow\cash_flow.py:
│def execute(filters=None):
⋮...
│def get_chart_data(columns, data, currency):
⋮...
│def get_report_summary(summary_data, currency):
⋮...
│def add_total_row_account(out, data, label, period_list, currency, summary_data, filters, consolidated=False):
⋮...
│def get_cash_flow_accounts():
⋮...
│def get_account_type_based_data(company, account_type, period_list, accumulated_values, filters):
⋮...
│def get_account_type_based_gl_data(company, filters=None):
⋮...
│def get_start_date(period, accumulated_values, company):
⋮...

erpnext\accounts\doctype\journal_entry\journal_entry.py:
│def get_payment_entry(ref_doc, args):
⋮...
│def get_exchange_rate(
│	posting_date,
│	account=None,
│	account_currency=None,
│	company=None,
│	reference_type=None,
│	reference_name=None,
│	debit=None,
│	credit=None,
│	exchange_rate=None,
│):
⋮...
│def get_default_bank_cash_account(
│	company, account_type=None, mode_of_payment=None, account=None, ignore_permissions=False
│):
⋮...
│def get_payment_entry_against_invoice(
│	dt, dn, amount=None, debit_in_account_currency=None, journal_entry=False, bank_account=None
│):
⋮...
│class StockAccountInvalidTransaction(frappe.ValidationError):
│	pass
⋮...
│def make_reverse_journal_entry(source_name, target_doc=None):
⋮...
│class JournalEntry(AccountsController):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
⋮...
│	def validate(self):
⋮...
│	def validate_advance_accounts(self):
⋮...
│	def validate_for_repost(self):
│		validate_docs_for_voucher_types(["Journal Entry"])
│		validate_docs_for_deferred_accounting([self.name], [])
⋮...
│	def submit(self):
│		if len(self.accounts) > 100:
│			msgprint(_("The task has been enqueued as a background job."), alert=True)
│			self.queue_action("submit", timeout=4600)
│		else:
│			return self._submit()
⋮...
│	def cancel(self):
│		if len(self.accounts) > 100:
│			msgprint(_("The task has been enqueued as a background job."), alert=True)
│			self.queue_action("cancel", timeout=4600)
│		else:
│			return self._cancel()
⋮...
│	def before_submit(self):
│		# Do not validate while importing via data import
│		if not frappe.flags.in_import:
│			self.validate_total_debit_and_credit()
⋮...
│	def on_submit(self):
⋮...
│	def on_update_after_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def get_title(self):
│		return self.pay_to_recd_from or self.accounts[0].account
⋮...
│	def update_advance_paid(self):
⋮...
│	def validate_inter_company_accounts(self):
⋮...
│	def validate_depr_entry_voucher_type(self):
│		if (
│			any(d.account_type == "Depreciation" for d in self.get("accounts"))
│			and self.voucher_type != "Depreciation Entry"
│		):
│			frappe.throw(_("Journal Entry type should be set as Depreciation Entry for asset depreciation"))
⋮...
│	def validate_stock_accounts(self):
⋮...
│	def apply_tax_withholding(self):
⋮...
│	def update_asset_value(self):
⋮...
│	def update_inter_company_jv(self):
⋮...
│	def update_invoice_discounting(self):
⋮...
│	def update_booked_depreciation(self, cancel=0):
⋮...
│	def unlink_advance_entry_reference(self):
⋮...
│	def unlink_asset_reference(self):
⋮...
│	def unlink_inter_company_jv(self):
⋮...
│	def unlink_asset_adjustment_entry(self):
│		frappe.db.sql(
│			""" update `tabAsset Value Adjustment`
│			set journal_entry = null where journal_entry = %s""",
│			self.name,
│		)
⋮...
│	def validate_party(self):
⋮...
│	def check_credit_limit(self):
⋮...
│	def validate_cheque_info(self):
⋮...
│	def validate_entries_for_advance(self):
⋮...
│	def system_generated_gain_loss(self):
│		return (
│			self.voucher_type == "Exchange Gain Or Loss" and self.multi_currency and self.is_system_generated
│		)
⋮...
│	def validate_against_jv(self):
⋮...
│	def validate_reference_doc(self):
⋮...
│	def validate_orders(self):
⋮...
│	def validate_invoices(self):
⋮...
│	def set_against_account(self):
⋮...
│	def validate_debit_credit_amount(self):
│		if not (self.voucher_type == "Exchange Gain Or Loss" and self.multi_currency):
│			for d in self.get("accounts"):
│				if not flt(d.debit) and not flt(d.credit):
│					frappe.throw(_("Row {0}: Both Debit and Credit values cannot be zero").format(d.idx))
⋮...
│	def validate_total_debit_and_credit(self):
⋮...
│	def set_total_debit_credit(self):
⋮...
│	def validate_multi_currency(self):
⋮...
│	def set_amounts_in_company_currency(self):
⋮...
│	def set_exchange_rate(self):
⋮...
│	def create_remarks(self):
⋮...
│	def set_print_format_fields(self):
⋮...
│	def set_total_amount(self, amt, currency):
│		self.total_amount = amt
│		self.total_amount_currency = currency
│		from frappe.utils import money_in_words
│
│		self.total_amount_in_words = money_in_words(amt, currency)
⋮...
│	def build_gl_map(self):
⋮...
│	def make_gl_entries(self, cancel=0, adv_adj=0):
⋮...
│	def get_balance(self, difference_account=None):
⋮...
│	def get_outstanding_invoices(self):
⋮...
│	def get_values(self):
⋮...
│	def validate_credit_debit_note(self):
⋮...
│	def validate_empty_accounts_table(self):
│		if not self.get("accounts"):
│			frappe.throw(_("Accounts table cannot be blank."))
⋮...
│def get_payment_entry_against_order(
│	dt, dn, amount=None, debit_in_account_currency=None, journal_entry=False, bank_account=None
│):
⋮...
│def get_against_jv(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_outstanding(args):
⋮...
│def get_party_account_and_currency(company, party_type, party):
⋮...
│def get_account_details_and_party_type(account, date, company, debit=None, credit=None, exchange_rate=None):
⋮...
│def get_average_exchange_rate(account):
⋮...
│def make_inter_company_journal_entry(name, voucher_type, company):
⋮...

erpnext\accounts\report\balance_sheet\balance_sheet.py:
│def execute(filters=None):
⋮...
│def get_chart_data(filters, columns, asset, liability, equity, currency):
⋮...
│def get_report_summary(
│	period_list,
│	asset,
│	liability,
│	equity,
│	provisional_profit_loss,
│	currency,
│	filters,
│	consolidated=False,
│):
⋮...
│def get_provisional_profit_loss(
│	asset, liability, equity, period_list, company, currency=None, consolidated=False
│):
⋮...
│def check_opening_balance(asset, liability, equity):
⋮...

erpnext\accounts\report\profit_and_loss_statement\profit_and_loss_statement.py:
│def execute(filters=None):
⋮...
│def get_chart_data(filters, columns, income, expense, net_profit_loss, currency):
⋮...
│def get_report_summary(
│	period_list, periodicity, income, expense, net_profit_loss, currency, filters, consolidated=False
│):
⋮...
│def get_net_profit_loss(income, expense, period_list, company, currency=None, consolidated=False):
⋮...

erpnext\controllers\accounts_controller.py:
│def update_child_qty_rate(parent_doctype, trans_items, parent_doctype_name, child_docname="items"):
⋮...
│def get_due_date(term, posting_date=None, bill_date=None):
⋮...
│class InvalidQtyError(frappe.ValidationError):
│	pass
⋮...
│class AccountsController(TransactionBase):
⋮...
│def get_taxes_and_charges(master_doctype, master_name):
⋮...
│def validate_conversion_rate(currency, conversion_rate, conversion_rate_label, company):
⋮...
│def validate_account_head(idx: int, account: str, company: str, context: str | None = None) -> None:
⋮...
│def validate_taxes_and_charges(tax):
⋮...
│def validate_inclusive_tax(tax, doc):
⋮...
│def get_advance_payment_entries_for_regional(*args, **kwargs):
│	return get_advance_payment_entries(*args, **kwargs)
⋮...
│def get_common_query(
│	party_type,
│	party,
│	party_account,
│	default_advance_account,
│	limit,
│	condition,
│):
⋮...
│def update_invoice_status():
⋮...
│def get_payment_terms(
│	terms_template, posting_date=None, grand_total=None, base_grand_total=None, bill_date=None
│):
⋮...
│def get_discount_date(term, posting_date=None, bill_date=None):
⋮...
│def merge_taxes(source_taxes, target_doc):
⋮...
│def validate_einvoice_fields(doc):
│	pass
⋮...
│class AccountMissingError(frappe.ValidationError):
│	pass
⋮...
│	def get_print_settings(self):
⋮...
│	def company_currency(self):
│		if not hasattr(self, "__company_currency"):
│			self.__company_currency = erpnext.get_company_currency(self.company)
│
│		return self.__company_currency
⋮...
│	def onload(self):
⋮...
│	def remove_bundle_for_non_stock_invoices(self):
⋮...
│	def ensure_supplier_is_not_blocked(self):
⋮...
│	def validate_against_voucher_outstanding(self):
⋮...
│	def validate(self):
⋮...
│	def set_default_letter_head(self):
│		if hasattr(self, "letter_head") and not self.letter_head:
│			self.letter_head = frappe.db.get_value("Company", self.company, "default_letter_head")
⋮...
│	def init_internal_values(self):
⋮...
│	def before_cancel(self):
│		validate_einvoice_fields(self)
⋮...
│	def _remove_references_in_unreconcile(self):
⋮...
│	def _remove_references_in_repost_doctypes(self):
⋮...
│	def _remove_advance_payment_ledger_entries(self):
⋮...
│	def on_trash(self):
⋮...
│	def remove_serial_and_batch_bundle(self):
⋮...
│	def validate_company_in_accounting_dimension(self):
⋮...
│	def validate_company(self, dimension_list, child=None):
⋮...
│	def validate_party_address_and_contact(self):
⋮...
│	def validate_party_address(self, party, party_type, billing_address, shipping_address=None):
⋮...
│	def validate_party_contact(self, party, party_type):
⋮...
│	def validate_return_against_account(self):
⋮...
│	def validate_deferred_income_expense_account(self):
⋮...
│	def validate_auto_repeat_subscription_dates(self):
│		if self.get("from_date") and self.get("to_date") and getdate(self.from_date) > getdate(self.to_date):
│			frappe.throw(_("To Date cannot be before From Date"), title=_("Invalid Auto Repeat Date"))
⋮...
│	def validate_deferred_start_and_end_date(self):
⋮...
│	def validate_invoice_documents_schedule(self):
⋮...
│	def validate_non_invoice_documents_schedule(self):
│		self.set_payment_schedule()
│		self.validate_payment_schedule_dates()
│		self.validate_payment_schedule_amount()
⋮...
│	def validate_all_documents_schedule(self):
│		if self.doctype in ("Sales Invoice", "Purchase Invoice"):
│			self.validate_invoice_documents_schedule()
│		elif self.doctype in ("Quotation", "Purchase Order", "Sales Order"):
│			self.validate_non_invoice_documents_schedule()
⋮...
│	def before_print(self, settings=None):
⋮...
│	def calculate_paid_amount(self):
⋮...
│	def set_missing_values(self, for_validate=False):
│		if frappe.flags.in_test:
│			for fieldname in ["posting_date", "transaction_date"]:
│				if self.meta.get_field(fieldname) and not self.get(fieldname):
│					self.set(fieldname, today())
│					break
⋮...
│	def calculate_taxes_and_totals(self):
⋮...
│	def validate_date_with_fiscal_year(self):
⋮...
│	def validate_party_accounts(self):
⋮...
│	def validate_inter_company_reference(self):
⋮...
│	def disable_pricing_rule_on_internal_transfer(self):
⋮...
│	def disable_tax_included_prices_for_internal_transfer(self):
⋮...
│	def validate_due_date(self):
⋮...
│	def set_price_list_currency(self, buying_or_selling):
⋮...
│	def set_missing_item_details(self, for_validate=False):
⋮...
│	def apply_pricing_rule_on_items(self, item, pricing_rule_args):
⋮...
│	def set_pricing_rule_details(self, item_row, args):
⋮...
│	def set_taxes(self):
⋮...
│	def is_pos_profile_changed(self):
⋮...
│	def set_taxes_and_charges(self):
│		if frappe.db.get_single_value("Accounts Settings", "add_taxes_from_item_tax_template"):
│			if hasattr(self, "taxes_and_charges") and not self.get("taxes") and not self.get("is_pos"):
│				if tax_master_doctype := self.meta.get_field("taxes_and_charges").options:
│					self.append_taxes_from_master(tax_master_doctype)
⋮...
│	def append_taxes_from_master(self, tax_master_doctype=None):
│		if self.get("taxes_and_charges"):
│			if not tax_master_doctype:
│				tax_master_doctype = self.meta.get_field("taxes_and_charges").options
│
│			self.extend("taxes", get_taxes_and_charges(tax_master_doctype, self.get("taxes_and_charges")))
⋮...
│	def append_taxes_from_item_tax_template(self):
⋮...
│	def get_tax_row(self, account_head):
│		for row in self.taxes:
│			if row.account_head == account_head:
│				return row
⋮...
│	def set_other_charges(self):
│		self.set("taxes", [])
│		self.set_taxes()
⋮...
│	def validate_enabled_taxes_and_charges(self):
│		taxes_and_charges_doctype = self.meta.get_options("taxes_and_charges")
│		if self.taxes_and_charges and frappe.get_cached_value(
│			taxes_and_charges_doctype, self.taxes_and_charges, "disabled"
│		):
│			frappe.throw(_("{0} '{1}' is disabled").format(taxes_and_charges_doctype, self.taxes_and_charges))
⋮...
│	def validate_tax_account_company(self):
⋮...
│	def get_gl_dict(self, args, account_currency=None, item=None):
⋮...
│	def get_voucher_subtype(self):
⋮...
│	def get_value_in_transaction_currency(self, account_currency, gl_dict, field):
│		if account_currency == self.get("currency"):
│			return gl_dict.get(field + "_in_account_currency")
│		else:
│			return flt(gl_dict.get(field, 0) / self.get("conversion_rate", 1))
⋮...
│	def validate_zero_qty_for_return_invoices_with_stock(self):
⋮...
│	def validate_qty_is_not_zero(self):
⋮...
│	def validate_account_currency(self, account, account_currency=None):
⋮...
│	def clear_unallocated_advances(self, childtype, parentfield):
⋮...
│	def apply_shipping_rule(self):
│		if self.shipping_rule:
│			shipping_rule = frappe.get_doc("Shipping Rule", self.shipping_rule)
│			shipping_rule.apply(self)
│			self.calculate_taxes_and_totals()
⋮...
│	def get_shipping_address(self):
⋮...
│	def set_advances(self):
⋮...
│	def get_advance_entries(self, include_unallocated=True):
⋮...
│	def is_inclusive_tax(self):
⋮...
│	def should_show_taxes_as_table_in_print(self):
│		return cint(frappe.db.get_single_value("Accounts Settings", "show_taxes_as_table_in_print"))
⋮...
│	def validate_advance_entries(self):
⋮...
│	def set_advance_gain_or_loss(self):
⋮...
│	def make_precision_loss_gl_entry(self, gl_entries):
⋮...
│	def gain_loss_journal_already_booked(
│		self,
│		gain_loss_account,
│		exc_gain_loss,
│		ref2_dt,
│		ref2_dn,
│		ref2_detail_no,
│	) -> bool:
⋮...
│	def make_exchange_gain_loss_journal(
│		self, args: dict | None = None, dimensions_dict: dict | None = None
⋮...
│	def is_payable_account(self, reference_doctype, account):
⋮...
│	def update_against_document_in_jv(self):
⋮...
│	def cancel_system_generated_credit_debit_notes(self):
⋮...
│	def on_cancel(self):
⋮...
│	def unlink_ref_doc_from_po(self):
⋮...
│	def get_tax_map(self):
⋮...
│	def get_amount_and_base_amount(self, item, enable_discount_accounting):
⋮...
│	def get_tax_amounts(self, tax, enable_discount_accounting):
⋮...
│	def make_discount_gl_entries(self, gl_entries):
⋮...
│	def validate_multiple_billing(self, ref_dt, item_ref_dn, based_on):
⋮...
│	def get_billing_reference_details(self, reference_names, reference_doctype, based_on):
⋮...
│	def get_billed_amount_for_item(self, item, item_ref_dn, based_on):
⋮...
│	def throw_overbill_exception(self, item, max_allowed_amt):
│		frappe.throw(
│			_(
│				"Cannot overbill for Item {0} in row {1} more than {2}. To allow over-billing, please set allowance in Accounts Settings"
│			).format(item.item_code, item.idx, max_allowed_amt)
│		)
⋮...
│	def get_company_default(self, fieldname, ignore_validation=False):
│		from erpnext.accounts.utils import get_company_default
│
│		return get_company_default(self.company, fieldname, ignore_validation=ignore_validation)
⋮...
│	def get_stock_items(self):
⋮...
│	def calculate_total_advance_from_ledger(self):
⋮...
│	def set_total_advance_paid(self):
⋮...
│	def set_advance_payment_status(self):
⋮...
│	def company_abbr(self):
│		if not hasattr(self, "_abbr"):
│			self._abbr = frappe.get_cached_value("Company", self.company, "abbr")
│
│		return self._abbr
⋮...
│	def raise_missing_debit_credit_account_error(self, party_type, party):
⋮...
│	def validate_party(self):
│		party_type, party = self.get_party()
│		validate_party_frozen_disabled(party_type, party)
⋮...
│	def get_party(self):
⋮...
│	def validate_currency(self):
⋮...
│	def validate_party_account_currency(self):
⋮...
│	def delink_advance_entries(self, linked_doc_name):
⋮...
│	def group_similar_items(self):
⋮...
│	def set_payment_schedule(self):
⋮...
│	def get_order_details(self):
⋮...
│	def linked_order_has_payment_terms(self, po_or_so, fieldname, doctype):
⋮...
│	def all_items_have_same_po_or_so(self, po_or_so, fieldname):
│		for item in self.get("items"):
│			if item.get(fieldname) != po_or_so:
│				return False
│
│		return True
⋮...
│	def linked_order_has_payment_terms_template(self, po_or_so, doctype):
│		return frappe.get_value(doctype, po_or_so, "payment_terms_template")
⋮...
│	def linked_order_has_payment_schedule(self, po_or_so):
│		return frappe.get_all("Payment Schedule", filters={"parent": po_or_so})
⋮...
│	def fetch_payment_terms_from_order(
│		self, po_or_so, po_or_so_doctype, grand_total, base_grand_total, automatically_fetch_payment_terms
│	):
⋮...
│	def set_due_date(self):
│		due_dates = [d.due_date for d in self.get("payment_schedule") if d.due_date]
│		if due_dates:
│			self.due_date = max(due_dates)
⋮...
│	def validate_payment_schedule_dates(self):
⋮...
│	def validate_payment_schedule_amount(self):
⋮...
│	def is_rounded_total_disabled(self):
│		if self.meta.get_field("disable_rounded_total"):
│			return self.disable_rounded_total
│		else:
│			return frappe.db.get_single_value("Global Defaults", "disable_rounded_total")
⋮...
│	def set_inter_company_account(self):
⋮...
│	def is_internal_transfer(self):
⋮...
│	def process_common_party_accounting(self):
⋮...
│	def get_common_party_link(self):
⋮...
│	def create_advance_and_reconcile(self, party_link):
⋮...
│	def check_conversion_rate(self):
⋮...
│	def check_finance_books(self, item, asset):
⋮...
│	def check_if_fields_updated(self, fields_to_check, child_tables):
⋮...
│	def repost_accounting_entries(self):
⋮...
│	def get_advance_payment_doctypes(self) -> list:
│		return frappe.get_hooks("advance_payment_receivable_doctypes") + frappe.get_hooks(
│			"advance_payment_payable_doctypes"
│		)
⋮...
│	def make_advance_payment_ledger_for_journal(self):
⋮...
│	def make_advance_payment_ledger_for_payment(self):
⋮...
│	def make_advance_payment_ledger_entries(self):
│		if self.docstatus != 0:
│			if self.doctype == "Journal Entry":
│				self.make_advance_payment_ledger_for_journal()
│			elif self.doctype == "Payment Entry":
│				self.make_advance_payment_ledger_for_payment()
⋮...
│	def set_transaction_currency_and_rate_in_gl_map(self, gl_entries):
│		for x in gl_entries:
│			x["transaction_currency"] = self.currency
│			x["transaction_exchange_rate"] = self.get("conversion_rate") or 1
⋮...
│def get_tax_rate(account_head):
│	return frappe.get_cached_value("Account", account_head, ["tax_rate", "account_name"], as_dict=True)
⋮...
│def get_default_taxes_and_charges(master_doctype, tax_template=None, company=None):
⋮...
│def validate_cost_center(tax, doc):
⋮...
│def set_balance_in_account_currency(
│	gl_dict, account_currency=None, conversion_rate=None, company_currency=None
│):
⋮...
│def get_advance_journal_entries(
│	party_type,
│	party,
│	party_account,
│	amount_field,
│	order_doctype,
│	order_list,
│	include_unallocated=True,
│):
⋮...
│def get_advance_payment_entries(
│	party_type,
│	party,
│	party_account,
│	order_doctype,
│	order_list=None,
│	default_advance_account=None,
│	include_unallocated=True,
│	against_all_orders=False,
│	limit=None,
│	condition=None,
│):
⋮...
│def get_payment_term_details(
│	term, posting_date=None, grand_total=None, base_grand_total=None, bill_date=None
│):
⋮...
│def get_supplier_block_status(party_name):
⋮...
│def set_child_tax_template_and_map(item, child_item, parent_doc):
⋮...
│def add_taxes_from_tax_template(child_item, parent_doc, db_insert=True):
⋮...
│def set_order_defaults(parent_doctype, parent_doctype_name, child_doctype, child_docname, trans_item):
⋮...
│def validate_child_on_delete(row, parent):
⋮...
│def update_bin_on_delete(row, doctype):
⋮...
│def validate_and_delete_children(parent, data) -> bool:
⋮...
│def check_if_child_table_updated(child_table_before_update, child_table_after_update, fields_to_check):
⋮...
│def validate_regional(doc):
│	pass
⋮...
│def update_gl_dict_with_regional_fields(doc, gl_dict):
│	pass
⋮...

erpnext\patches\v14_0\update_closing_balances.py:
│def execute():
⋮...
│def get_gl_entries(pcv_list):
⋮...
│def process_grouped_pcvs(pcvs, gl_entries):
⋮...
│def get_period_closing_vouchers():
⋮...
│def get_gle_fields():
⋮...

erpnext\accounts\report\accounts_receivable\accounts_receivable.py:
│def execute(filters=None):
│	args = {
│		"account_type": "Receivable",
│		"naming_by": ["Selling Settings", "cust_master_name"],
│	}
│	return ReceivablePayableReport(filters).run(args)
⋮...
│class ReceivablePayableReport:
⋮...
│	def __init__(self, filters=None):
⋮...
│	def run(self, args):
⋮...
│	def set_defaults(self):
⋮...
│	def get_data(self):
⋮...
│	def build_voucher_dict(self, ple):
⋮...
│	def init_voucher_balance(self):
⋮...
│	def get_invoices(self, ple):
⋮...
│	def init_subtotal_row(self, party):
│		if not self.total_row_map.get(party):
│			self.total_row_map.setdefault(party, {"party": party, "bold": 1})
│
│			for field in self.get_currency_fields():
│				self.total_row_map[party][field] = 0.0
⋮...
│	def get_currency_fields(self):
⋮...
│	def get_voucher_balance(self, ple):
⋮...
│	def update_voucher_balance(self, ple):
⋮...
│	def update_sub_total_row(self, row, party):
⋮...
│	def append_subtotal_row(self, party):
⋮...
│	def build_data(self):
⋮...
│	def append_row(self, row):
⋮...
│	def set_invoice_details(self, row):
⋮...
│	def set_delivery_notes(self, row):
│		delivery_notes = self.delivery_notes.get(row.voucher_no, [])
│		if delivery_notes:
│			row.delivery_notes = ", ".join(delivery_notes)
⋮...
│	def build_delivery_note_map(self):
⋮...
│	def get_invoice_details(self):
⋮...
│	def set_party_details(self, row):
⋮...
│	def allocate_outstanding_based_on_payment_terms(self, row):
⋮...
│	def get_payment_terms(self, row):
⋮...
│	def append_payment_term(self, row, d, term, company_currency):
⋮...
│	def allocate_closing_to_term(self, row, term, key):
⋮...
│	def allocate_extra_payments_or_credits(self, row):
⋮...
│	def get_future_payments(self):
⋮...
│	def get_future_payments_from_payment_entry(self):
⋮...
│	def get_future_payments_from_journal_entry(self):
⋮...
│	def allocate_future_payments(self, row):
⋮...
│	def get_return_entries(self):
⋮...
│	def set_ageing(self, row):
⋮...
│	def get_ageing_data(self, entry_date, row):
⋮...
│	def get_ple_entries(self):
⋮...
│	def get_sales_invoices_or_customers_based_on_sales_person(self):
⋮...
│	def prepare_conditions(self):
⋮...
│	def get_cost_center_conditions(self):
⋮...
│	def add_common_filters(self):
⋮...
│	def add_customer_filters(
│		self,
│	):
⋮...
│	def add_supplier_filters(self):
⋮...
│	def get_hierarchical_filters(self, doctype, key):
⋮...
│	def add_accounting_dimensions_filters(self):
⋮...
│	def is_invoice(self, ple):
│		if ple.voucher_type in ("Sales Invoice", "Purchase Invoice"):
│			return True
⋮...
│	def get_party_details(self, party):
⋮...
│	def get_columns(self):
⋮...
│	def add_column(self, label, fieldname=None, fieldtype="Currency", options=None, width=120):
⋮...
│	def setup_ageing_columns(self):
⋮...
│	def get_chart_data(self):
⋮...
│	def get_exchange_rate_revaluations(self):
⋮...
│def get_customer_group_with_children(customer_groups):
⋮...

erpnext\subcontracting\doctype\subcontracting_receipt\subcontracting_receipt.py:
│def make_purchase_receipt(source_name, target_doc=None, save=False, submit=False, notify=False):
⋮...
│class SubcontractingReceipt(SubcontractingController):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def onload(self):
│		self.set_onload(
│			"backflush_based_on",
│			frappe.db.get_single_value("Buying Settings", "backflush_raw_materials_of_subcontract_based_on"),
│		)
⋮...
│	def before_validate(self):
│		super().before_validate()
│		self.validate_items_qty()
│		self.set_items_bom()
│		self.set_items_cost_center()
│		self.set_items_expense_account()
⋮...
│	def validate(self):
⋮...
│	def on_submit(self):
⋮...
│	def on_update(self):
│		for table_field in ["items", "supplied_items"]:
│			if self.get(table_field):
│				self.set_serial_and_batch_bundle(table_field)
⋮...
│	def on_cancel(self):
⋮...
│	def reset_raw_materials(self):
│		self.supplied_items = []
│		self.create_raw_materials_supplied()
⋮...
│	def validate_closed_subcontracting_order(self):
│		for item in self.items:
│			if item.subcontracting_order:
│				check_on_hold_or_closed_status("Subcontracting Order", item.subcontracting_order)
⋮...
│	def update_job_card(self):
│		for row in self.get("items"):
│			if row.job_card:
│				doc = frappe.get_doc("Job Card", row.job_card)
│				doc.set_manufactured_qty()
⋮...
│	def get_manufactured_qty(self, job_card):
⋮...
│	def validate_items_qty(self):
⋮...
│	def set_items_bom(self):
⋮...
│	def set_items_cost_center(self):
⋮...
│	def set_items_expense_account(self):
⋮...
│	def reset_supplied_items(self):
⋮...
│	def get_scrap_items(self, recalculate_rate=False):
⋮...
│	def remove_scrap_items(self, recalculate_rate=False):
⋮...
│	def set_missing_values(self):
│		self.set_available_qty_for_consumption()
│		self.calculate_additional_costs()
│		self.calculate_items_qty_and_amount()
⋮...
│	def set_available_qty_for_consumption(self):
⋮...
│	def calculate_items_qty_and_amount(self):
⋮...
│	def validate_scrap_items(self):
⋮...
│	def validate_accepted_warehouse(self):
⋮...
│	def validate_available_qty_for_consumption(self):
⋮...
│	def update_status_updater_args(self):
⋮...
│	def update_status(self, status=None, update_modified=False):
⋮...
│	def get_gl_entries(self, warehouse_account=None):
⋮...
│	def make_item_gl_entries(self, gl_entries, warehouse_account=None):
⋮...
│	def auto_create_purchase_receipt(self):
│		if frappe.db.get_single_value("Buying Settings", "auto_create_purchase_receipt"):
│			make_purchase_receipt(self, save=True, notify=True)
⋮...
│def make_subcontract_return(source_name, target_doc=None):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("Subcontracting Receipt", source_name, target_doc)
⋮...
│def add_po_items_to_pr(scr_doc, target_doc):
⋮...

erpnext\stock\report\delivery_note_trends\delivery_note_trends.py:
│def execute(filters=None):
⋮...
│def get_chart_data(data, filters):
⋮...

erpnext\buying\report\purchase_order_trends\purchase_order_trends.py:
│def execute(filters=None):
⋮...
│def get_chart_data(data, conditions, filters):
⋮...

erpnext\selling\report\sales_order_trends\sales_order_trends.py:
│def execute(filters=None):
⋮...
│def get_chart_data(data, conditions, filters):
⋮...

erpnext\selling\report\quotation_trends\quotation_trends.py:
│def execute(filters=None):
⋮...
│def get_chart_data(data, conditions, filters):
⋮...

erpnext\stock\report\purchase_receipt_trends\purchase_receipt_trends.py:
│def execute(filters=None):
⋮...
│def get_chart_data(data, filters):
⋮...

erpnext\stock\doctype\packing_slip\packing_slip.py:
│def item_details(doctype, txt, searchfield, start, page_len, filters):
⋮...
│class PackingSlip(StatusUpdater):
⋮...
│	def __init__(self, *args, **kwargs) -> None:
⋮...
│	def validate(self) -> None:
⋮...
│	def on_submit(self):
│		self.update_prevdoc_status()
⋮...
│	def on_cancel(self):
│		self.update_prevdoc_status()
⋮...
│	def validate_delivery_note(self):
⋮...
│	def validate_case_nos(self):
⋮...
│	def validate_items(self):
⋮...
│	def set_missing_values(self):
⋮...
│	def get_recommended_case_no(self):
⋮...
│	def calculate_net_total_pkg(self):
⋮...

erpnext\assets\doctype\asset\test_asset.py:
│def create_asset(**args):
⋮...
│def get_gl_entries(doctype, docname):
⋮...
│def create_asset_data():
⋮...
│def set_depreciation_settings_in_company(company=None):
⋮...
│def create_asset_category(enable_cwip=1):
⋮...
│def create_fixed_asset_item(item_code=None, auto_create_assets=1, is_grouped_asset=0):
⋮...
│class AssetSetup(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
⋮...
│	def tearDownClass(cls):
│		frappe.db.rollback()
⋮...
│class TestAsset(AssetSetup):
⋮...
│	def test_asset_category_is_fetched(self):
⋮...
│	def test_gross_purchase_amount_is_mandatory(self):
│		asset = create_asset(item_code="Macbook Pro", do_not_save=1)
│		asset.gross_purchase_amount = 0
│
│		self.assertRaises(frappe.MandatoryError, asset.save)
⋮...
│	def test_pr_or_pi_mandatory_if_not_existing_asset(self):
⋮...
│	def test_available_for_use_date_is_after_purchase_date(self):
⋮...
│	def test_item_exists(self):
│		asset = create_asset(item_code="MacBook", do_not_save=1)
│
│		self.assertRaises(frappe.ValidationError, asset.save)
⋮...
│	def test_validate_item(self):
⋮...
│	def test_purchase_asset(self):
⋮...
│	def test_purchase_of_grouped_asset(self):
⋮...
│	def test_is_fixed_asset_set(self):
⋮...
│	def test_scrap_asset(self):
⋮...
│	def test_gle_made_by_asset_sale(self):
⋮...
│	def test_gle_made_by_asset_sale_for_existing_asset(self):
⋮...
│	def test_asset_with_maintenance_required_status_after_sale(self):
⋮...
│	def test_asset_splitting(self):
⋮...
│	def test_expense_head(self):
│		pr = make_purchase_receipt(item_code="Macbook Pro", qty=2, rate=200000.0, location="Test Location")
│		doc = make_invoice(pr.name)
│
│		self.assertEqual("Asset Received But Not Billed - _TC", doc.items[0].expense_account)
⋮...
│	def test_cwip_accounting(self):
⋮...
│	def test_asset_cwip_toggling_cases(self):
⋮...
│class TestDepreciationMethods(AssetSetup):
⋮...
│	def test_schedule_for_straight_line_method(self):
⋮...
│	def test_schedule_for_straight_line_method_with_daily_prorata_based(
│		self,
│	):
⋮...
│	def test_schedule_for_straight_line_method_for_existing_asset(self):
⋮...
│	def test_schedule_for_double_declining_method(self):
⋮...
│	def test_schedule_for_double_declining_method_for_existing_asset(self):
⋮...
│	def test_schedule_for_prorated_straight_line_method(self):
⋮...
│	def test_depreciation_entry_for_wdv_without_pro_rata(self):
⋮...
│	def test_pro_rata_depreciation_entry_for_wdv(self):
⋮...
│	def test_monthly_depreciation_by_wdv_method(self):
⋮...
│class TestDepreciationBasics(AssetSetup):
⋮...
│	def test_depreciation_without_pro_rata(self):
⋮...
│	def test_depreciation_with_pro_rata(self):
⋮...
│	def test_get_depreciation_amount(self):
⋮...
│	def test_make_depr_schedule(self):
⋮...
│	def test_set_accumulated_depreciation(self):
⋮...
│	def test_check_is_pro_rata(self):
⋮...
│	def test_expected_value_after_useful_life_greater_than_purchase_amount(self):
⋮...
│	def test_depreciation_start_date(self):
⋮...
│	def test_opening_accumulated_depreciation(self):
⋮...
│	def test_opening_booked_depreciations(self):
⋮...
│	def test_number_of_depreciations(self):
⋮...
│	def test_depreciation_start_date_is_before_purchase_date(self):
⋮...
│	def test_depreciation_start_date_is_before_available_for_use_date(self):
⋮...
│	def test_finance_books_are_present_if_calculate_depreciation_is_enabled(self):
│		asset = create_asset(item_code="Macbook Pro", do_not_save=1)
│		asset.calculate_depreciation = 1
│
│		self.assertRaises(frappe.ValidationError, asset.save)
⋮...
│	def test_post_depreciation_entries(self):
⋮...
│	def test_depr_entry_posting_when_depr_expense_account_is_an_expense_account(self):
⋮...
│	def test_depr_entry_posting_when_depr_expense_account_is_an_income_account(self):
⋮...
│	def test_clear_depr_schedule(self):
⋮...
│	def test_clear_depr_schedule_for_multiple_finance_books(self):
⋮...
│	def test_depreciation_schedules_are_set_up_for_multiple_finance_books(self):
⋮...
│	def test_depreciation_entry_cancellation(self):
⋮...
│	def test_asset_expected_value_after_useful_life(self):
⋮...
│	def test_gle_made_by_depreciation_entries(self):
⋮...
│	def test_expected_value_change(self):
⋮...
│	def test_asset_cost_center(self):
⋮...
│	def test_depreciation_on_final_day_of_the_month(self):
⋮...
│	def test_manual_depreciation_for_existing_asset(self):
⋮...
│	def test_manual_depreciation_for_depreciable_asset(self):
⋮...
│	def test_manual_depreciation_with_incorrect_jv_voucher_type(self):
⋮...
│	def test_multi_currency_asset_pr_creation(self):
⋮...
│def enable_cwip_accounting(asset_category, enable=1):
│	frappe.db.set_value("Asset Category", asset_category, "enable_cwip_accounting", enable)
⋮...

erpnext\stock\report\stock_balance\stock_balance.py:
│def execute(filters: StockBalanceFilter | None = None):
│	return StockBalanceReport(filters).run()
⋮...
│class StockBalanceFilter(TypedDict):
⋮...
│def filter_items_with_no_transactions(
│	iwb_map, float_precision: float, inventory_dimensions: list | None = None
⋮...
│class StockBalanceReport:
⋮...
│	def __init__(self, filters: StockBalanceFilter | None) -> None:
⋮...
│	def set_company_currency(self) -> None:
│		if self.filters.get("company"):
│			self.company_currency = erpnext.get_company_currency(self.filters.get("company"))
│		else:
│			self.company_currency = frappe.db.get_single_value("Global Defaults", "default_currency")
⋮...
│	def run(self):
⋮...
│	def prepare_opening_stock(self) -> None:
⋮...
│	def get_entries_from_stock_closing_balance(self) -> list:
⋮...
│	def filter_fields(self) -> list[str]:
⋮...
│	def prepare_sle_query(self):
⋮...
│	def prepare_item_warehouse_map_for_current_period(self):
⋮...
│	def prepare_new_data(self):
⋮...
│	def get_sre_reserved_qty_details(self) -> dict:
⋮...
│	def prepare_item_warehouse_map(self, entry, group_by_key):
⋮...
│	def initialize_data(self, group_by_key, entry):
⋮...
│	def get_group_by_key(self, row) -> tuple:
⋮...
│	def apply_inventory_dimensions_filters(self, query, sle) -> str:
⋮...
│	def apply_warehouse_filters(self, query, sle) -> str:
⋮...
│	def apply_items_filters(self, query, item_table) -> str:
⋮...
│	def apply_date_filters(self, query, sle) -> str:
⋮...
│	def get_columns(self):
⋮...
│	def add_additional_uom_columns(self):
│		if not self.filters.get("include_uom"):
│			return
│
│		conversion_factors = self.get_itemwise_conversion_factor()
│		add_additional_uom_columns(self.columns, self.data, self.filters.include_uom, conversion_factors)
⋮...
│	def get_itemwise_conversion_factor(self):
⋮...
│	def get_variant_values_for(self):
⋮...
│	def get_opening_vouchers(self):
⋮...
│	def get_inventory_dimension_fields():
│		return [dimension.fieldname for dimension in get_inventory_dimensions()]
⋮...
│	def get_opening_fifo_queue(report_data):
│		opening_fifo_queue = report_data.get("opening_fifo_queue") or []
│		for row in opening_fifo_queue:
│			row[1] = getdate(row[1])
│
│		return opening_fifo_queue
⋮...
│def get_variants_attributes() -> list[str]:
│	"""Return all item variant attributes."""
│	return frappe.get_all("Item Attribute", pluck="name")
⋮...

erpnext\accounts\report\customer_ledger_summary\customer_ledger_summary.py:
│def execute(filters=None):
⋮...
│def get_children(doctype, value):
│	children = get_descendants_of(doctype, value)
│
│	return [value, *children]
⋮...
│class PartyLedgerSummaryReport:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
│		self.filters.from_date = getdate(self.filters.from_date or nowdate())
│		self.filters.to_date = getdate(self.filters.to_date or nowdate())
⋮...
│	def run(self, args):
⋮...
│	def validate_filters(self):
⋮...
│	def update_hierarchical_filters(self):
│		for doctype in TREE_DOCTYPES:
│			key = scrub(doctype)
│			if self.filters.get(key):
│				self.filters[key] = get_children(doctype, self.filters[key])
⋮...
│	def get_party_details(self):
⋮...
│	def get_party_conditions(self, doctype):
⋮...
│	def get_columns(self):
⋮...
│	def get_data(self):
⋮...
│	def get_gl_entries(self):
⋮...
│	def prepare_conditions(self, query):
⋮...
│	def get_return_invoices(self):
⋮...
│	def get_party_adjustment_amounts(self):
⋮...

erpnext\accounts\report\deferred_revenue_and_expense\deferred_revenue_and_expense.py:
│def execute(filters=None):
⋮...
│class Deferred_Revenue_and_Expense_Report:
⋮...
│class Deferred_Item:
⋮...
│	def __init__(self, item, inv, gle_entries):
⋮...
│	def report_data(self):
⋮...
│	def get_amount(self, entry):
⋮...
│	def get_item_total(self):
⋮...
│	def calculate_amount(self, start_date, end_date):
⋮...
│	def make_dummy_gle(self, name, date, amount):
⋮...
│	def simulate_future_posting(self):
⋮...
│	def calculate_item_revenue_expense_for_period(self):
⋮...
│class Deferred_Invoice:
⋮...
│	def __init__(self, invoice, items, filters, period_list):
⋮...
│	def calculate_invoice_revenue_expense_for_period(self):
⋮...
│	def estimate_future(self):
│		"""
│		create dummy GL entries for upcoming months for all items in invoice
│		"""
│		[item.simulate_future_posting() for item in self.items]
⋮...
│	def report_data(self):
⋮...
│	def __init__(self, filters=None):
⋮...
│	def get_period_list(self):
⋮...
│	def get_invoices(self):
⋮...
│	def estimate_future(self):
│		"""
│		For all Invoices estimate upcoming postings
│		"""
│		for x in self.deferred_invoices:
│			x.estimate_future()
⋮...
│	def calculate_revenue_and_expense(self):
⋮...
│	def get_columns(self):
⋮...
│	def generate_report_data(self):
⋮...
│	def prepare_chart(self):
⋮...
│	def run(self, *args, **kwargs):
⋮...

erpnext\selling\report\sales_analytics\sales_analytics.py:
│def execute(filters=None):
⋮...
│class Analytics:
⋮...
│def append_report(dt, org, new):
⋮...
│	def __init__(self, filters=None):
⋮...
│	def update_company_list_for_parent_company(self):
⋮...
│	def run(self):
⋮...
│	def get_columns(self):
⋮...
│	def get_data(self):
⋮...
│	def get_sales_transactions_based_on_order_type(self):
⋮...
│	def get_sales_transactions_based_on_customers_or_suppliers(self):
⋮...
│	def get_sales_transactions_based_on_items(self):
⋮...
│	def get_sales_transactions_based_on_customer_or_territory_group(self):
⋮...
│	def get_sales_transactions_based_on_item_group(self):
⋮...
│	def get_sales_transactions_based_on_project(self):
⋮...
│	def get_rows(self):
⋮...
│	def get_rows_by_group(self):
⋮...
│	def get_periodic_data(self):
⋮...
│	def get_period(self, posting_date):
⋮...
│	def get_period_date_ranges(self):
⋮...
│	def get_groups(self):
⋮...
│	def get_teams(self):
⋮...
│	def get_supplier_parent_child_map(self):
│		self.parent_child_map = frappe._dict(
│			frappe.db.sql(""" select name, supplier_group from `tabSupplier`""")
│		)
⋮...
│	def get_chart_data(self):
⋮...

erpnext\buying\doctype\supplier_quotation\supplier_quotation.py:
│def make_purchase_invoice(source_name, target_doc=None):
⋮...
│def get_list_context(context=None):
⋮...
│def make_quotation(source_name, target_doc=None):
⋮...
│def make_purchase_order(source_name, target_doc=None):
⋮...
│class SupplierQuotation(BuyingController):
⋮...
│	def validate(self):
⋮...
│	def on_submit(self):
│		self.db_set("status", "Submitted")
│		self.update_rfq_supplier_status(1)
⋮...
│	def on_cancel(self):
│		self.db_set("status", "Cancelled")
│		self.update_rfq_supplier_status(0)
⋮...
│	def on_trash(self):
│		pass
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def validate_valid_till(self):
│		if self.valid_till and getdate(self.valid_till) < getdate(self.transaction_date):
│			frappe.throw(_("Valid till Date cannot be before Transaction Date"))
⋮...
│	def update_rfq_supplier_status(self, include_me):
⋮...
│def set_expired_status():
⋮...

erpnext\crm\report\sales_pipeline_analytics\sales_pipeline_analytics.py:
│def execute(filters=None):
│	return SalesPipelineAnalytics(filters).run()
⋮...
│class SalesPipelineAnalytics:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
⋮...
│	def validate_filters(self):
│		if not self.filters.from_date:
│			frappe.throw(_("From Date is mandatory"))
│
│		if not self.filters.to_date:
│			frappe.throw(_("To Date is mandatory"))
⋮...
│	def run(self):
⋮...
│	def get_columns(self):
│		self.columns = []
│
│		self.set_range_columns()
│		self.set_pipeline_based_on_column()
⋮...
│	def set_range_columns(self):
⋮...
│	def set_pipeline_based_on_column(self):
⋮...
│	def get_fields(self):
⋮...
│	def get_data(self):
⋮...
│	def get_conditions(self):
⋮...
│	def get_chart_data(self):
⋮...
│	def get_periodic_data(self):
⋮...
│	def set_formatted_data(self, period, value, count_or_amount, assigned_to):
⋮...
│	def check_for_assigned_to(self, period, value, count_or_amount, assigned_to, info):
⋮...
│	def get_month_list(self):
⋮...
│	def append_to_dataset(self, datasets):
⋮...
│	def append_data(self, pipeline_by, period_by):
⋮...
│	def get_default_currency(self):
│		company = self.filters.get("company")
│		return frappe.db.get_value("Company", company, ["default_currency"])
⋮...
│	def get_currency_rate(self, from_currency, to_currency):
⋮...
│	def convert_to_base_currency(self):
⋮...

erpnext\stock\doctype\stock_entry\stock_entry.py:
│def make_stock_in_entry(source_name, target_doc=None):
⋮...
│def get_supplied_items(
│	subcontract_order, rm_detail_field="sco_rm_detail", subcontract_order_field="subcontracting_order"
│):
⋮...
│class FinishedGoodError(frappe.ValidationError):
│	pass
⋮...
│class StockEntry(StockController):
⋮...
│def get_warehouse_details(args):
⋮...
│def create_serial_and_batch_bundle(parent_doc, row, child, type_of_transaction=None):
⋮...
│def get_available_materials(work_order) -> dict:
⋮...
│class IncorrectValuationRateError(frappe.ValidationError):
│	pass
⋮...
│class DuplicateEntryForWorkOrderError(frappe.ValidationError):
│	pass
⋮...
│class OperationsNotCompleteError(frappe.ValidationError):
│	pass
⋮...
│class MaxSampleAlreadyRetainedError(frappe.ValidationError):
│	pass
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def onload(self):
│		for item in self.get("items"):
│			item.update(get_bin_details(item.item_code, item.s_warehouse))
⋮...
│	def before_validate(self):
⋮...
│	def validate(self):
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def on_update(self):
│		self.set_serial_and_batch_bundle()
⋮...
│	def set_job_card_data(self):
⋮...
│	def validate_job_card_fg_item(self):
⋮...
│	def validate_job_card_item(self):
⋮...
│	def validate_work_order_status(self):
│		pro_doc = frappe.get_doc("Work Order", self.work_order)
│		if pro_doc.status == "Completed":
│			frappe.throw(_("Cannot cancel transaction for Completed Work Order."))
⋮...
│	def validate_purpose(self):
⋮...
│	def delete_linked_stock_entry(self):
⋮...
│	def set_transfer_qty(self):
⋮...
│	def update_cost_in_project(self):
⋮...
│	def validate_item(self):
⋮...
│	def validate_fg_completed_qty(self):
⋮...
│	def validate_difference_account(self):
⋮...
│	def validate_warehouse(self):
⋮...
│	def validate_work_order(self):
⋮...
│	def check_if_operations_completed(self):
⋮...
│	def check_duplicate_entry_for_work_order(self):
⋮...
│	def set_actual_qty(self):
⋮...
│	def validate_component_and_quantities(self):
⋮...
│	def get_matched_items(self, item_code):
│		for row in self.items:
│			if row.item_code == item_code or row.original_item == item_code:
│				return row
│
│		return {}
⋮...
│	def get_stock_and_rate(self):
⋮...
│	def calculate_rate_and_amount(self, reset_outgoing_rate=True, raise_error_if_no_rate=True):
⋮...
│	def set_basic_rate(self, reset_outgoing_rate=True, raise_error_if_no_rate=True):
⋮...
│	def set_rate_for_outgoing_items(self, reset_outgoing_rate=True, raise_error_if_no_rate=True):
⋮...
│	def get_args_for_incoming_rate(self, item):
⋮...
│	def get_basic_rate_for_repacked_items(self, finished_item_qty, outgoing_items_cost):
⋮...
│	def get_basic_rate_for_manufactured_item(self, finished_item_qty, outgoing_items_cost=0) -> float:
⋮...
│	def distribute_additional_costs(self):
⋮...
│	def update_valuation_rate(self):
│		for d in self.get("items"):
│			if d.transfer_qty:
│				d.amount = flt(flt(d.basic_amount) + flt(d.additional_cost), d.precision("amount"))
│				# Do not round off valuation rate to avoid precision loss
│				d.valuation_rate = flt(d.basic_rate) + (flt(d.additional_cost) / flt(d.transfer_qty))
⋮...
│	def set_total_incoming_outgoing_value(self):
⋮...
│	def set_total_amount(self):
│		self.total_amount = None
│		if self.purpose not in ["Manufacture", "Repack"]:
│			self.total_amount = sum([flt(item.amount) for item in self.get("items")])
⋮...
│	def set_stock_entry_type(self):
│		if self.purpose:
│			self.stock_entry_type = frappe.get_cached_value(
│				"Stock Entry Type", {"purpose": self.purpose, "is_standard": 1}, "name"
│			)
⋮...
│	def set_purpose_for_stock_entry(self):
│		if self.stock_entry_type and not self.purpose:
│			self.purpose = frappe.get_cached_value("Stock Entry Type", self.stock_entry_type, "purpose")
⋮...
│	def make_serial_and_batch_bundle_for_outward(self):
⋮...
│	def validate_subcontract_order(self):
⋮...
│	def validate_bom(self):
│		for d in self.get("items"):
│			if d.bom_no and d.is_finished_item:
│				item_code = d.original_item or d.item_code
│				validate_bom_no(item_code, d.bom_no)
⋮...
│	def validate_purchase_order(self):
⋮...
│	def validate_closed_subcontracting_order(self):
│		if self.get("subcontracting_order"):
│			check_on_hold_or_closed_status("Subcontracting Order", self.subcontracting_order)
⋮...
│	def mark_finished_and_scrap_items(self):
⋮...
│	def get_finished_item(self):
⋮...
│	def validate_finished_goods(self):
⋮...
│	def update_stock_ledger(self, allow_negative_stock=False):
⋮...
│	def get_finished_item_row(self):
⋮...
│	def validate_serial_batch_bundle_type(self, serial_and_batch_bundle):
⋮...
│	def get_sle_for_source_warehouse(self, sl_entries, finished_item_row):
⋮...
│	def make_serial_and_batch_bundle_for_transfer(self):
⋮...
│	def get_sle_for_target_warehouse(self, sl_entries, finished_item_row):
⋮...
│	def get_gl_entries(self, warehouse_account):
⋮...
│	def update_work_order(self):
⋮...
│	def make_stock_reserve_for_wip_and_fg(self):
⋮...
│	def cancel_stock_reserve_for_wip_and_fg(self):
⋮...
│	def is_stock_reserve_for_work_order(self):
⋮...
│	def get_item_details(self, args: ItemDetailsCtx = None, for_update=False):
⋮...
│	def set_items_for_stock_in(self):
⋮...
│	def get_items_for_disassembly(self):
⋮...
│	def get_items_from_manufacture_entry(self):
⋮...
│	def get_items(self):
⋮...
│	def set_serial_batch_from_reserved_entry(self):
⋮...
│	def get_available_reserved_materials(self):
⋮...
│	def get_reserved_materials(self):
⋮...
│	def set_scrap_items(self):
⋮...
│	def set_process_loss_qty(self):
⋮...
│	def set_work_order_details(self):
⋮...
│	def load_items_from_bom(self):
⋮...
│	def set_batchwise_finished_goods(self, args, item):
⋮...
│	def add_batchwise_finished_good(self, batches, args, item):
⋮...
│	def add_finished_goods(self, args, item):
│		self.add_to_stock_entry_detail({item.name: args}, bom_no=self.bom_no)
⋮...
│	def get_bom_raw_materials(self, qty):
⋮...
│	def get_bom_scrap_material(self, qty):
⋮...
│	def get_scrap_items_from_job_card(self):
⋮...
│	def get_completed_job_card_qty(self):
│		return flt(min([d.completed_qty for d in self.pro_doc.operations]))
⋮...
│	def get_used_scrap_items(self):
⋮...
│	def get_unconsumed_raw_materials(self):
⋮...
│	def add_transfered_raw_materials_in_items(self) -> None:
⋮...
│	def update_batches_to_be_consume(self, batches, row, qty):
⋮...
│	def update_item_in_stock_entry_detail(self, row, item, qty) -> None:
⋮...
│	def get_serial_nos_based_on_transferred_batch(batch_no, serial_nos) -> list:
⋮...
│	def get_pending_raw_materials(self, backflush_based_on=None):
⋮...
│	def get_pro_order_required_items(self, backflush_based_on=None):
⋮...
│	def get_job_card_item_codes(self, job_card=None):
⋮...
│	def add_to_stock_entry_detail(self, item_dict, bom_no=None):
⋮...
│	def validate_with_material_request(self):
⋮...
│	def validate_batch(self):
⋮...
│	def update_subcontract_order_supplied_items(self):
⋮...
│	def update_transferred_qty(self):
⋮...
│	def update_quality_inspection(self):
⋮...
│	def set_material_request_transfer_status(self, status):
⋮...
│	def set_serial_no_batch_for_finished_good(self):
⋮...
│	def get_available_serial_nos(self) -> list[str]:
⋮...
│	def update_subcontracting_order_status(self):
⋮...
│	def update_pick_list_status(self):
│		from erpnext.stock.doctype.pick_list.pick_list import update_pick_list_status
│
│		update_pick_list_status(self.pick_list)
⋮...
│	def set_missing_values(self):
│		"Updates rate and availability of all the items of mapped doc."
│		self.set_transfer_qty()
│		self.set_actual_qty()
│		self.calculate_rate_and_amount()
⋮...
│def move_sample_to_retention_warehouse(company, items):
⋮...
│def get_work_order_details(work_order, company):
⋮...
│def get_operating_cost_per_unit(work_order=None, bom_no=None):
⋮...
│def get_used_alternative_items(
│	subcontract_order=None, subcontract_order_field="subcontracting_order", work_order=None
│):
⋮...
│def get_valuation_rate_for_finished_good_entry(work_order):
⋮...
│def get_uom_details(item_code, uom, qty):
⋮...
│def get_expired_batch_items():
⋮...
│def get_expired_batches():
⋮...
│def validate_sample_quantity(item_code, sample_quantity, qty, batch_no=None):
⋮...
│def get_items_from_subcontract_order(source_name, target_doc=None):
⋮...
│def get_stock_entry_data(work_order):
⋮...
│def get_batchwise_serial_nos(item_code, row):
⋮...

erpnext\accounts\report\delivered_items_to_be_billed\delivered_items_to_be_billed.py:
│def execute(filters=None):
│	columns = get_column()
│	args = get_args()
│	data = get_ordered_to_be_billed_data(args, filters)
│	return columns, data
⋮...
│def get_column():
⋮...
│def get_args():
⋮...

erpnext\accounts\report\received_items_to_be_billed\received_items_to_be_billed.py:
│def execute(filters=None):
│	columns = get_column()
│	args = get_args()
│	data = get_ordered_to_be_billed_data(args, filters)
│	return columns, data
⋮...
│def get_column():
⋮...
│def get_args():
⋮...

erpnext\stock\doctype\item\item.py:
│def get_item_details(item_code, company=None):
⋮...
│def get_item_defaults(item_code, company):
⋮...
│def get_timeline_data(doctype: str, name: str) -> dict[int, int]:
⋮...
│def make_item_price(item, price_list_name, item_price):
⋮...
│class Item(Document):
⋮...
│def get_child_warehouses(warehouse):
│	from erpnext.stock.doctype.warehouse.warehouse import get_child_warehouses
│
│	return get_child_warehouses(warehouse)
⋮...
│def get_uom_conv_factor(uom, stock_uom):
⋮...
│def validate_end_of_life(item_code, end_of_life=None, disabled=None):
⋮...
│def get_last_purchase_details(item_code, doc_name=None, conversion_rate=1.0):
⋮...
│class DataValidationError(frappe.ValidationError):
│	pass
⋮...
│def validate_is_stock_item(item_code, is_stock_item=None):
│	if not is_stock_item:
│		is_stock_item = frappe.db.get_value("Item", item_code, "is_stock_item")
│
│	if is_stock_item != 1:
│		frappe.throw(_("Item {0} is not a stock Item").format(item_code))
⋮...
│def get_purchase_voucher_details(doctype, item_code, document_name=None):
⋮...
│class StockExistsForTemplate(frappe.ValidationError):
│	pass
⋮...
│class InvalidBarcode(frappe.ValidationError):
│	pass
⋮...
│def check_stock_uom_with_bin(item, stock_uom):
⋮...
│def get_item_attribute(parent, attribute_value=""):
⋮...
│def validate_item_default_company_links(item_defaults: list[ItemDefault]) -> None:
⋮...
│def get_asset_naming_series():
│	from erpnext.assets.doctype.asset.asset import get_asset_naming_series
│
│	return get_asset_naming_series()
⋮...
│class DuplicateReorderRows(frappe.ValidationError):
│	pass
⋮...
│	def onload(self):
│		self.set_onload("stock_exists", self.stock_ledger_created())
│		self.set_onload("asset_naming_series", get_asset_naming_series())
⋮...
│	def autoname(self):
⋮...
│	def after_insert(self):
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		self.update_variants()
│		self.update_item_price()
⋮...
│	def validate_description(self):
│		"""Clean HTML description if set"""
│		if cint(frappe.db.get_single_value("Stock Settings", "clean_description_html")):
│			self.description = clean_html(self.description)
⋮...
│	def validate_customer_provided_part(self):
⋮...
│	def add_price(self, price_list=None):
⋮...
│	def set_opening_stock(self):
⋮...
│	def validate_fixed_asset(self):
⋮...
│	def validate_retain_sample(self):
⋮...
│	def clear_retain_sample(self):
│		if not self.has_batch_no:
│			self.retain_sample = False
│
│		if not self.retain_sample:
│			self.sample_quantity = 0
⋮...
│	def add_default_uom_in_conversion_factor_table(self):
⋮...
│	def validate_item_tax_net_rate_range(self):
⋮...
│	def update_template_tables(self):
⋮...
│	def validate_conversion_factor(self):
⋮...
│	def validate_item_type(self):
│		if self.has_serial_no == 1 and self.is_stock_item == 0 and not self.is_fixed_asset:
│			frappe.throw(_("'Has Serial No' can not be 'Yes' for non-stock item"))
│
│		if self.has_serial_no == 0 and self.serial_no_series:
│			self.serial_no_series = None
⋮...
│	def validate_naming_series(self):
⋮...
│	def check_for_active_boms(self):
⋮...
│	def fill_customer_code(self):
⋮...
│	def check_item_tax(self):
⋮...
│	def validate_barcode(self):
⋮...
│	def validate_warehouse_for_reorder(self):
⋮...
│	def stock_ledger_created(self):
⋮...
│	def update_item_price(self):
⋮...
│	def on_trash(self):
│		frappe.db.sql("""delete from tabBin where item_code=%s""", self.name)
│		frappe.db.sql("delete from `tabItem Price` where item_code=%s", self.name)
│		for variant_of in frappe.get_all("Item", filters={"variant_of": self.name}):
│			frappe.delete_doc("Item", variant_of.name)
⋮...
│	def before_rename(self, old_name, new_name, merge=False):
⋮...
│	def after_rename(self, old_name, new_name, merge):
⋮...
│	def delete_old_bins(self, old_name):
│		frappe.db.delete("Bin", {"item_code": old_name})
⋮...
│	def validate_duplicate_item_in_stock_reconciliation(self, old_name, new_name):
⋮...
│	def validate_properties_before_merge(self, new_name):
⋮...
│	def validate_duplicate_product_bundles_before_merge(self, old_name, new_name):
⋮...
│	def set_last_purchase_rate(self, new_name):
│		last_purchase_rate = get_last_purchase_details(new_name).get("base_net_rate", 0)
│		frappe.db.set_value("Item", new_name, "last_purchase_rate", last_purchase_rate)
⋮...
│	def recalculate_bin_qty(self, new_name):
⋮...
│	def update_bom_item_desc(self):
⋮...
│	def validate_item_defaults(self):
⋮...
│	def update_defaults_from_item_group(self):
⋮...
│	def update_variants(self):
⋮...
│	def validate_has_variants(self):
│		if not self.has_variants and frappe.db.get_value("Item", self.name, "has_variants"):
│			if frappe.db.exists("Item", {"variant_of": self.name}):
│				frappe.throw(_("Item has variants."))
⋮...
│	def validate_attributes_in_variants(self):
⋮...
│	def validate_stock_exists_for_template_item(self):
⋮...
│	def validate_variant_based_on_change(self):
│		if not self.is_new() and (
│			self.variant_of or (self.has_variants and frappe.get_all("Item", {"variant_of": self.name}))
│		):
│			if self.variant_based_on != frappe.db.get_value("Item", self.name, "variant_based_on"):
│				frappe.throw(_("Variant Based On cannot be changed"))
⋮...
│	def validate_uom(self):
⋮...
│	def validate_uom_conversion_factor(self):
│		if self.uoms:
│			for d in self.uoms:
│				value = get_uom_conv_factor(d.uom, self.stock_uom)
│				if value:
│					d.conversion_factor = value
⋮...
│	def validate_attributes(self):
⋮...
│	def validate_variant_attributes(self):
⋮...
│	def cant_change(self):
⋮...
│	def _get_linked_submitted_documents(self, changed_fields: list[str]) -> dict[str, str] | None:
⋮...
│	def validate_auto_reorder_enabled_in_stock_settings(self):
⋮...
│def convert_erpnext_to_barcodenumber(erpnext_number, barcode):
⋮...
│def validate_cancelled_item(item_code, docstatus=None):
│	if docstatus is None:
│		docstatus = frappe.db.get_value("Item", item_code, "docstatus")
│
│	if docstatus == 2:
│		frappe.throw(_("Item {0} is cancelled").format(item_code))
⋮...
│def set_item_default(item_code, company, fieldname, value):
⋮...
│def update_variants(variants, template, publish_progress=True):
⋮...

erpnext\crm\report\opportunity_summary_by_sales_stage\opportunity_summary_by_sales_stage.py:
│def execute(filters=None):
│	return OpportunitySummaryBySalesStage(filters).run()
⋮...
│class OpportunitySummaryBySalesStage:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
⋮...
│	def run(self):
│		self.get_columns()
│		self.get_data()
│		self.get_chart_data()
│		return self.columns, self.data, None, self.chart
⋮...
│	def get_columns(self):
⋮...
│	def set_sales_stage_columns(self):
⋮...
│	def get_data(self):
⋮...
│	def get_data_query(self, based_on, data_based_on):
⋮...
│	def get_rows(self):
⋮...
│	def get_formatted_data(self):
⋮...
│	def set_formatted_data_based_on_sales_stage(self, based_on, sales_stage, count):
│		self.formatted_data.setdefault(based_on, frappe._dict()).setdefault(sales_stage, 0)
│		self.formatted_data[based_on][sales_stage] += count
⋮...
│	def get_conditions(self):
⋮...
│	def get_chart_data(self):
⋮...
│	def get_exchange_rate(self, from_currency, to_currency):
⋮...
│	def get_default_currency(self):
│		company = self.filters.get("company")
│		return frappe.db.get_value("Company", company, "default_currency")
⋮...
│	def convert_to_base_currency(self):
⋮...

erpnext\manufacturing\report\production_planning_report\production_planning_report.py:
│def execute(filters=None):
│	return ProductionPlanReport(filters).execute_report()
⋮...
│class ProductionPlanReport:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
│		self.raw_materials_dict = {}
│		self.data = []
⋮...
│	def execute_report(self):
⋮...
│	def get_open_orders(self):
⋮...
│	def get_raw_materials(self):
⋮...
│	def get_item_details(self):
⋮...
│	def get_bin_details(self):
⋮...
│	def get_purchase_details(self):
⋮...
│	def prepare_data(self):
⋮...
│	def update_raw_materials(self, data, key):
⋮...
│	def pick_materials_from_warehouses(self, args, order_data, warehouses):
⋮...
│	def get_args(self):
⋮...
│	def get_columns(self):
⋮...

erpnext\regional\report\vat_audit_report\vat_audit_report.py:
│def execute(filters=None):
│	return VATAuditReport(filters).run()
⋮...
│class VATAuditReport:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
│		self.columns = []
│		self.data = []
│		self.doctypes = ["Purchase Invoice", "Sales Invoice"]
⋮...
│	def run(self):
⋮...
│	def get_sa_vat_accounts(self):
⋮...
│	def get_invoice_data(self, doctype):
⋮...
│	def get_invoice_items(self, doctype):
⋮...
│	def get_items_based_on_tax_rate(self, doctype):
⋮...
│	def get_item_amount_map(self, parent, item_code, tax_data):
⋮...
│	def get_conditions(self):
⋮...
│	def get_data(self, doctype):
⋮...
│	def get_consolidated_data(self, doctype):
⋮...
│	def get_columns(self):
⋮...

erpnext\support\report\issue_analytics\issue_analytics.py:
│def execute(filters=None):
│	return IssueAnalytics(filters).run()
⋮...
│class IssueAnalytics:
⋮...
│	def __init__(self, filters=None):
│		"""Issue Analytics Report"""
│		self.filters = frappe._dict(filters or {})
│		self.get_period_date_ranges()
⋮...
│	def run(self):
│		self.get_columns()
│		self.get_data()
│		self.get_chart_data()
│
│		return self.columns, self.data, None, self.chart
⋮...
│	def get_columns(self):
⋮...
│	def get_data(self):
│		self.get_issues()
│		self.get_rows()
⋮...
│	def get_period(self, date):
⋮...
│	def get_period_date_ranges(self):
⋮...
│	def get_issues(self):
⋮...
│	def get_common_filters(self):
⋮...
│	def get_rows(self):
⋮...
│	def get_periodic_data(self):
⋮...
│	def get_chart_data(self):
│		length = len(self.columns)
│		labels = [d.get("label") for d in self.columns[1 : length - 1]]
│		self.chart = {"data": {"labels": labels, "datasets": []}, "type": "line"}
⋮...

erpnext\manufacturing\report\exponential_smoothing_forecasting\exponential_smoothing_forecasting.py:
│def execute(filters=None):
│	return ForecastingReport(filters).execute_report()
⋮...
│class ExponentialSmoothingForecast:
⋮...
│	def forecast_future_data(self):
⋮...
│class ForecastingReport(ExponentialSmoothingForecast):
⋮...
│	def __init__(self, filters=None):
⋮...
│	def execute_report(self):
⋮...
│	def prepare_periodical_data(self):
⋮...
│	def get_data_for_forecast(self):
⋮...
│	def prepare_final_data(self):
⋮...
│	def add_total(self):
⋮...
│	def get_columns(self):
⋮...
│	def get_chart_data(self):
⋮...
│	def get_summary_data(self):
⋮...

erpnext\support\report\issue_summary\issue_summary.py:
│def execute(filters=None):
│	return IssueSummary(filters).run()
⋮...
│class IssueSummary:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
⋮...
│	def run(self):
⋮...
│	def get_columns(self):
⋮...
│	def get_data(self):
│		self.get_issues()
│		self.get_rows()
⋮...
│	def get_issues(self):
⋮...
│	def get_common_filters(self):
⋮...
│	def get_rows(self):
⋮...
│	def get_summary_data(self):
⋮...
│	def get_metrics_data(self):
⋮...
│	def get_chart_data(self):
⋮...
│	def get_report_summary(self):
⋮...

erpnext\accounts\report\general_and_payment_ledger_comparison\general_and_payment_ledger_comparison.py:
│def execute(filters=None):
⋮...
│class General_Payment_Ledger_Comparison:
⋮...
│	def __init__(self, filters=None):
│		self.filters = filters
│		self.gle = []
│		self.ple = []
⋮...
│	def get_accounts(self):
⋮...
│	def generate_filters(self):
⋮...
│	def get_gle(self):
⋮...
│	def get_ple(self):
⋮...
│	def compare(self):
⋮...
│	def generate_data(self):
⋮...
│	def get_columns(self):
⋮...
│	def run(self):
⋮...

erpnext\accounts\report\gross_and_net_profit_report\gross_and_net_profit_report.py:
│def execute(filters=None):
⋮...
│def get_revenue(data, period_list, include_in_gross=1):
⋮...
│def set_total(node, value, complete_list, totals):
⋮...
│def remove_parent_with_no_child(data):
⋮...
│def adjust_account_totals(data, period_list):
⋮...
│def get_profit(
│	gross_income, gross_expense, period_list, company, profit_type, currency=None, consolidated=False
│):
⋮...
│def get_net_profit(
│	non_gross_income,
│	gross_income,
│	gross_expense,
│	non_gross_expense,
│	period_list,
│	company,
│	currency=None,
│	consolidated=False,
│):
⋮...

erpnext\accounts\report\accounts_receivable_summary\accounts_receivable_summary.py:
│def execute(filters=None):
⋮...
│class AccountsReceivableSummary(ReceivablePayableReport):
⋮...
│	def run(self, args):
⋮...
│	def get_data(self, args):
⋮...
│	def get_party_total(self, args):
⋮...
│	def init_party_total(self, row):
⋮...
│	def set_party_details(self, row):
⋮...
│	def get_columns(self):
⋮...
│def get_gl_balance(report_date, company):
⋮...

erpnext\tests\test_webform.py:
│def get_data():
│	webform_list_contexts = frappe.get_hooks("webform_list_context")
│	if webform_list_contexts:
│		context = frappe._dict(frappe.get_attr(webform_list_contexts[0])("Buying") or {})
│	kwargs = dict(doctype="Order Assignment", order_by="creation desc")
│	return context.get_list(**kwargs)
⋮...
│def create_user(name, email):
⋮...
│def create_custom_doctype():
⋮...
│def create_order_assignment(supplier, po):
⋮...
│class TestWebsite(IntegrationTestCase):
⋮...
│	def test_permission_for_custom_doctype(self):
⋮...
│def create_webform():
⋮...

erpnext\stock\dashboard\warehouse_capacity_dashboard.py:
│def get_data(
│	item_code=None,
│	warehouse=None,
│	parent_warehouse=None,
│	company=None,
│	start=0,
│	sort_by="stock_capacity",
│	sort_order="desc",
│):
⋮...
│def get_filters(item_code=None, warehouse=None, parent_warehouse=None, company=None):
⋮...
│def get_warehouse_filter_based_on_permissions(filters):
⋮...
│def get_warehouse_capacity_data(filters, start):
⋮...

erpnext\patches\v13_0\rename_issue_doctype_fields.py:
│def execute():
⋮...
│def convert_to_seconds(value, unit):
⋮...

erpnext\accounts\report\payment_ledger\payment_ledger.py:
│def execute(filters=None):
│	return PaymentLedger(filters).run()
⋮...
│class PaymentLedger:
⋮...
│	def __init__(self, filters=None):
│		self.filters = filters
│		self.columns, self.data = [], []
│		self.voucher_dict = OrderedDict()
│		self.voucher_amount = []
│		self.ple = qb.DocType("Payment Ledger Entry")
⋮...
│	def init_voucher_dict(self):
⋮...
│	def build_data(self):
⋮...
│	def build_conditions(self):
⋮...
│	def get_data(self):
⋮...
│	def get_columns(self):
⋮...
│	def run(self):
⋮...

erpnext\patches\v13_0\update_sla_enhancements.py:
│def execute():
⋮...
│def convert_to_seconds(value, unit):
⋮...

erpnext\stock\report\delayed_item_report\delayed_item_report.py:
│def execute(filters=None, consolidated=False):
│	data, columns = DelayedItemReport(filters).run()
│
│	return data, columns
⋮...
│class DelayedItemReport:
⋮...
│	def __init__(self, filters=None):
│		self.filters = frappe._dict(filters or {})
⋮...
│	def run(self):
│		return self.get_columns(), self.get_data() or []
⋮...
│	def get_data(self, consolidated=False):
⋮...
│	def filter_transactions_data(self, consolidated=False):
⋮...
│	def get_columns(self):
⋮...

erpnext\patches\v11_0\refactor_naming_series.py:
│def execute():
⋮...
│def set_series(doctype, options, default):
⋮...
│def get_series():
⋮...
│def get_series_to_preserve(doctype):
│	series_to_preserve = frappe.db.sql_list(
│		f"""select distinct naming_series from `tab{doctype}` where ifnull(naming_series, '') != ''"""
│	)
│	series_to_preserve.sort()
│	return series_to_preserve
⋮...
│def get_default_series(doctype):
│	field = frappe.get_meta(doctype).get_field("naming_series")
│	default_series = field.get("default", "") if field else ""
│	return default_series
⋮...

erpnext\patches\v13_0\delete_orphaned_tables.py:
│def execute():
⋮...
│def has_deleted_company_transactions():
│	return frappe.get_all("Transaction Deletion Record")
⋮...
│def get_child_doctypes_whose_parent_doctypes_were_affected():
⋮...
│def get_affected_doctypes():
⋮...
│def is_not_child_table(doctype):
│	return not bool(frappe.get_value("DocType", doctype, "istable"))
⋮...
│def remove_duplicate_items(affected_doctypes):
│	return list(set(affected_doctypes))
⋮...
│def check_for_new_doc_with_same_name_as_deleted_parent(doc):
⋮...

erpnext\patches\v11_0\refactor_autoname_naming.py:
│def execute():
│	series_to_set = get_series()
│	for doctype, opts in series_to_set.items():
│		set_series(doctype, opts["value"])
⋮...
│def set_series(doctype, value):
│	doc = frappe.db.exists("Property Setter", {"doc_type": doctype, "property": "autoname"})
│	if doc:
│		frappe.db.set_value("Property Setter", doc, "value", value)
│	else:
│		make_property_setter(doctype, "", "autoname", value, "", for_doctype=True)
⋮...
│def get_series():
⋮...
│def get_series_to_preserve(doctype):
│	series_to_preserve = frappe.db.get_value("DocType", doctype, "autoname")
│	return series_to_preserve
⋮...

erpnext\patches\v12_0\move_item_tax_to_item_tax_template.py:
│def execute():
⋮...
│def get_item_tax_template(
│	item_tax_templates, item_tax_map, item_code, parenttype=None, parent=None, tax_types=None
│):
⋮...
│def get_company(company_abbr, parenttype=None, parent=None):
⋮...

erpnext\patches\v15_0\create_advance_payment_ledger_records.py:
│def execute():
⋮...
│def get_advance_doctypes() -> list:
│	return frappe.get_hooks("advance_payment_receivable_doctypes") + frappe.get_hooks(
│		"advance_payment_payable_doctypes"
│	)
⋮...
│def make_advance_ledger_entries(vouchers: list):
│	for x in vouchers:
│		frappe.get_doc(x.doctype, x.name).make_advance_payment_ledger_entries()
⋮...
│def get_payments_with_so_po_reference() -> list:
⋮...
│def get_journals_with_so_po_reference() -> list:
⋮...

erpnext\patches\v15_0\update_sub_voucher_type_in_gl_entries.py:
│def execute():
│	update_purchase_invoices()
│	update_sales_invoices()
│	update_sales_debit_notes()
⋮...
│def update_gl_entry(doctype, invoices, value):
⋮...
│def update_purchase_invoices():
⋮...
│def update_sales_invoices():
⋮...
│def update_sales_debit_notes():
⋮...

erpnext\patches\v15_0\update_invoice_remarks.py:
│def execute():
│	update_sales_invoice_remarks()
│	update_purchase_invoice_remarks()
⋮...
│def update_sales_invoice_remarks():
⋮...
│def update_purchase_invoice_remarks():
⋮...
│def update_sales_invoice_gle_remarks():
⋮...
│def update_sales_invoice_ple_remarks():
⋮...
│def update_purchase_invoice_gle_remarks():
⋮...
│def update_purchase_invoice_ple_remarks():
⋮...

erpnext\stock\doctype\delivery_note\delivery_note.py:
│def make_sales_invoice(source_name, target_doc=None, args=None):
⋮...
│def get_list_context(context=None):
⋮...
│def make_sales_return(source_name, target_doc=None):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("Delivery Note", source_name, target_doc)
⋮...
│def make_inter_company_purchase_receipt(source_name, target_doc=None):
│	return make_inter_company_transaction("Delivery Note", source_name, target_doc)
⋮...
│def make_inter_company_transaction(doctype, source_name, target_doc=None):
⋮...
│def make_packing_slip(source_name, target_doc=None):
⋮...
│def update_billed_amount_based_on_so(so_detail, update_modified=True):
⋮...
│def get_invoiced_qty_map(delivery_note):
⋮...
│def get_returned_qty_map(delivery_note):
⋮...
│def make_delivery_trip(source_name, target_doc=None, kwargs=None):
⋮...
│class DeliveryNote(SellingController):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def onload(self):
│		super().onload()
│
│		if self.docstatus == 0:
│			self.set_onload("has_unpacked_items", self.has_unpacked_items())
⋮...
│	def before_print(self, settings=None):
⋮...
│	def set_actual_qty(self):
⋮...
│	def so_required(self):
│		"""check in manage account if sales order required or not"""
│		if frappe.db.get_single_value("Selling Settings", "so_required") == "Yes":
│			for d in self.get("items"):
│				if not d.against_sales_order:
│					frappe.throw(_("Sales Order required for Item {0}").format(d.item_code))
⋮...
│	def validate(self):
⋮...
│	def validate_with_previous_doc(self):
⋮...
│	def set_serial_and_batch_bundle_from_pick_list(self):
⋮...
│	def validate_references(self):
│		self.validate_sales_order_references()
│		self.validate_sales_invoice_references()
⋮...
│	def validate_sales_order_references(self):
│		self._validate_dependent_item_fields(
│			"against_sales_order", "so_detail", _("References to Sales Orders are Incomplete")
│		)
⋮...
│	def validate_sales_invoice_references(self):
│		self._validate_dependent_item_fields(
│			"against_sales_invoice", "si_detail", _("References to Sales Invoices are Incomplete")
│		)
⋮...
│	def _validate_dependent_item_fields(self, field_a: str, field_b: str, error_title: str):
⋮...
│	def validate_proj_cust(self):
⋮...
│	def validate_warehouse(self):
│		super().validate_warehouse()
│
│		for d in self.get_item_list():
│			if not d["warehouse"] and frappe.get_cached_value("Item", d["item_code"], "is_stock_item") == 1:
│				frappe.throw(_("Warehouse required for stock Item {0}").format(d["item_code"]))
⋮...
│	def update_current_stock(self):
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def validate_against_stock_reservation_entries(self):
⋮...
│	def check_credit_limit(self):
⋮...
│	def validate_packed_qty(self):
⋮...
│	def update_pick_list_status(self):
│		from erpnext.stock.doctype.pick_list.pick_list import update_pick_list_status
│
│		update_pick_list_status(self.pick_list)
⋮...
│	def check_next_docstatus(self):
⋮...
│	def cancel_packing_slips(self):
⋮...
│	def update_status(self, status):
│		self.set_status(update=True, status=status)
│		self.notify_update()
│		clear_doctype_notifications(self)
⋮...
│	def update_billing_status(self, update_modified=True):
⋮...
│	def make_return_invoice(self):
⋮...
│	def has_unpacked_items(self):
⋮...
│	def get_product_bundle_list(self):
⋮...
│def make_installation_note(source_name, target_doc=None, kwargs=None):
⋮...
│def make_shipment(source_name, target_doc=None):
⋮...
│def update_delivery_note_status(docname, status):
│	dn = frappe.get_doc("Delivery Note", docname)
│	dn.update_status(status)
⋮...

erpnext\patches\v14_0\update_pos_return_ledger_entries.py:
│def execute():
│	affected_pos_returns = get_pos_returns_with_invalid_against_ref()
│	fix_incorrect_against_voucher_ref(affected_pos_returns)
│	update_outstanding_for_affected(affected_pos_returns)
⋮...
│def get_valid_against_voucher_ref(pos_returns):
⋮...
│def build_dict_of_valid_against_reference(pos_returns):
│	_against_ref_dict = frappe._dict()
│	res = get_valid_against_voucher_ref(pos_returns)
│	for x in res:
│		_against_ref_dict[x.name] = x.return_against
│	return _against_ref_dict
⋮...
│def fix_incorrect_against_voucher_ref(affected_pos_returns):
⋮...
│def get_pos_returns_with_invalid_against_ref():
⋮...
│def update_outstanding_for_affected(affected_pos_returns):
⋮...

erpnext\stock\report\delayed_order_report\delayed_order_report.py:
│def execute(filters=None):
│	columns, data = [], []
│
│	columns, data = DelayedOrderReport(filters).run()
│
│	return columns, data
⋮...
│class DelayedOrderReport(DelayedItemReport):
⋮...
│	def run(self):
│		return self.get_columns(), self.get_data(consolidated=True) or []
⋮...
│	def get_data(self, consolidated=False):
⋮...
│	def get_columns(self):
⋮...

erpnext\patches\v13_0\add_missing_fg_item_for_stock_entry.py:
│def execute():
⋮...
│def set_expense_account(doc):
│	for row in doc.items:
│		if row.is_finished_item and not row.expense_account:
│			row.expense_account = frappe.get_cached_value("Company", doc.company, "stock_adjustment_account")
⋮...
│def repost_stock_entry(doc):
⋮...
│def get_sle_for_target_warehouse(doc, sl_entries, finished_item_row):
⋮...
│def repost_future_sle_and_gle(doc):
⋮...

erpnext\patches\v13_0\fix_additional_cost_in_mfg_stock_entry.py:
│def execute():
│	stock_entry_codes = find_broken_stock_entries()
│
│	for stock_entry_code in stock_entry_codes:
│		patched_stock_entry = patch_additional_cost(stock_entry_code)
│		create_repost_item_valuation(patched_stock_entry)
⋮...
│def create_repost_item_valuation(stock_entry):
⋮...
│def find_broken_stock_entries() -> list[StockEntryCode]:
⋮...
│def patch_additional_cost(code: StockEntryCode):
⋮...

erpnext\stock\doctype\delivery_note\test_delivery_note.py:
│def create_delivery_note(**args):
⋮...
│class UnitTestDeliveryNote(UnitTestCase):
⋮...
│class TestDeliveryNote(IntegrationTestCase):
⋮...
│	def test_delivery_note_qty(self):
⋮...
│	def test_over_billing_against_dn(self):
⋮...
│	def test_delivery_note_no_gl_entry(self):
⋮...
│	def test_delivery_note_gl_entry_packing_item(self):
⋮...
│	def test_serialize_status(self):
⋮...
│	def check_serial_no_values(self, serial_no, field_values):
│		serial_no = frappe.get_doc("Serial No", serial_no)
│		for field, value in field_values.items():
│			self.assertEqual(cstr(serial_no.get(field)), value)
⋮...
│	def test_delivery_note_return_against_denormalized_serial_no(self):
⋮...
│	def test_sales_return_for_non_bundled_items_partial(self):
⋮...
│	def test_sales_return_for_non_bundled_items_full(self):
⋮...
│	def test_delivery_note_return_valuation_on_different_warehouse(self):
⋮...
│	def test_sales_return_against_serial_batch_bundle(self):
⋮...
│	def test_return_single_item_from_bundled_items(self):
⋮...
│	def test_return_entire_bundled_items(self):
⋮...
│	def test_bin_details_of_packed_item(self):
⋮...
│	def test_return_for_serialized_items(self):
⋮...
│	def test_delivery_note_internal_transfer_serial_no_status(self):
⋮...
│	def test_delivery_of_bundled_items_to_target_warehouse(self):
⋮...
│	def test_closed_delivery_note(self):
⋮...
│	def test_sales_order_reference_validation(self):
⋮...
│	def test_dn_billing_status_case1(self):
⋮...
│	def test_dn_billing_status_case2(self):
⋮...
│	def test_dn_billing_status_case3(self):
⋮...
│	def test_dn_billing_status_case4(self):
⋮...
│	def test_delivery_trip(self):
⋮...
│	def test_delivery_note_with_cost_center(self):
⋮...
│	def test_delivery_note_cost_center_with_balance_sheet_account(self):
⋮...
│	def test_make_sales_invoice_from_dn_for_returned_qty(self):
⋮...
│	def test_make_sales_invoice_from_dn_with_returned_qty_duplicate_items(self):
⋮...
│	def test_delivery_note_bundle_with_batched_item(self):
⋮...
│	def test_payment_terms_are_fetched_when_creating_sales_invoice(self):
⋮...
│	def test_returned_qty_in_return_dn(self):
⋮...
│	def test_internal_transfer_with_valuation_only(self):
⋮...
│	def test_internal_transfer_precision_gle(self):
⋮...
│	def test_batch_expiry_for_delivery_note(self):
⋮...
│	def test_reserve_qty_on_sales_return(self):
│		frappe.db.set_single_value("Selling Settings", "dont_reserve_sales_order_qty_on_sales_return", 0)
│		self.reserved_qty_check()
⋮...
│	def test_dont_reserve_qty_on_sales_return(self):
│		frappe.db.set_single_value("Selling Settings", "dont_reserve_sales_order_qty_on_sales_return", 1)
│		self.reserved_qty_check()
⋮...
│	def reserved_qty_check(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
│		frappe.db.set_single_value("Selling Settings", "dont_reserve_sales_order_qty_on_sales_return", 0)
⋮...
│	def test_non_internal_transfer_delivery_note(self):
⋮...
│	def test_serial_no_status(self):
⋮...
│	def test_sales_return_valuation_for_moving_average(self):
⋮...
│	def test_sales_return_valuation_for_moving_average_case2(self):
⋮...
│	def test_batch_with_non_stock_uom(self):
⋮...
│	def test_internal_transfer_for_non_stock_item(self):
⋮...
│	def test_use_serial_batch_fields_for_packed_items(self):
⋮...
│	def test_delivery_note_legacy_serial_no_valuation(self):
⋮...
│	def test_sales_return_batch_no_for_batched_item_in_dn(self):
⋮...
│	def test_partial_sales_return_batch_no_for_batched_item_in_dn(self):
⋮...
│	def test_sales_return_serial_no_for_serial_item_in_dn(self):
⋮...
│	def test_same_posting_date_and_posting_time(self):
⋮...
│	def test_warranty_expiry_date_for_serial_item(self):
⋮...
│	def test_batch_return_dn(self):
⋮...
│	def test_delivery_note_return_valuation_without_use_serial_batch_field(self):
⋮...
│	def test_delivery_note_return_valuation_with_use_serial_batch_field(self):
⋮...
│	def test_auto_set_serial_batch_for_draft_dn(self):
⋮...
│	def test_delivery_note_return_for_batch_item_with_different_warehouse(self):
⋮...
│	def test_delivery_note_per_billed_after_return(self):
⋮...

erpnext\patches\v14_0\migrate_deferred_accounts_to_item_defaults.py:
│def execute():
⋮...
│def add_company_wise_item_default(item, account_type):
⋮...
│def get_deferred_accounts():
⋮...
│def add_to_item_defaults(item_dict):
│	for item in item_dict:
│		add_company_wise_item_default(item, "deferred_expense_account")
│		add_company_wise_item_default(item, "deferred_revenue_account")
⋮...

erpnext\selling\report\customer_acquisition_and_loyalty\customer_acquisition_and_loyalty.py:
│def execute(filters=None):
⋮...
│def get_customer_stats(filters, tree_view=False):
⋮...
│def get_data_by_time(filters, common_columns):
⋮...
│def get_data_by_territory(filters, common_columns):
⋮...

erpnext\patches\v12_0\set_priority_for_support.py:
│def execute():
⋮...
│def set_issue_priority():
│	# Adds priority from issue to Issue Priority DocType as Priority is a new DocType.
│	for priority in frappe.get_meta("Issue").get_field("priority").options.split("\n"):
│		if priority and not frappe.db.exists("Issue Priority", priority):
│			frappe.get_doc({"doctype": "Issue Priority", "name": priority}).insert(ignore_permissions=True)
⋮...
│def set_priority_for_issue():
⋮...
│def set_priorities_service_level():
⋮...
│def set_priorities_service_level_agreement():
⋮...

erpnext\patches\v13_0\delete_old_purchase_reports.py:
│def execute():
⋮...
│def delete_auto_email_reports(report):
│	"""Check for one or multiple Auto Email Reports and delete"""
│	auto_email_reports = frappe.db.get_values("Auto Email Report", {"report": report}, ["name"])
│	for auto_email_report in auto_email_reports:
│		frappe.delete_doc("Auto Email Report", auto_email_report[0])
⋮...
│def delete_links_from_desktop_icons(report):
│	"""Check for one or multiple Desktop Icons and delete"""
│	desktop_icons = frappe.db.get_values("Desktop Icon", {"_report": report}, ["name"])
│	for desktop_icon in desktop_icons:
│		frappe.delete_doc("Desktop Icon", desktop_icon[0], force=True)
⋮...

erpnext\patches\v13_0\delete_old_sales_reports.py:
│def execute():
⋮...
│def delete_auto_email_reports(report):
│	"""Check for one or multiple Auto Email Reports and delete"""
│	auto_email_reports = frappe.db.get_values("Auto Email Report", {"report": report}, ["name"])
│	for auto_email_report in auto_email_reports:
│		frappe.delete_doc("Auto Email Report", auto_email_report[0], force=True)
⋮...
│def delete_links_from_desktop_icons(report):
│	"""Check for one or multiple Desktop Icons and delete"""
│	desktop_icons = frappe.db.get_values("Desktop Icon", {"_report": report}, ["name"])
│	for desktop_icon in desktop_icons:
│		frappe.delete_doc("Desktop Icon", desktop_icon[0], force=True)
⋮...

erpnext\patches\v15_0\create_asset_depreciation_schedules_from_assets.py:
│def execute():
⋮...
│def get_asset_finance_books_map():
⋮...
│def get_asset_depreciation_schedules_map():
⋮...
│def update_depreciation_schedules(
│	depreciation_schedules,
│	asset_depr_schedule_name,
│):
⋮...

erpnext\patches\v15_0\correct_asset_value_if_je_with_workflow.py:
│def execute():
⋮...
│def correct_value_for_assets_with_auto_depr(fb_name=None):
⋮...
│def correct_value_for_assets_with_manual_depr_entries():
⋮...

erpnext\patches\v14_0\update_reports_with_range.py:
│def execute():
│	for report in REFERENCE_REPORTS:
│		update_reference_reports(report)
⋮...
│def update_reference_reports(reference_report):
⋮...
│def update_report_json(report):
⋮...

erpnext\patches\v13_0\reset_clearance_date_for_intracompany_payment_entries.py:
│def execute():
⋮...
│def get_reconciled_bank_transactions(intra_company_pe):
⋮...
│def get_intra_company_payment_entries_with_clearance_dates():
│	return frappe.get_all(
│		"Payment Entry",
│		filters={"payment_type": "Internal Transfer", "clearance_date": ["not in", None]},
│		pluck="name",
│	)
⋮...

erpnext\patches\v15_0\recalculate_amount_difference_field.py:
│def execute():
⋮...
│def get_billed_qty_against_purchase_receipt(pr_names):
⋮...

erpnext\patches\v15_0\refactor_closing_stock_balance.py:
│def execute():
│	if not frappe.db.has_table("Closing Stock Balance"):
│		return
│
│	add_inventory_dimensions_to_stock_closing_balance()
│	create_stock_closing_entries()
⋮...
│def add_inventory_dimensions_to_stock_closing_balance():
⋮...
│def create_stock_closing_entries():
⋮...

erpnext\patches\v14_0\migrate_cost_center_allocations.py:
│def execute():
⋮...
│def create_new_cost_center_allocation_records(cc_allocations):
⋮...
│def get_existing_cost_center_allocations():
⋮...

erpnext\patches\v11_0\update_sales_partner_type.py:
│def execute():
⋮...
│def insert_sales_partner_type(s):
│	if not frappe.db.exists("Sales Partner Type", s):
│		frappe.get_doc(dict(doctype="Sales Partner Type", sales_partner_type=s)).insert()
⋮...

erpnext\patches\v11_0\create_department_records_for_each_company.py:
│def execute():
⋮...
│def update_records(doctype, comp_dict):
⋮...
│def update_instructors(comp_dict):
⋮...

erpnext\patches\v15_0\link_purchase_item_to_asset_doc.py:
│def execute():
⋮...
│def get_linked_item(doctype, parent, item_code, amount, quantity):
⋮...

erpnext\manufacturing\dashboard_fixtures.py:
│def get_data():
⋮...
│def get_dashboards():
⋮...
│def get_charts():
⋮...
│def get_number_cards():
⋮...

erpnext\buying\doctype\supplier\patches\migrate_supplier_portal_users.py:
│def execute():
⋮...
│def get_portal_user_contacts():
⋮...
│def add_portal_users(contacts):
⋮...

erpnext\patches\v14_0\crm_ux_cleanup.py:
│def execute():
⋮...
│def add_calendar_event_for_leads():
⋮...
│def add_calendar_event_for_opportunities():
⋮...

erpnext\patches\v12_0\stock_entry_enhancements.py:
│def execute():
│	create_stock_entry_types()
│
│	company = frappe.db.get_value("Company", {"country": "India"}, "name")
│	if company:
│		add_gst_hsn_code_field()
⋮...
│def create_stock_entry_types():
⋮...
│def add_gst_hsn_code_field():
⋮...

erpnext\patches\v12_0\rename_bank_reconciliation_fields.py:
│def execute():
│	_rename_single_field(doctype="Bank Clearance", old_name="bank_account", new_name="account")
│	_rename_single_field(doctype="Bank Clearance", old_name="bank_account_no", new_name="bank_account")
│	frappe.reload_doc("Accounts", "doctype", "Bank Clearance")
⋮...
│def _rename_single_field(**kwargs):
⋮...

erpnext\patches\v13_0\add_bin_unique_constraint.py:
│def execute():
│	delete_broken_bins()
│	delete_and_patch_duplicate_bins()
⋮...
│def delete_broken_bins():
│	# delete useless bins
│	frappe.db.sql("delete from `tabBin` where item_code is null or warehouse is null")
⋮...
│def delete_and_patch_duplicate_bins():
⋮...

erpnext\assets\dashboard_fixtures.py:
│def get_data():
⋮...
│def get_dashboards():
⋮...
│def get_charts(fiscal_year, year_start_date, year_end_date):
⋮...
│def get_number_cards(fiscal_year, year_start_date, year_end_date):
⋮...

erpnext\patches\v14_0\remove_india_localisation.py:
│def execute():
⋮...
│def delete_docs():
⋮...
│def unlink_custom_fields():
│	frappe.db.set_value(
│		"Custom Field",
│		{"dt": "Item", "fieldname": "gst_hsn_code"},
│		{"fieldtype": "Data", "options": ""},
│	)
⋮...

erpnext\patches\v10_1\transfer_subscription_to_auto_repeat.py:
│def execute():
⋮...
│def drop_columns_from_subscription():
⋮...

erpnext\patches\v13_0\rename_issue_status_hold_to_on_hold.py:
│def execute():
│	if frappe.db.exists("DocType", "Issue"):
│		frappe.reload_doc("support", "doctype", "issue")
│		rename_status()
⋮...
│def rename_status():
⋮...

erpnext\patches\v12_0\rename_bank_account_field_in_journal_entry_account.py:
│def execute():
│	"""Change the fieldname from bank_account_no to bank_account"""
│	if not frappe.get_meta("Journal Entry Account").has_field("bank_account"):
│		frappe.reload_doc("Accounts", "doctype", "Journal Entry Account")
│		update_journal_entry_account_fieldname()
⋮...
│def update_journal_entry_account_fieldname():
│	"""maps data from old field to the new field"""
│	if frappe.db.has_column("Journal Entry Account", "bank_account_no"):
│		rename_field("Journal Entry Account", "bank_account_no", "bank_account")
⋮...

erpnext\patches\v11_0\rename_supplier_type_to_supplier_group.py:
│def execute():
⋮...
│def build_tree():
⋮...

erpnext\patches\v11_0\make_location_from_warehouse.py:
│def execute():
⋮...
│def get_parent_warehouse_name(warehouse):
│	return frappe.db.get_value("Warehouse", warehouse, "warehouse_name")
⋮...

erpnext\patches\v15_0\update_payment_schedule_fields_in_invoices.py:
│def execute():
│	invoice_types = ["Sales Invoice", "Purchase Invoice"]
│	for invoice_type in invoice_types:
│		invoice = DocType(invoice_type)
│		invoice_details = frappe.qb.from_(invoice).select(invoice.conversion_rate, invoice.name)
│		update_payment_schedule(invoice_details)
⋮...
│def update_payment_schedule(invoice_details):
│	ps = DocType("Payment Schedule")
│
│	frappe.qb.update(ps).join(invoice_details).on(ps.parent == invoice_details.name).set(
│		ps.base_paid_amount, ps.paid_amount * invoice_details.conversion_rate
│	).set(ps.base_outstanding, ps.outstanding * invoice_details.conversion_rate).run()
⋮...

erpnext\patches\v13_0\set_payment_channel_in_payment_gateway_account.py:
│def execute():
⋮...
│def set_payment_channel_as_email():
⋮...

erpnext\patches\v15_0\remove_exotel_integration.py:
│def execute():
⋮...
│def notify_existing_users():
⋮...

erpnext\patches\v13_0\fix_invoice_statuses.py:
│def execute():
⋮...
│def get_correct_status(doc):
⋮...

erpnext\patches\v14_0\single_to_multi_dunning.py:
│def execute():
⋮...
│def get_accounts_closing_date():
⋮...

erpnext\patches\v12_0\move_credit_limit_to_customer_credit_limit.py:
│def execute():
⋮...
│def move_credit_limit_to_child_table():
⋮...

erpnext\stock\doctype\delivery_note\patches\drop_unused_return_against_index.py:
│def execute():
│	for doctype, index_fields in UNUSED_INDEXES:
│		table = f"tab{doctype}"
│		index_name = frappe.db.get_index_name(index_fields)
│		drop_index_if_exists(table, index_name)
⋮...
│def drop_index_if_exists(table: str, index: str):
⋮...

erpnext\patches\v14_0\update_posting_datetime_and_dropped_indexes.py:
│def execute():
⋮...
│def drop_indexes():
│	if not frappe.db.has_index("tabStock Ledger Entry", "posting_sort_index"):
│		return
│
│	frappe.db.sql_ddl("ALTER TABLE `tabStock Ledger Entry` DROP INDEX `posting_sort_index`")
⋮...

erpnext\patches\v14_0\create_incoterms_and_migrate_shipment.py:
│def execute():
│	create_incoterms()
│	migrate_shipments()
⋮...
│def migrate_shipments():
⋮...

erpnext\patches\v13_0\item_reposting_for_incorrect_sl_and_gl.py:
│def execute():
⋮...
│def get_creation_time():
│	return frappe.db.sql(
│		""" SELECT create_time FROM
│		INFORMATION_SCHEMA.TABLES where TABLE_NAME = "tabRepost Item Valuation" """,
│		as_list=1,
│	)[0][0]
⋮...

erpnext\patches\v14_0\change_autoname_for_tax_withheld_vouchers.py:
│def execute():
⋮...

erpnext\patches\v11_1\set_default_action_for_quality_inspection.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_returned_qty_in_pr_dn.py:
│def execute():
⋮...

erpnext\patches\v12_0\rename_lost_reason_detail.py:
│def execute():
⋮...

erpnext\patches\v13_0\change_default_pos_print_format.py:
│def execute():
│	frappe.db.sql(
│		"""UPDATE `tabPOS Profile` profile
│		SET profile.`print_format` = 'POS Invoice'
│		WHERE profile.`print_format` = 'Point of Sale'"""
│	)
⋮...

erpnext\patches\v15_0\delete_orphaned_asset_movement_item_records.py:
│def execute():
⋮...

erpnext\patches\v13_0\show_india_localisation_deprecation_warning.py:
│def execute():
⋮...

erpnext\patches\v4_2\update_requested_and_ordered_qty.py:
│def execute():
⋮...

erpnext\patches\v11_1\move_customer_lead_to_dynamic_column.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_warehouse_field_in_asset_repair_consumed_item_doctype.py:
│def execute():
⋮...

erpnext\patches\v15_0\migrate_checkbox_to_select_for_reconciliation_effect.py:
│def execute():
⋮...

erpnext\patches\v13_0\create_accounting_dimensions_in_pos_doctypes.py:
│def execute():
⋮...

erpnext\patches\v11_0\merge_land_unit_with_location.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_proprietorship_to_individual.py:
│def execute():
│	for doctype in ["Customer", "Supplier"]:
│		field = doctype.lower() + "_type"
│		frappe.db.set_value(doctype, {field: "Proprietorship"}, field, "Individual")
⋮...

erpnext\patches\v12_0\set_against_blanket_order_in_sales_and_purchase_order.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_asset_quantity_field.py:
│def execute():
│	if frappe.db.count("Asset"):
│		frappe.reload_doc("assets", "doctype", "Asset")
│		asset = frappe.qb.DocType("Asset")
│		frappe.qb.update(asset).set(asset.asset_quantity, 1).run()
⋮...

erpnext\patches\v5_7\update_item_description_based_on_item_master.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_task_assignee_email_field_in_asset_maintenance_log.py:
│def execute():
⋮...

erpnext\selling\report\territory_target_variance_based_on_item_group\territory_target_variance_based_on_item_group.py:
│def execute(filters=None):
│	return get_data_column(filters, "Territory")
⋮...

erpnext\patches\v13_0\modify_invalid_gain_loss_gl_entries.py:
│def execute():
⋮...

erpnext\patches\v13_0\create_accounting_dimensions_for_asset_repair.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_tds_check_field.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_reference_due_date_in_journal_entry.py:
│def execute():
⋮...

erpnext\patches\v15_0\allow_on_submit_dimensions_for_repostable_doctypes.py:
│def execute():
│	for dt in get_allowed_types_from_settings():
│		for dimension in get_accounting_dimensions():
│			frappe.db.set_value("Custom Field", dt + "-" + dimension, "allow_on_submit", 1)
⋮...

erpnext\patches\v13_0\move_branch_code_to_bank_account.py:
│def execute():
⋮...

erpnext\patches\v14_0\rename_ongoing_status_in_sla_documents.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_price_or_product_discount.py:
│def execute():
⋮...

erpnext\support\report\first_response_time_for_issues\first_response_time_for_issues.py:
│def execute(filters=None):
⋮...

erpnext\patches\v15_0\do_not_use_batchwise_valuation.py:
│def execute():
⋮...

erpnext\patches\v13_0\job_card_status_on_hold.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_per_billed_in_return_delivery_note.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_pos_closing_as_failed.py:
│def execute():
│	frappe.reload_doc("accounts", "doctype", "pos_closing_entry")
│
│	frappe.db.sql("update `tabPOS Closing Entry` set `status` = 'Failed' where `status` = 'Queued'")
⋮...

erpnext\patches\v13_0\add_custom_field_for_south_africa.py:
│def execute():
⋮...

erpnext\patches\v12_0\recalculate_requested_qty_in_bin.py:
│def execute():
⋮...

erpnext\patches\v11_0\renamed_from_to_fields_in_project.py:
│def execute():
│	frappe.reload_doc("projects", "doctype", "project")
│
│	if frappe.db.has_column("Project", "from"):
│		rename_field("Project", "from", "from_time")
│		rename_field("Project", "to", "to_time")
⋮...

erpnext\patches\v13_0\update_docs_link.py:
│def execute():
⋮...

erpnext\patches\v11_0\remove_barcodes_field_from_copy_fields_to_variants.py:
│def execute():
│	"""Remove barcodes field from "Copy Fields to Variants" table because barcodes must be unique"""
│
│	settings = frappe.get_doc("Item Variant Settings")
│	settings.remove_invalid_fields_for_copy_fields_in_variants()
⋮...

erpnext\patches\v11_1\renamed_delayed_item_report.py:
│def execute():
│	for report in ["Delayed Order Item Summary", "Delayed Order Summary"]:
│		if frappe.db.exists("Report", report):
│			frappe.delete_doc("Report", report)
⋮...

erpnext\patches\v13_0\enable_uoms.py:
│def execute():
⋮...

erpnext\patches\v13_0\requeue_failed_reposts.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_healthcare_doctypes.py:
│def execute():
⋮...

erpnext\patches\v15_0\delete_saudi_doctypes.py:
│def execute():
⋮...

erpnext\patches\v12_0\remove_patient_medical_record_page.py:
│def execute():
│	frappe.delete_doc("Page", "medical_record")
⋮...

erpnext\patches\v14_0\update_currency_exchange_settings_for_frankfurter.py:
│def execute():
⋮...

erpnext\patches\v13_0\drop_unused_sle_index_parts.py:
│def execute():
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_in_reconciliation_tool.py:
│def execute():
│	create_accounting_dimensions_for_doctype(doctype="Payment Reconciliation")
│	create_accounting_dimensions_for_doctype(doctype="Payment Reconciliation Allocation")
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_in_subcontracting_doctypes.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_education_doctypes.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_lead_title_field.py:
│def execute():
⋮...

erpnext\patches\v12_0\fix_percent_complete_for_projects.py:
│def execute():
⋮...

erpnext\patches\v11_0\set_department_for_doctypes.py:
│def execute():
⋮...

erpnext\patches\v14_0\cleanup_workspaces.py:
│def execute():
│	for ws in ["Retail", "Utilities"]:
│		frappe.delete_doc_if_exists("Workspace", ws)
│
│	for ws in ["Integrations", "Settings"]:
│		frappe.db.set_value("Workspace", ws, "public", 0)
⋮...

erpnext\patches\v11_0\remove_modules_setup_page.py:
│def execute():
│	frappe.delete_doc("Page", "modules_setup")
⋮...

erpnext\patches\v11_0\set_update_field_and_value_in_workflow_state.py:
│def execute():
⋮...

erpnext\patches\v14_0\set_report_in_process_SOA.py:
│def execute():
│	process_soa = frappe.qb.DocType("Process Statement Of Accounts")
│	q = frappe.qb.update(process_soa).set(process_soa.report, "General Ledger")
│	q.run()
⋮...

erpnext\patches\v12_0\set_purchase_receipt_delivery_note_detail.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_pricing_rule_fields.py:
│def execute():
⋮...

erpnext\patches\v14_0\disable_add_row_in_gross_profit.py:
│def execute():
│	frappe.db.set_value("Report", "Gross Profit", "add_total_row", 0)
⋮...

erpnext\patches\v12_0\unhide_cost_center_field.py:
│def execute():
⋮...

erpnext\patches\v10_0\update_translatable_fields.py:
│def execute():
⋮...

erpnext\patches\v15_0\set_is_exchange_gain_loss_in_payment_entry_deductions.py:
│def execute():
⋮...

erpnext\patches\v14_0\rename_over_order_allowance_field.py:
│def execute():
⋮...

erpnext\patches\v11_0\add_default_dispatch_notification_template.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_youtube_video_id.py:
│def execute():
│	frappe.reload_doc("utilities", "doctype", "video")
│
│	for video in frappe.get_all("Video", fields=["name", "url", "youtube_video_id"]):
│		if video.url and not video.youtube_video_id:
│			frappe.db.set_value("Video", video.name, "youtube_video_id", get_id_from_url(video.url))
⋮...

erpnext\patches\v12_0\set_produced_qty_field_in_sales_order_for_work_order.py:
│def execute():
⋮...

erpnext\patches\v13_0\rename_membership_settings_to_non_profit_settings.py:
│def execute():
⋮...

erpnext\patches\v11_0\check_buying_selling_in_currency_exchange.py:
│def execute():
│	frappe.reload_doc("setup", "doctype", "currency_exchange")
│	frappe.db.sql("""update `tabCurrency Exchange` set for_buying = 1, for_selling = 1""")
⋮...

erpnext\patches\v12_0\create_default_energy_point_rules.py:
│def execute():
│	frappe.reload_doc("social", "doctype", "energy_point_rule")
│	create_default_energy_point_rules()
⋮...

erpnext\patches\v11_0\add_index_on_nestedset_doctypes.py:
│def execute():
⋮...

erpnext\patches\v11_1\update_default_supplier_in_item_defaults.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_subscription_status_in_memberships.py:
│def execute():
⋮...

erpnext\patches\v11_1\set_missing_opportunity_from.py:
│def execute():
⋮...

erpnext\patches\v11_0\hr_ux_cleanups.py:
│def execute():
⋮...

erpnext\patches\v11_1\set_missing_title_for_quotation.py:
│def execute():
⋮...

erpnext\patches\v11_0\update_delivery_trip_status.py:
│def execute():
⋮...

erpnext\patches\v12_0\rename_tolerance_fields.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_opportunity_currency_fields.py:
│def execute():
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_for_asset_capitalization.py:
│def execute():
⋮...

erpnext\patches\v15_0\delete_payment_gateway_doctypes.py:
│def execute():
│	for dt in ("GoCardless Settings", "GoCardless Mandate", "Mpesa Settings"):
│		frappe.delete_doc("DocType", dt, ignore_missing=True)
⋮...

erpnext\patches\v12_0\move_plaid_settings_to_doctype.py:
│def execute():
⋮...

erpnext\patches\v11_0\rename_duplicate_item_code_values.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_manufacturing_settings_field.py:
│def execute():
│	rename_field(
│		"Manufacturing Settings",
│		"set_op_cost_and_scrape_from_sub_assemblies",
│		"set_op_cost_and_scrap_from_sub_assemblies",
│	)
⋮...

erpnext\patches\v14_0\discount_accounting_separation.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_permission_einvoicing.py:
│def execute():
⋮...

erpnext\selling\report\sales_person_target_variance_based_on_item_group\sales_person_target_variance_based_on_item_group.py:
│def execute(filters=None):
│	return get_data_column(filters, "Sales Person")
⋮...

erpnext\patches\v12_0\rename_bank_reconciliation.py:
│def execute():
⋮...

erpnext\patches\v13_0\remove_attribute_field_from_item_variant_setting.py:
│def execute():
⋮...

erpnext\accounts\report\accounts_payable\accounts_payable.py:
│def execute(filters=None):
│	args = {
│		"account_type": "Payable",
│		"naming_by": ["Buying Settings", "supp_master_name"],
│	}
│	return ReceivablePayableReport(filters).run(args)
⋮...

erpnext\patches\v13_0\update_pos_closing_entry_in_merge_log.py:
│def execute():
⋮...

erpnext\patches\v14_0\clear_reconciliation_values_from_singles.py:
│def execute():
⋮...

erpnext\patches\v10_0\set_currency_in_pricing_rule.py:
│def execute():
⋮...

erpnext\patches\v11_0\update_allow_transfer_for_manufacture.py:
│def execute():
⋮...

erpnext\patches\v13_0\migrate_stripe_api.py:
│def execute():
│	frappe.reload_doc("accounts", "doctype", "subscription_plan")
│	rename_field("Subscription Plan", "payment_plan_id", "product_price_id")
⋮...

erpnext\patches\v12_0\set_payment_entry_status.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_invoicing_period_in_subscription.py:
│def execute():
│	subscription = frappe.qb.DocType("Subscription")
│	frappe.qb.update(subscription).set(
│		subscription.generate_invoice_at, "Beginning of the current subscription period"
│	).where(subscription.generate_invoice_at_period_start == 1).run()
⋮...

erpnext\patches\v12_0\remove_bank_remittance_custom_fields.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_amt_in_work_order_required_items.py:
│def execute():
⋮...

erpnext\patches\v13_0\delete_report_requested_items_to_order.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_cost_center_in_child_table_of_expense_claim.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_status_in_maintenance_schedule_table.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_end_date_and_status_in_email_campaign.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_entry_type_for_journal_entry.py:
│def execute():
⋮...

erpnext\patches\v11_0\add_expense_claim_default_account.py:
│def execute():
⋮...

erpnext\patches\v13_0\healthcare_deprecation_warning.py:
│def execute():
│	click.secho(
│		"Healthcare Module is moved to a separate app and will be removed from ERPNext in version-14.\n"
│		"Please install the app to continue using the module: https://github.com/frappe/healthcare",
│		fg="yellow",
│	)
⋮...

erpnext\patches\v13_0\update_shipment_status.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_dates_in_tax_withholding_category.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_sane_transfer_against.py:
│def execute():
│	bom = frappe.qb.DocType("BOM")
│
│	(
│		frappe.qb.update(bom).set(bom.transfer_material_against, "Work Order").where(bom.with_operations == 0)
│	).run()
⋮...

erpnext\patches\v15_0\update_gpa_and_ndb_for_assdeprsch.py:
│def execute():
⋮...

erpnext\patches\v11_0\make_quality_inspection_template.py:
│def execute():
⋮...

erpnext\patches\v13_0\item_naming_series_not_mandatory.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_sre_from_voucher_details.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_payment_terms_outstanding.py:
│def execute():
⋮...

erpnext\patches\v13_0\drop_razorpay_payload_column.py:
│def execute():
│	if frappe.db.exists("DocType", "Membership"):
│		if "webhook_payload" in frappe.db.get_table_columns("Membership"):
│			frappe.db.sql("alter table `tabMembership` drop column webhook_payload")
⋮...

erpnext\patches\v12_0\set_quotation_status.py:
│def execute():
│	frappe.db.sql(
│		""" UPDATE `tabQuotation` set status = 'Open'
│		where docstatus = 1 and status = 'Submitted' """
│	)
⋮...

erpnext\patches\v12_0\add_permission_in_lower_deduction.py:
│def execute():
⋮...

erpnext\patches\v4_2\repost_reserved_qty.py:
│def execute():
⋮...

erpnext\patches\v15_0\enable_allow_existing_serial_no.py:
│def execute():
│	if frappe.get_all("Company", filters={"country": "India"}, limit=1):
│		frappe.db.set_single_value("Stock Settings", "allow_existing_serial_no", 1)
⋮...

erpnext\patches\v12_0\unset_customer_supplier_based_on_type_of_item_price.py:
│def execute():
⋮...

erpnext\patches\v14_0\fix_subcontracting_receipt_gl_entries.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_job_card_details.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_sla_fields.py:
│def execute():
⋮...

erpnext\patches\v13_0\trim_whitespace_from_serial_nos.py:
│def execute():
⋮...

erpnext\patches\v13_0\enable_scheduler_job_for_item_reposting.py:
│def execute():
│	frappe.reload_doc("core", "doctype", "scheduled_job_type")
│	if frappe.db.exists("Scheduled Job Type", "repost_item_valuation.repost_entries"):
│		frappe.db.set_value("Scheduled Job Type", "repost_item_valuation.repost_entries", "stopped", 0)
⋮...

erpnext\patches\v13_0\remove_bad_selling_defaults.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_received_qty_in_material_request_as_per_stock_uom.py:
│def execute():
⋮...

erpnext\patches\v12_0\delete_priority_property_setter.py:
│def execute():
⋮...

erpnext\patches\v12_0\add_default_buying_selling_terms_in_company.py:
│def execute():
⋮...

erpnext\patches\v15_0\add_default_operations.py:
│def execute():
│	make_default_operations()
⋮...

erpnext\patches\v14_0\update_zero_asset_quantity_field.py:
│def execute():
│	asset = frappe.qb.DocType("Asset")
│	frappe.qb.update(asset).set(asset.asset_quantity, 1).where(asset.asset_quantity == 0).run()
⋮...

erpnext\patches\v13_0\update_category_in_ltds_certificate.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_production_plan_status.py:
│def execute():
⋮...

erpnext\patches\v14_0\fix_crm_no_of_employees.py:
│def execute():
⋮...

erpnext\patches\v12_0\add_document_type_field_for_italy_einvoicing.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_cwip_and_delete_asset_settings.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_member_email_address.py:
│def execute():
⋮...

erpnext\patches\v13_0\replace_supplier_item_group_with_party_specific_item.py:
│def execute():
⋮...

erpnext\patches\v14_0\add_default_for_repost_settings.py:
│def execute():
⋮...

erpnext\patches\v11_0\set_user_permissions_for_department.py:
│def execute():
⋮...

erpnext\patches\v12_0\repost_stock_ledger_entries_for_target_warehouse.py:
│def execute():
⋮...

erpnext\patches\v13_0\create_accounting_dimensions_in_orders.py:
│def execute():
⋮...

erpnext\patches\v11_0\make_job_card.py:
│def execute():
⋮...

erpnext\patches\v14_0\rearrange_company_fields.py:
│def execute():
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_in_supplier_quotation.py:
│def execute():
│	create_accounting_dimensions_for_doctype(doctype="Supplier Quotation")
│	create_accounting_dimensions_for_doctype(doctype="Supplier Quotation Item")
⋮...

erpnext\patches\v14_0\migrate_existing_lead_notes_as_per_the_new_format.py:
│def execute():
⋮...

erpnext\patches\v14_0\change_is_subcontracted_fieldtype.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_asset_repair_field_in_stock_entry.py:
│def execute():
⋮...

erpnext\patches\v15_0\set_difference_amount_in_asset_value_adjustment.py:
│def execute():
⋮...

erpnext\patches\v13_0\delete_bank_reconciliation_detail.py:
│def execute():
│	if frappe.db.exists("DocType", "Bank Reconciliation Detail") and frappe.db.exists(
│		"DocType", "Bank Clearance Detail"
│	):
│		frappe.delete_doc("DocType", "Bank Reconciliation Detail", force=1)
⋮...

erpnext\patches\v15_0\create_advance_payment_status.py:
│def execute():
⋮...

erpnext\patches\v14_0\set_pick_list_status.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_query_report.py:
│def execute():
⋮...

erpnext\patches\v14_0\migrate_delivery_stop_lock_field.py:
│def execute():
│	if frappe.db.has_column("Delivery Stop", "lock"):
│		rename_field("Delivery Stop", "lock", "locked")
⋮...

erpnext\patches\v14_0\update_company_in_ldc.py:
│def execute():
│	company = get_default_company()
│	if company:
│		for d in frappe.get_all("Lower Deduction Certificate", pluck="name"):
│			frappe.db.set_value("Lower Deduction Certificate", d, "company", company, update_modified=False)
⋮...

erpnext\patches\v15_0\update_asset_status_to_work_in_progress.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_timesheet_changes.py:
│def execute():
⋮...

erpnext\patches\v11_1\delete_bom_browser.py:
│def execute():
│	frappe.delete_doc_if_exists("Page", "bom-browser")
⋮...

erpnext\patches\v14_0\delete_agriculture_doctypes.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_asset_value_for_manual_depr_entries.py:
│def execute():
⋮...

erpnext\accounts\report\accounts_payable_summary\accounts_payable_summary.py:
│def execute(filters=None):
│	args = {
│		"account_type": "Payable",
│		"naming_by": ["Buying Settings", "supp_master_name"],
│	}
│	return AccountsReceivableSummary(filters).run(args)
⋮...

erpnext\patches\v14_0\update_flag_for_return_invoices.py:
│def execute():
⋮...

erpnext\accounts\report\sales_invoice_trends\sales_invoice_trends.py:
│def execute(filters=None):
⋮...

erpnext\patches\v13_0\wipe_serial_no_field_for_0_qty.py:
│def execute():
⋮...

erpnext\patches\v15_0\sync_auto_reconcile_config.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_uom_conversion_factor.py:
│def execute():
⋮...

erpnext\patches\v14_0\set_period_start_end_date_in_pcv.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_serial_no_status.py:
│def execute():
⋮...

erpnext\patches\v11_1\set_variant_based_on.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_job_card_status.py:
│def execute():
⋮...

erpnext\patches\v11_1\setup_guardian_role.py:
│def execute():
│	if "Education" in frappe.get_active_domains() and not frappe.db.exists("Role", "Guardian"):
│		doc = frappe.new_doc("Role")
│		doc.update({"role_name": "Guardian", "desk_access": 0})
│
│		doc.insert(ignore_permissions=True)
⋮...

erpnext\patches\v12_0\create_irs_1099_field_united_states.py:
│def execute():
⋮...

erpnext\patches\v12_0\add_item_name_in_work_orders.py:
│def execute():
⋮...

erpnext\patches\v11_1\update_bank_transaction_status.py:
│def execute():
⋮...

erpnext\patches\v14_0\remove_hr_and_payroll_modules.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_owner_fields_in_acc_dimension_custom_fields.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_app_name.py:
│def execute():
│	frappe.reload_doctype("System Settings")
│	settings = frappe.get_doc("System Settings")
│	settings.db_set("app_name", "ERPNext", commit=True)
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_for_payment_request.py:
│def execute():
⋮...

erpnext\patches\v14_0\set_packed_qty_in_draft_delivery_notes.py:
│def execute():
⋮...

erpnext\patches\v13_0\fix_non_unique_represents_company.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_vehicle_no_reqd_condition.py:
│def execute():
⋮...

erpnext\patches\v14_0\migrate_crm_settings.py:
│def execute():
⋮...

erpnext\patches\v14_0\show_loan_management_deprecation_warning.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_purchase_receipt_amount_to_purchase_amount.py:
│def execute():
│	frappe.reload_doc("assets", "doctype", "asset")
│	if frappe.db.has_column("Asset", "purchase_receipt_amount"):
│		rename_field("Asset", "purchase_receipt_amount", "purchase_amount")
⋮...

erpnext\patches\v13_0\bill_for_rejected_quantity_in_purchase_invoice.py:
│def execute():
│	frappe.reload_doctype("Buying Settings")
│	buying_settings = frappe.get_single("Buying Settings")
│	buying_settings.bill_for_rejected_quantity_in_purchase_invoice = 0
│	buying_settings.save()
⋮...

erpnext\patches\v12_0\purchase_receipt_status.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_hospitality_doctypes.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_actual_start_and_end_date_in_wo.py:
│def execute():
⋮...

erpnext\patches\v11_0\uom_conversion_data.py:
│def execute():
⋮...

erpnext\patches\v13_0\show_hr_payroll_deprecation_warning.py:
│def execute():
⋮...

erpnext\patches\v11_0\rename_asset_adjustment_doctype.py:
│def execute():
│	if frappe.db.table_exists("Asset Adjustment") and not frappe.db.table_exists("Asset Value Adjustment"):
│		frappe.rename_doc("DocType", "Asset Adjustment", "Asset Value Adjustment", force=True)
│		frappe.reload_doc("assets", "doctype", "asset_value_adjustment")
⋮...

erpnext\patches\v13_0\shopify_deprecation_warning.py:
│def execute():
│	click.secho(
│		"Shopify Integration is moved to a separate app and will be removed from ERPNext in version-14.\n"
│		"Please install the app to continue using the integration: https://github.com/frappe/ecommerce_integrations",
│		fg="yellow",
│	)
⋮...

erpnext\patches\v12_0\replace_accounting_with_accounts_in_home_settings.py:
│def execute():
│	frappe.db.sql(
│		"""UPDATE `tabUser` SET `home_settings` = REPLACE(`home_settings`, 'Accounting', 'Accounts')"""
│	)
│	frappe.cache().delete_key("home_settings")
⋮...

erpnext\patches\v15_0\add_disassembly_order_stock_entry_type.py:
│def execute():
⋮...

erpnext\patches\v15_0\create_accounting_dimensions_in_payment_request.py:
│def execute():
│	create_accounting_dimensions_for_doctype(doctype="Payment Request")
⋮...

erpnext\patches\v12_0\set_production_capacity_in_workstation.py:
│def execute():
⋮...

erpnext\patches\v15_0\set_reserved_stock_in_bin.py:
│def execute():
⋮...

erpnext\patches\v13_0\create_custom_field_for_finance_book.py:
│def execute():
⋮...

erpnext\patches\v12_0\rename_account_type_doctype.py:
│def execute():
│	frappe.rename_doc("DocType", "Account Type", "Bank Account Type", force=True)
│	frappe.rename_doc("DocType", "Account Subtype", "Bank Account Subtype", force=True)
│	frappe.reload_doc("accounts", "doctype", "bank_account")
⋮...

erpnext\patches\v12_0\add_variant_of_in_item_attribute_table.py:
│def execute():
⋮...

erpnext\patches\v12_0\move_bank_account_swift_number_to_bank.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_number_of_depreciations_booked_to_opening_booked_depreciations.py:
│def execute():
│	if frappe.db.has_column("Asset", "number_of_depreciations_booked"):
│		rename_field("Asset", "number_of_depreciations_booked", "opening_number_of_booked_depreciations")
⋮...

erpnext\stock\report\bom_search\bom_search.py:
│def execute(filters=None):
⋮...

erpnext\patches\v13_0\loyalty_points_entry_for_pos_invoice.py:
│def execute():
⋮...

erpnext\patches\v11_0\rebuild_tree_for_company.py:
│def execute():
│	frappe.reload_doc("setup", "doctype", "company")
│	rebuild_tree("Company")
⋮...

erpnext\patches\v13_0\update_project_template_tasks.py:
│def execute():
⋮...

erpnext\patches\v13_0\setup_uae_vat_fields.py:
│def execute():
⋮...

erpnext\patches\v11_0\update_brand_in_item_price.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_operation_time_based_on_operating_cost.py:
│def execute():
⋮...

erpnext\selling\report\sales_partner_target_variance_based_on_item_group\sales_partner_target_variance_based_on_item_group.py:
│def execute(filters=None):
│	return get_data_column(filters, "Sales Partner")
⋮...

erpnext\patches\v14_0\update_total_asset_cost_field.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_amazon_mws_doctype.py:
│def execute():
│	frappe.delete_doc("DocType", "Amazon MWS Settings", ignore_missing=True)
⋮...

erpnext\patches\v12_0\move_target_distribution_from_parent_to_child.py:
│def execute():
⋮...

erpnext\patches\v15_0\fix_debit_credit_in_transaction_currency.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_total_number_of_booked_depreciations.py:
│def execute():
⋮...

erpnext\patches\v13_0\replace_pos_page_with_point_of_sale_page.py:
│def execute():
│	if frappe.db.exists("Page", "point-of-sale"):
│		frappe.rename_doc("Page", "pos", "point-of-sale", 1, 1)
⋮...

erpnext\patches\v15_0\rename_field_from_rate_difference_to_amount_difference.py:
│def execute():
⋮...

erpnext\patches\v11_0\rename_production_order_to_work_order.py:
│def execute():
⋮...

erpnext\patches\v11_1\set_status_for_material_request_type_manufacture.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_multi_uom_in_rfq.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_maintenance_schedule_field_in_visit.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_depreciation_amount_based_on_num_days_in_month_to_daily_prorata_based.py:
│def execute():
⋮...

erpnext\patches\v12_0\create_accounting_dimensions_in_missing_doctypes.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_is_cancelled_field.py:
│def execute():
⋮...

erpnext\patches\v13_0\reset_corrupt_defaults.py:
│def execute():
⋮...

erpnext\patches\v13_0\non_profit_deprecation_warning.py:
│def execute():
│	click.secho(
│		"Non Profit Domain is moved to a separate app and will be removed from ERPNext in version-14.\n"
│		"When upgrading to ERPNext version-14, please install the app to continue using the Non Profit domain: https://github.com/frappe/non_profit",
│		fg="yellow",
│	)
⋮...

erpnext\patches\v13_0\create_gst_payment_entry_fields.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_subcontracting_fields.py:
│def execute():
⋮...

erpnext\patches\v11_0\update_total_qty_field.py:
│def execute():
⋮...

erpnext\patches\v15_0\delete_ecommerce_doctypes.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_valid_till_date_in_supplier_quotation.py:
│def execute():
⋮...

erpnext\patches\v10_0\fichier_des_ecritures_comptables_for_france.py:
│def execute():
│	frappe.reload_doc("regional", "report", "fichier_des_ecritures_comptables_[fec]")
│	for d in frappe.get_all("Company", filters={"country": "France"}):
│		install_country_fixtures(d.name)
⋮...

erpnext\patches\v13_0\add_naming_series_to_old_projects.py:
│def execute():
⋮...

erpnext\patches\v15_0\rename_daily_depreciation_to_depreciation_amount_based_on_num_days_in_month.py:
│def execute():
⋮...

erpnext\patches\v13_0\hospitality_deprecation_warning.py:
│def execute():
│	click.secho(
│		"Hospitality domain is moved to a separate app and will be removed from ERPNext in version-14.\n"
│		"When upgrading to ERPNext version-14, please install the app to continue using the Hospitality domain: https://github.com/frappe/hospitality",
│		fg="yellow",
│	)
⋮...

erpnext\patches\v11_0\add_item_group_defaults.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_reserved_qty_closed_wo.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_hub_doctypes.py:
│def execute():
│	doctypes = frappe.get_all("DocType", {"module": "Hub Node", "custom": 0}, pluck="name")
│	for doctype in doctypes:
│		frappe.delete_doc("DocType", doctype, ignore_missing=True)
│
│	frappe.delete_doc("Module Def", "Hub Node", ignore_missing=True, force=True)
⋮...

erpnext\patches\v11_0\update_account_type_in_party_type.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_subscription.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_deferred_settings.py:
│def execute():
│	accounts_settings = frappe.get_doc("Accounts Settings", "Accounts Settings")
│	accounts_settings.book_deferred_entries_based_on = "Days"
│	accounts_settings.book_deferred_entries_via_journal_entry = 0
│	accounts_settings.submit_journal_entries = 0
│	accounts_settings.save()
⋮...

erpnext\patches\v13_0\update_exchange_rate_settings.py:
│def execute():
│	frappe.reload_doc("accounts", "doctype", "currency_exchange_settings")
│	setup_currency_exchange()
⋮...

erpnext\stock\doctype\stock_ledger_entry\patches\ensure_sle_indexes.py:
│def execute():
│	"""Ensure SLE Indexes"""
│
│	create_sle_indexes()
⋮...

erpnext\patches\v12_0\update_price_list_currency_in_bom.py:
│def execute():
⋮...

erpnext\patches\v10_0\rename_price_to_rate_in_pricing_rule.py:
│def execute():
⋮...

erpnext\patches\v12_0\fix_quotation_expired_status.py:
│def execute():
⋮...

erpnext\patches\v15_0\set_purchase_receipt_row_item_to_capitalization_stock_item.py:
│def execute():
⋮...

erpnext\patches\v11_0\make_italian_localization_fields.py:
│def execute():
⋮...

erpnext\patches\v13_0\add_po_to_global_search.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_default_batch_size.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_batch_valuation_flag.py:
│def execute():
⋮...

erpnext\patches\v14_0\enable_set_priority_for_pricing_rules.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_response_by_variance.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_reference_type_in_journal_entry_accounts.py:
│def execute():
⋮...

erpnext\patches\v11_0\update_department_lft_rgt.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_shopify_doctypes.py:
│def execute():
│	frappe.delete_doc("DocType", "Shopify Settings", ignore_missing=True)
│	frappe.delete_doc("DocType", "Shopify Log", ignore_missing=True)
⋮...

erpnext\patches\v12_0\set_automatically_process_deferred_accounting_in_accounts_settings.py:
│def execute():
│	frappe.reload_doc("accounts", "doctype", "accounts_settings")
│
│	frappe.db.set_single_value("Accounts Settings", "automatically_process_deferred_accounting_entry", 1)
⋮...

erpnext\patches\v13_0\delete_old_bank_reconciliation_doctypes.py:
│def execute():
⋮...

erpnext\patches\v11_0\rename_overproduction_percent_field.py:
│def execute():
⋮...

erpnext\patches\v11_1\make_job_card_time_logs.py:
│def execute():
⋮...

erpnext\patches\v13_0\remove_unknown_links_to_prod_plan_items.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_posting_datetime.py:
│def execute():
⋮...

erpnext\patches\v13_0\add_doctype_to_sla.py:
│def execute():
⋮...

erpnext\patches\v13_0\stock_entry_enhancements.py:
│def execute():
⋮...

erpnext\patches\v13_0\create_uae_pos_invoice_fields.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_due_date_in_gle.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_task_status.py:
│def execute():
⋮...

erpnext\patches\v13_0\replace_pos_payment_mode_table.py:
│def execute():
⋮...

erpnext\patches\v13_0\update_recipient_email_digest.py:
│def execute():
⋮...

erpnext\patches\v15_0\enable_old_serial_batch_fields.py:
│def execute():
│	sabb = frappe.get_all("Serial and Batch Bundle", filters={"docstatus": ("<", 2)}, limit=1)
│	if not sabb:
│		frappe.db.set_single_value("Stock Settings", "use_serial_batch_fields", 1)
⋮...

erpnext\patches\v13_0\add_standard_navbar_items.py:
│def execute():
│	# Add standard navbar items for ERPNext in Navbar Settings
│	add_standard_navbar_items()
⋮...

erpnext\patches\v15_0\delete_taxjar_doctypes.py:
│def execute():
⋮...

erpnext\patches\v13_0\fix_number_and_frequency_for_monthly_depreciation.py:
│def execute():
⋮...

erpnext\patches\v15_0\migrate_payment_request_status.py:
│def execute():
⋮...

erpnext\patches\v14_0\delete_non_profit_doctypes.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_subscription_details.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_total_batch_quantity.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_partial_tds_fields.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_bom_in_so_mr.py:
│def execute():
⋮...

erpnext\patches\v11_0\make_asset_finance_book_against_old_entries.py:
│def execute():
⋮...

erpnext\patches\v13_0\enable_provisional_accounting.py:
│def execute():
⋮...

erpnext\patches\v11_0\create_default_success_action.py:
│def execute():
│	frappe.reload_doc("core", "doctype", "success_action")
│	create_default_success_action()
⋮...

erpnext\patches\v15_0\saudi_depreciation_warning.py:
│def execute():
⋮...

erpnext\patches\v8_1\removed_roles_from_gst_report_non_indian_account.py:
│def execute():
⋮...

erpnext\patches\v11_0\add_market_segments.py:
│def execute():
│	frappe.reload_doc("crm", "doctype", "market_segment")
│
│	frappe.local.lang = frappe.db.get_default("lang") or "en"
│
│	add_market_segments()
⋮...

erpnext\patches\v13_0\change_default_item_manufacturer_fieldtype.py:
│def execute():
⋮...

erpnext\patches\v15_0\update_cc_in_process_statement_of_accounts.py:
│def execute():
⋮...

erpnext\patches\v12_0\rename_pos_closing_doctype.py:
│def execute():
⋮...

erpnext\patches\v15_0\enable_all_leads.py:
│def execute():
│	lead = frappe.qb.DocType("Lead")
│	frappe.qb.update(lead).set(lead.disabled, 0).set(lead.docstatus, 0).where(
│		lead.disabled == 1 and lead.docstatus == 1
│	).run()
⋮...

erpnext\patches\v13_0\agriculture_deprecation_warning.py:
│def execute():
│	click.secho(
│		"Agriculture Domain is moved to a separate app and will be removed from ERPNext in version-14.\n"
│		"Please install the app to continue using the Agriculture domain: https://github.com/frappe/agriculture",
│		fg="yellow",
│	)
⋮...

erpnext\patches\v13_0\set_work_order_qty_in_so_from_mr.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_employee_preferred_emails.py:
│def execute():
⋮...

erpnext\patches\v11_0\rename_bom_wo_fields.py:
│def execute():
⋮...

erpnext\patches\v14_0\set_maintain_stock_for_bom_item.py:
│def execute():
⋮...

erpnext\patches\v12_0\make_item_manufacturer.py:
│def execute():
⋮...

erpnext\patches\v14_0\update_stock_uom_in_work_order_item.py:
│def execute():
⋮...

erpnext\patches\v11_0\move_item_defaults_to_child_table_for_multicompany.py:
│def execute():
⋮...

erpnext\accounts\report\supplier_ledger_summary\supplier_ledger_summary.py:
│def execute(filters=None):
│	args = {
│		"party_type": "Supplier",
│		"naming_by": ["Buying Settings", "supp_master_name"],
│	}
│	return PartyLedgerSummaryReport(filters).run(args)
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_in_sales_order_item.py:
│def execute():
│	create_accounting_dimensions_for_doctype(doctype="Sales Order Item")
⋮...

erpnext\patches\v10_0\item_barcode_childtable_migrate.py:
│def execute():
⋮...

erpnext\patches\v11_0\update_backflush_subcontract_rm_based_on_bom.py:
│def execute():
⋮...

erpnext\patches\v15_0\delete_woocommerce_settings_doctype.py:
│def execute():
│	frappe.delete_doc("DocType", "Woocommerce Settings", ignore_missing=True)
⋮...

erpnext\patches\v14_0\delete_datev_doctypes.py:
│def execute():
⋮...

erpnext\buying\report\purchase_analytics\purchase_analytics.py:
│def execute(filters=None):
│	return Analytics(filters).run()
⋮...

erpnext\patches\v11_1\woocommerce_set_creation_user.py:
│def execute():
⋮...

erpnext\patches\v11_0\rename_members_with_naming_series.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_updated_purpose_in_pick_list.py:
│def execute():
│	frappe.reload_doc("stock", "doctype", "pick_list")
│	frappe.db.sql(
│		"""UPDATE `tabPick List` set purpose = 'Delivery'
│        WHERE docstatus = 1  and purpose = 'Delivery against Sales Order' """
│	)
⋮...

erpnext\crm\report\first_response_time_for_opportunity\first_response_time_for_opportunity.py:
│def execute(filters=None):
⋮...

erpnext\patches\v14_0\copy_is_subcontracted_value_to_is_old_subcontracting_flow.py:
│def execute():
│	for doctype in ["Purchase Order", "Purchase Receipt", "Purchase Invoice"]:
│		tab = frappe.qb.DocType(doctype).as_("tab")
│		frappe.qb.update(tab).set(tab.is_old_subcontracting_flow, 1).where(tab.is_subcontracted == 1).run()
⋮...

erpnext\patches\v11_1\delete_scheduling_tool.py:
│def execute():
│	if frappe.db.exists("DocType", "Scheduling Tool"):
│		frappe.delete_doc("DocType", "Scheduling Tool", ignore_permissions=True)
⋮...

erpnext\patches\v13_0\convert_qi_parameter_to_link_field.py:
│def execute():
⋮...

erpnext\patches\v15_0\remove_loan_management_module.py:
│def execute():
⋮...

erpnext\patches\v15_0\drop_index_posting_datetime_from_sle.py:
│def execute():
⋮...

erpnext\patches\v14_0\create_accounting_dimensions_for_closing_balance.py:
│def execute():
⋮...

erpnext\patches\v13_0\set_return_against_in_pos_invoice_references.py:
│def execute():
⋮...

erpnext\regional\report\electronic_invoice_register\electronic_invoice_register.py:
│def execute(filters=None):
│	return _execute(filters)
⋮...

erpnext\patches\v12_0\rename_pricing_rule_child_doctypes.py:
│def execute():
│	for old_doc, new_doc in doctypes.items():
│		if not frappe.db.table_exists(new_doc) and frappe.db.table_exists(old_doc):
│			frappe.rename_doc("DocType", old_doc, new_doc)
│			frappe.reload_doc("accounts", "doctype", frappe.scrub(new_doc))
│			frappe.delete_doc("DocType", old_doc)
⋮...

erpnext\patches\v15_0\set_standard_stock_entry_type.py:
│def execute():
⋮...

erpnext\patches\v12_0\update_item_tax_template_company.py:
│def execute():
⋮...

erpnext\patches\v15_0\migrate_to_utm_analytics.py:
│def execute():
⋮...

erpnext\accounts\report\purchase_invoice_trends\purchase_invoice_trends.py:
│def execute(filters=None):
⋮...

erpnext\patches\v13_0\requeue_recoverable_reposts.py:
│def execute():
⋮...

erpnext\patches\v15_0\migrate_old_item_wise_tax_detail_data_format.py:
│def execute():
⋮...

erpnext\patches\v12_0\set_italian_import_supplier_invoice_permissions.py:
│def execute():
│	countries = frappe.get_all("Company", fields="country")
│	countries = [country["country"] for country in countries]
│	if "Italy" in countries:
│		add_permissions()
⋮...

erpnext\patches\v11_0\add_sales_stages.py:
│def execute():
│	frappe.reload_doc("crm", "doctype", "sales_stage")
│
│	frappe.local.lang = frappe.db.get_default("lang") or "en"
│
│	add_sale_stages()
⋮...

erpnext\buying\doctype\supplier_scorecard\supplier_scorecard_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\purchase_invoice\purchase_invoice_dashboard.py:
│def get_data():
⋮...

erpnext\stock\doctype\pick_list\pick_list_dashboard.py:
│def get_data():
⋮...

erpnext\manufacturing\doctype\production_plan\production_plan_dashboard.py:
│def get_data():
⋮...

erpnext\buying\doctype\supplier\supplier_dashboard.py:
│def get_data():
⋮...

erpnext\manufacturing\doctype\workstation\workstation_dashboard.py:
│def get_data():
⋮...

erpnext\setup\doctype\holiday_list\holiday_list_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\sales_invoice\sales_invoice_dashboard.py:
│def get_data():
⋮...

erpnext\manufacturing\doctype\job_card\job_card_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\payment_request\payment_request_dashboard.py:
│def get_data():
⋮...

erpnext\buying\doctype\supplier_quotation\supplier_quotation_dashboard.py:
│def get_data():
⋮...

erpnext\selling\doctype\customer\customer_dashboard.py:
│def get_data():
⋮...

erpnext\stock\doctype\stock_closing_entry\stock_closing_entry_dashboard.py:
│def get_data():
⋮...

erpnext\stock\doctype\delivery_note\delivery_note_dashboard.py:
│def get_data():
⋮...

erpnext\manufacturing\doctype\blanket_order\blanket_order_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "blanket_order",
│		"transactions": [{"items": ["Purchase Order", "Sales Order", "Quotation"]}],
│	}
⋮...

erpnext\accounts\doctype\payment_terms_template\payment_terms_template_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\subscription_plan\subscription_plan_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "subscription_plan",
│		"non_standard_fieldnames": {"Payment Request": "plan", "Subscription": "plan"},
│		"transactions": [{"label": _("References"), "items": ["Payment Request", "Subscription"]}],
│	}
⋮...

erpnext\buying\doctype\purchase_order\purchase_order_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\item_tax_template\item_tax_template_dashboard.py:
│def get_data():
⋮...

erpnext\assets\doctype\asset\asset_dashboard.py:
│def get_data():
│	return {
│		"non_standard_fieldnames": {"Asset Movement": "asset"},
│		"transactions": [{"label": _("Movement"), "items": ["Asset Movement"]}],
│	}
⋮...

erpnext\manufacturing\doctype\operation\operation_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "operation",
│		"transactions": [{"label": _("Manufacture"), "items": ["BOM", "Work Order", "Job Card"]}],
│	}
⋮...

erpnext\stock\doctype\stock_entry\stock_entry_dashboard.py:
│def get_data():
⋮...

erpnext\manufacturing\doctype\work_order\test_work_order.py:
│def make_wo_order_test_record(**args):
⋮...
│def allow_overproduction(fieldname, percentage):
│	doc = frappe.get_doc("Manufacturing Settings")
│	doc.update({fieldname: percentage})
│	doc.save()
⋮...
│def make_workstation(**kwargs):
⋮...
│def make_operation(**kwargs):
⋮...
│def update_job_card(job_card, jc_qty=None, days=None):
⋮...
│class UnitTestWorkOrder(UnitTestCase):
⋮...
│class TestWorkOrder(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.warehouse = "_Test Warehouse 2 - _TC"
│		self.item = "_Test Item"
│		prepare_data_for_backflush_based_on_materials_transferred()
⋮...
│	def tearDown(self):
│		frappe.local.future_sle = {}
│		frappe.db.rollback()
⋮...
│	def check_planned_qty(self):
⋮...
│	def test_over_production(self):
⋮...
│	def test_planned_operating_cost(self):
⋮...
│	def test_reserved_qty_for_partial_completion(self):
⋮...
│	def test_production_item(self):
⋮...
│	def test_reserved_qty_for_production_submit(self):
⋮...
│	def test_reserved_qty_for_production_cancel(self):
⋮...
│	def test_reserved_qty_for_production_on_stock_entry(self):
⋮...
│	def test_reserved_qty_for_production_closed(self):
⋮...
│	def test_backflush_qty_for_overpduction_manufacture(self):
⋮...
│	def test_reserved_qty_for_stopped_production(self):
⋮...
│	def test_scrap_material_qty(self):
⋮...
│	def test_allow_overproduction(self):
⋮...
│	def test_over_production_for_sales_order(self):
⋮...
│	def test_work_order_with_non_stock_item(self):
⋮...
│	def test_job_card(self):
⋮...
│	def test_work_order_material_transferred_qty_with_process_loss(self):
⋮...
│	def test_capcity_planning(self):
⋮...
│	def test_work_order_with_non_transfer_item(self):
⋮...
│	def test_cost_center_for_manufacture(self):
│		wo_order = make_wo_order_test_record()
│		ste = make_stock_entry(wo_order.name, "Material Transfer for Manufacture", wo_order.qty)
│		self.assertEqual(ste.get("items")[0].get("cost_center"), "_Test Cost Center - _TC")
⋮...
│	def test_operation_time_with_batch_size(self):
⋮...
│	def test_batch_size_for_fg_item(self):
⋮...
│	def test_partial_material_consumption(self):
⋮...
│	def test_extra_material_transfer(self):
⋮...
│	def test_make_stock_entry_for_customer_provided_item(self):
⋮...
│	def test_valuation_rate_missing_on_make_stock_entry(self):
⋮...
│	def test_wo_completion_with_pl_bom(self):
⋮...
│	def test_job_card_scrap_item(self):
⋮...
│	def test_close_work_order(self):
⋮...
│	def test_fix_time_operations(self):
⋮...
│	def test_partial_manufacture_entries(self):
⋮...
│	def test_auto_batch_creation(self):
⋮...
│	def test_auto_serial_no_creation(self):
⋮...
│	def test_auto_serial_no_batch_creation(self):
⋮...
│	def get_serial_nos_for_fg(self, work_order):
│		serial_nos = []
│		for row in frappe.get_all("Serial No", filters={"work_order": work_order}):
│			serial_nos.append(row.name)
│
│		return serial_nos
⋮...
│	def test_manufacture_entry_mapped_idx_with_exploded_bom(self):
⋮...
│	def test_work_order_multiple_material_transfer(self):
⋮...
│	def test_backflushed_batch_raw_materials_based_on_transferred(self):
⋮...
│	def test_backflushed_serial_no_raw_materials_based_on_transferred(self):
⋮...
│	def test_backflushed_serial_no_batch_raw_materials_based_on_transferred(self):
⋮...
│	def test_backflushed_batch_raw_materials_based_on_transferred_autosabb(self):
⋮...
│	def test_backflushed_serial_no_raw_materials_based_on_transferred_autosabb(self):
⋮...
│	def test_backflushed_serial_no_batch_raw_materials_based_on_transferred_autosabb(self):
⋮...
│	def test_non_consumed_material_return_against_work_order(self):
⋮...
│	def test_workstation_type_for_work_order(self):
⋮...
│	def test_job_card_extra_qty(self):
⋮...
│	def test_operating_cost_account(self):
⋮...
│	def test_op_cost_and_scrap_based_on_sub_assemblies(self):
⋮...
│	def test_get_rm_cost_from_consumption_entry(self):
⋮...
│	def test_capcity_planning_for_workstation(self):
⋮...
│	def test_partial_material_consumption_with_batch(self):
⋮...
│	def test_disassemby_order(self):
⋮...
│	def test_components_alternate_item_for_bom_based_manufacture_entry(self):
⋮...
│	def test_components_qty_for_bom_based_manufacture_entry(self):
⋮...
│	def test_components_as_per_bom_for_manufacture_entry(self):
⋮...
│	def test_wip_skip(self):
⋮...
│	def test_serial_no_status_for_stock_entry(self):
⋮...
│	def test_stock_reservation_for_serialized_raw_material(self):
⋮...
│	def test_stock_reservation_for_batched_raw_material(self):
⋮...
│	def test_auto_stock_reservation_for_batched_raw_material(self):
⋮...
│	def test_work_order_valuation_auto_pick(self):
⋮...
│def make_stock_in_entries_and_get_batches(rm_item, source_warehouse, wip_warehouse):
⋮...
│def prepare_boms_for_sub_assembly_test():
⋮...
│def prepare_data_for_workstation_type_check():
⋮...
│def prepare_data_for_backflush_based_on_materials_transferred():
⋮...
│def get_scrap_item_details(bom_no):
⋮...

erpnext\accounts\doctype\tax_withholding_category\tax_withholding_category_dashboard.py:
│def get_data():
│	return {"fieldname": "tax_withholding_category", "transactions": [{"items": ["Supplier"]}]}
⋮...

erpnext\stock\doctype\batch\batch_dashboard.py:
│def get_data():
⋮...

erpnext\stock\doctype\purchase_receipt\purchase_receipt_dashboard.py:
│def get_data():
⋮...

erpnext\subcontracting\doctype\subcontracting_order\subcontracting_order_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "subcontracting_order",
│		"transactions": [{"label": _("Reference"), "items": ["Subcontracting Receipt", "Stock Entry"]}],
│	}
⋮...

erpnext\accounts\doctype\fiscal_year\fiscal_year_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\payment_term\payment_term_dashboard.py:
│def get_data():
⋮...

erpnext\setup\doctype\sales_person\sales_person_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\invoice_discounting\invoice_discounting_dashboard.py:
│def get_data():
⋮...

erpnext\setup\doctype\vehicle\vehicle_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "license_plate",
│		"non_standard_fieldnames": {"Delivery Trip": "vehicle"},
│		"transactions": [{"items": ["Vehicle Log"]}, {"items": ["Delivery Trip"]}],
│	}
⋮...

erpnext\accounts\doctype\sales_taxes_and_charges_template\sales_taxes_and_charges_template_dashboard.py:
│def get_data():
⋮...

erpnext\selling\doctype\sales_order\sales_order_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\purchase_taxes_and_charges_template\purchase_taxes_and_charges_template_dashboard.py:
│def get_data():
⋮...

erpnext\support\doctype\issue\issue_dashboard.py:
│def get_data():
│	return {"fieldname": "issue", "transactions": [{"label": _("Activity"), "items": ["Task"]}]}
⋮...

erpnext\accounts\doctype\finance_book\finance_book_dashboard.py:
│def get_data():
⋮...

erpnext\stock\doctype\item\item_dashboard.py:
│def get_data():
⋮...

erpnext\setup\doctype\company\company_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\payment_order\payment_order_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "payment_order",
│		"transactions": [{"items": ["Payment Entry", "Journal Entry"]}],
│	}
⋮...

erpnext\manufacturing\doctype\routing\routing_dashboard.py:
│def get_data():
│	return {"fieldname": "routing", "transactions": [{"items": ["BOM"]}]}
⋮...

erpnext\stock\doctype\material_request\material_request_dashboard.py:
│def get_data():
⋮...

erpnext\buying\doctype\request_for_quotation\request_for_quotation_dashboard.py:
│def get_data():
⋮...

erpnext\manufacturing\doctype\bom\bom_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\payment_gateway_account\payment_gateway_account_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "payment_gateway_account",
│		"non_standard_fieldnames": {"Subscription Plan": "payment_gateway"},
│		"transactions": [{"items": ["Payment Request"]}, {"items": ["Subscription Plan"]}],
│	}
⋮...

erpnext\accounts\doctype\tax_category\tax_category_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\promotional_scheme\promotional_scheme_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "promotional_scheme",
│		"transactions": [{"label": _("Reference"), "items": ["Pricing Rule"]}],
│	}
⋮...

erpnext\selling\doctype\quotation\quotation_dashboard.py:
│def get_data():
⋮...

erpnext\crm\doctype\lead\lead_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\shipping_rule\shipping_rule_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\loyalty_program\loyalty_program_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "loyalty_program",
│		"transactions": [{"items": ["Sales Invoice", "Customer"]}],
│	}
⋮...

erpnext\accounts\doctype\shareholder\shareholder_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "shareholder",
│		"non_standard_fieldnames": {"Share Transfer": "to_shareholder"},
│		"transactions": [{"items": ["Share Transfer"]}],
│	}
⋮...

erpnext\manufacturing\doctype\work_order\work_order_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\cost_center\cost_center_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "cost_center",
│		"reports": [{"label": _("Reports"), "items": ["Budget Variance Report", "General Ledger"]}],
│	}
⋮...

erpnext\accounts\doctype\exchange_rate_revaluation\exchange_rate_revaluation_dashboard.py:
│def get_data():
│	return {"fieldname": "reference_name", "transactions": [{"items": ["Journal Entry"]}]}
⋮...

erpnext\stock\dashboard\item_dashboard.py:
│def get_data(
│	item_code=None, warehouse=None, item_group=None, start=0, sort_by="actual_qty", sort_order="desc"
│):
⋮...

erpnext\crm\doctype\opportunity\opportunity_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\process_payment_reconciliation\process_payment_reconciliation_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\monthly_distribution\monthly_distribution_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\bank\bank_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "bank",
│		"transactions": [{"label": _("Bank Details"), "items": ["Bank Account", "Bank Guarantee"]}],
│	}
⋮...

erpnext\subcontracting\doctype\subcontracting_receipt\subcontracting_receipt_dashboard.py:
│def get_data():
⋮...

erpnext\accounts\doctype\share_type\share_type_dashboard.py:
│def get_data():
│	return {
│		"fieldname": "share_type",
│		"transactions": [{"label": _("References"), "items": ["Share Transfer", "Shareholder"]}],
│	}
⋮...

erpnext\config\projects.py:
│def get_data():
⋮...

erpnext\buying\doctype\purchase_order\test_purchase_order.py:
│def create_purchase_order(**args):
⋮...
│def get_ordered_qty(item_code="_Test Item", warehouse="_Test Warehouse - _TC"):
│	return flt(frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse}, "ordered_qty"))
⋮...
│def prepare_data_for_internal_transfer():
⋮...
│def make_pr_against_po(po, received_qty=0):
│	pr = make_purchase_receipt(po)
│	pr.get("items")[0].qty = received_qty or 5
│	pr.insert()
│	pr.submit()
│	return pr
⋮...
│def create_pr_against_po(po, received_qty=4):
│	pr = make_purchase_receipt(po)
│	pr.get("items")[0].qty = received_qty
│	pr.insert()
│	pr.submit()
│	return pr
⋮...
│def get_requested_qty(item_code="_Test Item", warehouse="_Test Warehouse - _TC"):
│	return flt(frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse}, "indented_qty"))
⋮...
│class UnitTestPurchaseOrder(UnitTestCase):
⋮...
│class TestPurchaseOrder(IntegrationTestCase):
⋮...
│	def test_purchase_order_qty(self):
⋮...
│	def test_make_purchase_receipt(self):
⋮...
│	def test_ordered_qty(self):
⋮...
│	def test_ordered_qty_against_pi_with_update_stock(self):
⋮...
│	def test_update_remove_child_linked_to_mr(self):
⋮...
│	def test_update_child(self):
⋮...
│	def test_update_child_adding_new_item(self):
⋮...
│	def test_update_child_removing_item(self):
⋮...
│	def test_update_child_perm(self):
⋮...
│	def test_update_child_with_tax_template(self):
⋮...
│	def test_update_qty(self):
⋮...
│	def test_return_against_purchase_order(self):
⋮...
│	def test_purchase_order_invoice_receipt_workflow(self):
⋮...
│	def test_make_purchase_invoice(self):
⋮...
│	def test_purchase_order_on_hold(self):
⋮...
│	def test_make_purchase_invoice_with_terms(self):
⋮...
│	def test_warehouse_company_validation(self):
│		from erpnext.stock.utils import InvalidWarehouseCompany
│
│		po = create_purchase_order(company="_Test Company 1", do_not_save=True)
│		self.assertRaises(InvalidWarehouseCompany, po.insert)
⋮...
│	def test_uom_integer_validation(self):
│		from erpnext.utilities.transaction_base import UOMMustBeIntegerError
│
│		po = create_purchase_order(qty=3.4, do_not_save=True)
│		self.assertRaises(UOMMustBeIntegerError, po.insert)
⋮...
│	def test_ordered_qty_for_closing_po(self):
⋮...
│	def test_group_same_items(self):
⋮...
│	def test_make_po_without_terms(self):
⋮...
│	def test_po_for_blocked_supplier_all(self):
⋮...
│	def test_po_for_blocked_supplier_invoices(self):
⋮...
│	def test_po_for_blocked_supplier_payments(self):
⋮...
│	def test_po_for_blocked_supplier_payments_with_today_date(self):
⋮...
│	def test_po_for_blocked_supplier_payments_past_date(self):
⋮...
│	def test_default_payment_terms(self):
│		due_date = get_due_date_from_template("_Test Payment Term Template 1", "2023-02-03", None).strftime(
│			"%Y-%m-%d"
│		)
│		self.assertEqual(due_date, "2023-03-31")
⋮...
│	def test_terms_are_not_copied_if_automatically_fetch_payment_terms_is_unchecked(self):
⋮...
│	def test_terms_copied(self):
⋮...
│	def test_advance_payment_entry_unlink_against_purchase_order(self):
⋮...
│	def create_account(self, account_name, company, currency, parent):
⋮...
│	def test_advance_payment_with_separate_party_account_enabled(self):
⋮...
│	def test_advance_paid_upon_payment_entry_cancellation(self):
⋮...
│	def test_schedule_date(self):
⋮...
│	def test_po_optional_blanket_order(self):
⋮...
│	def test_blanket_order_on_po_close_and_open(self):
⋮...
│	def test_payment_terms_are_fetched_when_creating_purchase_invoice(self):
⋮...
│	def test_internal_transfer_flow(self):
⋮...
│	def test_variant_item_po(self):
│		po = create_purchase_order(item_code="_Test Variant Item", qty=1, rate=100, do_not_save=1)
│
│		self.assertRaises(frappe.ValidationError, po.save)
⋮...
│	def test_update_items_for_subcontracting_purchase_order(self):
⋮...
│	def test_new_sc_flow(self):
⋮...
│	def test_auto_create_subcontracting_order(self):
⋮...
│	def test_purchase_order_advance_payment_status(self):
⋮...
│	def test_po_billed_amount_against_return_entry(self):
⋮...
│def create_po_for_sc_testing():
⋮...
│def get_same_items():
⋮...

erpnext\stock\utils.py:
│def get_stock_balance(
│	item_code,
│	warehouse,
│	posting_date=None,
│	posting_time=None,
│	with_valuation_rate=False,
│	with_serial_no=False,
│	inventory_dimensions_dict=None,
│):
⋮...
│def get_or_make_bin(item_code: str, warehouse: str) -> str:
⋮...
│def get_combine_datetime(posting_date, posting_time):
⋮...
│def get_bin(item_code, warehouse):
⋮...
│def get_incoming_rate(args, raise_error_if_no_rate=True):
⋮...
│def get_valuation_method(item_code):
│	"""get valuation method from item or default"""
│	val_method = frappe.db.get_value("Item", item_code, "valuation_method", cache=True)
│	if not val_method:
│		val_method = frappe.db.get_single_value("Stock Settings", "valuation_method", cache=True) or "FIFO"
│	return val_method
⋮...
│def is_reposting_item_valuation_in_progress():
⋮...
│class InvalidWarehouseCompany(frappe.ValidationError):
│	pass
⋮...
│def get_stock_value_on(
│	warehouses: list | str | None = None,
⋮...
│def validate_warehouse_company(warehouse, company):
⋮...
│def scan_barcode(search_value: str) -> BarcodeScanResult:
⋮...
│def _create_bin(item_code, warehouse):
⋮...
│def _get_fifo_lifo_rate(previous_stock_queue, qty, method):
⋮...
│def get_valid_serial_nos(sr_nos, qty=0, item_code=""):
⋮...
│def validate_disabled_warehouse(warehouse):
⋮...
│def update_included_uom_in_report(columns, result, include_uom, conversion_factors):
⋮...
│def _update_item_info(scan_result: dict[str, str | None]) -> dict[str, str | None]:
⋮...
│class PendingRepostingError(frappe.ValidationError):
│	pass
⋮...
│def get_serial_nos_data(serial_nos):
│	from erpnext.stock.doctype.serial_no.serial_no import get_serial_nos
│
│	return get_serial_nos(serial_nos)
⋮...
│def get_latest_stock_qty(item_code, warehouse=None):
⋮...
│def is_group_warehouse(warehouse):
│	if frappe.db.get_value("Warehouse", warehouse, "is_group", cache=True):
│		frappe.throw(_("Group node warehouse is not allowed to select for transactions"))
⋮...
│def get_incoming_outgoing_rate_for_cancel(item_code, voucher_type, voucher_no, voucher_detail_no):
⋮...
│def check_pending_reposting(posting_date: str, throw_error: bool = True) -> bool:
⋮...
│def get_default_stock_uom() -> str | None:
⋮...
│def get_stock_value_from_bin(warehouse=None, item_code=None):
⋮...
│def get_latest_stock_balance():
⋮...
│def get_batch_incoming_rate(item_code, warehouse, batch_no, posting_date, posting_time, creation=None):
⋮...
│def get_avg_purchase_rate(serial_nos):
⋮...
│def get_fifo_rate(previous_stock_queue, qty):
│	"""get FIFO (average) Rate from Queue"""
│	return _get_fifo_lifo_rate(previous_stock_queue, qty, "FIFO")
⋮...
│def get_lifo_rate(previous_stock_queue, qty):
│	"""get LIFO (average) Rate from Queue"""
│	return _get_fifo_lifo_rate(previous_stock_queue, qty, "LIFO")
⋮...
│def add_additional_uom_columns(columns, result, include_uom, conversion_factors):
⋮...

erpnext\manufacturing\doctype\production_plan\test_production_plan.py:
│def make_bom(**args):
⋮...
│def create_production_plan(**args):
⋮...
│class UnitTestProductionPlan(UnitTestCase):
⋮...
│class TestProductionPlan(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self) -> None:
│		frappe.db.rollback()
⋮...
│	def test_production_plan_mr_creation(self):
⋮...
│	def test_production_plan_start_date(self):
⋮...
│	def test_production_plan_for_existing_ordered_qty(self):
⋮...
│	def test_production_plan_with_non_stock_item(self):
│		"Test if MR Planning table includes Non Stock RM."
│		pln = create_production_plan(item_code="Test Production Item 1", include_non_stock_items=1)
│		self.assertTrue(len(pln.mr_items), 3)
│		pln.cancel()
⋮...
│	def test_production_plan_without_multi_level(self):
│		"Test MR Planning table for non exploded BOM."
│		pln = create_production_plan(item_code="Test Production Item 1", use_multi_level_bom=0)
│		self.assertTrue(len(pln.mr_items), 2)
│		pln.cancel()
⋮...
│	def test_production_plan_without_multi_level_for_existing_ordered_qty(self):
⋮...
│	def test_production_plan_sales_orders(self):
⋮...
│	def test_donot_allow_to_make_multiple_pp_against_same_so(self):
⋮...
│	def test_so_based_bill_of_material(self):
⋮...
│	def test_production_plan_with_non_active_bom_item(self):
⋮...
│	def test_production_plan_combine_items(self):
⋮...
│	def test_production_plan_subassembly_default_supplier(self):
⋮...
│	def test_production_plan_for_subcontracting_po(self):
⋮...
│	def test_production_plan_for_mr_items(self):
⋮...
│	def test_production_plan_combine_subassembly(self):
⋮...
│	def test_pp_to_mr_customer_provided(self):
⋮...
│	def test_production_plan_with_multi_level_bom(self):
⋮...
│	def test_get_warehouse_list_group(self):
⋮...
│	def test_get_warehouse_list_single(self):
⋮...
│	def test_get_sales_order_with_variant(self):
⋮...
│	def test_multiple_work_order_for_production_plan_item(self):
⋮...
│	def test_production_plan_pending_qty_with_sales_order(self):
⋮...
│	def test_production_plan_pending_qty_independent_items(self):
⋮...
│	def test_qty_based_status(self):
⋮...
│	def test_production_plan_planned_qty(self):
⋮...
│	def test_temporary_name_relinking(self):
⋮...
│	def test_produced_qty_for_multi_level_bom_item(self):
⋮...
│	def test_material_request_item_for_purchase_uom(self):
⋮...
│	def test_material_request_for_sub_assembly_items(self):
⋮...
│	def test_resered_qty_for_production_plan_for_material_requests(self):
⋮...
│	def test_resered_qty_for_production_plan_for_work_order(self):
⋮...
│	def test_resered_qty_for_production_plan_for_less_rm_qty(self):
⋮...
│	def test_resered_qty_for_production_plan_for_material_requests_with_multi_UOM(self):
⋮...
│	def test_from_warehouse_for_purchase_material_request(self):
⋮...
│	def test_skip_available_qty_for_sub_assembly_items(self):
⋮...
│	def test_sub_assembly_and_their_raw_materials_exists(self):
⋮...
│	def test_transfer_and_purchase_mrp_for_purchase_uom(self):
⋮...
│	def test_mr_qty_for_complex_bom(self):
⋮...
│	def test_mr_qty_for_same_rm_with_different_sub_assemblies(self):
⋮...
│	def test_reserve_sub_assembly_items(self):
⋮...
│	def test_material_request_qty_purchase_and_material_transfer(self):
⋮...
│	def test_unreserve_qty_on_closing_of_pp(self):
⋮...
│	def test_min_order_qty_in_pp(self):
⋮...
│	def test_fg_item_quantity(self):
⋮...
│	def test_parent_warehouse_for_sub_assembly_items(self):
⋮...
│	def test_calculation_of_sub_assembly_items(self):
⋮...

erpnext\manufacturing\doctype\bom\bom.py:
│def get_list_context(context):
│	context.title = _("Bill of Materials")
⋮...
│def get_children(parent=None, is_root=False, **filters):
⋮...
│def get_valuation_rate(data):
⋮...
│def get_bom_items_as_dict(
│	bom,
│	company,
│	qty=1,
│	fetch_exploded=1,
│	fetch_scrap_items=0,
│	include_non_stock_items=False,
│	fetch_qty_in_stock_uom=True,
│):
⋮...
│def item_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│class BOMTree:
⋮...
│class BOM(WebsiteGenerator):
⋮...
│def validate_bom_no(item, bom_no):
⋮...
│class BOMRecursionError(frappe.ValidationError):
│	pass
⋮...
│def get_bom_item_rate(args, bom_doc):
⋮...
│def get_bom_items(bom, company, qty=1, fetch_exploded=1):
│	items = get_bom_items_as_dict(bom, company, qty, fetch_exploded, include_non_stock_items=True).values()
│	items = list(items)
│	items.sort(key=functools.cmp_to_key(lambda a, b: a.item_code > b.item_code and 1 or -1))
│	return items
⋮...
│def get_op_cost_from_sub_assemblies(bom_no, op_cost=0):
⋮...
│def get_scrap_items_from_sub_assemblies(bom_no, company, qty, scrap_items=None):
⋮...
│	def __init__(self, name: str, is_bom: bool = True, exploded_qty: float = 1.0, qty: float = 1) -> None:
⋮...
│	def __create_tree(self):
⋮...
│	def level_order_traversal(self) -> list["BOMTree"]:
⋮...
│	def __str__(self) -> str:
│		return (
│			f"{self.item_code}{' - ' + self.name if self.is_bom else ''} qty(per unit): {self.qty}"
│			f" exploded_qty: {self.exploded_qty}"
│		)
⋮...
│	def __repr__(self, level: int = 0) -> str:
│		rep = "┃  " * (level - 1) + "┣━ " * (level > 0) + str(self) + "\n"
│		for child in self.child_items:
│			rep += child.__repr__(level=level + 1)
│		return rep
⋮...
│	def autoname(self):
⋮...
│	def get_index_for_bom(self, existing_boms):
│		index = 1
│		if existing_boms:
│			index = self.get_next_version_index(existing_boms)
│
│		return index
⋮...
│	def onload(self):
│		super().onload()
│
│		self.set_onload_for_muulti_level_bom()
⋮...
│	def set_onload_for_muulti_level_bom(self):
⋮...
│	def get_next_version_index(existing_boms: list[str]) -> int:
⋮...
│	def validate(self):
⋮...
│	def set_default_uom(self):
⋮...
│	def get_context(self, context):
│		context.parents = [{"name": "boms", "title": _("All BOMs")}]
⋮...
│	def on_update(self):
│		frappe.cache().hdel("bom_children", self.name)
│		self.check_recursion()
⋮...
│	def on_submit(self):
│		self.manage_default_bom()
│		self.update_bom_creator_status()
⋮...
│	def on_cancel(self):
⋮...
│	def update_bom_creator_status(self):
⋮...
│	def on_update_after_submit(self):
│		self.validate_bom_links()
│		self.manage_default_bom()
⋮...
│	def get_item_det(self, item_code):
⋮...
│	def get_routing(self):
⋮...
│	def set_bom_material_details(self):
⋮...
│	def set_bom_scrap_items_detail(self):
⋮...
│	def get_bom_material_detail(self, args=None):
⋮...
│	def validate_bom_currency(self, item):
⋮...
│	def get_rm_rate(self, arg):
⋮...
│	def update_cost(self, update_parent=True, from_child_bom=False, update_hour_rate=True, save=True):
⋮...
│	def update_parent_cost(self):
⋮...
│	def get_bom_unitcost(self, bom_no):
⋮...
│	def manage_default_bom(self):
⋮...
│	def clear_operations(self):
│		if not self.with_operations:
│			self.set("operations", [])
│
│		if not self.with_operations and self.track_semi_finished_goods:
│			self.track_semi_finished_goods = 0
⋮...
│	def clear_inspection(self):
│		if not self.inspection_required:
│			self.quality_inspection_template = None
⋮...
│	def validate_main_item(self):
⋮...
│	def validate_currency(self):
⋮...
│	def update_stock_qty(self):
⋮...
│	def validate_uom_is_interger(self):
│		from erpnext.utilities.transaction_base import validate_uom_is_integer
│
│		validate_uom_is_integer(self, "uom", "qty", "BOM Item")
│		validate_uom_is_integer(self, "stock_uom", "stock_qty", "BOM Item")
⋮...
│	def set_conversion_rate(self):
⋮...
│	def set_plc_conversion_rate(self):
⋮...
│	def validate_materials(self):
⋮...
│	def check_recursion(self, bom_list=None):
⋮...
│	def set_materials_based_on_operation_bom(self):
⋮...
│	def add_raw_materials(self, operation_row_id, items):
⋮...
│	def add_materials_from_bom(self, finished_good, bom_no, operation_row_id, qty=None):
⋮...
│	def traverse_tree(self, bom_list=None):
⋮...
│	def calculate_cost(self, save_updates=False, update_hour_rate=False):
⋮...
│	def calculate_op_cost(self, update_hour_rate=False):
⋮...
│	def update_rate_and_time(self, row, update_hour_rate=False):
⋮...
│	def calculate_rm_cost(self, save=False):
⋮...
│	def calculate_sm_cost(self, save=False):
⋮...
│	def calculate_exploded_cost(self):
⋮...
│	def get_rm_rate_map(self) -> dict[str, float]:
⋮...
│	def update_exploded_items(self, save=True):
│		"""Update Flat BOM, following will be correct data"""
│		self.get_exploded_items()
│		self.add_exploded_items(save=save)
⋮...
│	def get_exploded_items(self):
⋮...
│	def company_currency(self):
│		return erpnext.get_company_currency(self.company)
⋮...
│	def add_to_cur_exploded_items(self, args):
│		if self.cur_exploded_items.get(args.item_code):
│			self.cur_exploded_items[args.item_code]["stock_qty"] += args.stock_qty
│		else:
│			self.cur_exploded_items[args.item_code] = args
⋮...
│	def get_child_exploded_items(self, bom_no, stock_qty, operation=None):
⋮...
│	def add_exploded_items(self, save=True):
⋮...
│	def validate_bom_links(self):
⋮...
│	def validate_transfer_against(self):
⋮...
│	def set_routing_operations(self):
│		if self.routing and self.with_operations and not self.operations:
│			self.get_routing()
⋮...
│	def validate_operations(self):
⋮...
│	def get_tree_representation(self) -> BOMTree:
│		"""Get a complete tree representation preserving order of child items."""
│		return BOMTree(self.name)
⋮...
│	def set_process_loss_qty(self):
│		if self.process_loss_percentage:
│			self.process_loss_qty = flt(self.quantity) * flt(self.process_loss_percentage) / 100
⋮...
│	def validate_scrap_items(self):
⋮...
│def add_additional_cost(stock_entry, work_order):
⋮...
│def add_non_stock_items_cost(stock_entry, work_order, expense_account):
⋮...
│def add_operations_cost(stock_entry, work_order=None, expense_account=None):
⋮...
│def get_bom_diff(bom1, bom2):
⋮...
│def make_variant_bom(source_name, bom_no, item, variant_items, target_doc=None):
⋮...

erpnext\stock\stock_ledger.py:
│def get_stock_ledger_entries(
│	previous_sle,
│	operator=None,
│	order="desc",
│	limit=None,
│	for_update=False,
│	debug=False,
│	check_serial_no=True,
│	extra_cond=None,
│):
⋮...
│def get_previous_sle(args, for_update=False, extra_cond=None):
⋮...
│def get_valuation_rate(
│	item_code,
│	warehouse,
│	voucher_type,
│	voucher_no,
│	allow_zero_rate=False,
│	currency=None,
│	company=None,
│	raise_error_if_no_rate=True,
│	batch_no=None,
│	serial_and_batch_bundle=None,
│):
⋮...
│class NegativeStockError(frappe.ValidationError):
│	pass
⋮...
│def is_negative_stock_allowed(*, item_code: str | None = None) -> bool:
│	if cint(frappe.db.get_single_value("Stock Settings", "allow_negative_stock", cache=True)):
│		return True
│	if item_code and cint(frappe.db.get_value("Item", item_code, "allow_negative_stock", cache=True)):
│		return True
│	return False
⋮...
│def get_reposting_data(file_path) -> dict:
⋮...
│class update_entries_after:
⋮...
│def get_stock_value_difference(item_code, warehouse, posting_date, posting_time, voucher_no=None):
⋮...
│def make_entry(args, allow_negative_stock=False, via_landed_cost_voucher=False):
⋮...
│def get_items_to_be_repost(voucher_type=None, voucher_no=None, doc=None, reposting_data=None):
⋮...
│def make_sl_entries(sl_entries, allow_negative_stock=False, via_landed_cost_voucher=False):
⋮...
│def set_as_cancel(voucher_type, voucher_no):
⋮...
│def repost_future_sle(
│	args=None,
│	voucher_type=None,
│	voucher_no=None,
│	allow_negative_stock=None,
│	via_landed_cost_voucher=False,
│	doc=None,
│):
⋮...
│def create_file(doc, compressed_content):
⋮...
│def get_affected_transactions(doc, reposting_data=None) -> set[tuple[str, str]]:
⋮...
│def get_previous_sle_of_current_voucher(args, operator="<", exclude_current_voucher=False):
⋮...
│def is_negative_with_precision(neg_sle, is_batch=False):
⋮...
│def validate_reserved_serial_nos(item_code, warehouse, serial_nos):
⋮...
│def validate_reserved_batch_nos(item_code, warehouse, batch_nos):
⋮...
│def get_incoming_rate_for_inter_company_transfer(sle) -> float:
⋮...
│def is_internal_transfer(sle):
⋮...
│class SerialNoExistsInFutureTransaction(frappe.ValidationError):
│	pass
⋮...
│def repost_current_voucher(args, allow_negative_stock=False, via_landed_cost_voucher=False):
⋮...
│def get_args_for_future_sle(row):
⋮...
│def validate_serial_no(sle):
⋮...
│def validate_cancellation(kargs):
⋮...
│def validate_item_warehouse(args):
│	for field in ["item_code", "warehouse", "posting_date", "posting_time"]:
│		if args.get(field) in [None, ""]:
│			validation_msg = f"The field {frappe.unscrub(field)} is required for the reposting"
│			frappe.throw(_(validation_msg))
⋮...
│def update_args_in_repost_item_valuation(doc, index, args, distinct_item_warehouses, affected_transactions):
⋮...
│def get_reposting_file_name(dt, dn):
⋮...
│def create_json_gz_file(data, doc, file_name=None) -> str:
⋮...
│def get_distinct_item_warehouse(args=None, doc=None, reposting_data=None):
⋮...
│def parse_distinct_items_and_warehouses(distinct_items_and_warehouses):
⋮...
│def get_current_index(doc=None):
│	if doc and doc.current_index:
│		return doc.current_index
⋮...
│	def __init__(
│		self,
│		args,
│		allow_zero_rate=False,
│		allow_negative_stock=None,
│		via_landed_cost_voucher=False,
│		verbose=1,
│	):
⋮...
│	def get_reserved_stock(self):
⋮...
│	def set_precision(self):
│		self.flt_precision = cint(frappe.db.get_default("float_precision")) or 2
│		self.currency_precision = get_field_precision(
│			frappe.get_meta("Stock Ledger Entry").get_field("stock_value")
│		)
⋮...
│	def initialize_previous_data(self, args):
⋮...
│	def build(self):
⋮...
│	def has_stock_reco_with_serial_batch(self, sle):
⋮...
│	def process_sle_against_current_timestamp(self):
│		sl_entries = self.get_sle_against_current_voucher()
│		for sle in sl_entries:
│			self.process_sle(sle)
⋮...
│	def get_sle_against_current_voucher(self):
⋮...
│	def get_future_entries_to_fix(self):
⋮...
│	def get_dependent_entries_to_fix(self, entries_to_fix, sle):
⋮...
│	def update_distinct_item_warehouses(self, dependant_sle):
⋮...
│	def is_dependent_voucher_reposted(self, dependant_sle) -> bool:
⋮...
│	def get_dependent_voucher_detail_nos(self, key):
│		if "dependent_voucher_detail_nos" not in self.distinct_item_warehouses[key]:
│			self.distinct_item_warehouses[key].dependent_voucher_detail_nos = []
│
│		return self.distinct_item_warehouses[key].dependent_voucher_detail_nos
⋮...
│	def validate_previous_sle_qty(self, sle):
⋮...
│	def process_sle(self, sle):
⋮...
│	def get_serialized_values(self, sle):
⋮...
│	def reset_actual_qty_for_stock_reco(self, sle):
⋮...
│	def update_serial_no_status(self, sle):
⋮...
│	def calculate_valuation_for_serial_batch_bundle(self, sle):
⋮...
│	def get_outgoing_rate_for_batched_item(self, sle):
│		if self.wh_data.qty_after_transaction == 0:
│			return 0
│
│		return flt(self.wh_data.stock_value) / flt(self.wh_data.qty_after_transaction)
⋮...
│	def validate_negative_stock(self, sle):
⋮...
│	def get_dynamic_incoming_outgoing_rate(self, sle):
⋮...
│	def has_landed_cost_based_on_pi(self, sle):
⋮...
│	def get_incoming_outgoing_rate_from_transaction(self, sle):
⋮...
│	def update_outgoing_rate_on_transaction(self, sle):
⋮...
│	def update_rate_on_stock_entry(self, sle, outgoing_rate):
│		frappe.db.set_value("Stock Entry Detail", sle.voucher_detail_no, "basic_rate", outgoing_rate)
│
│		# Update outgoing item's rate, recalculate FG Item's rate and total incoming/outgoing amount
│		if not sle.dependant_sle_voucher_detail_no or self.is_manufacture_entry_with_sabb(sle):
│			self.recalculate_amounts_in_stock_entry(sle.voucher_no, sle.voucher_detail_no)
⋮...
│	def is_manufacture_entry_with_sabb(self, sle):
⋮...
│	def recalculate_amounts_in_stock_entry(self, voucher_no, voucher_detail_no):
⋮...
│	def update_rate_on_delivery_and_sales_return(self, sle, outgoing_rate):
⋮...
│	def update_rate_on_purchase_receipt(self, sle, outgoing_rate):
⋮...
│	def update_rate_on_subcontracting_receipt(self, sle, outgoing_rate):
⋮...
│	def update_rate_on_stock_reconciliation(self, sle):
⋮...
│	def get_incoming_value_for_serial_nos(self, sle, serial_nos):
⋮...
│	def get_moving_average_values(self, sle):
⋮...
│	def update_queue_values(self, sle):
⋮...
│	def update_batched_values(self, sle):
⋮...
│	def check_if_allow_zero_valuation_rate(self, voucher_type, voucher_detail_no):
⋮...
│	def get_fallback_rate(self, sle) -> float:
⋮...
│	def get_sle_before_datetime(self, args):
│		"""get previous stock ledger entry before current time-bucket"""
│		sle = get_stock_ledger_entries(args, "<", "desc", "limit 1", for_update=False)
│		sle = sle[0] if sle else frappe._dict()
│		return sle
⋮...
│	def get_sle_after_datetime(self, args):
│		"""get Stock Ledger Entries after a particular datetime, for reposting"""
│		return get_stock_ledger_entries(args, ">", "asc", for_update=True, check_serial_no=False)
⋮...
│	def raise_exceptions(self):
⋮...
│	def update_bin_data(self, sle):
⋮...
│	def update_bin(self):
⋮...
│def get_sle_by_voucher_detail_no(voucher_detail_no, excluded_sle=None):
⋮...
│def get_batch_incoming_rate(item_code, warehouse, batch_no, posting_date, posting_time, creation=None):
⋮...
│def update_qty_in_future_sle(args, allow_negative_stock=False):
⋮...
│def get_stock_reco_qty_shift(args):
⋮...
│def get_next_stock_reco(kwargs):
⋮...
│def get_datetime_limit_condition(detail):
⋮...
│def validate_negative_qty_in_future_sle(args, allow_negative_stock=False):
⋮...
│def get_future_sle_with_negative_qty(sle_args):
⋮...
│def get_future_sle_with_negative_batch_qty(sle_args):
⋮...
│def validate_reserved_stock(kwargs):
⋮...

erpnext\stock\doctype\serial_and_batch_bundle\serial_and_batch_bundle.py:
│def get_available_serial_nos(kwargs):
⋮...
│def get_auto_batch_nos(kwargs):
⋮...
│def get_available_batches(kwargs):
⋮...
│def item_query(doctype, txt, searchfield, start, page_len, filters, as_dict=False):
⋮...
│def make_serial_nos(item_code, serial_nos):
⋮...
│class SerialNoExistsInFutureTransactionError(frappe.ValidationError):
│	pass
⋮...
│class BatchNegativeStockError(frappe.ValidationError):
│	pass
⋮...
│def make_batch_nos(item_code, batch_nos):
⋮...
│def get_voucher_wise_serial_batch_from_bundle(**kwargs) -> dict[str, dict]:
⋮...
│class SerialNoDuplicateError(frappe.ValidationError):
│	pass
⋮...
│def get_serial_batch_from_csv(item_code, file_path):
⋮...
│def get_serial_batch_from_data(item_code, kwargs):
⋮...
│def get_serial_batch_ledgers(item_code=None, docstatus=None, voucher_no=None, name=None, child_row=None):
⋮...
│def get_type_of_transaction(parent_doc, child_row):
⋮...
│class SerialNoWarehouseError(frappe.ValidationError):
│	pass
⋮...
│class SerialandBatchBundle(Document):
⋮...
│	def autoname(self):
⋮...
│	def validate(self):
⋮...
│	def validate_voucher_detail_no(self):
⋮...
│	def allow_existing_serial_nos(self):
⋮...
│	def reset_serial_batch_bundle(self):
⋮...
│	def set_batch_no(self):
⋮...
│	def validate_serial_nos_inventory(self):
⋮...
│	def validate_serial_nos_duplicate(self):
⋮...
│	def throw_error_message(self, message, exception=frappe.ValidationError):
│		frappe.throw(_(message), exception, title=_("Error"))
⋮...
│	def set_incoming_rate(self, parent=None, row=None, save=False, allow_negative_stock=False):
⋮...
│	def set_valuation_rate_for_return_entry(self, return_against, row, save=False):
⋮...
│	def validate_returned_serial_batch_no(self, return_against, row, original_inv_details):
⋮...
│	def get_valuation_rate_for_return_entry(self, return_against):
⋮...
│	def calculate_total_qty(self, save=True):
⋮...
│	def get_serial_nos(self):
│		return [d.serial_no for d in self.entries if d.serial_no]
⋮...
│	def update_valuation_rate(self, valuation_rate=None, save=False):
⋮...
│	def set_incoming_rate_for_outward_transaction(self, row=None, save=False, allow_negative_stock=False):
⋮...
│	def validate_negative_batch(self, batch_no, available_qty):
⋮...
│	def is_stock_reco_for_valuation_adjustment(self, available_qty):
⋮...
│	def get_sle_for_outward_transaction(self):
⋮...
│	def get_return_against(self, parent=None):
⋮...
│	def set_incoming_rate_for_inward_transaction(self, row=None, save=False):
⋮...
│	def set_serial_and_batch_values(self, parent, row, qty_field=None):
⋮...
│	def validate_voucher_no(self):
⋮...
│	def check_future_entries_exists(self):
⋮...
│	def reset_qty(self, row, qty_field=None):
⋮...
│	def validate_quantity(self, row, qty_field=None):
⋮...
│	def get_qty_field(self, row, qty_field=None) -> str:
⋮...
│	def set_is_outward(self):
⋮...
│	def set_warehouse(self):
│		for row in self.entries:
│			if row.warehouse != self.warehouse:
│				row.warehouse = self.warehouse
⋮...
│	def calculate_qty_and_amount(self, save=False):
⋮...
│	def calculate_outgoing_rate(self):
⋮...
│	def validate_serial_and_batch_no(self):
⋮...
│	def validate_serial_batch_no(self, serial_batches):
⋮...
│	def validate_incorrect_serial_nos(self, serial_nos):
⋮...
│	def validate_incorrect_batch_nos(self, batch_nos):
⋮...
│	def validate_serial_and_batch_no_for_returned(self):
⋮...
│	def get_orignal_document_data(self):
⋮...
│	def validate_duplicate_serial_and_batch_no(self):
⋮...
│	def before_cancel(self):
│		self.delink_serial_and_batch_bundle()
⋮...
│	def delink_serial_and_batch_bundle(self):
│		sles = frappe.get_all("Stock Ledger Entry", filters={"serial_and_batch_bundle": self.name})
│
│		for sle in sles:
│			frappe.db.set_value("Stock Ledger Entry", sle.name, "serial_and_batch_bundle", None)
⋮...
│	def child_table(self):
⋮...
│	def delink_refernce_from_voucher(self):
⋮...
│	def delink_reference_from_batch(self):
⋮...
│	def validate_serial_and_batch_data(self):
│		if not self.voucher_no:
│			frappe.throw(_("Voucher No is mandatory"))
⋮...
│	def before_submit(self):
│		self.validate_serial_and_batch_data()
│		self.validate_serial_and_batch_no_for_returned()
│		self.set_purchase_document_no()
⋮...
│	def on_submit(self):
│		self.validate_serial_nos_inventory()
⋮...
│	def set_purchase_document_no(self):
⋮...
│	def validate_serial_and_batch_inventory(self):
│		self.check_future_entries_exists()
│		self.validate_batch_inventory()
⋮...
│	def validate_batch_inventory(self):
⋮...
│	def on_cancel(self):
│		self.validate_voucher_no_docstatus()
⋮...
│	def validate_voucher_no_docstatus(self):
⋮...
│	def on_trash(self):
│		self.validate_voucher_no_docstatus()
│		self.delink_refernce_from_voucher()
│		self.delink_reference_from_batch()
⋮...
│	def add_serial_batch(self, data):
⋮...
│	def delete_serial_batch_entries(self):
│		SBBE = frappe.qb.DocType("Serial and Batch Entry")
│
│		frappe.qb.from_(SBBE).delete().where(SBBE.parent == self.name).run()
│
│		self.set("entries", [])
⋮...
│def download_blank_csv_template(content):
⋮...
│def upload_csv_file(item_code, file_path):
⋮...
│def parse_csv_file_to_get_serial_batch(reader):
⋮...
│def create_serial_nos(item_code, serial_nos):
⋮...
│def parse_serial_nos(data):
│	if isinstance(data, list):
│		return data
│
│	return [s.strip() for s in cstr(data).strip().replace(",", "\n").split("\n") if s.strip()]
⋮...
│def get_filters_for_bundle(item_code=None, docstatus=None, voucher_no=None, name=None, child_row=None):
⋮...
│def get_reference_serial_and_batch_bundle(child_row):
⋮...
│def add_serial_batch_ledgers(entries, child_row, doc, warehouse, do_not_save=False) -> object:
⋮...
│def create_serial_batch_no_ledgers(
│	entries, child_row, parent_doc, warehouse=None, do_not_save=False
│) -> object:
⋮...
│def get_batch(item_code):
⋮...
│def update_serial_batch_no_ledgers(bundle, entries, child_row, parent_doc, warehouse=None) -> object:
⋮...
│def update_serial_or_batch(bundle_id, serial_no=None, batch_no=None):
⋮...
│def get_serial_and_batch_ledger(**kwargs):
⋮...
│def get_auto_data(**kwargs):
⋮...
│def get_available_batches_qty(available_batches):
│	available_batches_qty = defaultdict(float)
│	for batch in available_batches:
│		available_batches_qty[batch.batch_no] += batch.qty
│
│	return available_batches_qty
⋮...
│def get_non_expired_batches(batches):
⋮...
│def get_serial_nos_based_on_posting_date(kwargs, ignore_serial_nos):
⋮...
│def get_bundle_wise_serial_nos(data, kwargs):
⋮...
│def get_reserved_serial_nos(kwargs) -> list:
⋮...
│def get_reserved_serial_nos_for_pos(kwargs):
⋮...
│def get_reserved_serial_nos_for_sre(kwargs) -> list:
⋮...
│def get_reserved_batches_for_pos(kwargs) -> dict:
⋮...
│def get_reserved_batches_for_sre(kwargs) -> dict:
⋮...
│def filter_zero_near_batches(available_batches, kwargs):
⋮...
│def get_qty_based_available_batches(available_batches, qty):
⋮...
│def update_available_batches(available_batches, *reserved_batches) -> None:
⋮...
│def get_picked_batches(kwargs) -> dict[str, dict]:
⋮...
│def get_picked_serial_nos(item_code, warehouse=None) -> list[str]:
⋮...
│def get_ledgers_from_serial_batch_bundle(**kwargs) -> list[frappe._dict]:
⋮...
│def get_stock_ledgers_for_serial_nos(kwargs):
⋮...
│def get_stock_ledgers_batches(kwargs):
⋮...
│def get_batch_no_from_serial_no(serial_no):
│	return frappe.get_cached_value("Serial No", serial_no, "batch_no")
⋮...
│def is_serial_batch_no_exists(item_code, type_of_transaction, serial_no=None, batch_no=None):
⋮...
│def make_serial_no(serial_no, item_code):
│	serial_no_doc = frappe.new_doc("Serial No")
│	serial_no_doc.serial_no = serial_no
│	serial_no_doc.item_code = item_code
│	serial_no_doc.save(ignore_permissions=True)
⋮...
│def make_batch_no(batch_no, item_code):
│	batch_doc = frappe.new_doc("Batch")
│	batch_doc.batch_id = batch_no
│	batch_doc.item = item_code
│	batch_doc.save(ignore_permissions=True)
⋮...
│def is_duplicate_serial_no(bundle_id, serial_no):
│	return frappe.db.exists("Serial and Batch Entry", {"parent": bundle_id, "serial_no": serial_no})
⋮...

erpnext\assets\doctype\asset_depreciation_schedule\asset_depreciation_schedule.py:
│def get_depr_schedule(asset_name, status, finance_book=None):
⋮...
│def get_asset_depr_schedule_doc(asset_name, status, finance_book=None):
⋮...
│def _get_pro_rata_amt(
│	row,
│	depreciation_amount,
│	from_date,
│	to_date,
│	has_wdv_or_dd_non_yearly_pro_rata=False,
│	original_schedule_date=None,
│):
⋮...
│def make_new_active_asset_depr_schedules_and_cancel_current_ones(
│	asset_doc,
│	notes,
│	date_of_disposal=None,
│	date_of_return=None,
│	value_after_depreciation=None,
│	ignore_booked_entry=False,
│	difference_amount=None,
│):
⋮...
│def _check_is_pro_rata(asset_doc, row, wdv_or_dd_non_yearly=False):
⋮...
│def get_total_days(date, frequency):
│	period_start_date = add_months(date, cint(frequency) * -1)
│	if is_last_day_of_the_month(date):
│		period_start_date = get_last_day(period_start_date)
│	return date_diff(date, period_start_date)
⋮...
│class AssetDepreciationSchedule(Document):
⋮...
│def _get_total_days(depreciation_start_date, schedule_idx, frequency_of_depreciation):
⋮...
│def get_asset_depr_schedule_name(asset_name, status, finance_book=None):
⋮...
│def get_depreciation_amount(
│	asset_depr_schedule,
│	asset,
│	depreciable_value,
│	yearly_opening_wdv,
│	fb_row,
│	schedule_idx=0,
│	prev_depreciation_amount=0,
│	has_wdv_or_dd_non_yearly_pro_rata=False,
│	number_of_pending_depreciations=0,
│	prev_per_day_depr=0,
│):
⋮...
│def get_daily_prorata_based_straight_line_depr(
│	asset, row, schedule_idx, number_of_pending_depreciations, amount
│):
⋮...
│def get_asset_shift_factors_map():
│	return dict(frappe.db.get_all("Asset Shift Factor", ["shift_name", "shift_factor"], as_list=True))
⋮...
│def get_monthly_depr_amount(fb_row, schedule_idx, depreciable_value):
⋮...
│def get_monthly_depr_amount_based_on_prev_per_day_depr(fb_row, schedule_idx, prev_per_day_depr):
⋮...
│def make_draft_asset_depr_schedule(asset_doc, row):
⋮...
│def get_temp_asset_depr_schedule_doc(
│	asset_doc,
│	row,
│	date_of_disposal=None,
│	date_of_return=None,
│	update_asset_finance_book_row=False,
│	new_depr_schedule=None,
│):
⋮...
│	def before_save(self):
│		if not self.finance_book_id:
│			self.prepare_draft_asset_depr_schedule_data_from_asset_name_and_fb_name(
│				self.asset, self.finance_book
│			)
│		self.update_shift_depr_schedule()
⋮...
│	def validate(self):
│		self.validate_another_asset_depr_schedule_does_not_exist()
⋮...
│	def validate_another_asset_depr_schedule_does_not_exist(self):
⋮...
│	def on_submit(self):
│		self.db_set("status", "Active")
⋮...
│	def before_cancel(self):
│		if not self.flags.should_not_cancel_depreciation_entries:
│			self.cancel_depreciation_entries()
⋮...
│	def cancel_depreciation_entries(self):
│		for d in self.get("depreciation_schedule"):
│			if d.journal_entry:
│				frappe.get_doc("Journal Entry", d.journal_entry).cancel()
⋮...
│	def on_cancel(self):
│		self.db_set("status", "Cancelled")
⋮...
│	def update_shift_depr_schedule(self):
⋮...
│	def prepare_draft_asset_depr_schedule_data_from_asset_name_and_fb_name(self, asset_name, fb_name):
⋮...
│	def prepare_draft_asset_depr_schedule_data(
│		self,
│		asset_doc,
│		row,
│		date_of_disposal=None,
│		date_of_return=None,
│		update_asset_finance_book_row=True,
│	):
⋮...
│	def have_asset_details_been_modified(self, asset_doc):
│		return (
│			asset_doc.gross_purchase_amount != self.gross_purchase_amount
│			or asset_doc.opening_accumulated_depreciation != self.opening_accumulated_depreciation
│			or asset_doc.opening_number_of_booked_depreciations != self.opening_number_of_booked_depreciations
│		)
⋮...
│	def not_manual_depr_or_have_manual_depr_details_been_modified(self, row):
⋮...
│	def should_prepare_depreciation_schedule(
│		self, have_asset_details_been_modified, not_manual_depr_or_have_manual_depr_details_been_modified
│	):
⋮...
│	def set_draft_asset_depr_schedule_details(self, asset_doc, row):
⋮...
│	def make_depr_schedule(
│		self,
│		asset_doc,
│		row,
│		date_of_disposal=None,
│		update_asset_finance_book_row=True,
│		value_after_depreciation=None,
│	):
⋮...
│	def clear_depr_schedule(self):
⋮...
│	def _make_depr_schedule(
│		self,
│		asset_doc,
│		row,
│		start,
│		date_of_disposal,
│		update_asset_finance_book_row,
│		value_after_depreciation,
│	):
⋮...
│	def get_adjusted_depreciation_amount(
│		self, depreciation_amount_without_pro_rata, depreciation_amount_for_last_row
│	):
⋮...
│	def get_depreciation_amount_for_first_row(self):
│		return self.get("depreciation_schedule")[0].depreciation_amount
⋮...
│	def add_depr_schedule_row(self, schedule_date, depreciation_amount, schedule_idx):
⋮...
│	def set_accumulated_depreciation(
│		self,
│		asset_doc,
│		row,
│		date_of_disposal=None,
│		date_of_return=None,
│		ignore_booked_entry=False,
│	):
⋮...
│def _get_value_after_depreciation_for_making_schedule(asset_doc, fb_row):
⋮...
│def _get_modified_available_for_use_date(asset_doc, row, wdv_or_dd_non_yearly=False):
⋮...
│def get_straight_line_or_manual_depr_amount(
│	asset_depr_schedule, asset, row, schedule_idx, number_of_pending_depreciations
│):
⋮...
│def get_daily_depr_amount(asset, row, schedule_idx, amount):
⋮...
│def get_shift_depr_amount(asset_depr_schedule, asset, row, schedule_idx):
⋮...
│def get_wdv_or_dd_depr_amount(
│	asset,
│	fb_row,
│	depreciable_value,
│	yearly_opening_wdv,
│	schedule_idx,
│	prev_depreciation_amount,
│	has_wdv_or_dd_non_yearly_pro_rata,
│	asset_depr_schedule,
│	prev_per_day_depr,
│):
⋮...
│def get_default_wdv_or_dd_depr_amount(
│	asset,
│	fb_row,
│	depreciable_value,
│	schedule_idx,
│	prev_depreciation_amount,
│	has_wdv_or_dd_non_yearly_pro_rata,
│	asset_depr_schedule,
│	prev_per_day_depr,
│):
⋮...
│def _get_default_wdv_or_dd_depr_amount(
│	asset,
│	fb_row,
│	depreciable_value,
│	schedule_idx,
│	prev_depreciation_amount,
│	has_wdv_or_dd_non_yearly_pro_rata,
│	asset_depr_schedule,
│):
⋮...
│def _get_daily_prorata_based_default_wdv_or_dd_depr_amount(
│	asset,
│	fb_row,
│	depreciable_value,
│	schedule_idx,
│	prev_depreciation_amount,
│	has_wdv_or_dd_non_yearly_pro_rata,
│	asset_depr_schedule,
│	prev_per_day_depr,
│):
⋮...
│def get_per_day_depr(
│	fb_row,
│	depreciable_value,
│	from_date,
│):
⋮...
│def make_draft_asset_depr_schedules_if_not_present(asset_doc):
⋮...
│def make_draft_asset_depr_schedules(asset_doc):
⋮...
│def update_draft_asset_depr_schedules(asset_doc):
⋮...
│def convert_draft_asset_depr_schedules_into_active(asset_doc):
⋮...
│def cancel_asset_depr_schedules(asset_doc):
⋮...
│def is_first_day_of_the_month(date):
│	first_day_of_the_month = get_first_day(date)
│
│	return getdate(first_day_of_the_month) == getdate(date)
⋮...

erpnext\utilities\bulk_transaction.py:
│def task(doc_name, from_doctype, to_doctype):
⋮...
│def job(deserialized_data, from_doctype, to_doctype, args):
⋮...
│def update_log(log_name, status, retried, err=None):
│	frappe.db.set_value("Bulk Transaction Log Detail", log_name, "transaction_status", status)
│	frappe.db.set_value("Bulk Transaction Log Detail", log_name, "retried", retried)
│	if err:
│		frappe.db.set_value("Bulk Transaction Log Detail", log_name, "error_description", err)
⋮...
│def create_log(doc_name, e, from_doctype, to_doctype, status, log_date=None, restarted=0):
⋮...
│def transaction_processing(data, from_doctype, to_doctype, args=None):
⋮...
│def retry(date: str | None = None):
⋮...
│def retry_failed_transactions(failed_docs: list | None):
⋮...
│def show_job_status(fail_count, deserialized_data_count, to_doctype):
⋮...

erpnext\accounts\report\purchase_register\test_purchase_register.py:
│def make_purchase_invoice():
⋮...
│def make_payment_entry():
⋮...
│class TestPurchaseRegister(IntegrationTestCase):
⋮...
│	def test_purchase_register(self):
⋮...
│	def test_purchase_register_ledger_view(self):
⋮...
│def create_purchase_invoice_with_taxes():
⋮...

erpnext\controllers\subcontracting_controller.py:
│def get_item_details(items):
⋮...
│def make_rm_stock_entry(
│	subcontract_order, rm_items=None, order_doctype="Subcontracting Order", target_doc=None
│):
⋮...
│def get_materials_from_supplier(subcontract_order, rm_details, order_doctype="Subcontracting Order"):
⋮...
│class SubcontractingController(StockController):
⋮...
│def add_items_in_ste(ste_doc, row, qty, rm_details, rm_detail_field="sco_rm_detail", batch_no=None):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def before_validate(self):
│		if self.doctype in ["Subcontracting Order", "Subcontracting Receipt"]:
│			self.remove_empty_rows()
│			self.set_items_conversion_factor()
⋮...
│	def validate(self):
│		if self.doctype in ["Subcontracting Order", "Subcontracting Receipt"]:
│			self.validate_items()
│			self.create_raw_materials_supplied()
│		else:
│			super().validate()
⋮...
│	def validate_rejected_warehouse(self):
⋮...
│	def remove_empty_rows(self):
⋮...
│	def set_items_conversion_factor(self):
│		for item in self.get("items"):
│			if not item.conversion_factor:
│				item.conversion_factor = 1
⋮...
│	def validate_items(self):
⋮...
│	def __get_data_before_save(self):
⋮...
│	def __identify_change_in_item_table(self):
⋮...
│	def __get_backflush_based_on(self):
│		self.backflush_based_on = frappe.db.get_single_value(
│			"Buying Settings", "backflush_raw_materials_of_subcontract_based_on"
│		)
⋮...
│	def initialized_fields(self):
│		self.available_materials = frappe._dict()
│		self.__transferred_items = frappe._dict()
│		self.alternative_item_details = frappe._dict()
│		self.__get_backflush_based_on()
⋮...
│	def __get_subcontract_orders(self):
⋮...
│	def __get_pending_qty_to_receive(self):
⋮...
│	def __get_transferred_items(self):
⋮...
│	def __set_alternative_item_details(self, row):
│		if row.get("original_item"):
│			self.alternative_item_details[row.get("original_item")] = row
⋮...
│	def __get_received_items(self, doctype):
⋮...
│	def __get_consumed_items(self, doctype, receipt_items):
⋮...
│	def __update_consumed_materials(self, doctype, return_consumed_items=False):
⋮...
│	def get_available_materials(self):
⋮...
│	def __remove_changed_rows(self):
⋮...
│	def __remove_serial_and_batch_bundle(self, item):
│		if item.serial_and_batch_bundle:
│			frappe.delete_doc("Serial and Batch Bundle", item.serial_and_batch_bundle, force=True)
⋮...
│	def __get_materials_from_bom(self, item_code, bom_no, exploded_item=0):
⋮...
│	def __update_reserve_warehouse(self, row, item):
│		if self.doctype == self.subcontract_data.order_doctype:
│			row.reserve_warehouse = self.set_reserve_warehouse or item.warehouse
⋮...
│	def __set_alternative_item(self, bom_item):
│		if self.alternative_item_details.get(bom_item.rm_item_code):
│			bom_item.update(self.alternative_item_details[bom_item.rm_item_code])
⋮...
│	def __set_serial_and_batch_bundle(self, item_row, rm_obj, qty):
⋮...
│	def __get_batch_nos_for_bundle(self, qty, key):
⋮...
│	def __get_serial_nos_for_bundle(self, qty, key):
⋮...
│	def __add_supplied_item(self, item_row, bom_item, qty):
⋮...
│	def update_rate_for_supplied_items(self):
⋮...
│	def get_item_row(self, reference_name):
│		for item in self.items:
│			if item.name == reference_name:
│				return item
⋮...
│	def set_rate_for_supplied_items(self, rm_obj, item_row):
⋮...
│	def __set_batch_nos(self, bom_item, item_row, rm_obj, qty):
⋮...
│	def __set_consumed_qty(self, rm_obj, consumed_qty, required_qty=0):
│		rm_obj.required_qty = flt(required_qty, rm_obj.precision("required_qty"))
│		rm_obj.consumed_qty = flt(consumed_qty, rm_obj.precision("consumed_qty"))
⋮...
│	def __set_serial_nos(self, item_row, rm_obj):
⋮...
│	def __set_batch_no_as_per_qty(self, item_row, rm_obj, batch_no, qty):
⋮...
│	def __get_qty_based_on_material_transfer(self, item_row, transfer_item):
⋮...
│	def __set_supplied_items(self):
⋮...
│	def __set_rate_for_serial_and_batch_bundle(self):
⋮...
│	def __modify_serial_and_batch_bundle(self):
⋮...
│	def __get_bundle_to_modify(self, name):
⋮...
│	def __prepare_supplied_items(self):
⋮...
│	def __validate_batch_no(self, row, key):
⋮...
│	def __validate_serial_no(self, row, key):
⋮...
│	def __validate_supplied_items(self):
⋮...
│	def set_materials_for_subcontracted_items(self, raw_material_table):
⋮...
│	def create_raw_materials_supplied(self, raw_material_table="supplied_items"):
│		self.set_materials_for_subcontracted_items(raw_material_table)
│
│		if self.doctype in ["Subcontracting Receipt", "Purchase Receipt", "Purchase Invoice"]:
│			for item in self.get("items"):
│				item.rm_supp_cost = 0.0
⋮...
│	def __update_consumed_qty_in_subcontract_order(self, itemwise_consumed_qty):
⋮...
│	def set_consumed_qty_in_subcontract_order(self):
⋮...
│	def update_ordered_and_reserved_qty(self):
⋮...
│	def make_sl_entries_for_supplier_warehouse(self, sl_entries):
⋮...
│	def update_stock_ledger(self, allow_negative_stock=False, via_landed_cost_voucher=False):
⋮...
│	def get_supplied_items_cost(self, item_row_id, reset_outgoing_rate=True):
⋮...
│	def set_subcontracting_order_status(self):
⋮...
│	def calculate_additional_costs(self):
⋮...
│	def get_current_stock(self):
⋮...
│	def sub_contracted_items(self):
⋮...
│	def update_requested_qty(self):
⋮...
│def get_pending_subcontracted_quantity(po_name):
⋮...
│def make_return_stock_entry_for_subcontract(
│	available_materials, order_doc, rm_details, order_doctype="Subcontracting Order"
│):
⋮...

erpnext\accounts\doctype\payment_entry\test_payment_entry.py:
│def create_payment_entry(**args):
⋮...
│def create_customer(name="_Test Customer 2 USD", currency="USD"):
⋮...
│def create_payment_terms_template():
⋮...
│def create_payment_term(name):
│	if not frappe.db.exists("Payment Term", name):
│		frappe.get_doc({"doctype": "Payment Term", "payment_term_name": name}).insert()
⋮...
│def create_payment_terms_template_with_discount(
│	name=None, discount_type=None, discount=None, template_name=None
│):
⋮...
│class UnitTestPaymentEntry(UnitTestCase):
⋮...
│class TestPaymentEntry(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def get_journals_for(self, voucher_type: str, voucher_no: str) -> list:
⋮...
│	def test_payment_entry_against_order(self):
⋮...
│	def test_payment_against_sales_order_usd_to_inr(self):
⋮...
│	def test_payment_entry_for_blocked_supplier_invoice(self):
⋮...
│	def test_payment_entry_for_blocked_supplier_payments(self):
⋮...
│	def test_payment_entry_for_blocked_supplier_payments_today_date(self):
⋮...
│	def test_payment_entry_for_blocked_supplier_payments_past_date(self):
⋮...
│	def test_payment_entry_against_si_usd_to_usd(self):
⋮...
│	def test_payment_entry_against_pi(self):
⋮...
│	def test_payment_against_sales_invoice_to_check_status(self):
⋮...
│	def test_payment_entry_against_payment_terms(self):
⋮...
│	def test_payment_entry_against_payment_terms_with_discount_on_pi(self):
⋮...
│	def test_payment_entry_against_payment_terms_with_discount(self):
⋮...
│	def test_payment_entry_against_payment_terms_with_discount_amount(self):
⋮...
│	def test_payment_entry_multicurrency_si_with_base_currency_accounting_early_payment_discount(
│		self,
│	):
⋮...
│	def test_payment_entry_multicurrency_accounting_si_with_early_payment_discount(self):
⋮...
│	def test_payment_against_purchase_invoice_to_check_status(self):
⋮...
│	def test_payment_entry_against_si_usd_to_inr(self):
⋮...
│	def test_payment_entry_against_si_usd_to_usd_with_deduction_in_base_currency(self):
⋮...
│	def test_payment_entry_retrieves_last_exchange_rate(self):
⋮...
│	def test_internal_transfer_usd_to_inr(self):
⋮...
│	def test_payment_against_negative_sales_invoice(self):
⋮...
│	def validate_gl_entries(self, voucher_no, expected_gle):
⋮...
│	def get_gle(self, voucher_no):
⋮...
│	def test_payment_entry_write_off_difference(self):
⋮...
│	def test_payment_entry_exchange_gain_loss(self):
⋮...
│	def test_payment_entry_against_sales_invoice_with_cost_centre(self):
⋮...
│	def test_payment_entry_against_purchase_invoice_with_cost_center(self):
⋮...
│	def test_payment_entry_account_and_party_balance_with_cost_center(self):
⋮...
│	def test_gl_of_multi_currency_payment_transaction(self):
⋮...
│	def test_multi_currency_payment_entry_with_taxes(self):
⋮...
│	def test_gl_of_multi_currency_payment_with_taxes(self):
⋮...
│	def test_payment_entry_against_onhold_purchase_invoice(self):
⋮...
│	def test_payment_entry_for_employee(self):
│		employee = make_employee("test_payment_entry@salary.com", company="_Test Company")
│		create_payment_entry(party_type="Employee", party=employee, save=True)
⋮...
│	def test_duplicate_payment_entry_allocate_amount(self):
⋮...
│	def test_duplicate_payment_entry_partial_allocate_amount(self):
⋮...
│	def test_details_update_on_reference_table(self):
⋮...
│	def test_overallocation_validation_on_payment_terms(self):
⋮...
│	def test_overallocation_validation_shouldnt_misfire(self):
⋮...
│	def test_allocation_validation_for_sales_order(self):
⋮...
│	def test_outstanding_invoices_api(self):
⋮...
│	def test_receive_payment_from_payable_party_type(self):
⋮...
│	def test_payment_against_partial_return_invoice(self):
⋮...
│	def test_ledger_entries_for_advance_as_liability(self):
⋮...
│	def test_advance_as_liability_against_order(self):
⋮...
│	def check_pl_entries(self):
⋮...
│	def check_gl_entries(self):
⋮...
│	def test_reverse_payment_reconciliation(self):
⋮...
│	def test_advance_reverse_payment_reconciliation(self):
⋮...
│	def test_opening_flag_for_advance_as_liability(self):
⋮...
│	def test_delete_linked_exchange_gain_loss_journal(self):
⋮...

erpnext\support\doctype\issue\test_issue.py:
│def create_issue_and_communication(issue_creation, first_responded_on):
⋮...
│def create_communication(reference_name, sender, sent_or_received, creation):
⋮...
│def make_issue(creation=None, customer=None, index=0, priority=None, issue_type=None):
⋮...
│def create_customer(name, customer_group, territory):
⋮...
│def create_customer_group(customer_group):
│	if not frappe.db.exists("Customer Group", {"customer_group_name": customer_group}):
│		frappe.get_doc({"doctype": "Customer Group", "customer_group_name": customer_group}).insert(
│			ignore_permissions=True
│		)
⋮...
│def create_territory(territory):
⋮...
│class TestSetUp(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│class TestIssue(TestSetUp):
⋮...
│	def test_response_time_and_resolution_time_based_on_different_sla(self):
⋮...
│	def test_hold_time_on_replied(self):
⋮...
│	def test_issue_close_after_on_hold(self):
⋮...
│	def test_issue_open_after_closed(self):
⋮...
│	def test_recording_of_assignment_on_first_reponse_failure(self):
⋮...
│	def test_agreement_status_on_response(self):
⋮...
│class TestFirstResponseTime(TestSetUp):
⋮...
│	def test_first_response_time_case1(self):
⋮...
│	def test_first_response_time_case2(self):
⋮...
│	def test_first_response_time_case3(self):
⋮...
│	def test_first_response_time_case4(self):
⋮...
│	def test_first_response_time_case5(self):
⋮...
│	def test_first_response_time_case6(self):
⋮...
│	def test_first_response_time_case7(self):
⋮...
│	def test_first_response_time_case8(self):
⋮...
│	def test_first_response_time_case9(self):
⋮...
│	def test_first_response_time_case10(self):
⋮...
│	def test_first_response_time_case11(self):
⋮...
│	def test_first_response_time_case12(self):
⋮...
│	def test_first_response_time_case13(self):
⋮...
│	def test_first_response_time_case14(self):
⋮...
│	def test_first_response_time_case15(self):
⋮...
│	def test_first_response_time_case16(self):
⋮...
│	def test_first_response_time_case17(self):
⋮...
│	def test_first_response_time_case18(self):
⋮...
│	def test_first_response_time_case19(self):
⋮...
│	def test_first_response_time_case20(self):
⋮...
│	def test_first_response_time_case21(self):
⋮...
│	def test_first_response_time_case22(self):
⋮...
│	def test_first_response_time_case23(self):
⋮...
│	def test_first_response_time_case24(self):
⋮...
│	def test_first_response_time_case25(self):
⋮...
│	def test_first_response_time_case26(self):
⋮...
│	def test_first_response_time_case27(self):
⋮...
│	def test_first_response_time_case28(self):
⋮...
│	def test_first_response_time_case29(self):
⋮...

erpnext\support\doctype\service_level_agreement\service_level_agreement.py:
│def now_datetime(user):
│	dt = convert_utc_to_user_timezone(datetime.utcnow(), user)
│	return dt.replace(tzinfo=None)
⋮...
│def get_context(doc):
│	return {
│		"doc": doc.as_dict(),
│		"nowdate": nowdate,
│		"frappe": frappe._dict(utils=get_safe_globals().get("frappe").get("utils")),
│	}
⋮...
│def set_documents_with_active_service_level_agreement():
│	active = frozenset(
│		sla.document_type for sla in frappe.get_all("Service Level Agreement", fields=["document_type"])
│	)
│	frappe.cache.set_value("doctypes_with_active_sla", active)
│	return active
⋮...
│def get_service_level_agreement_fields():
⋮...
│def update_agreement_status(doc, apply_sla_for_resolution):
⋮...
│def is_holiday(date, holidays):
│	return getdate(date) in holidays
⋮...
│def get_customer_group(customer):
⋮...
│def get_customer_territory(customer):
⋮...
│def get_repeated(values):
⋮...
│def handle_status_change(doc, apply_sla_for_resolution):
⋮...
│def update_response_and_resolution_metrics(doc, apply_sla_for_resolution):
│	priority = get_response_and_resolution_duration(doc)
│	start_date_time = get_datetime(doc.get("service_level_agreement_creation") or doc.creation)
│	set_response_by(doc, start_date_time, priority)
│	if apply_sla_for_resolution and not doc.get("on_hold_since"):  # resolution_by is reset if on hold
│		set_resolution_by(doc, start_date_time, priority)
⋮...
│def get_expected_time_for(parameter, service_level, start_date_time):
⋮...
│def set_resolution_time(doc):
⋮...
│def reset_resolution_metrics(doc):
⋮...
│def reset_expected_response_and_resolution(doc):
│	if doc.meta.has_field("first_responded_on") and not doc.get("first_responded_on"):
│		doc.response_by = None
│	if doc.meta.has_field("sla_resolution_by") and not doc.get("sla_resolution_date"):
│		doc.sla_resolution_by = None
⋮...
│def get_sla_doctypes():
⋮...
│class ServiceLevelAgreement(Document):
⋮...
│	def validate(self):
⋮...
│	def check_priorities(self):
⋮...
│	def check_support_and_resolution(self):
⋮...
│	def validate_doc(self):
⋮...
│	def validate_selected_doctype(self):
⋮...
│	def validate_status_field(self):
⋮...
│	def validate_condition(self):
⋮...
│	def get_service_level_agreement_priority(self, priority):
⋮...
│	def before_insert(self):
⋮...
│	def on_trash(self):
│		set_documents_with_active_service_level_agreement()
⋮...
│	def after_insert(self):
│		set_documents_with_active_service_level_agreement()
⋮...
│	def on_update(self):
│		set_documents_with_active_service_level_agreement()
⋮...
│	def clear_cache(self):
│		get_sla_doctypes.clear_cache()
│		return super().clear_cache()
⋮...
│	def create_docfields(self, meta, service_level_agreement_fields):
⋮...
│	def create_custom_fields(self, meta, service_level_agreement_fields):
⋮...
│	def reset_field_properties(self, field, field_dt, sla_field):
⋮...
│def check_agreement_status():
⋮...
│def get_active_service_level_agreement_for(doc):
⋮...
│def get_service_level_agreement_filters(doctype, name, customer=None):
⋮...
│def get_documents_with_active_service_level_agreement():
⋮...
│def apply(doc, method=None):
⋮...
│def remove_sla_if_applied(doc):
│	doc.service_level_agreement = None
│	doc.response_by = None
│	doc.sla_resolution_by = None
⋮...
│def process_sla(doc, sla):
⋮...
│def get_fulfillment_statuses(service_level_agreement):
⋮...
│def get_hold_statuses(service_level_agreement):
⋮...
│def get_allotted_seconds(parameter, service_level):
⋮...
│def get_support_days(service_level):
⋮...
│def change_service_level_agreement_and_priority(self):
⋮...
│def get_response_and_resolution_duration(doc):
│	sla = frappe.get_doc("Service Level Agreement", doc.service_level_agreement)
│	priority = sla.get_service_level_agreement_priority(doc.priority)
│	priority.update({"support_and_resolution": sla.support_and_resolution, "holiday_list": sla.holiday_list})
│	return priority
⋮...
│def reset_service_level_agreement(doctype: str, docname: str, reason, user):
⋮...
│def on_communication_update(doc, status):
⋮...
│def set_response_by(doc, start_date_time, priority):
⋮...
│def set_resolution_by(doc, start_date_time, priority):
⋮...
│def record_assigned_users_on_failure(doc):
⋮...
│def update_agreement_status_on_custom_status(doc):
│	# Update Agreement Fulfilled status using Custom Scripts for Custom Status
│	update_agreement_status(doc)
⋮...
│def get_time_in_timedelta(time):
│	"""Converts datetime.time(10, 36, 55, 961454) to datetime.timedelta(seconds=38215)."""
│	import datetime
│
│	return datetime.timedelta(hours=time.hour, minutes=time.minute, seconds=time.second)
⋮...
│def convert_utc_to_user_timezone(utc_timestamp, user):
⋮...
│def get_tz(user):
│	return frappe.db.get_value("User", user, "time_zone") or get_system_timezone()
⋮...
│def get_user_time(user, to_string=False):
│	return get_datetime_str(now_datetime(user)) if to_string else now_datetime(user)
⋮...
│def add_sla_doctypes(bootinfo):
│	bootinfo.service_level_agreement_doctypes = get_sla_doctypes()
⋮...

erpnext\stock\stock_balance.py:
│def get_reserved_qty(item_code, warehouse):
⋮...
│def get_ordered_qty(item_code, warehouse):
⋮...
│def update_bin_qty(item_code, warehouse, qty_dict=None):
⋮...
│def get_indented_qty(item_code, warehouse):
⋮...
│def repost(only_actual=False, allow_negative_stock=False, allow_zero_rate=False, only_bin=False):
⋮...
│def get_planned_qty(item_code, warehouse):
⋮...
│def repost_stock(
│	item_code,
│	warehouse,
│	allow_zero_rate=False,
│	only_actual=False,
│	only_bin=False,
│	allow_negative_stock=False,
│):
⋮...
│def get_balance_qty_from_sle(item_code, warehouse):
⋮...
│def repost_actual_qty(item_code, warehouse, allow_zero_rate=False, allow_negative_stock=False):
⋮...
│def set_stock_balance_as_per_serial_no(
│	item_code=None, posting_date=None, posting_time=None, fiscal_year=None
│):
⋮...

erpnext\accounts\report\balance_sheet\test_balance_sheet.py:
│def create_account(account_name: str, parent_account: str, company: str):
⋮...
│def make_journal_entry(rows):
⋮...
│class TestBalanceSheet(IntegrationTestCase):
⋮...
│	def test_balance_sheet(self):
⋮...

erpnext\stock\doctype\warehouse\test_warehouse.py:
│def create_warehouse(warehouse_name, properties=None, company=None):
⋮...
│def get_warehouse_account(warehouse_name, company, company_abbr=None):
⋮...
│def get_warehouse(**args):
⋮...
│class UnitTestWarehouse(UnitTestCase):
⋮...
│class TestWarehouse(IntegrationTestCase):
⋮...
│	def test_parent_warehouse(self):
│		parent_warehouse = frappe.get_doc("Warehouse", "_Test Warehouse Group - _TC")
│		self.assertEqual(parent_warehouse.is_group, 1)
⋮...
│	def test_warehouse_hierarchy(self):
⋮...
│	def test_naming(self):
⋮...
│	def test_unlinking_warehouse_from_item_defaults(self):
⋮...
│	def test_group_non_group_conversion(self):
⋮...
│	def test_get_children(self):
│		company = "_Test Company"
│
│		children = get_children("Warehouse", parent=company, company=company, is_root=True)
│		self.assertTrue(any(wh["value"] == "_Test Warehouse - _TC" for wh in children))
⋮...
│def get_group_stock_account(company, company_abbr=None):
⋮...

erpnext\accounts\doctype\account\account.py:
│def get_account_currency(account):
⋮...
│def on_doctype_update():
│	frappe.db.add_index("Account", ["lft", "rgt"])
⋮...
│def update_account_number(name, account_name, account_number=None, from_descendant=False):
⋮...
│def merge_account(old, new):
⋮...
│class InvalidAccountMergeError(frappe.ValidationError):
│	pass
⋮...
│class RootNotEditable(frappe.ValidationError):
│	pass
⋮...
│def _ensure_idle_system():
⋮...
│class BalanceMismatchError(frappe.ValidationError):
│	pass
⋮...
│class Account(NestedSet):
⋮...
│	def on_update(self):
│		if frappe.local.flags.ignore_update_nsm:
│			return
│		else:
│			super().on_update()
⋮...
│	def onload(self):
│		frozen_accounts_modifier = frappe.db.get_single_value("Accounts Settings", "frozen_accounts_modifier")
│		if not frozen_accounts_modifier or frozen_accounts_modifier in frappe.get_roles():
│			self.set_onload("can_freeze_account", True)
⋮...
│	def autoname(self):
│		from erpnext.accounts.utils import get_autoname_with_number
│
│		self.name = get_autoname_with_number(self.account_number, self.account_name, self.company)
⋮...
│	def validate(self):
⋮...
│	def validate_parent_child_account_type(self):
⋮...
│	def validate_parent(self):
⋮...
│	def set_root_and_report_type(self):
⋮...
│	def validate_receivable_payable_account_type(self):
⋮...
│	def validate_root_details(self):
⋮...
│	def validate_root_company_and_sync_account_to_children(self):
⋮...
│	def validate_group_or_ledger(self):
⋮...
│	def validate_frozen_accounts_modifier(self):
⋮...
│	def validate_balance_must_be_debit_or_credit(self):
⋮...
│	def validate_account_currency(self):
⋮...
│	def validate_account_number(self, account_number=None):
⋮...
│	def create_account_for_child_company(self, parent_acc_name_map, descendants, parent_acc_name):
⋮...
│	def convert_group_to_ledger(self):
⋮...
│	def convert_ledger_to_group(self):
⋮...
│	def check_gle_exists(self):
│		return frappe.db.get_value("GL Entry", {"account": self.name})
⋮...
│	def check_if_child_exists(self):
│		return frappe.db.sql(
│			"""select name from `tabAccount` where parent_account = %s
│			and docstatus != 2""",
│			self.name,
│		)
⋮...
│	def validate_mandatory(self):
│		if not self.root_type:
│			throw(_("Root Type is mandatory"))
│
│		if not self.report_type:
│			throw(_("Report Type is mandatory"))
⋮...
│	def on_trash(self):
│		# checks gl entries and if child exists
│		if self.check_gle_exists():
│			throw(_("Account with existing transaction can not be deleted"))
│
│		super().on_trash(True)
⋮...
│def get_parent_account(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_account_autoname(account_number, account_name, company):
⋮...
│def get_root_company(company):
│	# return the topmost company in the hierarchy
│	ancestors = get_ancestors_of("Company", company, "lft asc")
│	return [ancestors[0]] if ancestors else []
⋮...
│def sync_update_account_number_in_child(
│	descendants, old_acc_name, account_name, account_number=None, old_acc_number=None
│):
⋮...

erpnext\stock\doctype\stock_reconciliation\test_stock_reconciliation.py:
│def create_stock_reconciliation(**args):
⋮...
│def create_batch_item_with_batch(item_name, batch_id):
⋮...
│def set_valuation_method(item_code, valuation_method):
⋮...
│class TestStockReconciliation(IntegrationTestCase, StockTestMixin):
⋮...
│	def setUpClass(cls):
│		create_batch_or_serial_no_items()
│		super().setUpClass()
│		frappe.db.set_single_value("Stock Settings", "allow_negative_stock", 1)
⋮...
│	def tearDown(self):
│		frappe.local.future_sle = {}
│		frappe.flags.pop("dont_execute_stock_reposts", None)
⋮...
│	def test_reco_for_fifo(self):
│		self._test_reco_sle_gle("FIFO")
⋮...
│	def test_reco_for_moving_average(self):
│		self._test_reco_sle_gle("Moving Average")
⋮...
│	def _test_reco_sle_gle(self, valuation_method):
⋮...
│	def test_get_items(self):
⋮...
│	def test_stock_reco_for_serialized_item(self):
⋮...
│	def test_stock_reco_for_batch_item(self):
⋮...
│	def test_stock_reco_for_serial_and_batch_item(self):
⋮...
│	def test_stock_reco_for_serial_and_batch_item_with_future_dependent_entry(self):
⋮...
│	def test_customer_provided_items(self):
⋮...
│	def test_backdated_stock_reco_qty_reposting(self):
⋮...
│	def test_backdated_stock_reco_future_negative_stock(self):
⋮...
│	def test_backdated_stock_reco_cancellation_future_negative_stock(self):
⋮...
│	def test_intermediate_sr_bin_update(self):
⋮...
│	def test_valid_batch(self):
⋮...
│	def test_serial_no_cancellation(self):
⋮...
│	def test_serial_no_creation_and_inactivation(self):
⋮...
│	def test_serial_no_batch_no_item(self):
⋮...
│	def test_backdated_stock_reco_entry(self):
⋮...
│	def test_update_stock_reconciliation_while_reposting(self):
⋮...
│	def test_make_stock_zero_for_serial_batch_item(self):
⋮...
│	def test_backdated_purchase_receipt_with_stock_reco(self):
⋮...
│	def test_balance_qty_for_batch_with_backdated_stock_reco_and_future_entries(self):
⋮...
│	def test_stock_reco_and_backdated_purchase_receipt(self):
⋮...
│	def test_not_reconcile_all_batch(self):
⋮...
│	def test_not_reconcile_all_serial_nos(self):
⋮...
│	def test_stock_reco_with_legacy_batch(self):
⋮...
│	def test_skip_reposting_for_entries_after_stock_reco(self):
⋮...
│	def test_stock_reco_for_negative_batch(self):
⋮...
│	def test_stock_reco_batch_item_current_valuation(self):
⋮...
│def insert_existing_sle(warehouse, item_code="_Test Item"):
⋮...
│def create_batch_or_serial_no_items():
⋮...

erpnext\accounts\doctype\period_closing_voucher\test_period_closing_voucher.py:
│def create_account():
⋮...
│def create_cost_center(cc_name):
⋮...
│def create_company():
⋮...
│class TestPeriodClosingVoucher(IntegrationTestCase):
⋮...
│	def test_closing_entry(self):
⋮...
│	def test_cost_center_wise_posting(self):
⋮...
│	def test_period_closing_with_finance_book_entries(self):
⋮...
│	def test_gl_entries_restrictions(self):
⋮...
│	def test_closing_balance_with_dimensions_and_test_reposting_entry(self):
⋮...
│	def make_period_closing_voucher(self, posting_date, submit=True):
⋮...

erpnext\manufacturing\doctype\production_plan\production_plan.py:
│def get_items_for_material_requests(doc, warehouses=None, get_parent_warehouse_data=None):
⋮...
│def get_bin_details(row, company, for_warehouse=None, all_warehouse=False):
⋮...
│def get_uom_conversion_factor(item_code, uom):
│	return frappe.db.get_value(
│		"UOM Conversion Detail", {"parent": item_code, "uom": uom}, "conversion_factor"
│	)
⋮...
│def get_warehouse_list(warehouses):
⋮...
│def get_exploded_items(item_details, company, bom_no, include_non_stock_items, planned_qty=1, doc=None):
⋮...
│def get_sales_orders(self):
⋮...
│def get_subitems(
│	doc,
│	data,
│	item_details,
│	bom_no,
│	company,
│	include_non_stock_items,
│	include_subcontracted_items,
│	parent_qty,
│	planned_qty=1,
│):
⋮...
│def get_item_data(item_code):
⋮...
│def get_sub_assembly_items(
│	sub_assembly_items,
│	bin_details,
│	bom_no,
│	bom_data,
│	to_produce_qty,
│	company,
│	warehouse=None,
│	indent=0,
│	skip_available_sub_assembly_item=False,
│):
⋮...
│def get_non_completed_production_plans():
⋮...
│def get_raw_materials_of_sub_assembly_items(
│	existing_sub_assembly_items,
│	item_details,
│	company,
│	bom_no,
│	include_non_stock_items,
│	sub_assembly_items,
│	planned_qty=1,
│):
⋮...
│def get_reserved_qty_for_sub_assembly(item_code, warehouse):
⋮...
│class ProductionPlan(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_material_request_type(self):
│		for row in self.get("mr_items"):
│			if row.from_warehouse and row.material_request_type != "Material Transfer":
│				row.from_warehouse = ""
⋮...
│	def validate_sales_orders(self, sales_order=None):
⋮...
│	def set_pending_qty_in_row_without_reference(self):
⋮...
│	def calculate_total_planned_qty(self):
│		self.total_planned_qty = 0
│		for d in self.po_items:
│			self.total_planned_qty += flt(d.planned_qty)
⋮...
│	def validate_data(self):
⋮...
│	def _rename_temporary_references(self):
⋮...
│	def get_open_sales_orders(self):
⋮...
│	def add_so_in_table(self, open_so):
⋮...
│	def get_pending_material_requests(self):
⋮...
│	def add_mr_in_table(self, pending_mr):
⋮...
│	def combine_so_items(self):
⋮...
│	def get_items(self):
⋮...
│	def get_so_mr_list(self, field, table):
│		"""Returns a list of Sales Orders or Material Requests from the respective tables"""
│		so_mr_list = [d.get(field) for d in self.get(table) if d.get(field)]
│		return so_mr_list
⋮...
│	def get_bom_item_condition(self):
⋮...
│	def get_so_items(self):
⋮...
│	def get_mr_items(self):
⋮...
│	def add_items(self, items):
⋮...
│	def add_pp_ref(self, refs):
⋮...
│	def calculate_total_produced_qty(self):
│		self.total_produced_qty = 0
│		for d in self.po_items:
│			self.total_produced_qty += flt(d.produced_qty)
│
│		self.db_set("total_produced_qty", self.total_produced_qty, update_modified=False)
⋮...
│	def update_produced_pending_qty(self, produced_qty, production_plan_item):
⋮...
│	def on_submit(self):
│		self.update_bin_qty()
│		self.update_sales_order()
⋮...
│	def on_cancel(self):
│		self.db_set("status", "Cancelled")
│		self.delete_draft_work_order()
│		self.update_bin_qty()
│		self.update_sales_order()
⋮...
│	def update_sales_order(self):
⋮...
│	def get_so_wise_planned_qty(sales_orders):
⋮...
│	def update_bin_qty(self):
⋮...
│	def delete_draft_work_order(self):
│		for d in frappe.get_all(
│			"Work Order", fields=["name"], filters={"docstatus": 0, "production_plan": ("=", self.name)}
│		):
│			frappe.delete_doc("Work Order", d.name)
⋮...
│	def set_status(self, close=None, update_bin=False):
⋮...
│	def update_ordered_status(self):
⋮...
│	def update_requested_status(self):
⋮...
│	def get_production_items(self):
⋮...
│	def make_work_order(self):
⋮...
│	def make_work_order_for_finished_goods(self, wo_list, default_warehouses):
⋮...
│	def make_work_order_for_subassembly_items(self, wo_list, subcontracted_po, default_warehouses):
⋮...
│	def prepare_data_for_sub_assembly_items(self, row, wo_data):
⋮...
│	def make_subcontracted_purchase_order(self, subcontracted_po, purchase_orders):
⋮...
│	def show_list_created_message(self, doctype, doc_list=None):
⋮...
│	def create_work_order(self, item):
⋮...
│	def validate_mr_subcontracted(self):
⋮...
│	def make_material_request(self):
⋮...
│	def get_sub_assembly_items(self, manufacturing_type=None):
⋮...
│	def set_sub_assembly_items_based_on_level(self, row, bom_data, manufacturing_type=None):
⋮...
│	def set_default_supplier_for_subcontracting_order(self):
⋮...
│	def combine_subassembly_items(self, sub_assembly_items_store):
⋮...
│	def all_items_completed(self):
⋮...
│def download_raw_materials(doc, warehouses=None):
⋮...
│def get_material_request_items(
│	doc,
│	row,
│	sales_order,
│	company,
│	ignore_existing_ordered_qty,
│	include_safety_stock,
│	warehouse,
│	bin_dict,
│):
⋮...
│def get_so_details(sales_order):
│	return frappe.db.get_value(
│		"Sales Order", sales_order, ["transaction_date", "customer", "grand_total"], as_dict=1
│	)
⋮...
│def get_materials_from_other_locations(item, warehouses, new_mr_items, company):
⋮...
│def set_default_warehouses(row, default_warehouses):
│	for field in ["wip_warehouse", "fg_warehouse"]:
│		if not row.get(field):
│			row[field] = default_warehouses.get(field)
⋮...
│def get_reserved_qty_for_production_plan(item_code, warehouse):
⋮...
│def sales_order_query(doctype=None, txt=None, searchfield=None, start=None, page_len=None, filters=None):
⋮...

erpnext\stock\doctype\stock_entry\test_stock_entry.py:
│def make_serialized_item(self, **args):
⋮...
│def get_qty_after_transaction(**args):
⋮...
│def get_sle(**args):
⋮...
│class UnitTestStockEntry(UnitTestCase):
⋮...
│class TestStockEntry(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
│		frappe.set_user("Administrator")
⋮...
│	def test_stock_entry_qty(self):
⋮...
│	def test_fifo(self):
⋮...
│	def test_auto_material_request(self):
│		make_item_variant()
│		self._test_auto_material_request("_Test Item")
│		self._test_auto_material_request("_Test Item", material_request_type="Transfer")
⋮...
│	def test_barcode_item_stock_entry(self):
│		item_code = make_item("_Test Item Stock Entry For Barcode", barcode="BDD-1234567890")
│
│		se = make_stock_entry(item_code=item_code, target="_Test Warehouse - _TC", qty=1, basic_rate=100)
│		self.assertEqual(se.items[0].barcode, "BDD-1234567890")
⋮...
│	def test_auto_material_request_for_variant(self):
⋮...
│	def test_auto_material_request_for_warehouse_group(self):
│		self._test_auto_material_request(
│			"_Test Item Warehouse Group Wise Reorder", warehouse="_Test Warehouse Group-C1 - _TC"
│		)
⋮...
│	def _test_auto_material_request(
│		self, item_code, material_request_type="Purchase", warehouse="_Test Warehouse - _TC"
│	):
⋮...
│	def test_add_to_transit_entry(self):
⋮...
│	def test_material_receipt_gl_entry(self):
⋮...
│	def test_material_issue_gl_entry(self):
⋮...
│	def test_material_transfer_gl_entry(self):
⋮...
│	def test_repack_multiple_fg(self):
⋮...
│	def test_repack_no_change_in_valuation(self):
⋮...
│	def test_repack_with_additional_costs(self):
⋮...
│	def check_stock_ledger_entries(self, voucher_type, voucher_no, expected_sle):
⋮...
│	def check_gl_entries(self, voucher_type, voucher_no, expected_gl_entries):
⋮...
│	def test_serial_no_not_reqd(self):
⋮...
│	def test_serial_no_reqd(self):
⋮...
│	def test_serial_no_qty_less(self):
⋮...
│	def test_serial_no_transfer_in(self):
⋮...
│	def test_serial_by_series(self):
⋮...
│	def test_serial_move(self):
⋮...
│	def test_serial_cancel(self):
⋮...
│	def test_serial_batch_item_stock_entry(self):
⋮...
│	def test_warehouse_company_validation(self):
⋮...
│	def test_warehouse_user(self):
⋮...
│	def test_freeze_stocks(self):
⋮...
│	def test_work_order(self):
⋮...
│	def test_work_order_manufacture_with_material_consumption(self):
⋮...
│	def test_variant_work_order(self):
⋮...
│	def test_nagative_stock_for_batch(self):
⋮...
│	def test_quality_check_for_scrap_item(self):
⋮...
│	def test_quality_check(self):
⋮...
│	def test_customer_provided_parts_se(self):
⋮...
│	def test_zero_incoming_rate(self):
⋮...
│	def test_gle_for_opening_stock_entry(self):
⋮...
│	def test_total_basic_amount_zero(self):
⋮...
│	def test_conversion_factor_change(self):
⋮...
│	def test_additional_cost_distribution_manufacture(self):
⋮...
│	def test_additional_cost_distribution_non_manufacture(self):
⋮...
│	def test_independent_manufacture_entry(self):
⋮...
│	def test_future_negative_sle(self):
⋮...
│	def test_future_negative_sle_batch(self):
⋮...
│	def test_multi_batch_value_diff(self):
⋮...
│	def test_transfer_qty_validation(self):
│		se = make_stock_entry(item_code="_Test Item", do_not_save=True, qty=0.001, rate=100)
│		se.items[0].uom = "Kg"
│		se.items[0].conversion_factor = 0.002
│
│		self.assertRaises(frappe.ValidationError, se.save)
⋮...
│	def test_mapped_stock_entry(self):
⋮...
│	def test_stock_entry_item_details(self):
⋮...
│	def test_reposting_for_depedent_warehouse(self):
⋮...
│	def test_batch_expiry(self):
⋮...
│	def test_negative_stock_reco(self):
⋮...
│	def test_negative_batch(self):
⋮...
│	def test_auto_reorder_level(self):
⋮...
│	def test_auto_reorder_level_with_lead_time_days(self):
⋮...
│	def test_use_serial_and_batch_fields(self):
⋮...
│	def test_serial_batch_bundle_type_of_transaction(self):
⋮...
│	def test_stock_entry_for_same_posting_date_and_time(self):
⋮...
│	def test_stock_entry_amount(self):
⋮...
│	def test_use_batch_wise_valuation_for_moving_average_item(self):
⋮...
│def get_multiple_items():
⋮...
│def initialize_records_for_future_negative_sle_test(
│	item_code, batch_no, warehouses, opening_qty, posting_date
│):
⋮...
│def create_stock_entries(sequence_of_entries):
│	for entry_detail in sequence_of_entries:
│		make_stock_entry(**entry_detail)
⋮...

erpnext\stock\doctype\serial_no\serial_no.py:
│def get_serial_nos(serial_no):
│	if isinstance(serial_no, list):
│		return serial_no
│
│	return [s.strip() for s in cstr(serial_no).strip().replace(",", "\n").split("\n") if s.strip()]
⋮...
│def get_available_serial_nos(serial_no_series, qty) -> list[str]:
│	serial_nos = []
│	for _i in range(cint(qty)):
│		serial_nos.append(get_new_serial_number(serial_no_series))
│
│	return serial_nos
⋮...
│def get_serial_nos_for_outward(kwargs):
⋮...
│class SerialNoCannotCannotChangeError(ValidationError):
│	pass
⋮...
│def clean_serial_no_string(serial_no: str) -> str:
│	if not serial_no:
│		return ""
│
│	serial_no_list = get_serial_nos(serial_no)
│	return "\n".join(serial_no_list)
⋮...
│class SerialNoCannotCreateDirectError(ValidationError):
│	pass
⋮...
│def get_new_serial_number(series):
│	sr_no = make_autoname(series, "Serial No")
│	if frappe.db.exists("Serial No", sr_no):
│		sr_no = get_new_serial_number(series)
│	return sr_no
⋮...
│class SerialNoWarehouseError(ValidationError):
│	pass
⋮...
│class SerialNo(StockController):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		self.via_stock_ledger = False
⋮...
│	def validate(self):
⋮...
│	def validate_warehouse(self):
⋮...
│	def set_maintenance_status(self):
⋮...
│	def on_trash(self):
⋮...
│def get_items_html(serial_nos, item_code):
⋮...
│def get_serial_nos_from_sle_list(bundles):
⋮...
│def update_maintenance_status():
⋮...
│def auto_fetch_serial_number(
│	qty: int,
⋮...
│def get_pos_reserved_serial_nos(filters):
⋮...
│def fetch_serial_numbers(filters, qty, do_not_include=None):
⋮...

erpnext\controllers\sales_and_purchase_return.py:
│def make_return_doc(doctype: str, source_name: str, target_doc=None, return_against_rejected_qty=False):
⋮...
│def get_filters(
│	voucher_type,
│	voucher_no,
│	voucher_detail_no,
│	return_against,
│	item_code,
│	return_against_item_field,
│	item_row,
│):
⋮...
│def get_available_serial_nos(serial_nos, warehouse):
│	return frappe.get_all(
│		"Serial No", filters={"warehouse": warehouse, "name": ("in", serial_nos)}, pluck="name"
│	)
⋮...
│def get_returned_qty_map_for_row(return_against, party, row_name, doctype):
⋮...
│def get_rate_for_return(
│	voucher_type,
│	voucher_no,
│	item_code,
│	return_against=None,
│	item_row=None,
│	voucher_detail_no=None,
│	sle=None,
│):
⋮...
│class StockOverReturnError(frappe.ValidationError):
│	pass
⋮...
│def validate_quantity(doc, key, args, ref, valid_items, already_returned_items):
⋮...
│def get_ref_item_dict(valid_items, ref_item_row):
⋮...
│def get_returned_serial_nos(child_doc, parent_doc, serial_no_field=None, ignore_voucher_detail_no=None):
⋮...
│def available_serial_batch_for_return(field, doctype, reference_ids, is_rejected=False):
│	available_dict = get_available_serial_batches(field, doctype, reference_ids, is_rejected=is_rejected)
│	if not available_dict:
│		frappe.throw(_("No Serial / Batches are available for return"))
│
│	return available_dict
⋮...
│def get_serial_and_batch_bundle(field, doctype, reference_ids, is_rejected=False):
⋮...
│def filter_serial_batches(parent_doc, data, row, warehouse_field=None, qty_field=None):
⋮...
│def make_serial_batch_bundle_for_return(data, child_doc, parent_doc, warehouse_field=None, qty_field=None):
⋮...
│def validate_return(doc):
⋮...
│def validate_return_against(doc):
⋮...
│def validate_returned_items(doc):
⋮...
│def get_already_returned_items(doc):
⋮...
│def get_return_against_item_fields(voucher_type):
⋮...
│def get_returned_batches(child_doc, parent_doc, batch_no_field=None, ignore_voucher_detail_no=None):
⋮...
│def get_available_serial_batches(field, doctype, reference_ids, is_rejected=False):
│	_bundle_ids = get_serial_and_batch_bundle(field, doctype, reference_ids, is_rejected=is_rejected)
│	if not _bundle_ids:
│		return frappe._dict({})
│
│	return get_serial_batches_based_on_bundle(field, _bundle_ids)
⋮...
│def get_serial_batches_based_on_bundle(field, _bundle_ids):
⋮...
│def get_available_batch_qty(parent_doc, batch_no, warehouse):
⋮...
│def get_payment_data(invoice):
│	payment = frappe.db.get_all("Sales Invoice Payment", {"parent": invoice}, ["mode_of_payment", "amount"])
│	return payment
⋮...
│def get_pos_invoice_item_returned_qty(pos_invoice, customer, item_row_name):
│	is_return, docstatus = frappe.db.get_value("POS Invoice", pos_invoice, ["is_return", "docstatus"])
│	if not is_return and docstatus == 1:
│		return get_returned_qty_map_for_row(pos_invoice, customer, item_row_name, "POS Invoice")
⋮...
│def is_pos_invoice_returnable(pos_invoice):
⋮...

erpnext\accounts\doctype\account\test_account.py:
│def create_account(**kwargs):
⋮...
│def get_inventory_account(company, warehouse=None):
⋮...
│class TestAccount(IntegrationTestCase):
⋮...
│	def test_rename_account(self):
⋮...
│	def test_merge_account(self):
⋮...
│	def test_account_sync(self):
⋮...
│	def test_add_account_to_a_group(self):
⋮...
│	def test_account_rename_sync(self):
⋮...
│	def test_account_currency_sync(self):
⋮...
│	def test_child_company_account_rename_sync(self):
⋮...
│	def test_validate_account_currency(self):
⋮...
│	def test_account_balance(self):
⋮...
│def _make_test_records(verbose=None):
⋮...

erpnext\manufacturing\doctype\bom_creator\bom_creator.py:
│def get_item_details(item_code):
│	return frappe.get_cached_value(
│		"Item", item_code, ["item_name", "description", "image", "stock_uom", "default_bom"], as_dict=1
│	)
⋮...
│def get_children(doctype=None, parent=None, **kwargs):
⋮...
│def add_item(**kwargs):
⋮...
│def add_sub_assembly(**kwargs):
⋮...
│def get_parent_row_no(doc, name):
│	for row in doc.items:
│		if row.name == name:
│			return row.idx
│
│	frappe.msgprint(_("Parent Row No not found for {0}").format(name))
⋮...
│class BOMCreator(Document):
⋮...
│	def before_save(self):
│		self.set_status()
│		self.set_is_expandable()
│		self.set_conversion_factor()
│		self.set_reference_id()
│		self.set_rate_for_items()
⋮...
│	def validate(self):
│		self.validate_items()
⋮...
│	def validate_items(self):
⋮...
│	def set_status(self, save=False):
⋮...
│	def set_status_completed(self):
⋮...
│	def on_cancel(self):
│		self.set_status(True)
⋮...
│	def set_conversion_factor(self):
│		for row in self.items:
│			row.conversion_factor = 1.0
⋮...
│	def before_submit(self):
│		self.validate_fields()
│		self.set_status()
⋮...
│	def set_reference_id(self):
⋮...
│	def add_boms(self):
│		self.submit()
⋮...
│	def set_rate_for_items(self):
│		amount = self.get_raw_material_cost()
│		self.raw_material_cost = amount
⋮...
│	def get_raw_material_cost(self, fg_item=None, amount=0):
⋮...
│	def set_is_expandable(self):
│		fg_items = [row.fg_item for row in self.items if row.fg_item != self.item_code]
│		for row in self.items:
│			row.is_expandable = 0
│			if row.item_code in fg_items:
│				row.is_expandable = 1
⋮...
│	def validate_fields(self):
⋮...
│	def on_submit(self):
│		self.enqueue_create_boms()
⋮...
│	def enqueue_create_boms(self):
⋮...
│	def create_boms(self):
⋮...
│	def create_bom(self, row, production_item_wise_rm):
⋮...
│	def has_operations(self):
│		for row in self.items:
│			if row.operation:
│				return True
│
│		return False
⋮...
│	def get_default_bom(self, item_code) -> str:
│		return frappe.get_cached_value("Item", item_code, "default_bom")
⋮...
│def delete_node(**kwargs):
⋮...
│def edit_bom_creator(doctype, docname, data, parent):
⋮...

erpnext\assets\doctype\asset_capitalization\test_asset_capitalization.py:
│def create_stock_reconciliation(asset_capitalization, stock_rate=0):
⋮...
│def get_actual_gle_dict(name):
⋮...
│def get_actual_sle_dict(name):
⋮...
│def create_asset_capitalization(**args):
⋮...
│class TestAssetCapitalization(IntegrationTestCase):
⋮...
│	def setUp(self):
│		set_depreciation_settings_in_company()
│		create_asset_data()
│		create_asset_capitalization_data()
│		frappe.db.sql("delete from `tabTax Rule`")
⋮...
│	def test_capitalization_with_perpetual_inventory(self):
⋮...
│	def test_capitalization_with_periodical_inventory(self):
⋮...
│	def test_capitalization_with_wip_composite_asset(self):
⋮...
│	def test_capitalize_only_service_item(self):
⋮...
│def create_asset_capitalization_data():
│	create_item("Capitalization Target Stock Item", is_stock_item=1, is_fixed_asset=0, is_purchase_item=0)
│	create_item("Capitalization Source Stock Item", is_stock_item=1, is_fixed_asset=0, is_purchase_item=0)
│	create_item("Capitalization Source Service Item", is_stock_item=0, is_fixed_asset=0, is_purchase_item=0)
⋮...
│def create_depreciation_asset(**args):
⋮...

erpnext\selling\doctype\customer\customer.py:
│def make_quotation(source_name, target_doc=None):
⋮...
│def make_address(args, is_primary_address=1, is_shipping_address=1):
⋮...
│def make_opportunity(source_name, target_doc=None):
⋮...
│def _set_missing_values(source, target):
⋮...
│def get_customer_outstanding(customer, company, ignore_outstanding_sales_order=False, cost_center=None):
⋮...
│def parse_full_name(full_name: str) -> tuple[str, str | None, str | None]:
⋮...
│def check_credit_limit(customer, company, ignore_outstanding_sales_order=False, extra_amount=0):
⋮...
│def get_credit_limit(customer, company):
⋮...
│def make_payment_entry(source_name, target_doc=None):
⋮...
│def get_loyalty_programs(doc):
⋮...
│def get_nested_links(link_doctype, link_name, ignore_permissions=False):
⋮...
│def send_emails(customer, customer_outstanding, credit_limit, credit_controller_users_list):
⋮...
│def make_contact(args, is_primary_contact=1):
⋮...
│class Customer(TransactionBase):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
│		self.load_dashboard_info()
⋮...
│	def load_dashboard_info(self):
│		info = get_dashboard_info(self.doctype, self.name, self.loyalty_program)
│		self.set_onload("dashboard_info", info)
⋮...
│	def autoname(self):
⋮...
│	def get_customer_name(self):
⋮...
│	def after_insert(self):
│		"""If customer created from Lead, update customer id in quotations, opportunities"""
│		self.update_lead_status()
⋮...
│	def validate(self):
⋮...
│	def get_customer_group_details(self):
⋮...
│	def check_customer_group_change(self):
│		frappe.flags.customer_group_changed = False
│
│		if not self.get("__islocal"):
│			if self.customer_group != frappe.db.get_value("Customer", self.name, "customer_group"):
│				frappe.flags.customer_group_changed = True
⋮...
│	def validate_default_bank_account(self):
⋮...
│	def validate_internal_customer(self):
⋮...
│	def on_update(self):
⋮...
│	def add_role_for_user(self):
│		for portal_user in self.portal_users:
│			add_role_for_portal_user(portal_user, "Customer")
⋮...
│	def update_customer_groups(self):
│		ignore_doctypes = ["Lead", "Opportunity", "POS Profile", "Tax Rule", "Pricing Rule"]
│		if frappe.flags.customer_group_changed:
│			update_linked_doctypes(
│				"Customer", self.name, "Customer Group", self.customer_group, ignore_doctypes
│			)
⋮...
│	def create_primary_contact(self):
⋮...
│	def create_primary_address(self):
⋮...
│	def update_lead_status(self):
│		"""If Customer created from Lead, update lead status to "Converted"
│		update Customer link in Quotation, Opportunity"""
│		if self.lead_name:
│			frappe.db.set_value("Lead", self.lead_name, "status", "Converted")
⋮...
│	def link_lead_address_and_contact(self):
⋮...
│	def copy_communication(self):
⋮...
│	def validate_name_with_customer_group(self):
⋮...
│	def validate_credit_limit_on_change(self):
⋮...
│	def on_trash(self):
⋮...
│	def after_rename(self, olddn, newdn, merge=False):
│		if frappe.defaults.get_global_default("cust_master_name") == "Customer Name":
│			self.db_set("customer_name", newdn)
⋮...
│	def set_loyalty_program(self):
⋮...
│def get_customer_primary_contact(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\accounts\doctype\accounting_dimension\accounting_dimension.py:
│def get_accounting_dimensions(as_list=True, filters=None):
⋮...
│def get_dimensions(with_cost_center_and_project=False):
⋮...
│def disable_dimension(doc):
│	if frappe.flags.in_test:
│		toggle_disabling(doc=doc)
│	else:
│		frappe.enqueue(toggle_disabling, doc=doc)
⋮...
│def get_checks_for_pl_and_bs_accounts():
⋮...
│def get_dimension_with_children(doctype, dimensions):
⋮...
│def create_accounting_dimensions_for_doctype(doctype):
⋮...
│def get_doctypes_with_dimensions():
│	return frappe.get_hooks("accounting_dimension_doctypes")
⋮...
│def make_dimension_in_accounting_doctypes(doc, doclist=None):
⋮...
│def delete_accounting_dimension(doc):
⋮...
│def toggle_disabling(doc):
⋮...
│class AccountingDimension(Document):
⋮...
│	def before_insert(self):
│		self.set_fieldname_and_label()
⋮...
│	def validate(self):
│		self.validate_doctype()
│		validate_column_name(self.fieldname)
│		self.validate_dimension_defaults()
⋮...
│	def validate_doctype(self):
⋮...
│	def validate_document_type_change(self):
│		doctype_before_save = frappe.db.get_value("Accounting Dimension", self.name, "document_type")
│		if doctype_before_save != self.document_type:
│			message = _("Cannot change Reference Document Type.")
│			message += _("Please create a new Accounting Dimension if required.")
│			frappe.throw(message)
⋮...
│	def validate_dimension_defaults(self):
⋮...
│	def after_insert(self):
⋮...
│	def on_trash(self):
│		if frappe.flags.in_test:
│			delete_accounting_dimension(doc=self)
│		else:
│			frappe.enqueue(delete_accounting_dimension, doc=self, queue="long", enqueue_after_commit=True)
⋮...
│	def set_fieldname_and_label(self):
│		if not self.label:
│			self.label = cstr(self.document_type)
│
│		if not self.fieldname:
│			self.fieldname = scrub(self.label)
⋮...
│	def on_update(self):
│		frappe.flags.accounting_dimensions = None
│		frappe.flags.accounting_dimensions_details = None
⋮...
│def add_dimension_to_budget_doctype(df, doc):
⋮...

erpnext\accounts\doctype\pos_invoice\test_pos_invoice.py:
│def create_pos_invoice(**args):
⋮...
│class TestPOSInvoice(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
⋮...
│	def tearDown(self):
│		if frappe.session.user != "Administrator":
│			frappe.set_user("Administrator")
│
│		if frappe.db.get_single_value("Selling Settings", "validate_selling_price"):
│			frappe.db.set_single_value("Selling Settings", "validate_selling_price", 0)
⋮...
│	def test_timestamp_change(self):
⋮...
│	def test_change_naming_series(self):
│		inv = create_pos_invoice(do_not_submit=1)
│		inv.naming_series = "TEST-"
│
│		self.assertRaises(frappe.CannotChangeConstantError, inv.save)
⋮...
│	def test_discount_and_inclusive_tax(self):
⋮...
│	def test_tax_calculation_with_multiple_items(self):
⋮...
│	def test_tax_calculation_with_item_tax_template(self):
⋮...
│	def test_tax_calculation_with_multiple_items_and_discount(self):
⋮...
│	def test_pos_returns_with_repayment(self):
⋮...
│	def test_pos_return_for_serialized_item(self):
⋮...
│	def test_partial_pos_returns(self):
⋮...
│	def test_pos_change_amount(self):
⋮...
│	def test_without_payment(self):
│		inv = create_pos_invoice(do_not_save=1)
│		# Check that the invoice cannot be submitted without payments
│		inv.payments = []
│		self.assertRaises(frappe.ValidationError, inv.insert)
⋮...
│	def test_partial_payment(self):
⋮...
│	def test_serialized_item_transaction(self):
⋮...
│	def test_delivered_serialized_item_transaction(self):
⋮...
│	def test_invalid_serial_no_validation(self):
⋮...
│	def test_value_error_on_serial_no_validation(self):
⋮...
│	def test_loyalty_points(self):
⋮...
│	def test_loyalty_points_redeemption(self):
⋮...
│	def test_merging_into_sales_invoice_with_discount(self):
⋮...
│	def test_merging_into_sales_invoice_with_discount_and_inclusive_tax(self):
⋮...
│	def test_merging_with_validate_selling_price(self):
⋮...
│	def test_pos_batch_reservation(self):
⋮...
│	def test_pos_batch_item_qty_validation(self):
⋮...
│	def test_ignore_pricing_rule(self):
⋮...
│	def test_delivered_serial_no_case(self):
⋮...
│def make_batch_item(item_name):
│	from erpnext.stock.doctype.item.test_item import make_item
│
│	if not frappe.db.exists(item_name):
│		return make_item(item_name, dict(has_batch_no=1, create_new_batch=1, is_stock_item=1))
⋮...

erpnext\support\doctype\issue\issue.py:
│def get_list_context(context=None):
⋮...
│def set_multiple_status(names, status):
│	for name in json.loads(names):
│		frappe.db.set_value("Issue", name, "status", status)
⋮...
│def get_elapsed_time(start_time, end_time):
│	return round(time_diff_in_seconds(end_time, start_time), 2)
⋮...
│def get_working_hours(date, support_hours):
│	if is_work_day(date, support_hours):
│		weekday = frappe.utils.get_weekday(date)
│		for day in support_hours:
│			if day.workday == weekday:
│				return day.start_time, day.end_time
⋮...
│def is_during_working_hours(date, support_hours):
│	start_time, end_time = get_working_hours(date, support_hours)
│	time = get_time_in_seconds(date)
│	if time >= start_time and time <= end_time:
│		return True
│	return False
⋮...
│def is_work_day(date, support_hours):
│	weekday = frappe.utils.get_weekday(date)
│	for day in support_hours:
│		if day.workday == weekday:
│			return True
│	return False
⋮...
│def get_time_in_seconds(date):
│	return timedelta(hours=date.hour, minutes=date.minute, seconds=date.second)
⋮...
│def is_before_working_hours(date, support_hours):
│	start_time, end_time = get_working_hours(date, support_hours)
│	time = get_time_in_seconds(date)
│	if time < start_time:
│		return True
│	return False
⋮...
│class Issue(Document):
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		# Add a communication in the issue timeline
│		if self.flags.create_communication and self.via_customer_portal:
│			self.create_communication()
│			self.flags.communication_created = None
⋮...
│	def set_lead_contact(self, email_id):
⋮...
│	def create_communication(self):
⋮...
│	def split_issue(self, subject, communication_id):
⋮...
│	def reset_issue_metrics(self):
│		self.db_set("resolution_time", None)
│		self.db_set("user_resolution_time", None)
⋮...
│def get_issue_list(doctype, txt, filters, limit_start, limit_page_length=20, order_by=None):
⋮...
│def set_status(name, status):
│	frappe.db.set_value("Issue", name, "status", status)
⋮...
│def auto_close_tickets():
⋮...
│def has_website_permission(doc, ptype, user, verbose=False):
│	from erpnext.controllers.website_list_for_contact import has_website_permission
│
│	permission_based_on_customer = has_website_permission(doc, ptype, user, verbose)
│
│	return permission_based_on_customer or doc.raised_by == user
⋮...
│def update_issue(contact, method):
│	"""Called when Contact is deleted"""
│	frappe.db.sql("""UPDATE `tabIssue` set contact='' where contact=%s""", contact.name)
⋮...
│def make_task(source_name, target_doc=None):
│	return get_mapped_doc("Issue", source_name, {"Issue": {"doctype": "Task"}}, target_doc)
⋮...
│def make_issue_from_communication(communication, ignore_communication_links=False):
⋮...
│def get_time_in_timedelta(time):
│	"""
│	Converts datetime.time(10, 36, 55, 961454) to datetime.timedelta(seconds=38215)
│	"""
│	return timedelta(hours=time.hour, minutes=time.minute, seconds=time.second)
⋮...
│def set_first_response_time(communication, method):
│	if communication.get("reference_doctype") == "Issue":
│		issue = get_parent_doc(communication)
│		if is_first_response(issue) and issue.service_level_agreement:
│			first_response_time = calculate_first_response_time(issue, get_datetime(issue.first_responded_on))
│			issue.db_set("first_response_time", first_response_time)
⋮...
│def is_first_response(issue):
⋮...
│def calculate_first_response_time(issue, first_responded_on):
⋮...
│def calculate_initial_frt(issue_creation_date, days_in_between, support_hours):
⋮...
│def get_holidays(holiday_list_name):
│	holiday_list = frappe.get_cached_doc("Holiday List", holiday_list_name)
│	holidays = [holiday.holiday_date for holiday in holiday_list.holidays]
│	return holidays
⋮...

erpnext\accounts\doctype\budget\budget.py:
│def get_item_details(args):
⋮...
│class BudgetError(frappe.ValidationError):
│	pass
⋮...
│def validate_expense_against_budget(args, expense_amount=0):
⋮...
│def compare_expense_with_budget(args, budget_amount, action_for, action, budget_against, amount=0):
⋮...
│def get_other_condition(args, for_doc):
⋮...
│def get_actual_expense(args):
⋮...
│class DuplicateBudgetError(frappe.ValidationError):
│	pass
⋮...
│class Budget(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_duplicate(self):
⋮...
│	def validate_accounts(self):
⋮...
│	def set_null_value(self):
│		if self.budget_against == "Cost Center":
│			self.project = None
│		else:
│			self.cost_center = None
⋮...
│	def validate_applicable_for(self):
⋮...
│	def before_naming(self):
│		self.naming_series = f"{{{frappe.scrub(self.budget_against)}}}./.{self.fiscal_year}/.###"
⋮...
│def validate_budget_records(args, budget_records, expense_amount):
⋮...
│def get_expense_breakup(args, currency, budget_against):
⋮...
│def get_actions(args, budget):
⋮...
│def get_requested_amount(args):
⋮...
│def get_ordered_amount(args):
⋮...
│def get_accumulated_monthly_budget(monthly_distribution, posting_date, fiscal_year, annual_budget):
⋮...
│def get_expense_cost_center(doctype, args):
⋮...

erpnext\accounts\doctype\payment_request\payment_request.py:
│def make_payment_request(**args):
⋮...
│def _get_payment_gateway_controller(*args, **kwargs):
│	with payment_app_import_guard():
│		from payments.utils import get_payment_gateway_controller
│
│	return get_payment_gateway_controller(*args, **kwargs)
⋮...
│def get_amount(ref_doc, payment_account=None):
⋮...
│def get_existing_payment_request_amount(ref_doc, statuses: list | None = None) -> list:
⋮...
│def make_payment_entry(docname):
│	doc = frappe.get_doc("Payment Request", docname)
│	return doc.create_payment_entry(submit=False).as_dict()
⋮...
│class PaymentRequest(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_reference_document(self):
│		if not self.reference_doctype or not self.reference_name:
│			frappe.throw(_("To create a Payment Request reference document is required"))
⋮...
│	def validate_payment_request_amount(self):
⋮...
│	def validate_currency(self):
│		ref_doc = frappe.get_doc(self.reference_doctype, self.reference_name)
│		if self.payment_account and ref_doc.currency != frappe.get_cached_value(
│			"Account", self.payment_account, "account_currency"
│		):
│			frappe.throw(_("Transaction currency must be same as Payment Gateway currency"))
⋮...
│	def validate_subscription_details(self):
⋮...
│	def before_submit(self):
⋮...
│	def on_submit(self):
│		self.update_reference_advance_payment_status()
⋮...
│	def request_phone_payment(self):
⋮...
│	def get_request_amount(self):
⋮...
│	def on_cancel(self):
│		self.check_if_payment_entry_exists()
│		self.set_as_cancelled()
│		self.update_reference_advance_payment_status()
⋮...
│	def make_invoice(self):
⋮...
│	def payment_gateway_validation(self):
⋮...
│	def set_payment_request_url(self):
│		if self.payment_account and self.payment_gateway and self.payment_gateway_validation():
│			self.payment_url = self.get_payment_url()
⋮...
│	def get_payment_url(self):
⋮...
│	def set_as_paid(self):
⋮...
│	def create_payment_entry(self, submit=True):
⋮...
│	def send_email(self):
⋮...
│	def get_message(self):
⋮...
│	def set_failed(self):
│		pass
⋮...
│	def set_as_cancelled(self):
│		self.db_set("status", "Cancelled")
⋮...
│	def check_if_payment_entry_exists(self):
⋮...
│	def make_communication_entry(self):
⋮...
│	def create_subscription(self, payment_provider, gateway_controller, data):
│		if payment_provider == "stripe":
│			with payment_app_import_guard():
│				from payments.payment_gateways.stripe_integration import create_stripe_subscription
│
│			return create_stripe_subscription(gateway_controller, data)
⋮...
│	def update_reference_advance_payment_status(self):
⋮...
│	def _allocate_payment_request_to_pe_references(self, references):
⋮...
│def get_irequest_status(payment_requests: None | list = None) -> list:
⋮...
│def cancel_old_payment_requests(ref_dt, ref_dn):
⋮...
│def get_gateway_details(args):  # nosemgrep
│	"""
│	Return gateway and payment account of default payment gateway
│	"""
│	gateway_account = args.get("payment_gateway_account", {"is_default": 1})
│	return get_payment_gateway_account(gateway_account)
⋮...
│def get_payment_gateway_account(filter):
⋮...
│def get_print_format_list(ref_doctype):
⋮...
│def resend_payment_email(docname):
│	return frappe.get_doc("Payment Request", docname).send_email()
⋮...
│def update_payment_requests_as_per_pe_references(references=None, cancel=False):
⋮...
│def get_dummy_message(doc):
⋮...
│def get_subscription_details(reference_doctype, reference_name):
⋮...
│def make_payment_order(source_name, target_doc=None):
⋮...
│def validate_payment(doc, method=None):
⋮...
│def get_open_payment_requests_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_irequests_of_payment_request(doc: str | None = None) -> list:
⋮...

erpnext\subcontracting\doctype\subcontracting_order\subcontracting_order.py:
│def make_subcontracting_receipt(source_name, target_doc=None):
│	return get_mapped_subcontracting_receipt(source_name, target_doc)
⋮...
│class SubcontractingOrder(SubcontractingController):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def onload(self):
│		self.set_onload(
│			"over_transfer_allowance",
│			frappe.db.get_single_value("Buying Settings", "over_transfer_allowance"),
│		)
⋮...
│	def before_validate(self):
│		super().before_validate()
⋮...
│	def validate(self):
⋮...
│	def on_submit(self):
│		self.update_prevdoc_status()
│		self.update_status()
│		self.update_subcontracted_quantity_in_po()
⋮...
│	def on_cancel(self):
│		self.update_prevdoc_status()
│		self.update_status()
│		self.update_subcontracted_quantity_in_po(cancel=True)
⋮...
│	def validate_purchase_order_for_subcontracting(self):
⋮...
│	def validate_service_items(self):
⋮...
│	def validate_supplied_items(self):
│		if self.supplier_warehouse:
│			for item in self.supplied_items:
│				if self.supplier_warehouse == item.reserve_warehouse:
│					msg = f"Reserve Warehouse must be different from Supplier Warehouse for Supplied Item {item.main_item_code}."
│					frappe.throw(_(msg))
⋮...
│	def set_missing_values(self):
│		self.calculate_additional_costs()
│		self.calculate_service_costs()
│		self.calculate_supplied_items_qty_and_amount()
│		self.calculate_items_qty_and_amount()
⋮...
│	def calculate_service_costs(self):
│		for idx, item in enumerate(self.get("service_items")):
│			self.items[idx].service_cost_per_qty = item.amount / self.items[idx].qty
⋮...
│	def calculate_supplied_items_qty_and_amount(self):
│		for item in self.get("items"):
│			bom = frappe.get_doc("BOM", item.bom)
│			rm_cost = sum(flt(rm_item.amount) for rm_item in bom.items)
│			item.rm_cost_per_qty = rm_cost / flt(bom.quantity)
⋮...
│	def calculate_items_qty_and_amount(self):
⋮...
│	def update_ordered_qty_for_subcontracting(self, sco_item_rows=None):
⋮...
│	def get_ordered_qty(item_code, warehouse):
⋮...
│	def update_reserved_qty_for_subcontracting(self):
│		for item in self.supplied_items:
│			if item.rm_item_code:
│				stock_bin = get_bin(item.rm_item_code, item.reserve_warehouse)
│				stock_bin.update_reserved_qty_for_sub_contracting()
⋮...
│	def populate_items_table(self):
⋮...
│	def update_status(self, status=None, update_modified=True):
⋮...
│	def update_subcontracted_quantity_in_po(self, cancel=False):
⋮...
│def get_mapped_subcontracting_receipt(source_name, target_doc=None):
⋮...
│def update_subcontracting_order_status(sco, status=None):
│	if isinstance(sco, str):
│		sco = frappe.get_doc("Subcontracting Order", sco)
│
│	sco.update_status(status)
⋮...

erpnext\accounts\doctype\pos_invoice\pos_invoice.py:
│def make_sales_return(source_name, target_doc=None):
│	from erpnext.controllers.sales_and_purchase_return import make_return_doc
│
│	return make_return_doc("POS Invoice", source_name, target_doc)
⋮...
│class POSInvoice(SalesInvoice):
⋮...
│def item_query(doctype, txt, searchfield, start, page_len, filters, as_dict=False):
⋮...
│def get_pos_reserved_qty(item_code, warehouse):
⋮...
│class PartialPaymentValidationError(frappe.ValidationError):
│	pass
⋮...
│def get_stock_availability(item_code, warehouse):
⋮...
│def get_bin_qty(item_code, warehouse):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
⋮...
│	def validate(self):
⋮...
│	def on_submit(self):
⋮...
│	def before_cancel(self):
⋮...
│	def on_cancel(self):
⋮...
│	def clear_unallocated_mode_of_payments(self):
│		self.set("payments", self.get("payments", {"amount": ["not in", [0, None, ""]]}))
│
│		sip = frappe.qb.DocType("Sales Invoice Payment")
│		frappe.qb.from_(sip).delete().where(sip.parent == self.name).where(sip.amount == 0).run()
⋮...
│	def delink_serial_and_batch_bundle(self):
⋮...
│	def submit_serial_batch_bundle(self, table_name):
⋮...
│	def check_phone_payments(self):
⋮...
│	def validate_pos_opening_entry(self):
⋮...
│	def validate_stock_availablility(self):
⋮...
│	def validate_serialised_or_batched_item(self):
⋮...
│	def validate_return_items_qty(self):
⋮...
│	def validate_mode_of_payment(self):
│		if len(self.payments) == 0:
│			frappe.throw(_("At least one mode of payment is required for POS invoice."))
⋮...
│	def validate_change_account(self):
⋮...
│	def validate_change_amount(self):
⋮...
│	def validate_payment_amount(self):
⋮...
│	def validate_company_with_pos_company(self):
⋮...
│	def validate_loyalty_transaction(self):
⋮...
│	def validate_full_payment(self):
⋮...
│	def set_status(self, update=False, status=None, update_modified=True):
⋮...
│	def set_pos_fields(self, for_validate=False):
⋮...
│	def set_missing_values(self, for_validate=False):
⋮...
│	def reset_mode_of_payments(self):
│		if self.pos_profile:
│			pos_profile = frappe.get_cached_doc("POS Profile", self.pos_profile)
│			update_multi_mode_option(self, pos_profile)
│			self.paid_amount = 0
⋮...
│	def create_payment_request(self):
⋮...
│	def get_new_payment_request(self, mop):
⋮...
│	def get_existing_payment_request(self, pay):
⋮...
│def get_bundle_availability(bundle_item_code, warehouse):
⋮...
│def make_merge_log(invoices):
⋮...
│def add_return_modes(doc, pos_profile):
⋮...
│def get_item_group(pos_profile):
⋮...

erpnext\setup\doctype\company\company.py:
│def get_children(doctype, parent=None, company=None, is_root=False):
⋮...
│def add_node():
⋮...
│def get_timeline_data(doctype, name):
⋮...
│def install_country_fixtures(company, country):
⋮...
│def get_default_company_address(name, sort_key="is_primary_address", existing_address=None):
⋮...
│def update_company_current_month_sales(company):
⋮...
│def update_transactions_annual_history(company, commit=False):
│	transactions_history = get_all_transactions_annual_history(company)
│	frappe.db.set_value("Company", company, "transactions_annual_history", json.dumps(transactions_history))
│
│	if commit:
│		frappe.db.commit()
⋮...
│class Company(NestedSet):
⋮...
│	def onload(self):
│		load_address_and_contact(self, "company")
⋮...
│	def check_if_transactions_exist(self):
⋮...
│	def validate(self):
⋮...
│	def validate_abbr(self):
⋮...
│	def create_default_tax_template(self):
│		setup_taxes_and_charges(self.name, self.country)
⋮...
│	def validate_default_accounts(self):
⋮...
│	def validate_advance_account_currency(self):
⋮...
│	def validate_currency(self):
⋮...
│	def on_update(self):
⋮...
│	def create_default_warehouses(self):
⋮...
│	def create_default_accounts(self):
⋮...
│	def create_default_departments(self):
⋮...
│	def validate_coa_input(self):
⋮...
│	def validate_perpetual_inventory(self):
│		if not self.get("__islocal"):
│			if cint(self.enable_perpetual_inventory) == 1 and not self.default_inventory_account:
│				frappe.msgprint(
│					_("Set default inventory account for perpetual inventory"), alert=True, indicator="orange"
│				)
⋮...
│	def validate_provisional_account_for_non_stock_items(self):
⋮...
│	def check_country_change(self):
│		frappe.flags.country_change = False
│
│		if not self.is_new() and self.country != frappe.get_cached_value("Company", self.name, "country"):
│			frappe.flags.country_change = True
⋮...
│	def set_chart_of_accounts(self):
│		"""If parent company is set, chart of accounts will be based on that company"""
│		if self.parent_company:
│			self.create_chart_of_accounts_based_on = "Existing Company"
│			self.existing_company = self.parent_company
⋮...
│	def validate_parent_company(self):
│		if self.parent_company:
│			is_group = frappe.get_value("Company", self.parent_company, "is_group")
│
│			if not is_group:
│				frappe.throw(_("Parent Company must be a group company"))
⋮...
│	def set_default_accounts(self):
⋮...
│	def _set_default_account(self, fieldname, account_type):
⋮...
│	def set_mode_of_payment_account(self):
⋮...
│	def create_default_cost_center(self):
⋮...
│	def after_rename(self, olddn, newdn, merge=False):
⋮...
│	def abbreviate(self):
│		self.abbr = "".join(c[0].upper() for c in self.company_name.split())
⋮...
│	def on_trash(self):
⋮...
│	def check_parent_changed(self):
⋮...
│def get_name_with_abbr(name, company):
⋮...
│def update_company_monthly_sales(company):
⋮...
│def cache_companies_monthly_sales_history():
│	companies = [d["name"] for d in frappe.get_list("Company")]
│	for company in companies:
│		update_company_monthly_sales(company)
│		update_transactions_annual_history(company)
│	frappe.db.commit()
⋮...
│def get_all_transactions_annual_history(company):
⋮...
│def get_billing_shipping_address(name, billing_address=None, shipping_address=None):
│	primary_address = get_default_company_address(name, "is_primary_address", billing_address)
│	shipping_address = get_default_company_address(name, "is_shipping_address", shipping_address)
│
│	return {"primary_address": primary_address, "shipping_address": shipping_address}
⋮...
│def create_transaction_deletion_request(company):
⋮...

erpnext\crm\doctype\lead\lead.py:
│def make_customer(source_name, target_doc=None):
│	return _make_customer(source_name, target_doc)
⋮...
│def make_quotation(source_name, target_doc=None):
⋮...
│def make_opportunity(source_name, target_doc=None):
⋮...
│def _set_missing_values(source, target):
⋮...
│class Lead(SellingController, CRMNote):
⋮...
│	def onload(self):
│		customer = frappe.db.get_value("Customer", {"lead_name": self.name})
│		self.get("__onload").is_customer = customer
│		load_address_and_contact(self)
│		self.set_onload("linked_prospects", self.get_linked_prospects())
⋮...
│	def validate(self):
⋮...
│	def before_insert(self):
⋮...
│	def after_insert(self):
│		self.link_to_contact()
⋮...
│	def on_update(self):
│		self.update_prospect()
⋮...
│	def on_trash(self):
│		frappe.db.set_value("Issue", {"lead": self.name}, "lead", None)
│		delete_contact_and_address(self.doctype, self.name)
│		self.remove_link_from_prospect()
⋮...
│	def set_full_name(self):
│		if self.first_name:
│			self.lead_name = " ".join(
│				filter(None, [self.salutation, self.first_name, self.middle_name, self.last_name])
│			)
⋮...
│	def set_lead_name(self):
⋮...
│	def set_title(self):
│		self.title = self.company_name or self.lead_name
⋮...
│	def check_email_id_is_unique(self):
⋮...
│	def validate_email_id(self):
⋮...
│	def link_to_contact(self):
⋮...
│	def update_prospect(self):
⋮...
│	def remove_link_from_prospect(self):
⋮...
│	def get_linked_prospects(self):
│		return frappe.get_all(
│			"Prospect Lead",
│			filters={"lead": self.name},
│			fields=["parent"],
│		)
⋮...
│	def has_customer(self):
│		return frappe.db.get_value("Customer", {"lead_name": self.name})
⋮...
│	def has_opportunity(self):
│		return frappe.db.get_value("Opportunity", {"party_name": self.name, "status": ["!=", "Lost"]})
⋮...
│	def has_quotation(self):
│		return frappe.db.get_value(
│			"Quotation", {"party_name": self.name, "docstatus": 1, "status": ["!=", "Lost"]}
│		)
⋮...
│	def has_lost_quotation(self):
│		return frappe.db.get_value("Quotation", {"party_name": self.name, "docstatus": 1, "status": "Lost"})
⋮...
│	def create_prospect_and_contact(self, data):
⋮...
│	def create_contact(self):
⋮...
│	def create_prospect(self, company_name):
⋮...
│def _make_customer(source_name, target_doc=None, ignore_permissions=False):
⋮...
│def get_lead_details(lead, posting_date=None, company=None):
⋮...
│def make_lead_from_communication(communication, ignore_communication_links=False):
⋮...
│def get_lead_with_phone_number(number):
⋮...
│def add_lead_to_prospect(lead, prospect):
⋮...

erpnext\accounts\general_ledger.py:
│def make_gl_entries(
│	gl_map,
│	cancel=False,
│	adv_adj=False,
│	merge_entries=True,
│	update_outstanding="Yes",
│	from_repost=False,
│):
⋮...
│def make_reverse_gl_entries(
│	gl_entries=None,
│	voucher_type=None,
│	voucher_no=None,
│	adv_adj=False,
│	update_outstanding="Yes",
│	partial_cancel=False,
│):
⋮...
│def process_gl_map(gl_map, merge_entries=True, precision=None, from_repost=False):
⋮...
│def merge_similar_entries(gl_map, precision=None):
⋮...
│def get_round_off_account_and_cost_center(company, voucher_type, voucher_no, use_company_default=False):
⋮...
│def validate_accounting_period(gl_map):
⋮...
│def make_entry(args, adv_adj, update_outstanding, from_repost=False):
⋮...
│def toggle_debit_credit_if_negative(gl_map):
⋮...
│def process_debit_credit_difference(gl_map):
⋮...
│def get_debit_credit_difference(gl_map, precision):
⋮...
│def raise_debit_credit_not_equal_error(debit_credit_diff, voucher_type, voucher_no):
│	frappe.throw(
│		_("Debit and Credit not equal for {0} #{1}. Difference is {2}.").format(
│			voucher_type, voucher_no, debit_credit_diff
│		)
│	)
⋮...
│def update_accounting_dimensions(round_off_gle):
⋮...
│def check_freezing_date(posting_date, adv_adj=False):
⋮...
│def validate_against_pcv(is_opening, posting_date, company):
⋮...
│def set_as_cancel(voucher_type, voucher_no):
⋮...
│def make_acc_dimensions_offsetting_entry(gl_map):
⋮...
│def get_accounting_dimensions_for_offsetting_entry(gl_map, company):
⋮...
│def validate_disabled_accounts(gl_map):
⋮...
│def distribute_gl_based_on_cost_center_allocation(gl_map, precision=None, from_repost=False):
⋮...
│def get_cost_center_allocation_data(company, posting_date, cost_center):
⋮...
│def get_merge_properties(dimensions=None):
⋮...
│def get_merge_key(entry, merge_properties):
│	merge_key = []
│	for fieldname in merge_properties:
│		merge_key.append(entry.get(fieldname, ""))
│
│	return tuple(merge_key)
⋮...
│def check_if_in_list(gle, gl_map):
│	for e in gl_map:
│		if e.merge_key == gle.merge_key:
│			return e
⋮...
│def save_entries(gl_map, adv_adj, update_outstanding, from_repost=False):
⋮...
│def validate_cwip_accounts(gl_map):
⋮...
│def get_debit_credit_allowance(voucher_type, precision):
⋮...
│def has_opening_entries(gl_map: list) -> bool:
│	for x in gl_map:
│		if x.is_opening == "Yes":
│			return True
│	return False
⋮...
│def make_round_off_gle(gl_map, debit_credit_diff, trx_cur_debit_credit_diff, precision):
⋮...
│def validate_allowed_dimensions(gl_entry, dimension_filter_map):
⋮...
│def is_immutable_ledger_enabled():
│	return frappe.db.get_single_value("Accounts Settings", "enable_immutable_ledger")
⋮...

erpnext\selling\page\point_of_sale\point_of_sale.py:
│def get_conditions(search_term):
⋮...
│def get_items(start, page_length, price_list, item_group, pos_profile, search_term=""):
⋮...
│def get_item_group_condition(pos_profile):
⋮...
│def search_by_term(search_term, warehouse, price_list):
⋮...
│def filter_result_items(result, pos_profile):
│	if result and result.get("items"):
│		pos_item_groups = frappe.db.get_all("POS Item Group", {"parent": pos_profile}, pluck="item_group")
│		if not pos_item_groups:
│			return
│		result["items"] = [item for item in result.get("items") if item.get("item_group") in pos_item_groups]
⋮...
│def get_parent_item_group():
│	# Using get_all to ignore user permission
│	item_group = frappe.get_all("Item Group", {"lft": 1, "is_group": 1}, pluck="name")
│	if item_group:
│		return item_group[0]
⋮...
│def search_for_serial_or_batch_or_barcode_number(search_value: str) -> dict[str, str | None]:
│	return scan_barcode(search_value)
⋮...
│def add_search_fields_condition(search_term):
⋮...
│def item_group_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def check_opening_entry(user):
⋮...
│def create_opening_voucher(pos_profile, company, balance_details):
⋮...
│def get_past_order_list(search_term, status, limit=20):
⋮...
│def set_customer_info(fieldname, customer, value=""):
⋮...
│def get_pos_profile_data(pos_profile):
⋮...

erpnext\controllers\tests\test_accounts_controller.py:
│def make_customer(customer_name, currency=None):
⋮...
│def make_supplier(supplier_name, currency=None):
⋮...
│class TestAccountsController(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_account()
│		self.create_item()
│		self.create_parties()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_company(self):
⋮...
│	def create_item(self):
│		item = create_item(
│			item_code="_Test Notebook", is_stock_item=0, company=self.company, warehouse=self.warehouse
│		)
│		self.item = item if isinstance(item, str) else item.item_code
⋮...
│	def create_parties(self):
│		self.create_customer()
│		self.create_supplier()
⋮...
│	def create_customer(self):
│		self.customer = make_customer("_Test MC Customer USD", "USD")
⋮...
│	def create_supplier(self):
│		self.supplier = make_supplier("_Test MC Supplier USD", "USD")
⋮...
│	def create_account(self):
⋮...
│	def setup_advance_accounts_in_party_master(self):
⋮...
│	def remove_advance_accounts_from_party_master(self):
⋮...
│	def create_sales_invoice(
│		self,
│		qty=1,
│		rate=1,
│		conversion_rate=80,
│		posting_date=None,
│		do_not_save=False,
│		do_not_submit=False,
│	):
⋮...
│	def create_payment_entry(
│		self, amount=1, source_exc_rate=75, posting_date=None, customer=None, submit=True
│	):
⋮...
│	def create_purchase_invoice(
│		self,
│		qty=1,
│		rate=1,
│		conversion_rate=80,
│		posting_date=None,
│		do_not_save=False,
│		do_not_submit=False,
│	):
⋮...
│	def clear_old_entries(self):
⋮...
│	def create_payment_reconciliation(self):
⋮...
│	def create_journal_entry(
│		self,
│		acc1=None,
│		acc1_exc_rate=None,
│		acc2_exc_rate=None,
│		acc2=None,
│		acc1_amount=0,
│		acc2_amount=0,
│		posting_date=None,
│		cost_center=None,
│	):
⋮...
│	def get_journals_for(self, voucher_type: str, voucher_no: str) -> list:
⋮...
│	def assert_ledger_outstanding(
│		self,
│		voucher_type: str,
⋮...
│	def test_10_payment_against_sales_invoice(self):
⋮...
│	def test_11_advance_against_sales_invoice(self):
⋮...
│	def test_12_partial_advance_and_payment_for_sales_invoice(self):
⋮...
│	def test_13_partial_advance_and_payment_for_invoice_with_cancellation(self):
⋮...
│	def test_14_same_payment_split_against_invoice(self):
⋮...
│	def test_15_gain_loss_on_different_posting_date(self):
⋮...
│	def test_16_internal_transfer_at_arms_length_price(self):
⋮...
│	def test_17_gain_loss_posting_date_for_normal_payment(self):
⋮...
│	def test_18_fetch_taxes_based_on_taxes_and_charges_template(self):
⋮...
│	def test_20_journal_against_sales_invoice(self):
⋮...
│	def test_21_advance_journal_against_sales_invoice(self):
⋮...
│	def test_22_partial_advance_and_payment_for_invoice_with_cancellation(self):
⋮...
│	def test_23_same_journal_split_against_single_invoice(self):
⋮...
│	def test_24_journal_against_multiple_invoices(self):
⋮...
│	def test_30_cr_note_against_sales_invoice(self):
⋮...
│	def test_40_cost_center_from_payment_entry(self):
⋮...
│	def test_41_cost_center_from_journal_entry(self):
⋮...
│	def test_42_cost_center_from_cr_note(self):
⋮...
│	def setup_dimensions(self):
⋮...
│	def test_90_dimensions_filter(self):
⋮...
│	def test_91_cr_note_should_inherit_dimension(self):
⋮...
│	def test_92_dimension_inhertiance_exc_gain_loss(self):
⋮...
│	def test_93_dimension_inheritance_on_advance(self):
⋮...
│	def test_50_journal_against_journal(self):
⋮...
│	def test_60_payment_entry_against_journal(self):
⋮...
│	def test_61_payment_entry_against_journal_for_payable_accounts(self):
⋮...
│	def test_70_advance_payment_against_sales_invoice_in_foreign_currency(self):
⋮...
│	def test_71_advance_payment_against_purchase_invoice_in_foreign_currency(self):
⋮...
│	def test_difference_posting_date_in_pi_and_si(self):
⋮...
│	def test_company_validation_in_dimension(self):
⋮...
│	def test_party_billing_and_shipping_address(self):
⋮...
│	def test_party_contact(self):
⋮...

erpnext\stock\doctype\stock_reservation_entry\stock_reservation_entry.py:
│def get_stock_reservation_entries_for_voucher(
│	voucher_type: str,
⋮...
│def has_reserved_stock(voucher_type: str, voucher_no: str, voucher_detail_no: str | None = None) -> bool:
⋮...
│def cancel_stock_reservation_entries(
│	voucher_type: str | None = None,
⋮...
│def get_available_qty_to_reserve(
│	item_code: str, warehouse: str, batch_no: str | None = None, ignore_sre=None
⋮...
│def validate_stock_reservation_settings(voucher: object) -> None:
⋮...
│def get_sre_reserved_qty_details_for_voucher(voucher_type: str, voucher_no: str) -> dict:
⋮...
│class StockReservation:
⋮...
│class StockReservationEntry(Document):
⋮...
│	def validate(self) -> None:
⋮...
│	def before_submit(self) -> None:
│		self.set_reservation_based_on()
│		self.validate_reservation_based_on_qty()
│		self.auto_reserve_serial_and_batch()
│		self.validate_reservation_based_on_serial_and_batch()
⋮...
│	def on_submit(self) -> None:
│		self.update_reserved_qty_in_voucher()
│		self.update_reserved_qty_in_pick_list()
│		self.update_status()
│		self.update_reserved_stock_in_bin()
⋮...
│	def on_update_after_submit(self) -> None:
⋮...
│	def on_cancel(self) -> None:
│		self.update_reserved_qty_in_voucher()
│		self.update_reserved_qty_in_pick_list()
│		self.update_status()
│		self.update_reserved_stock_in_bin()
⋮...
│	def validate_amended_doc(self) -> None:
⋮...
│	def validate_mandatory(self) -> None:
⋮...
│	def validate_group_warehouse(self) -> None:
│		"""Raises an exception if `Warehouse` is a Group Warehouse."""
│
│		if frappe.get_cached_value("Warehouse", self.warehouse, "is_group"):
│			msg = _("Stock cannot be reserved in group warehouse {0}.").format(frappe.bold(self.warehouse))
│			frappe.throw(msg, title=_("Invalid Warehouse"))
⋮...
│	def validate_uom_is_integer(self) -> None:
⋮...
│	def set_reservation_based_on(self) -> None:
⋮...
│	def validate_reservation_based_on_qty(self) -> None:
│		"""Validates `Reserved Qty` when `Reservation Based On` is `Qty`."""
│
│		if self.reservation_based_on == "Qty":
│			self.validate_with_allowed_qty(self.reserved_qty)
⋮...
│	def auto_reserve_serial_and_batch(self, based_on: str | None = None) -> None:
⋮...
│	def validate_reservation_based_on_serial_and_batch(self) -> None:
⋮...
│	def update_reserved_qty_in_voucher(
│		self, reserved_qty_field: str = "stock_reserved_qty", update_modified: bool = True
⋮...
│	def update_reserved_qty_in_pick_list(
│		self, reserved_qty_field: str = "stock_reserved_qty", update_modified: bool = True
⋮...
│	def update_reserved_stock_in_bin(self) -> None:
│		"""Updates `Reserved Stock` in Bin."""
│
│		bin_name = get_or_make_bin(self.item_code, self.warehouse)
│		bin_doc = frappe.get_cached_doc("Bin", bin_name)
│		bin_doc.update_reserved_stock()
⋮...
│	def update_status(self, status: str | None = None, update_modified: bool = True) -> None:
⋮...
│	def can_be_updated(self) -> None:
⋮...
│	def validate_with_allowed_qty(self, qty_to_be_reserved: float) -> None:
⋮...
│	def consume_serial_batch_for_material_transfer(self, row_wise_serial_batch):
⋮...
│def get_available_serial_nos_to_reserve(
│	item_code: str, warehouse: str, has_batch_no: bool = False, ignore_sre=None
⋮...
│def get_sre_reserved_qty_for_item_and_warehouse(item_code: str, warehouse: str | None = None) -> float:
⋮...
│def get_sre_reserved_qty_for_items_and_warehouses(
│	item_code_list: list, warehouse_list: list | None = None
⋮...
│def get_sre_reserved_warehouses_for_voucher(
│	voucher_type: str, voucher_no: str, voucher_detail_no: str | None = None
⋮...
│def get_sre_reserved_qty_for_voucher_detail_no(
│	voucher_type: str,
⋮...
│def get_sre_reserved_serial_nos_details(
│	item_code: str, warehouse: str, serial_nos: list | None = None
⋮...
│def get_sre_reserved_batch_nos_details(item_code: str, warehouse: str, batch_nos: list | None = None) -> dict:
⋮...
│def get_sre_details_for_voucher(voucher_type: str, voucher_no: str) -> list[dict]:
⋮...
│def get_serial_batch_entries_for_voucher(sre_name: str) -> list[dict]:
⋮...
│def get_ssb_bundle_for_voucher(sre: dict) -> object:
⋮...
│	def __init__(self, doc, items=None, notify=True):
⋮...
│	def initialize_fields(self) -> None:
⋮...
│	def cancel_stock_reservation_entries(self, names=None) -> None:
⋮...
│	def make_stock_reservation_entries(self):
⋮...
│	def set_serial_batch(self, sre, serial_batch_bundles):
⋮...
│	def throw_stock_not_exists_error(self, item, warehouse):
⋮...
│	def get_available_qty_to_reserve(self, item_code, warehouse, ignore_sre=None):
⋮...
│def create_stock_reservation_entries_for_so_items(
│	sales_order: object,
⋮...

erpnext\stock\doctype\stock_reconciliation\stock_reconciliation.py:
│def get_items(warehouse, posting_date, posting_time, company, item_code=None, ignore_empty_stock=False):
⋮...
│class EmptyStockReconciliationItemsError(frappe.ValidationError):
│	pass
⋮...
│def get_stock_balance_for(
│	item_code: str,
⋮...
│class OpeningEntryAccountError(frappe.ValidationError):
│	pass
⋮...
│def get_item_data(row, qty, valuation_rate, serial_no=None):
⋮...
│class StockReconciliation(StockController):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		self.head_row = ["Item Code", "Warehouse", "Quantity", "Valuation Rate"]
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		self.set_serial_and_batch_bundle(ignore_validate=True)
⋮...
│	def validate_inventory_dimension(self):
⋮...
│	def on_submit(self):
│		self.make_bundle_for_current_qty()
│		self.make_bundle_using_old_serial_batch_fields()
│		self.update_stock_ledger()
│		self.make_gl_entries()
│		self.repost_future_sle_and_gle()
⋮...
│	def on_cancel(self):
⋮...
│	def make_bundle_for_current_qty(self):
⋮...
│	def set_current_serial_and_batch_bundle(self, voucher_detail_no=None, save=False) -> None:
⋮...
│	def get_bundle_for_specific_serial_batch(self, row) -> str:
⋮...
│	def has_change_in_serial_batch(self, row) -> bool:
⋮...
│	def set_new_serial_and_batch_bundle(self):
⋮...
│	def update_existing_serial_and_batch_bundle(self, item):
⋮...
│	def remove_items_with_no_change(self):
⋮...
│	def calculate_difference_amount(self, item, item_dict):
⋮...
│	def validate_data(self):
⋮...
│	def validate_item(self, item_code, row):
⋮...
│	def validate_reserved_stock(self) -> None:
⋮...
│	def update_stock_ledger(self, allow_negative_stock=False):
⋮...
│	def make_adjustment_entry(self, row, sl_entries):
⋮...
│	def get_sle_for_serialized_items(self, row, sl_entries):
⋮...
│	def update_valuation_rate_for_serial_no(self):
⋮...
│	def update_valuation_rate_for_serial_nos(self, row, serial_nos):
⋮...
│	def get_sle_for_items(self, row, serial_nos=None, current_bundle=True):
⋮...
│	def make_sle_on_cancel(self):
⋮...
│	def merge_similar_item_serial_nos(self, sl_entries):
⋮...
│	def get_gl_entries(self, warehouse_account=None):
│		if not self.cost_center:
│			msgprint(_("Please enter Cost Center"), raise_exception=1)
│
│		return super().get_gl_entries(warehouse_account, self.expense_account, self.cost_center)
⋮...
│	def validate_expense_account(self):
⋮...
│	def set_zero_value_for_customer_provided_items(self):
⋮...
│	def set_total_qty_and_amount(self):
⋮...
│	def get_items_for(self, warehouse):
│		self.items = []
│		for item in get_items(warehouse, self.posting_date, self.posting_time, self.company):
│			self.append("items", item)
⋮...
│	def submit(self):
⋮...
│	def cancel(self):
⋮...
│	def recalculate_current_qty(self, voucher_detail_no):
⋮...
│	def has_negative_stock_allowed(self):
⋮...
│	def get_current_qty_for_serial_or_batch(self, row):
⋮...
│	def get_current_qty_for_serial_nos(self, doc):
⋮...
│	def get_current_qty_for_batch_nos(self, doc):
⋮...
│def get_batch_qty_for_stock_reco(item_code, warehouse, batch_no, posting_date, posting_time, voucher_no):
⋮...
│def get_item_and_warehouses(item_code, warehouse):
⋮...
│def get_items_for_stock_reco(warehouse, company):
⋮...
│def get_itemwise_batch(warehouse, posting_date, company, item_code=None):
⋮...
│def get_difference_account(purpose, company):
⋮...

erpnext\accounts\doctype\payment_reconciliation\test_payment_reconciliation.py:
│def make_customer(customer_name, currency=None):
⋮...
│def make_supplier(supplier_name, currency=None):
⋮...
│class UnitTestPaymentReconciliation(UnitTestCase):
⋮...
│class TestPaymentReconciliation(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_company(self):
⋮...
│	def create_item(self):
│		item = create_item(
│			item_code="_Test PR Item", is_stock_item=0, company=self.company, warehouse=self.warehouse
│		)
│		self.item = item if isinstance(item, str) else item.item_code
⋮...
│	def create_customer(self):
│		self.customer = make_customer("_Test PR Customer")
│		self.customer2 = make_customer("_Test PR Customer 2")
│		self.customer3 = make_customer("_Test PR Customer 3", "EUR")
│		self.customer4 = make_customer("_Test PR Customer 4", "EUR")
│		self.customer5 = make_customer("_Test PR Customer 5", "EUR")
⋮...
│	def create_account(self):
⋮...
│	def create_sales_invoice(
│		self, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False
│	):
⋮...
│	def create_payment_entry(self, amount=100, posting_date=None, customer=None):
⋮...
│	def create_purchase_invoice(
│		self, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False
│	):
⋮...
│	def create_purchase_order(
│		self, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False
│	):
⋮...
│	def clear_old_entries(self):
⋮...
│	def create_payment_reconciliation(self, party_is_customer=True):
⋮...
│	def create_journal_entry(self, acc1=None, acc2=None, amount=0, posting_date=None, cost_center=None):
⋮...
│	def create_cost_center(self):
⋮...
│	def test_filter_min_max(self):
⋮...
│	def test_filter_posting_date(self):
⋮...
│	def test_filter_posting_date_case2(self):
⋮...
│	def test_filter_invoice_limit(self):
⋮...
│	def test_payment_against_invoice(self):
⋮...
│	def test_payment_against_journal(self):
⋮...
│	def test_payment_against_foreign_currency_journal(self):
⋮...
│	def test_journal_against_invoice(self):
⋮...
│	def test_negative_debit_or_credit_journal_against_invoice(self):
⋮...
│	def test_journal_against_journal(self):
⋮...
│	def test_cr_note_against_invoice(self):
⋮...
│	def test_invoice_status_after_cr_note_cancellation(self):
⋮...
│	def test_cr_note_partial_against_invoice(self):
⋮...
│	def test_pr_output_foreign_currency_and_amount(self):
⋮...
│	def test_difference_amount_via_journal_entry(self):
⋮...
│	def test_difference_amount_via_negative_debit_or_credit_journal_entry(self):
⋮...
│	def test_difference_amount_via_payment_entry(self):
⋮...
│	def test_differing_cost_center_on_invoice_and_payment(self):
⋮...
│	def test_cost_center_filter_on_vouchers(self):
⋮...
│	def test_no_difference_amount_for_base_currency_accounts(self):
⋮...
│	def test_reconciliation_purchase_invoice_against_return(self):
⋮...
│	def test_reconciliation_from_purchase_order_to_multiple_invoices(self):
⋮...
│	def test_rounding_of_unallocated_amount(self):
⋮...
│	def test_reverse_payment_against_payment_for_supplier(self):
⋮...
│	def test_advance_reverse_payment_against_payment_for_supplier(self):
⋮...
│	def test_advance_payment_reconciliation_date(self):
⋮...
│	def test_advance_payment_reconciliation_against_journal_for_customer(self):
⋮...
│	def test_advance_payment_reconciliation_against_journal_for_supplier(self):
⋮...
│	def test_cr_note_payment_limit_filter(self):
⋮...
│	def test_reconciliation_on_closed_period_payment(self):
⋮...
│	def test_advance_reconciliation_effect_on_same_date(self):
⋮...
│def create_fiscal_year(company, year_start_date, year_end_date):
⋮...
│def make_period_closing_voucher(company, cost_center, posting_date=None, submit=True):
⋮...

erpnext\accounts\doctype\journal_entry\test_journal_entry.py:
│def make_journal_entry(
│	account1,
│	account2,
│	amount,
│	cost_center=None,
│	posting_date=None,
│	exchange_rate=1,
│	save=True,
│	submit=False,
│	project=None,
│	company=None,
│):
⋮...
│class UnitTestJournalEntry(UnitTestCase):
⋮...
│class TestJournalEntry(IntegrationTestCase):
⋮...
│	def test_journal_entry_with_against_jv(self):
│		jv_invoice = frappe.copy_doc(self.globalTestRecords["Journal Entry"][2])
│		base_jv = frappe.copy_doc(self.globalTestRecords["Journal Entry"][0])
│		self.jv_against_voucher_testcase(base_jv, jv_invoice)
⋮...
│	def test_jv_against_sales_order(self):
│		from erpnext.selling.doctype.sales_order.test_sales_order import make_sales_order
│
│		sales_order = make_sales_order(do_not_save=True)
│		base_jv = frappe.copy_doc(self.globalTestRecords["Journal Entry"][0])
│		self.jv_against_voucher_testcase(base_jv, sales_order)
⋮...
│	def test_jv_against_purchase_order(self):
│		from erpnext.buying.doctype.purchase_order.test_purchase_order import create_purchase_order
│
│		purchase_order = create_purchase_order(do_not_save=True)
│		base_jv = frappe.copy_doc(self.globalTestRecords["Journal Entry"][1])
│		self.jv_against_voucher_testcase(base_jv, purchase_order)
⋮...
│	def jv_against_voucher_testcase(self, base_jv, test_voucher):
⋮...
│	def advance_paid_testcase(self, base_jv, test_voucher, dr_or_cr):
⋮...
│	def cancel_against_voucher_testcase(self, test_voucher):
⋮...
│	def test_jv_against_stock_account(self):
⋮...
│	def test_multi_currency(self):
⋮...
│	def test_reverse_journal_entry(self):
⋮...
│	def test_disallow_change_in_account_currency_for_a_party(self):
⋮...
│	def test_inter_company_jv(self):
⋮...
│	def test_jv_with_cost_centre(self):
⋮...
│	def test_jv_with_project(self):
⋮...
│	def test_jv_account_and_party_balance_with_cost_centre(self):
⋮...
│	def test_repost_accounting_entries(self):
⋮...
│	def check_gl_entries(self):
⋮...
│	def test_negative_debit_and_credit_with_same_account_head(self):
⋮...
│	def test_toggle_debit_credit_if_negative(self):
⋮...
│	def test_transaction_exchange_rate_on_journals(self):
⋮...

erpnext\support\doctype\service_level_agreement\test_service_level_agreement.py:
│def create_service_level_agreement(
│	default_service_level_agreement,
│	holiday_list,
│	response_time,
│	entity_type,
│	entity,
│	resolution_time=0,
│	doctype="Issue",
│	condition="",
│	sla_fulfilled_on=None,
│	pause_sla_on=None,
│	apply_sla_for_resolution=1,
│	service_level=None,
│	start_time="10:00:00",
⋮...
│def create_customer():
⋮...
│def make_lead(creation=None, index=0, company=None):
⋮...
│def get_service_level_agreement(
│	default_service_level_agreement=None, entity_type=None, entity=None, doctype="Issue"
│):
⋮...
│def create_customer_group():
⋮...
│def create_territory():
⋮...
│def create_service_level_agreements_for_issues():
⋮...
│def make_holiday_list():
⋮...
│def create_custom_doctype():
⋮...
│class TestServiceLevelAgreement(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		frappe.db.set_single_value("Support Settings", "track_service_level_agreement", 1)
│		lead = frappe.qb.DocType("Lead")
│		frappe.qb.from_(lead).delete().where(lead.company == self.company).run()
⋮...
│	def create_company(self):
⋮...
│	def test_service_level_agreement(self):
⋮...
│	def test_custom_field_creation_for_sla_on_standard_dt(self):
⋮...
│	def test_docfield_creation_for_sla_on_custom_dt(self):
⋮...
│	def test_sla_application(self):
⋮...
│	def test_hold_time(self):
⋮...
│	def test_failed_sla_for_response_only(self):
⋮...
│	def test_fulfilled_sla_for_response_only(self):
⋮...
│	def test_service_level_agreement_filters(self):
⋮...
│	def tearDown(self):
│		for d in frappe.get_all("Service Level Agreement"):
│			frappe.delete_doc("Service Level Agreement", d.name, force=1)
⋮...

erpnext\manufacturing\doctype\bom\test_bom.py:
│def create_nested_bom(tree, prefix="_Test bom ", submit=True):
⋮...
│def get_default_bom(item_code="_Test FG Item 2"):
│	return frappe.db.get_value("BOM", {"item": item_code, "is_active": 1, "is_default": 1})
⋮...
│def create_bom_with_process_loss_item(
│	fg_item, bom_item, scrap_qty=0, scrap_rate=0, fg_qty=2, process_loss_percentage=0
│):
⋮...
│def level_order_traversal(node):
⋮...
│def reset_item_valuation_rate(item_code, warehouse_list=None, qty=None, rate=None):
⋮...
│def create_process_loss_bom_items():
⋮...
│class UnitTestBom(UnitTestCase):
⋮...
│class TestBOM(IntegrationTestCase):
⋮...
│	def test_get_items(self):
⋮...
│	def test_get_items_exploded(self):
⋮...
│	def test_get_items_list(self):
│		from erpnext.manufacturing.doctype.bom.bom import get_bom_items
│
│		self.assertEqual(len(get_bom_items(bom=get_default_bom(), company="_Test Company")), 3)
⋮...
│	def test_default_bom(self):
⋮...
│	def test_update_bom_cost_in_all_boms(self):
⋮...
│	def test_bom_cost(self):
⋮...
│	def test_bom_cost_with_batch_size(self):
⋮...
│	def test_bom_cost_multi_uom_multi_currency_based_on_price_list(self):
⋮...
│	def test_bom_cost_multi_uom_based_on_valuation_rate(self):
⋮...
│	def test_bom_cost_with_fg_based_operating_cost(self):
⋮...
│	def test_subcontractor_sourced_item(self):
⋮...
│	def test_bom_tree_representation(self):
⋮...
│	def test_generated_variant_bom(self):
⋮...
│	def test_bom_recursion_1st_level(self):
⋮...
│	def test_bom_recursion_transitive(self):
⋮...
│	def test_bom_with_process_loss_item(self):
⋮...
│	def test_bom_item_query(self):
⋮...
│	def test_exclude_exploded_items_from_bom(self):
⋮...
│	def test_valid_transfer_defaults(self):
⋮...
│	def test_bom_name_length(self):
│		"""test >140 char names"""
│		bom_tree = {"x" * 140: {" ".join(["abc"] * 35): {}}}
│		create_nested_bom(bom_tree, prefix="")
⋮...
│	def test_version_index(self):
⋮...
│	def test_bom_versioning(self):
⋮...
│	def test_clear_inpection_quality(self):
⋮...
│	def test_bom_pricing_based_on_lpp(self):
⋮...
│	def test_set_default_bom_for_item_having_single_bom(self):
⋮...
│	def test_exploded_items_rate(self):
⋮...
│	def test_bom_cost_update_flag(self):
⋮...
│	def test_bom_with_service_item_cost(self):
⋮...
│	def test_do_not_include_manufacturing_and_fixed_items(self):
⋮...
│	def test_bom_raw_materials_stock_uom(self):
⋮...
│def create_process_loss_bom_item(item_tuple):
│	item_code, stock_uom = item_tuple
│	if frappe.db.exists("Item", item_code) is None:
│		return make_item(item_code, {"stock_uom": stock_uom, "valuation_rate": 100})
│	else:
│		return frappe.get_doc("Item", item_code)
⋮...

erpnext\setup\doctype\employee\employee.py:
│def get_children(doctype, parent=None, company=None, is_root=False, is_tree=False):
⋮...
│def on_doctype_update():
│	frappe.db.add_index("Employee", ["lft", "rgt"])
⋮...
│def create_user(employee, user=None, email=None):
⋮...
│class Employee(NestedSet):
⋮...
│def is_holiday(employee, date=None, raise_exception=True, only_non_weekly=False, with_description=False):
⋮...
│class InactiveEmployeeStatusError(frappe.ValidationError):
│	pass
⋮...
│def get_holiday_list_for_employee(employee, raise_exception=True):
⋮...
│class EmployeeUserDisabledError(frappe.ValidationError):
│	pass
⋮...
│	def autoname(self):
│		set_name_by_naming_series(self)
│		self.employee = self.name
⋮...
│	def validate(self):
⋮...
│	def after_rename(self, old, new, merge):
│		self.db_set("employee", new)
⋮...
│	def set_employee_name(self):
│		self.employee_name = " ".join(
│			filter(lambda x: x, [self.first_name, self.middle_name, self.last_name])
│		)
⋮...
│	def validate_user_details(self):
⋮...
│	def update_nsm_model(self):
│		frappe.utils.nestedset.update_nsm(self)
⋮...
│	def on_update(self):
⋮...
│	def update_user_permissions(self):
⋮...
│	def update_user(self):
⋮...
│	def validate_date(self):
⋮...
│	def validate_email(self):
│		if self.company_email:
│			validate_email_address(self.company_email, True)
│		if self.personal_email:
│			validate_email_address(self.personal_email, True)
⋮...
│	def set_preferred_email(self):
│		preferred_email_field = frappe.scrub(self.prefered_contact_email)
│		self.prefered_email = self.get(preferred_email_field) if preferred_email_field else None
⋮...
│	def validate_status(self):
⋮...
│	def validate_for_enabled_user_id(self, enabled):
⋮...
│	def validate_duplicate_user_id(self):
⋮...
│	def validate_reports_to(self):
│		if self.reports_to == self.name:
│			throw(_("Employee cannot report to himself."))
⋮...
│	def on_trash(self):
│		self.update_nsm_model()
│		delete_events(self.doctype, self.name)
⋮...
│	def validate_preferred_email(self):
│		if self.prefered_contact_email and not self.get(scrub(self.prefered_contact_email)):
│			frappe.msgprint(_("Please enter {0}").format(self.prefered_contact_email))
⋮...
│	def reset_employee_emails_cache(self):
⋮...
│def validate_employee_role(doc, method=None, ignore_emp_check=False):
⋮...
│def get_employee_email(employee_doc):
│	return (
│		employee_doc.get("user_id") or employee_doc.get("personal_email") or employee_doc.get("company_email")
│	)
⋮...
│def deactivate_sales_person(status=None, employee=None):
│	if status == "Left":
│		sales_person = frappe.db.get_value("Sales Person", {"Employee": employee})
│		if sales_person:
│			frappe.db.set_value("Sales Person", sales_person, "enabled", 0)
⋮...
│def get_all_employee_emails(company):
⋮...
│def get_employee_emails(employee_list):
⋮...
│def has_user_permission_for_employee(user_name, employee_name):
⋮...
│def has_upload_permission(doc, ptype="read", user=None):
│	if not user:
│		user = frappe.session.user
│	if get_doc_permissions(doc, user=user, ptype=ptype).get(ptype):
│		return True
│	return doc.user_id == user
⋮...

erpnext\accounts\doctype\subscription\test_subscription.py:
│def create_subscription(**kwargs):
⋮...
│def create_plan(**kwargs):
⋮...
│class UnitTestSubscription(UnitTestCase):
⋮...
│class TestSubscription(IntegrationTestCase):
⋮...
│	def setUp(self):
│		make_plans()
│		create_parties()
│		reset_settings()
│		frappe.db.set_single_value("Accounts Settings", "acc_frozen_upto", None)
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_create_subscription_with_trial_with_correct_period(self):
⋮...
│	def test_create_subscription_without_trial_with_correct_period(self):
⋮...
│	def test_create_subscription_trial_with_wrong_dates(self):
│		subscription = create_subscription(
│			trial_period_start=add_days(nowdate(), 30), trial_period_end=nowdate(), do_not_save=True
│		)
│		self.assertRaises(frappe.ValidationError, subscription.save)
⋮...
│	def test_invoice_is_generated_at_end_of_billing_period(self):
⋮...
│	def test_status_goes_back_to_active_after_invoice_is_paid(self):
⋮...
│	def test_subscription_cancel_after_grace_period(self):
⋮...
│	def test_subscription_unpaid_after_grace_period(self):
⋮...
│	def test_subscription_invoice_days_until_due(self):
⋮...
│	def test_subscription_is_past_due_doesnt_change_within_grace_period(self):
⋮...
│	def test_subscription_remains_active_during_invoice_period(self):
⋮...
│	def test_subscription_cancellation(self):
│		subscription = create_subscription()
│		subscription.cancel_subscription()
│
│		self.assertEqual(subscription.status, "Cancelled")
⋮...
│	def test_subscription_cancellation_invoices(self):
⋮...
│	def test_subscription_cancellation_invoices_with_prorata_false(self):
⋮...
│	def test_subscription_cancellation_invoices_with_prorata_true(self):
⋮...
│	def test_subscription_cancellation_and_process(self):
⋮...
│	def test_subscription_restart_and_process(self):
⋮...
│	def test_subscription_unpaid_back_to_active(self):
⋮...
│	def test_restart_active_subscription(self):
│		subscription = create_subscription()
│		self.assertRaises(frappe.ValidationError, subscription.restart_subscription)
⋮...
│	def test_subscription_invoice_discount_percentage(self):
⋮...
│	def test_subscription_invoice_discount_amount(self):
⋮...
│	def test_prepaid_subscriptions(self):
⋮...
│	def test_prepaid_subscriptions_with_prorate_true(self):
⋮...
│	def test_subscription_with_follow_calendar_months(self):
⋮...
│	def test_subscription_generate_invoice_past_due(self):
⋮...
│	def test_subscription_without_generate_invoice_past_due(self):
⋮...
│	def test_multi_currency_subscription(self):
⋮...
│	def test_multi_currency_subscription_with_default_company_currency(self):
⋮...
│	def test_subscription_recovery(self):
⋮...
│	def test_subscription_invoice_generation_before_days(self):
⋮...
│	def test_future_subscription(self):
⋮...
│def make_plans():
⋮...
│def create_parties():
⋮...
│def reset_settings():
│	settings = frappe.get_single("Subscription Settings")
│	settings.grace_period = 0
│	settings.cancel_after_grace = 0
│	settings.save()
⋮...

erpnext\stock\doctype\stock_ledger_entry\test_stock_ledger_entry.py:
│def create_items(items=None, uoms=None):
⋮...
│def setup_item_valuation_test(
│	valuation_method="FIFO", suffix=None, use_batchwise_valuation=1, batches_list=None
│):
⋮...
│def fetch_sle_details_for_doc_list(doc_list, columns, as_dict=1):
⋮...
│def create_purchase_receipt_entries_for_batchwise_item_valuation_test(pr_entry_list):
⋮...
│def create_delivery_note_entries_for_batchwise_item_valuation_test(dn_entry_list):
⋮...
│def get_stock_value_from_q(q):
│	return sum(r * q for r, q in json.loads(q))
⋮...
│def create_stock_entry_entries_for_batchwise_item_valuation_test(se_entry_list, purpose):
⋮...
│class TestStockLedgerEntry(IntegrationTestCase, StockTestMixin):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_item_cost_reposting(self):
⋮...
│	def test_purchase_return_valuation_reposting(self):
⋮...
│	def test_sales_return_valuation_reposting(self):
⋮...
│	def test_reposting_of_sales_return_for_packed_item(self):
⋮...
│	def test_back_dated_entry_not_allowed(self):
⋮...
│	def test_batchwise_item_valuation_fifo(self):
⋮...
│	def test_batchwise_item_valuation_moving_average(self):
⋮...
│	def test_batchwise_item_valuation_stock_reco(self):
⋮...
│	def test_batch_wise_valuation_across_warehouse(self):
⋮...
│	def test_intermediate_average_batch_wise_valuation(self):
⋮...
│	def test_legacy_item_valuation_stock_entry(self):
⋮...
│	def test_fifo_dependent_consumption(self):
⋮...
│	def test_fifo_multi_item_repack_consumption(self):
⋮...
│	def test_negative_fifo_valuation(self):
⋮...
│	def test_dependent_gl_entry_reposting(self):
⋮...
│	def test_tie_breaking(self):
⋮...
│	def test_timestamp_clash(self):
⋮...
│	def test_previous_sle_with_clashed_timestamp(self):
⋮...
│	def test_backdated_sle_with_same_timestamp(self):
⋮...
│	def test_transfer_invariants(self):
⋮...
│	def test_negative_qty_with_precision(self):
⋮...
│	def test_future_negative_qty_with_precision(self):
⋮...
│def create_repack_entry(**args):
⋮...
│def create_product_bundle_item(new_item_code, packed_items):
⋮...
│def get_unique_suffix():
│	# Used to isolate valuation sensitive
│	# tests to prevent future tests from failing.
│	return str(uuid4())[:8].upper()
⋮...
│class UnitTestStockLedgerEntry(UnitTestCase):
⋮...
│class TestDeferredNaming(IntegrationTestCase):
⋮...
│	def setUpClass(cls) -> None:
│		super().setUpClass()
│		cls.gle_autoname = frappe.get_meta("GL Entry").autoname
│		cls.sle_autoname = frappe.get_meta("Stock Ledger Entry").autoname
⋮...
│	def setUp(self) -> None:
│		self.item = make_item().name
│		self.warehouse = "Stores - TCP1"
│		self.company = "_Test Company with perpetual inventory"
⋮...
│	def tearDown(self) -> None:
⋮...
│	def get_gle_sles(se):
│		filters = {"voucher_type": se.doctype, "voucher_no": se.name}
│		gle = set(frappe.get_list("GL Entry", filters, pluck="name"))
│		sle = set(frappe.get_list("Stock Ledger Entry", filters, pluck="name"))
│		return gle, sle
⋮...
│	def test_deferred_naming(self):
⋮...
│	def test_hash_naming(self):
⋮...

erpnext\buying\doctype\request_for_quotation\request_for_quotation.py:
│def get_list_context(context=None):
⋮...
│def make_supplier_quotation_from_rfq(source_name, target_doc=None, for_supplier=None):
⋮...
│def get_pdf(
│	name: str,
⋮...
│def add_items(sq_doc, supplier, items):
⋮...
│def create_supplier_quotation(doc):
⋮...
│class RequestforQuotation(BuyingController):
⋮...
│	def validate(self):
⋮...
│	def validate_duplicate_supplier(self):
│		supplier_list = [d.supplier for d in self.suppliers]
│		if len(supplier_list) != len(set(supplier_list)):
│			frappe.throw(_("Same supplier has been entered multiple times"))
⋮...
│	def validate_supplier_list(self):
⋮...
│	def update_email_id(self):
│		for rfq_supplier in self.suppliers:
│			if not rfq_supplier.email_id:
│				rfq_supplier.email_id = frappe.db.get_value("Contact", rfq_supplier.contact, "email_id")
⋮...
│	def validate_email_id(self, args):
⋮...
│	def on_submit(self):
│		self.db_set("status", "Submitted")
│		for supplier in self.suppliers:
│			supplier.email_sent = 0
│			supplier.quote_status = "Pending"
│		self.send_to_supplier()
⋮...
│	def before_print(self, settings=None):
⋮...
│	def on_cancel(self):
│		self.db_set("status", "Cancelled")
⋮...
│	def get_supplier_email_preview(self, supplier):
⋮...
│	def send_to_supplier(self):
⋮...
│	def get_link(self):
⋮...
│	def update_supplier_part_no(self, supplier):
│		self.vendor = supplier
│		for item in self.items:
│			item.supplier_part_no = frappe.db.get_value(
│				"Item Supplier", {"parent": item.item_code, "supplier": supplier}, "supplier_part_no"
│			)
⋮...
│	def update_supplier_contact(self, rfq_supplier, link):
⋮...
│	def link_supplier_contact(self, rfq_supplier, user):
⋮...
│	def update_user_in_supplier(self, supplier, user):
⋮...
│	def create_user(self, rfq_supplier, link):
⋮...
│	def supplier_rfq_mail(self, data, update_password_link, rfq_link, preview=False):
⋮...
│	def send_email(self, data, sender, subject, message, attachments):
⋮...
│	def get_attachments(self):
│		return [d.name for d in get_attachments(self.doctype, self.name)]
⋮...
│	def update_rfq_supplier_status(self, sup_name=None):
⋮...
│def send_supplier_emails(rfq_name):
│	check_portal_enabled("Request for Quotation")
│	rfq = frappe.get_doc("Request for Quotation", rfq_name)
│	if rfq.docstatus == 1:
│		rfq.send_to_supplier()
⋮...
│def check_portal_enabled(reference_doctype):
⋮...
│def create_rfq_items(sq_doc, supplier, data):
⋮...
│def get_item_from_material_requests_based_on_supplier(source_name, target_doc=None):
⋮...
│def get_supplier_tag():
│	filters = {"document_type": "Supplier"}
│	tags = list(set(tag.tag for tag in frappe.get_all("Tag Link", filters=filters, fields=["tag"]) if tag))
│
│	return tags
⋮...
│def get_rfq_containing_supplier(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\regional\italy\utils.py:
│def get_conditions(filters):
⋮...
│def get_e_invoice_attachments(invoices):
⋮...
│def prepare_and_attach_invoice(doc, replace=False):
⋮...
│def get_company_country(company):
│	return frappe.get_cached_value("Company", company, "country")
⋮...
│def validate_address(address_name):
⋮...
│def get_unamended_name(doc):
⋮...
│def update_itemised_tax_data(doc):
⋮...
│def export_invoices(filters=None):
⋮...
│def prepare_invoice(invoice, progressive_number):
⋮...
│def download_zip(files, output_filename):
⋮...
│def get_invoice_summary(items, taxes):
⋮...
│def sales_invoice_validate(doc):
⋮...
│def sales_invoice_on_submit(doc, method):
⋮...
│def generate_single_invoice(docname):
│	doc = frappe.get_doc("Sales Invoice", docname)
│	frappe.has_permission("Sales Invoice", doc=doc, throw=True)
│
│	e_invoice = prepare_and_attach_invoice(doc, True)
│	return e_invoice.file_url
⋮...
│def sales_invoice_on_cancel(doc, method):
⋮...
│def get_progressive_name_and_number(doc, replace=False):
⋮...
│def set_state_code(doc, method):
⋮...

erpnext\assets\doctype\asset\depreciation.py:
│def post_depreciation_entries(date=None):
⋮...
│def scrap_asset(asset_name, scrap_date=None):
⋮...
│def get_depreciation_accounts(asset_category, company):
⋮...
│def depreciate_asset(asset_doc, date, notes):
⋮...
│def reset_depreciation_schedule(asset_doc, date, notes):
⋮...
│def reverse_depreciation_entry_made_after_disposal(asset, date):
⋮...
│def get_gl_entries_on_asset_disposal(
│	asset, selling_amount=0, finance_book=None, voucher_type=None, voucher_no=None, date=None
│):
⋮...
│def get_credit_and_debit_accounts_for_asset_category_and_company(asset_category, company):
⋮...
│def make_depreciation_entry(
│	asset_depr_schedule_name,
│	date=None,
│	sch_start_idx=None,
│	sch_end_idx=None,
│	credit_and_debit_accounts=None,
│	depreciation_cost_center_and_depreciation_series=None,
│	accounting_dimensions=None,
│):
⋮...
│def get_comma_separated_links(names, doctype):
⋮...
│def get_asset_details(asset, finance_book=None):
⋮...
│def get_profit_gl_entries(
│	asset, profit_amount, gl_entries, disposal_account, depreciation_cost_center, date=None
│):
⋮...
│def get_disposal_account_and_cost_center(company):
⋮...
│def get_value_after_depreciation_on_disposal_date(asset, disposal_date, finance_book=None):
⋮...
│def get_depreciable_asset_depr_schedules_data(date):
⋮...
│def make_depreciation_entry_for_all_asset_depr_schedules(asset_doc, date=None):
│	for row in asset_doc.get("finance_books"):
│		asset_depr_schedule_name = get_asset_depr_schedule_name(asset_doc.name, "Active", row.finance_book)
│		make_depreciation_entry(asset_depr_schedule_name, date)
⋮...
│def get_acc_frozen_upto():
⋮...
│def get_depreciation_cost_center_and_depreciation_series_for_company():
⋮...
│def _make_journal_entry_for_depreciation(
│	asset_depr_schedule_doc,
│	asset,
│	date,
│	depr_schedule,
│	sch_start_idx,
│	sch_end_idx,
│	depreciation_cost_center,
│	depreciation_series,
│	credit_account,
│	debit_account,
│	accounting_dimensions,
│):
⋮...
│def get_credit_and_debit_accounts(accumulated_depreciation_account, depreciation_expense_account):
⋮...
│def set_depr_entry_posting_status_for_failed_assets(failed_asset_names):
│	for asset_name in failed_asset_names:
│		frappe.db.set_value("Asset", asset_name, "depr_entry_posting_status", "Failed")
⋮...
│def notify_depr_entry_posting_error(failed_asset_names, error_log_names):
⋮...
│def validate_scrap_date(scrap_date, today_date, purchase_date, calculate_depreciation, asset_name):
⋮...
│def restore_asset(asset_name):
⋮...
│def cancel_depreciation_entries(asset_doc, date):
│	pass
⋮...
│def modify_depreciation_schedule_for_asset_repairs(asset, notes):
⋮...
│def get_depreciation_amount_in_je(journal_entry):
│	if journal_entry.accounts[0].debit_in_account_currency:
│		return journal_entry.accounts[0].debit_in_account_currency
│	else:
│		return journal_entry.accounts[0].credit_in_account_currency
⋮...
│def disposal_was_made_on_original_schedule_date(schedule_idx, row, posting_date_of_disposal):
⋮...
│def disposal_happens_in_the_future(posting_date_of_disposal):
│	if posting_date_of_disposal > getdate():
│		return True
│
│	return False
⋮...
│def get_gl_entries_on_asset_regain(
│	asset, selling_amount=0, finance_book=None, voucher_type=None, voucher_no=None, date=None
│):
⋮...

erpnext\setup\utils.py:
│def get_exchange_rate(from_currency, to_currency, transaction_date=None, args=None):
⋮...
│def format_ces_api(data, param):
│	return data.format(
│		transaction_date=param.get("transaction_date"),
│		to_currency=param.get("to_currency"),
│		from_currency=param.get("from_currency"),
│	)
⋮...
│def _enable_all_roles_for_admin():
⋮...
│def before_tests():
⋮...
│def get_pegged_rate(from_currency: str, to_currency: str, transaction_date) -> float | None:
│	if rate := PEGGED_CURRENCIES.get(from_currency, {}).get(to_currency):
│		return rate
│	elif rate := PEGGED_CURRENCIES.get(to_currency, {}).get(from_currency):
│		return 1 / rate
│	return None
⋮...
│def enable_all_roles_and_domains():
│	"""enable all roles and domain for testing"""
│	_enable_all_roles_for_admin()
⋮...
│def set_defaults_for_tests():
⋮...
│def insert_record(records):
│	from frappe.desk.page.setup_wizard.setup_wizard import make_records
│
│	make_records(records)
⋮...
│def welcome_email():
│	site_name = get_default_company() or "ERPNext"
│	title = _("Welcome to {0}").format(site_name)
│	return title
⋮...

erpnext\regional\united_arab_emirates\utils.py:
│def get_account_currency(account):
⋮...
│def get_tax_accounts(company):
⋮...
│def make_regional_gl_entries(gl_entries, doc):
⋮...
│def update_itemised_tax_data(doc):
⋮...
│def update_grand_total_for_rcm(doc, method):
⋮...
│def update_totals(vat_tax, base_vat_tax, doc):
⋮...
│def make_gl_entry(tax, gl_entries, doc, tax_accounts):
⋮...
│def validate_returns(doc, method):
⋮...

erpnext\accounts\report\account_balance\test_account_balance.py:
│def make_sales_invoice():
⋮...
│class TestAccountBalance(IntegrationTestCase):
⋮...
│	def test_account_balance(self):
⋮...

erpnext\regional\doctype\import_supplier_invoice\import_supplier_invoice.py:
│def create_purchase_invoice(supplier_name, file_name, args, name):
⋮...
│def create_supplier(supplier_group, args):
⋮...
│def create_address(supplier_name, args):
⋮...
│def get_supplier_details(file_content):
⋮...
│class ImportSupplierInvoice(Document):
⋮...
│	def validate(self):
│		if not frappe.db.get_value("Stock Settings", fieldname="stock_uom"):
│			frappe.throw(_("Please set default UOM in Stock Settings"))
⋮...
│	def autoname(self):
│		if not self.name:
│			self.name = "Import Invoice on " + format_datetime(self.creation)
⋮...
│	def import_xml_data(self):
⋮...
│	def prepare_data_for_import(self, file_content, file_name, encoded_content):
⋮...
│	def prepare_items_for_invoice(self, file_content, invoices_args):
⋮...
│	def process_file_data(self):
│		self.db_set("status", "Processing File Data", notify=True, commit=True)
│		frappe.enqueue_doc(self.doctype, self.name, "import_xml_data", queue="long", timeout=3600)
⋮...
│	def publish(self, title, message, count, total):
│		frappe.publish_realtime(
│			"import_invoice_update",
│			{"title": title, "message": message, "count": count, "total": total},
│			user=self.modified_by,
│		)
⋮...
│def get_file_content(file_name, zip_file_object):
⋮...
│def get_taxes_from_file(file_content, tax_account):
⋮...
│def get_payment_terms_from_file(file_content):
⋮...
│def get_destination_code_from_file(file_content):
│	destination_code = ""
│	for line in file_content.find_all("DatiTrasmissione"):
│		destination_code = line.CodiceDestinatario.text
│
│	return destination_code
⋮...
│def get_country(code):
│	existing_country_name = frappe.db.get_value("Country", filters={"code": code}, fieldname="name")
│	if existing_country_name:
│		return existing_country_name
│	else:
│		frappe.throw(_("Country Code in File does not match with country code set up in the system"))
⋮...
│def create_uom(uom):
⋮...

erpnext\accounts\doctype\pricing_rule\test_pricing_rule.py:
│def make_pricing_rule(**args):
⋮...
│def make_item_price(item, price_list_name, item_price):
⋮...
│def delete_existing_pricing_rules():
⋮...
│class UnitTestPricingRule(UnitTestCase):
⋮...
│class TestPricingRule(IntegrationTestCase):
⋮...
│	def setUp(self):
│		delete_existing_pricing_rules()
│		setup_pricing_rule_data()
│		self.enterClassContext(self.change_settings("Selling Settings", validate_selling_price=0))
⋮...
│	def tearDown(self):
│		delete_existing_pricing_rules()
⋮...
│	def test_pricing_rule_for_discount(self):
⋮...
│	def test_pricing_rule_for_margin(self):
⋮...
│	def test_mixed_conditions_for_item_group(self):
⋮...
│	def test_pricing_rule_for_variants(self):
⋮...
│	def test_pricing_rule_for_stock_qty(self):
⋮...
│	def test_pricing_rule_with_margin_and_discount(self):
⋮...
│	def test_pricing_rule_with_margin_and_discount_amount(self):
⋮...
│	def test_pricing_rule_for_product_discount_on_same_item(self):
⋮...
│	def test_pricing_rule_for_product_discount_on_different_item(self):
⋮...
│	def test_dont_enforce_free_item_qty(self):
⋮...
│	def test_cumulative_pricing_rule(self):
⋮...
│	def test_pricing_rule_for_condition(self):
⋮...
│	def test_multiple_pricing_rules(self):
⋮...
│	def test_multiple_pricing_rules_with_apply_discount_on_discounted_rate(self):
⋮...
│	def test_item_price_with_pricing_rule(self):
⋮...
│	def test_item_price_with_blank_uom_pricing_rule(self):
⋮...
│	def test_item_price_with_selling_uom_pricing_rule(self):
⋮...
│	def test_item_group_price_with_blank_uom_pricing_rule(self):
⋮...
│	def test_item_group_price_with_selling_uom_pricing_rule(self):
⋮...
│	def test_pricing_rule_for_different_currency(self):
⋮...
│	def test_pricing_rule_for_transaction(self):
⋮...
│	def test_pricing_rule_for_transaction_with_condition(self):
⋮...
│	def test_remove_pricing_rule(self):
⋮...
│	def test_multiple_pricing_rules_with_min_qty(self):
⋮...
│	def test_pricing_rule_for_other_items_cond_with_amount(self):
⋮...
│	def test_pricing_rule_for_product_free_item_rounded_qty_and_recursion(self):
⋮...
│	def test_pricing_rule_for_product_free_item_round_free_qty(self):
⋮...
│	def test_apply_multiple_pricing_rules_for_discount_percentage_and_amount(self):
⋮...
│	def test_priority_of_multiple_pricing_rules(self):
⋮...
│	def test_pricing_rules_with_and_without_apply_multiple(self):
⋮...
│	def test_validation_on_mixed_condition_with_recursion(self):
⋮...
│	def test_ignore_pricing_rule_for_credit_note(self):
⋮...
│	def test_ignore_pricing_rule_for_debit_note(self):
⋮...
│def setup_pricing_rule_data():
│	if not frappe.db.exists("UTM Campaign", "_Test Campaign"):
│		frappe.get_doc(
│			{"doctype": "UTM Campaign", "description": "_Test Campaign", "name": "_Test Campaign"}
│		).insert()
⋮...

erpnext\controllers\taxes_and_totals.py:
│class calculate_taxes_and_totals:
⋮...
│def get_itemised_tax(taxes, with_tax_account=False):
⋮...
│def get_itemised_tax_breakup_data(doc):
⋮...
│class init_landed_taxes_and_totals:
⋮...
│	def __init__(self, doc: Document):
⋮...
│	def filter_rows(self):
│		"""Exclude rows, that do not fulfill the filter criteria, from totals computation."""
│		items = list(filter(lambda item: not item.get("is_alternative"), self.doc.get("items")))
│		return items
⋮...
│	def calculate(self):
⋮...
│	def _calculate(self):
⋮...
│	def calculate_tax_withholding_net_total(self):
⋮...
│	def validate_item_tax_template(self):
⋮...
│	def update_item_tax_map(self):
⋮...
│	def validate_conversion_rate(self):
⋮...
│	def calculate_item_values(self):
⋮...
│	def _set_in_company_currency(self, doc, fields):
⋮...
│	def initialize_taxes(self):
⋮...
│	def determine_exclusive_rate(self):
⋮...
│	def _load_item_tax_rate(self, item_tax_rate):
│		return json.loads(item_tax_rate) if item_tax_rate else {}
⋮...
│	def get_current_tax_fraction(self, tax, item_tax_map):
⋮...
│	def _get_tax_rate(self, tax, item_tax_map):
│		if tax.account_head in item_tax_map:
│			return flt(item_tax_map.get(tax.account_head), self.doc.precision("rate", tax))
│		else:
│			return tax.rate
⋮...
│	def calculate_net_total(self):
⋮...
│	def calculate_shipping_charges(self):
⋮...
│	def calculate_taxes(self):
⋮...
│	def get_tax_amount_if_for_valuation_or_deduction(self, tax_amount, tax):
⋮...
│	def set_cumulative_total(self, row_idx, tax):
⋮...
│	def get_current_tax_and_net_amount(self, item, tax, item_tax_map):
⋮...
│	def set_item_wise_tax(self, item, tax, tax_rate, current_tax_amount, current_net_amount):
⋮...
│	def round_off_totals(self, tax):
⋮...
│	def round_off_base_values(self, tax):
│		# Round off to nearest integer based on regional settings
│		if tax.account_head in frappe.flags.round_off_applicable_accounts:
│			tax.base_tax_amount = round(tax.base_tax_amount, 0)
│			tax.base_tax_amount_after_discount_amount = round(tax.base_tax_amount_after_discount_amount, 0)
⋮...
│	def manipulate_grand_total_for_inclusive_tax(self):
│		# for backward compatablility - if in case used by an external application
│		return self.adjust_grand_total_for_inclusive_tax()
⋮...
│	def adjust_grand_total_for_inclusive_tax(self):
⋮...
│	def calculate_totals(self):
⋮...
│	def calculate_total_net_weight(self):
│		if self.doc.meta.get_field("total_net_weight"):
│			self.doc.total_net_weight = 0.0
│			for d in self._items:
│				if d.total_weight:
│					self.doc.total_net_weight += d.total_weight
⋮...
│	def set_rounded_total(self):
⋮...
│	def _cleanup(self):
│		if not self.doc.get("is_consolidated"):
│			for tax in self.doc.get("taxes"):
│				if not tax.get("dont_recompute_tax"):
│					tax.item_wise_tax_detail = json.dumps(tax.item_wise_tax_detail)
⋮...
│	def set_discount_amount(self):
⋮...
│	def apply_discount_amount(self):
⋮...
│	def get_total_for_discount_amount(self):
⋮...
│	def calculate_total_advance(self):
⋮...
│	def is_internal_invoice(self):
⋮...
│	def calculate_outstanding_amount(self):
⋮...
│	def calculate_paid_amount(self):
⋮...
│	def calculate_change_amount(self):
⋮...
│	def calculate_write_off_amount(self):
⋮...
│	def calculate_margin(self, item):
⋮...
│	def set_item_wise_tax_breakup(self):
│		self.doc.other_charges_calculation = get_itemised_tax_breakup_html(self.doc)
⋮...
│	def set_total_amount_to_default_mop(self, total_amount_to_pay):
⋮...
│def get_itemised_tax_breakup_html(doc):
⋮...
│def get_round_off_applicable_accounts(company, account_list):
│	# required to set correct region
│	with temporary_flag("company", company):
│		return get_regional_round_off_accounts(company, account_list)
⋮...
│def get_regional_round_off_accounts(company, account_list):
│	pass
⋮...
│def update_itemised_tax_data(doc):
│	# Don't delete this method, used for localization
│	pass
⋮...
│def get_itemised_tax_breakup_header(item_doctype, tax_accounts):
│	return [_("Item"), _("Taxable Amount"), *tax_accounts]
⋮...
│def get_rounded_tax_amount(itemised_tax, precision):
│	# Rounding based on tax_amount precision
│	for taxes in itemised_tax:
│		for row in taxes.values():
│			if isinstance(row, dict) and isinstance(row["tax_amount"], float):
│				row["tax_amount"] = flt(row["tax_amount"], precision)
⋮...
│def get_rounding_tax_settings():
│	return frappe.db.get_single_value("Accounts Settings", "round_row_wise_tax")
⋮...
│	def __init__(self, doc):
│		self.doc = doc
│		self.tax_field = "taxes" if self.doc.doctype == "Landed Cost Voucher" else "additional_costs"
│		self.set_account_currency()
│		self.set_exchange_rate()
│		self.set_amounts_in_company_currency()
⋮...
│	def set_account_currency(self):
│		company_currency = erpnext.get_company_currency(self.doc.company)
│		for d in self.doc.get(self.tax_field):
│			if not d.account_currency:
│				account_currency = frappe.get_cached_value("Account", d.expense_account, "account_currency")
│				d.account_currency = account_currency or company_currency
⋮...
│	def set_exchange_rate(self):
⋮...
│	def set_amounts_in_company_currency(self):
│		for d in self.doc.get(self.tax_field):
│			d.amount = flt(d.amount, d.precision("amount"))
│			d.base_amount = flt(d.amount * flt(d.exchange_rate), d.precision("base_amount"))
⋮...

erpnext\stock\doctype\batch\batch.py:
│def get_batch_qty(
│	batch_no=None,
│	warehouse=None,
│	item_code=None,
│	posting_date=None,
│	posting_time=None,
│	ignore_voucher_nos=None,
│	for_stock_levels=False,
│	consider_negative_batches=False,
│):
⋮...
│def get_available_batches(kwargs):
⋮...
│def make_batch(kwargs):
│	if frappe.db.get_value("Item", kwargs.item, "has_batch_no"):
│		kwargs.doctype = "Batch"
│		return frappe.get_doc(kwargs).insert().name
⋮...
│def batch_uses_naming_series():
⋮...
│def _get_batch_prefix():
⋮...
│def _make_naming_series_key(prefix):
⋮...
│def make_batch_bundle(
│	item_code: str,
⋮...
│class UnableToSelectBatchError(frappe.ValidationError):
│	pass
⋮...
│def get_name_from_hash():
⋮...
│def get_batch_naming_series():
⋮...
│class Batch(Document):
⋮...
│	def autoname(self):
⋮...
│	def onload(self):
│		self.image = frappe.db.get_value("Item", self.item, "image")
⋮...
│	def after_delete(self):
│		revert_series_if_last(get_batch_naming_series(), self.name)
⋮...
│	def validate(self):
│		self.item_has_batch_enabled()
│		self.set_batchwise_valuation()
⋮...
│	def item_has_batch_enabled(self):
│		if frappe.db.get_value("Item", self.item, "has_batch_no") == 0:
│			frappe.throw(_("The selected item cannot have Batch"))
⋮...
│	def set_batchwise_valuation(self):
⋮...
│	def before_save(self):
│		self.set_expiry_date()
⋮...
│	def set_expiry_date(self):
⋮...
│	def get_name_from_naming_series(self):
⋮...
│def get_batches_by_oldest(item_code, warehouse):
│	"""Returns the oldest batch and qty for the given item_code and warehouse"""
│	batches = get_batch_qty(item_code=item_code, warehouse=warehouse)
│	batches_dates = [[batch, frappe.get_value("Batch", batch.batch_no, "expiry_date")] for batch in batches]
│	batches_dates.sort(key=lambda tup: tup[1])
│	return batches_dates
⋮...
│def split_batch(batch_no: str, item_code: str, warehouse: str, qty: float, new_batch_id: str | None = None):
⋮...
│def get_batches(item_code, warehouse, qty=1, throw=False, serial_no=None):
⋮...
│def validate_serial_no_with_batch(serial_nos, item_code):
⋮...
│def get_pos_reserved_batch_qty(filters):
⋮...
│def get_batch_no(bundle_id):
⋮...

erpnext\accounts\doctype\payment_order\payment_order.py:
│def make_journal_entry(doc, supplier, mode_of_payment=None):
⋮...
│class PaymentOrder(Document):
⋮...
│	def on_submit(self):
│		self.update_payment_status()
⋮...
│	def on_cancel(self):
│		self.update_payment_status(cancel=True)
⋮...
│	def update_payment_status(self, cancel=False):
⋮...
│def get_mop_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def get_supplier_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def make_payment_records(name, supplier, mode_of_payment=None):
│	doc = frappe.get_doc("Payment Order", name)
│	make_journal_entry(doc, supplier, mode_of_payment)
⋮...

erpnext\accounts\report\utils.py:
│def get_party_details(party_type, party_list):
⋮...
│def convert(value, from_, to, date):
⋮...
│def convert_to_presentation_currency(gl_entries, currency_info):
⋮...
│def get_values_for_columns(report_columns, report_row):
⋮...
│def get_taxes_query(invoice_list, doctype, parenttype):
⋮...
│def apply_common_conditions(filters, query, doctype, child_doctype=None, payments=False):
⋮...
│def get_currency(filters):
⋮...
│def get_journal_entries(filters, args):
⋮...
│def get_payment_entries(filters, args):
⋮...
│def get_query_columns(report_columns):
⋮...
│def get_advance_taxes_and_charges(invoice_list):
⋮...
│def get_opening_row(party_type, party, from_date, company):
⋮...
│def get_rate_as_at(date, from_currency, to_currency):
⋮...
│def get_appropriate_company(filters):
⋮...
│def get_invoiced_item_gross_margin(sales_invoice=None, item_code=None, company=None, with_item_data=False):
⋮...
│def filter_invoices_based_on_dimensions(filters, query, parent_doc):
⋮...

erpnext\quality_management\doctype\quality_procedure\quality_procedure.py:
│def get_children(doctype, parent=None, parent_quality_procedure=None, is_root=False):
⋮...
│def add_node():
⋮...
│class QualityProcedure(NestedSet):
⋮...
│	def before_save(self):
│		self.check_for_incorrect_child()
⋮...
│	def on_update(self):
│		NestedSet.on_update(self)
│		self.set_parent()
│		self.remove_parent_from_old_child()
│		self.add_child_to_parent()
│		self.remove_child_from_old_parent()
⋮...
│	def after_insert(self):
│		self.set_parent()
│		self.add_child_to_parent()
⋮...
│	def on_trash(self):
⋮...
│	def check_for_incorrect_child(self):
⋮...
│	def set_parent(self):
⋮...
│	def remove_parent_from_old_child(self):
⋮...
│	def add_child_to_parent(self):
⋮...
│	def remove_child_from_old_parent(self):
⋮...

erpnext\setup\doctype\email_digest\email_digest.py:
│def get_incomes_expenses_for_period(account, from_date, to_date):
⋮...
│class EmailDigest(Document):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def get_users(self):
⋮...
│	def send(self):
⋮...
│	def get_msg_html(self):
⋮...
│	def set_title(self, context):
⋮...
│	def set_style(self, context):
⋮...
│	def get_notifications(self):
⋮...
│	def get_calendar_events(self):
⋮...
│	def get_todo_list(self, user_id=None):
⋮...
│	def get_todo_count(self, user_id=None):
⋮...
│	def get_issue_list(self, user_id=None):
⋮...
│	def get_issue_count(self):
│		"""Get count of Issue"""
│		return frappe.db.sql(
│			"""select count(*) from `tabIssue`
│			where status in ('Open','Replied') """
│		)[0][0]
⋮...
│	def get_project_list(self, user_id=None):
⋮...
│	def get_project_count(self):
│		"""Get count of Project"""
│		return frappe.db.sql(
│			"""select count(*) from `tabProject`
│			where status='Open' and project_type='External'"""
│		)[0][0]
⋮...
│	def set_accounting_cards(self, context):
⋮...
│	def get_income(self):
⋮...
│	def get_income_year_to_date(self):
│		"""Get income to date"""
│		return self.get_year_to_date_balance("income", "income")
⋮...
│	def get_expense_year_to_date(self):
│		"""Get income to date"""
│		return self.get_year_to_date_balance("expense", "expenses_booked")
⋮...
│	def get_year_to_date_balance(self, root_type, fieldname):
⋮...
│	def get_bank_balance(self):
│		# account is of type "Bank" and root_type is Asset
│		return self.get_type_balance("bank_balance", "Bank", root_type="Asset")
⋮...
│	def get_credit_balance(self):
│		# account is of type "Bank" and root_type is Liability
│		return self.get_type_balance("credit_balance", "Bank", root_type="Liability")
⋮...
│	def get_payables(self):
│		return self.get_type_balance("payables", "Payable")
⋮...
│	def get_invoiced_amount(self):
│		return self.get_type_balance("invoiced_amount", "Receivable")
⋮...
│	def get_expenses_booked(self):
⋮...
│	def get_period_amounts(self, accounts, fieldname):
⋮...
│	def get_sales_orders_to_bill(self):
⋮...
│	def get_sales_orders_to_deliver(self):
⋮...
│	def get_purchase_orders_to_receive(self):
⋮...
│	def get_purchase_orders_to_bill(self):
⋮...
│	def get_type_balance(self, fieldname, account_type, root_type=None):
⋮...
│	def get_roots(self, root_type):
⋮...
│	def get_root_type_accounts(self, root_type):
⋮...
│	def get_purchase_order(self):
│		return self.get_summary_of_doc("Purchase Order", "purchase_order")
⋮...
│	def get_sales_order(self):
│		return self.get_summary_of_doc("Sales Order", "sales_order")
⋮...
│	def get_pending_purchase_orders(self):
│		return self.get_summary_of_pending("Purchase Order", "pending_purchase_orders", "per_received")
⋮...
│	def get_pending_sales_orders(self):
│		return self.get_summary_of_pending("Sales Order", "pending_sales_orders", "per_delivered")
⋮...
│	def get_sales_invoice(self):
│		return self.get_summary_of_doc("Sales Invoice", "sales_invoice")
⋮...
│	def get_purchase_invoice(self):
│		return self.get_summary_of_doc("Purchase Invoice", "purchase_invoice")
⋮...
│	def get_new_quotations(self):
│		return self.get_summary_of_doc("Quotation", "new_quotations")
⋮...
│	def get_pending_quotations(self):
│		return self.get_summary_of_pending_quotations("pending_quotations")
⋮...
│	def get_summary_of_pending(self, doc_type, fieldname, getfield):
⋮...
│	def get_summary_of_pending_quotations(self, fieldname):
⋮...
│	def get_summary_of_doc(self, doc_type, fieldname):
⋮...
│	def get_total_on(self, doc_type, from_date, to_date):
⋮...
│	def get_from_to_date(self):
⋮...
│	def set_dates(self):
⋮...
│	def get_next_sending(self):
⋮...
│	def onload(self):
│		self.get_next_sending()
⋮...
│	def fmt_money(self, value, absol=True):
│		if absol:
│			return fmt_money(abs(value), currency=self.currency)
│		else:
│			return fmt_money(value, currency=self.currency)
⋮...
│	def get_purchase_orders_items_overdue_list(self):
⋮...
│def send():
⋮...
│def get_digest_msg(name):
│	return frappe.get_doc("Email Digest", name).get_msg_html()
⋮...
│def get_count_for_period(account, fieldname, from_date, to_date):
⋮...
│def get_future_date_for_calendaer_event(frequency):
⋮...

erpnext\setup\doctype\transaction_deletion_record\test_transaction_deletion_record.py:
│def create_task(company):
│	task = frappe.get_doc({"doctype": "Task", "company": company, "subject": "Delete"})
│	task.insert()
⋮...
│def create_company(company_name):
│	company = frappe.get_doc({"doctype": "Company", "company_name": company_name, "default_currency": "INR"})
│	company.insert(ignore_if_duplicate=True)
⋮...
│def create_transaction_deletion_doc(company):
⋮...
│class UnitTestTransactionDeletionRecord(UnitTestCase):
⋮...
│class TestTransactionDeletionRecord(IntegrationTestCase):
⋮...
│	def setUp(self):
│		create_company("Dunder Mifflin Paper Co")
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_doctypes_contain_company_field(self):
⋮...
│	def test_no_of_docs_is_correct(self):
⋮...
│	def test_deletion_is_successful(self):
│		create_task("Dunder Mifflin Paper Co")
│		create_transaction_deletion_doc("Dunder Mifflin Paper Co")
│		tasks_containing_company = frappe.get_all("Task", filters={"company": "Dunder Mifflin Paper Co"})
│		self.assertEqual(tasks_containing_company, [])
⋮...
│	def test_company_transaction_deletion_request(self):
⋮...

erpnext\accounts\doctype\pricing_rule\utils.py:
│def update_coupon_code_count(coupon_name, transaction_type):
⋮...
│def get_applied_pricing_rules(pricing_rules):
⋮...
│def validate_coupon_code(coupon_name):
⋮...
│def get_pricing_rule_items(pr_doc, other_items=False) -> list:
⋮...
│def _get_tree_conditions(args, parenttype, table, allow_blank=True):
⋮...
│def filter_pricing_rules_for_qty_amount(qty, rate, pricing_rules, args=None):
⋮...
│class MultiplePricingRuleConflict(frappe.ValidationError):
│	pass
⋮...
│def get_pricing_rules(args, doc=None):
⋮...
│def filter_pricing_rule_based_on_condition(pricing_rules, doc=None):
⋮...
│def _get_pricing_rules(apply_on, args, values):
⋮...
│def apply_multiple_pricing_rules(pricing_rules):
│	for d in pricing_rules:
│		if not d.apply_multiple_pricing_rules:
│			return False
│
│	return True
⋮...
│def get_other_conditions(conditions, values, args):
⋮...
│def filter_pricing_rules(args, pricing_rules, doc=None):
⋮...
│def get_qty_amount_data_for_cumulative(pr_doc, doc, items=None):
⋮...
│def get_product_discount_rule(pricing_rule, item_details, args=None, doc=None):
⋮...
│def apply_pricing_rule_for_free_items(doc, pricing_rule_args):
⋮...
│def sorted_by_priority(pricing_rules, args, doc=None):
⋮...
│def validate_quantity_and_amount_for_suggestion(args, qty, amount, item_code, transaction_type):
⋮...
│def if_all_rules_same(pricing_rules, fields):
⋮...
│def apply_internal_priority(pricing_rules, field_set, args):
⋮...
│def get_qty_and_rate_for_mixed_conditions(doc, pr_doc, args):
⋮...
│def get_qty_and_rate_for_other_item(doc, pr_doc, pricing_rules, row_item):
⋮...
│def apply_pricing_rule_on_transaction(doc):
⋮...
│def remove_free_item(doc):
│	for d in doc.items:
│		if d.is_free_item:
│			doc.remove(d)
⋮...

erpnext\accounts\dashboard_chart_source\account_balance_timeline\account_balance_timeline.py:
│def get_gl_entries(account, to_date):
⋮...
│def get(
│	chart_name=None,
│	chart=None,
│	no_cache=None,
│	filters=None,
│	from_date=None,
│	to_date=None,
│	timespan=None,
│	time_interval=None,
│	heatmap_year=None,
│):
⋮...
│def build_result(account, dates, gl_entries):
⋮...
│def get_dates_from_timegrain(from_date, to_date, timegrain):
⋮...

erpnext\buying\doctype\supplier_scorecard_variable\supplier_scorecard_variable.py:
│def get_ordered_qty(scorecard):
⋮...
│class VariablePathNotFound(frappe.ValidationError):
│	pass
⋮...
│class SupplierScorecardVariable(Document):
⋮...
│	def validate(self):
│		self.validate_path_exists()
⋮...
│	def validate_path_exists(self):
⋮...
│def get_total_workdays(scorecard):
│	"""Gets the number of days in this period"""
│	delta = getdate(scorecard.end_date) - getdate(scorecard.start_date)
│	return delta.days
⋮...
│def get_item_workdays(scorecard):
⋮...
│def get_total_cost_of_shipments(scorecard):
⋮...
│def get_cost_of_delayed_shipments(scorecard):
│	"""Gets the total cost of all delayed shipments in the period (based on Purchase Receipts - POs)"""
│	return get_total_cost_of_shipments(scorecard) - get_cost_of_on_time_shipments(scorecard)
⋮...
│def get_cost_of_on_time_shipments(scorecard):
⋮...
│def get_total_days_late(scorecard):
⋮...
│def get_on_time_shipments(scorecard):
⋮...
│def get_late_shipments(scorecard):
│	"""Gets the number of late shipments (counting each item) in the period (based on Purchase Receipts vs POs)"""
│	return get_total_shipments(scorecard) - get_on_time_shipments(scorecard)
⋮...
│def get_total_received(scorecard):
⋮...
│def get_total_received_amount(scorecard):
⋮...
│def get_total_received_items(scorecard):
⋮...
│def get_total_rejected_amount(scorecard):
⋮...
│def get_total_rejected_items(scorecard):
⋮...
│def get_total_accepted_amount(scorecard):
⋮...
│def get_total_accepted_items(scorecard):
⋮...
│def get_total_shipments(scorecard):
⋮...
│def get_invoiced_qty(scorecard):
⋮...
│def get_rfq_total_number(scorecard):
⋮...
│def get_rfq_total_items(scorecard):
⋮...
│def get_sq_total_number(scorecard):
⋮...
│def get_sq_total_items(scorecard):
⋮...
│def get_rfq_response_days(scorecard):
⋮...

erpnext\controllers\website_list_for_contact.py:
│def get_list_context(context=None):
⋮...
│def post_process(doctype, data):
⋮...
│def get_customers_suppliers(doctype, user):
⋮...
│def get_transaction_list(
│	doctype,
│	txt=None,
│	filters=None,
│	limit_start=0,
│	limit_page_length=20,
│	order_by="creation desc",
│	custom=False,
│):
⋮...
│def get_parents_for_user(parenttype: str) -> list[str]:
⋮...
│def get_customer_field_name(doctype):
│	if doctype == "Quotation":
│		return "party_name"
│	else:
│		return "customer"
⋮...
│def add_role_for_portal_user(portal_user, role):
⋮...
│def get_webform_list_context(module):
│	if get_module_app(module) != "erpnext":
│		return
│	return {"get_list": get_webform_transaction_list}
⋮...
│def get_webform_transaction_list(
│	doctype, txt=None, filters=None, limit_start=0, limit_page_length=20, order_by="creation"
│):
⋮...
│def get_list_for_transactions(
│	doctype,
│	txt,
│	filters,
│	limit_start,
│	limit_page_length=20,
│	ignore_permissions=False,
│	fields=None,
│	order_by=None,
│):
⋮...
│def rfq_transaction_list(parties_doctype, doctype, parties, limit_start, limit_page_length):
⋮...
│def has_website_permission(doc, ptype, user, verbose=False):
⋮...
│def get_customer_filter(doc, customers):
⋮...

erpnext\selling\doctype\quotation\test_quotation.py:
│def make_quotation(**args):
⋮...
│def enable_calculate_bundle_price(enable=1):
│	selling_settings = frappe.get_doc("Selling Settings")
│	selling_settings.editable_bundle_item_rates = enable
│	selling_settings.save()
⋮...
│class UnitTestQuotation(UnitTestCase):
⋮...
│class TestQuotation(IntegrationTestCase):
⋮...
│	def test_quotation_qty(self):
⋮...
│	def test_make_quotation_without_terms(self):
⋮...
│	def test_make_sales_order_terms_copied(self):
⋮...
│	def test_do_not_add_ordered_items_in_new_sales_order(self):
⋮...
│	def test_gross_profit(self):
⋮...
│	def test_maintain_rate_in_sales_cycle_is_enforced(self):
⋮...
│	def test_make_sales_order_with_different_currency(self):
⋮...
│	def test_make_sales_order(self):
⋮...
│	def test_make_sales_order_with_terms(self):
⋮...
│	def test_valid_till_before_transaction_date(self):
│		quotation = frappe.copy_doc(self.globalTestRecords["Quotation"][0])
│		quotation.valid_till = add_days(quotation.transaction_date, -1)
│		self.assertRaises(frappe.ValidationError, quotation.validate)
⋮...
│	def test_so_from_expired_quotation(self):
⋮...
│	def test_create_quotation_with_margin(self):
⋮...
│	def test_create_two_quotations(self):
⋮...
│	def test_quotation_expiry(self):
⋮...
│	def test_product_bundle_mapping_on_creating_so(self):
⋮...
│	def test_product_bundle_price_calculation_when_calculate_bundle_price_is_unchecked(self):
⋮...
│	def test_product_bundle_price_calculation_when_calculate_bundle_price_is_checked(self):
⋮...
│	def test_product_bundle_price_calculation_for_multiple_product_bundles_when_calculate_bundle_price_is_checked(
│		self,
│	):
⋮...
│	def test_packed_items_indices_are_reset_when_product_bundle_is_deleted_from_items_table(self):
⋮...
│	def test_alternative_items_with_stock_items(self):
⋮...
│	def test_alternative_items_with_service_items(self):
⋮...
│	def test_amount_calculation_for_alternative_items(self):
⋮...
│	def test_alternative_items_sales_order_mapping_with_stock_items(self):
⋮...
│	def test_uom_validation(self):
⋮...
│	def test_item_tax_template_for_quotation(self):
⋮...
│	def test_grand_total_and_rounded_total_values(self):
⋮...
│def get_quotation_dict(party_name=None, item_code=None):
⋮...

erpnext\stock\doctype\repost_item_valuation\repost_item_valuation.py:
│def on_doctype_update():
│	frappe.db.add_index("Repost Item Valuation", ["warehouse", "item_code"], "item_warehouse")
⋮...
│def repost(doc):
⋮...
│def repost_entries():
⋮...
│def get_recipients():
⋮...
│def in_configured_timeslot(repost_settings=None, current_time=None):
⋮...
│def repost_sl_entries(doc):
⋮...
│def get_repost_item_valuation_entries():
⋮...
│class RepostItemValuation(Document):
⋮...
│	def clear_old_logs(days=None):
⋮...
│	def validate(self):
⋮...
│	def validate_period_closing_voucher(self):
⋮...
│	def reset_recreate_stock_ledgers(self):
│		if self.recreate_stock_ledgers and self.based_on != "Transaction":
│			self.recreate_stock_ledgers = 0
⋮...
│	def get_closing_stock_balance(self):
⋮...
│	def get_max_period_closing_date(company):
⋮...
│	def validate_accounts_freeze(self):
⋮...
│	def reset_field_values(self):
│		if self.based_on == "Transaction":
│			self.item_code = None
│			self.warehouse = None
│
│		self.allow_negative_stock = 1
⋮...
│	def on_cancel(self):
│		self.clear_attachment()
⋮...
│	def on_trash(self):
│		self.clear_attachment()
⋮...
│	def set_company(self):
│		if self.based_on == "Transaction":
│			self.company = frappe.get_cached_value(self.voucher_type, self.voucher_no, "company")
│		elif self.warehouse:
│			self.company = frappe.get_cached_value("Warehouse", self.warehouse, "company")
⋮...
│	def set_status(self, status=None, write=True):
⋮...
│	def clear_attachment(self):
⋮...
│	def on_submit(self):
⋮...
│	def before_cancel(self):
│		self.check_pending_repost_against_cancelled_transaction()
⋮...
│	def check_pending_repost_against_cancelled_transaction(self):
⋮...
│	def restart_reposting(self):
⋮...
│	def deduplicate_similar_repost(self):
⋮...
│	def recreate_stock_ledger_entries(self):
⋮...
│def remove_attached_file(docname):
│	if file_name := frappe.db.get_value(
│		"File", {"attached_to_name": docname, "attached_to_doctype": "Repost Item Valuation"}, "name"
│	):
│		frappe.delete_doc("File", file_name, ignore_permissions=True, delete_permanently=True, force=True)
⋮...
│def repost_gl_entries(doc):
⋮...
│def _get_directly_dependent_vouchers(doc):
⋮...
│def notify_error_to_stock_managers(doc, traceback):
⋮...
│def execute_repost_item_valuation():
⋮...

erpnext\accounts\doctype\tax_withholding_category\tax_withholding_category.py:
│def get_party_details(inv):
⋮...
│def get_party_tax_withholding_details(inv, tax_withholding_category=None):
⋮...
│def get_cost_center(inv):
⋮...
│def get_tax_withholding_rates(tax_withholding, posting_date):
⋮...
│def get_lower_deduction_amount(current_amount, limit_consumed, certificate_limit, rate, tax_details):
⋮...
│def is_valid_certificate(ldc, posting_date, limit_consumed):
│	available_amount = flt(ldc.certificate_limit) - flt(limit_consumed)
│	if (getdate(ldc.valid_from) <= getdate(posting_date) <= getdate(ldc.valid_upto)) and available_amount > 0:
│		return True
│
│	return False
⋮...
│class TaxWithholdingCategory(Document):
⋮...
│	def validate(self):
│		self.validate_dates()
│		self.validate_companies_and_accounts()
│		self.validate_thresholds()
⋮...
│	def validate_dates(self):
⋮...
│	def validate_companies_and_accounts(self):
⋮...
│	def validate_thresholds(self):
⋮...
│def get_tax_withholding_details(tax_withholding_category, posting_date, company):
⋮...
│def get_tax_row_for_tcs(inv, tax_details, tax_amount, tax_deducted):
⋮...
│def get_tax_row_for_tds(tax_details, tax_amount):
⋮...
│def get_lower_deduction_certificate(company, posting_date, tax_details, pan_no):
⋮...
│def get_tax_amount(party_type, parties, inv, tax_details, posting_date, pan_no=None):
⋮...
│def is_tax_deducted_on_the_basis_of_inv(vouchers):
⋮...
│def get_invoice_vouchers(parties, tax_details, company, party_type="Supplier"):
⋮...
│def get_payment_entry_vouchers(parties, tax_details, company, party_type="Supplier"):
⋮...
│def get_advance_vouchers(parties, company=None, from_date=None, to_date=None, party_type="Supplier"):
⋮...
│def get_taxes_deducted_on_advances_allocated(inv, tax_details):
⋮...
│def get_deducted_tax(taxable_vouchers, tax_details):
⋮...
│def get_advance_tax_across_fiscal_year(tax_deducted_on_advances, tax_details):
⋮...
│def get_tds_amount(ldc, parties, inv, tax_details, voucher_wise_amount):
⋮...
│def get_tcs_amount(parties, inv, tax_details, vouchers, adv_vouchers):
⋮...
│def get_advance_adjusted_in_invoice(inv):
│	advances_adjusted = 0
│	for row in inv.get("advances", []):
│		advances_adjusted += row.allocated_amount
│
│	return advances_adjusted
⋮...
│def get_invoice_total_without_tcs(inv, tax_details):
│	tcs_tax_row = [d for d in inv.taxes if d.account_head == tax_details.account_head]
│	tcs_tax_row_amount = tcs_tax_row[0].base_tax_amount if tcs_tax_row else 0
│
│	return inv.grand_total - tcs_tax_row_amount
⋮...
│def get_limit_consumed(ldc, parties):
⋮...
│def normal_round(number):
⋮...

erpnext\stock\doctype\material_request\test_material_request.py:
│def make_material_request(**args):
⋮...
│class UnitTestMaterialRequest(UnitTestCase):
⋮...
│class TestMaterialRequest(IntegrationTestCase):
⋮...
│	def test_material_request_qty(self):
⋮...
│	def test_make_purchase_order(self):
⋮...
│	def test_make_subcontracted_purchase_order(self):
⋮...
│	def test_make_supplier_quotation(self):
⋮...
│	def test_make_stock_entry(self):
⋮...
│	def test_partial_make_stock_entry(self):
⋮...
│	def test_in_transit_make_stock_entry(self):
⋮...
│	def _insert_stock_entry(self, qty1, qty2, warehouse=None):
⋮...
│	def test_cannot_stop_cancelled_material_request(self):
⋮...
│	def test_mr_changes_from_stopped_to_pending_after_reopen(self):
⋮...
│	def test_cannot_submit_cancelled_mr(self):
⋮...
│	def test_mr_changes_from_pending_to_cancelled_after_cancel(self):
│		mr = frappe.copy_doc(self.globalTestRecords["Material Request"][0])
│		mr.insert()
│		mr.submit()
│		mr.cancel()
│		self.assertEqual("Cancelled", mr.status)
⋮...
│	def test_cannot_change_cancelled_mr(self):
⋮...
│	def test_cannot_submit_deleted_material_request(self):
│		mr = frappe.copy_doc(self.globalTestRecords["Material Request"][0])
│		mr.insert()
│		mr.delete()
│
│		self.assertRaises(frappe.ValidationError, mr.submit)
⋮...
│	def test_cannot_delete_submitted_mr(self):
│		mr = frappe.copy_doc(self.globalTestRecords["Material Request"][0])
│		mr.insert()
│		mr.submit()
│
│		self.assertRaises(frappe.ValidationError, mr.delete)
⋮...
│	def test_stopped_mr_changes_to_pending_after_reopen(self):
⋮...
│	def test_pending_mr_changes_to_stopped_after_stop(self):
⋮...
│	def test_cannot_stop_unsubmitted_mr(self):
│		mr = frappe.copy_doc(self.globalTestRecords["Material Request"][0])
│		mr.insert()
│		self.assertRaises(frappe.InvalidStatusError, mr.update_status, "Stopped")
⋮...
│	def test_completed_qty_for_purchase(self):
⋮...
│	def test_completed_qty_for_transfer(self):
⋮...
│	def test_over_transfer_qty_allowance(self):
⋮...
│	def test_completed_qty_for_over_transfer(self):
⋮...
│	def test_incorrect_mapping_of_stock_entry(self):
⋮...
│	def test_warehouse_company_validation(self):
│		from erpnext.stock.utils import InvalidWarehouseCompany
│
│		mr = frappe.copy_doc(self.globalTestRecords["Material Request"][0])
│		mr.company = "_Test Company 1"
│		self.assertRaises(InvalidWarehouseCompany, mr.insert)
⋮...
│	def _get_requested_qty(self, item_code, warehouse):
│		return flt(
│			frappe.db.get_value("Bin", {"item_code": item_code, "warehouse": warehouse}, "indented_qty")
│		)
⋮...
│	def test_make_stock_entry_for_material_issue(self):
⋮...
│	def test_completed_qty_for_issue(self):
⋮...
│	def test_material_request_type_manufacture(self):
⋮...
│	def test_requested_qty_multi_uom(self):
⋮...
│	def test_multi_uom_for_purchase(self):
⋮...
│	def test_customer_provided_parts_mr(self):
⋮...
│	def test_auto_email_users_with_company_user_permissions(self):
⋮...
│def get_in_transit_warehouse(company):
⋮...

erpnext\controllers\buying_controller.py:
│class BuyingController(SubcontractingController):
⋮...
│class QtyMismatchError(ValidationError):
│	pass
⋮...
│def validate_item_type(doc, fieldname, message):
⋮...
│	def __setup__(self):
│		self.flags.ignore_permlevel_for_fields = ["buying_price_list", "price_list_currency"]
⋮...
│	def validate(self):
⋮...
│	def onload(self):
│		super().onload()
│		self.set_onload(
│			"backflush_based_on",
│			frappe.db.get_single_value("Buying Settings", "backflush_raw_materials_of_subcontract_based_on"),
│		)
⋮...
│	def create_package_for_transfer(self) -> None:
⋮...
│	def set_rate_for_standalone_debit_note(self):
⋮...
│	def set_missing_values(self, for_validate=False):
⋮...
│	def set_supplier_from_item_default(self):
⋮...
│	def validate_stock_or_nonstock_items(self):
│		if self.meta.get_field("taxes") and not self.get_stock_items() and not self.get_asset_items():
│			msg = _('Tax Category has been changed to "Total" because all the Items are non-stock items')
│			self.update_tax_category(msg)
⋮...
│	def update_tax_category(self, msg):
⋮...
│	def validate_asset_return(self):
⋮...
│	def get_asset_items(self):
│		if self.doctype not in ["Purchase Order", "Purchase Invoice", "Purchase Receipt"]:
│			return []
│
│		return [d.item_code for d in self.items if d.is_fixed_asset]
⋮...
│	def set_landed_cost_voucher_amount(self):
⋮...
│	def validate_from_warehouse(self):
⋮...
│	def set_supplier_address(self):
⋮...
│	def set_total_in_words(self):
⋮...
│	def update_valuation_rate(self, reset_outgoing_rate=True):
⋮...
│	def set_incoming_rate(self):
⋮...
│	def set_sales_incoming_rate_for_internal_transfer(self):
⋮...
│	def validate_for_subcontracting(self):
⋮...
│	def set_qty_as_per_stock_uom(self):
⋮...
│	def validate_purchase_return(self):
⋮...
│	def validate_accepted_rejected_qty(self):
⋮...
│	def validate_negative_quantity(self, item_row, field_list):
⋮...
│	def check_for_on_hold_or_closed_status(self, ref_doctype, ref_fieldname):
⋮...
│	def update_stock_ledger(self, allow_negative_stock=False, via_landed_cost_voucher=False):
⋮...
│	def get_package_for_target_warehouse(self, item, warehouse=None, type_of_transaction=None) -> str:
⋮...
│	def update_ordered_and_reserved_qty(self):
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def validate_budget(self):
⋮...
│	def process_fixed_asset(self):
⋮...
│	def auto_make_assets(self, asset_items):
⋮...
│	def make_asset(self, row, accounting_dimensions, is_grouped_asset=False):
⋮...
│	def update_fixed_asset(self, field, delete_asset=False):
⋮...
│	def delete_linked_asset(self):
│		if self.doctype == "Purchase Invoice" and not self.get("update_stock"):
│			return
│
│		asset_movement = frappe.db.get_value("Asset Movement", {"reference_name": self.name}, "name")
│		frappe.delete_doc("Asset Movement", asset_movement, force=1)
⋮...
│	def validate_schedule_date(self):
⋮...
│	def validate_items(self):
⋮...
│def get_asset_item_details(asset_items):
⋮...
│def update_regional_item_valuation_rate(doc):
│	pass
⋮...

erpnext\setup\doctype\holiday_list\holiday_list.py:
│class OverlapError(frappe.ValidationError):
│	pass
⋮...
│def get_events(start, end, filters=None):
⋮...
│def local_country_name(country_code: str) -> str:
│	"""Return the localized country name for the given country code."""
│	from babel import Locale
│
│	return Locale.parse(frappe.local.lang, sep="-").territories.get(country_code, country_code)
⋮...
│def is_holiday(holiday_list, date=None):
⋮...
│class HolidayList(Document):
⋮...
│	def validate(self):
│		self.validate_days()
│		self.total_holidays = len(self.holidays)
│		self.validate_duplicate_date()
│		self.sort_holidays()
⋮...
│	def get_weekly_off_dates(self):
⋮...
│	def get_supported_countries(self):
⋮...
│	def get_local_holidays(self):
⋮...
│	def sort_holidays(self):
│		self.holidays.sort(key=lambda x: getdate(x.holiday_date))
│		for i in range(len(self.holidays)):
│			self.holidays[i].idx = i + 1
⋮...
│	def get_holidays(self) -> list[date]:
│		return [getdate(holiday.holiday_date) for holiday in self.holidays]
⋮...
│	def validate_days(self):
⋮...
│	def get_weekly_off_date_list(self, start_date, end_date):
⋮...
│	def clear_table(self):
│		self.set("holidays", [])
⋮...
│	def validate_duplicate_date(self):
⋮...

erpnext\stock\doctype\inventory_dimension\test_inventory_dimension.py:
│def prepare_data_for_internal_transfer():
⋮...
│def create_inventory_dimension(**args):
⋮...
│def get_voucher_sl_entries(voucher_no, fields):
│	return frappe.get_all(
│		"Stock Ledger Entry", filters={"voucher_no": voucher_no}, fields=fields, order_by="creation"
│	)
⋮...
│class UnitTestInventoryDimension(UnitTestCase):
⋮...
│class TestInventoryDimension(IntegrationTestCase):
⋮...
│	def setUp(self):
│		prepare_test_data()
│		create_store_dimension()
⋮...
│	def test_validate_inventory_dimension(self):
⋮...
│	def test_delete_inventory_dimension(self):
⋮...
│	def test_inventory_dimension(self):
⋮...
│	def test_inventory_dimension_for_purchase_receipt_and_delivery_note(self):
⋮...
│	def test_check_standard_dimensions(self):
⋮...
│	def test_check_mandatory_dimensions(self):
⋮...
│	def test_check_mandatory_depends_on_dimensions(self):
⋮...
│	def test_for_purchase_sales_and_stock_transaction(self):
⋮...
│	def test_inter_transfer_return_against_inventory_dimension(self):
⋮...
│	def test_validate_negative_stock_for_inventory_dimension(self):
⋮...
│def create_store_dimension():
⋮...
│def prepare_test_data():
⋮...

erpnext\accounts\doctype\pos_invoice_merge_log\pos_invoice_merge_log.py:
│def consolidate_pos_invoices(pos_invoices=None, closing_entry=None):
⋮...
│def create_merge_logs(invoice_by_customer, closing_entry=None):
⋮...
│def update_item_wise_tax_detail(consolidate_tax_row, tax_row):
⋮...
│def cancel_merge_logs(merge_logs, closing_entry=None):
⋮...
│def enqueue_job(job, **kwargs):
⋮...
│def get_error_message(message) -> str:
│	try:
│		return message["message"]
│	except Exception:
│		return str(message)
⋮...
│class POSInvoiceMergeLog(Document):
⋮...
│	def validate(self):
│		self.validate_customer()
│		self.validate_pos_invoice_status()
│		self.validate_duplicate_pos_invoices()
⋮...
│	def validate_duplicate_pos_invoices(self):
⋮...
│	def validate_customer(self):
⋮...
│	def validate_pos_invoice_status(self):
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def process_merging_into_sales_invoice(self, data):
⋮...
│	def process_merging_into_credit_notes(self, data):
⋮...
│	def distinguish_return_pos_invoices(self, data, sales_invoice_doc=None):
⋮...
│	def merge_pos_invoice_into(self, invoice, data):
⋮...
│	def get_new_sales_invoice(self):
⋮...
│	def update_pos_invoices(self, invoice_docs, sales_invoice="", credit_notes=None):
⋮...
│	def serial_and_batch_bundle_reference_for_pos_invoice(self):
│		for d in self.pos_invoices:
│			pos_invoice = frappe.get_doc("POS Invoice", d.pos_invoice)
│			for table_name in ["items", "packed_items"]:
│				pos_invoice.set_serial_and_batch_bundle(table_name)
⋮...
│	def delink_serial_and_batch_bundle(self):
⋮...
│	def get_serial_and_batch_bundles(self):
⋮...
│	def cancel_linked_invoices(self):
⋮...
│def get_all_unconsolidated_invoices():
⋮...
│def get_invoice_customer_map(pos_invoices):
⋮...
│def unconsolidate_pos_invoices(closing_entry):
⋮...
│def split_invoices(invoices):
⋮...
│def check_scheduler_status():
│	if is_scheduler_inactive() and not frappe.flags.in_test:
│		frappe.throw(_("Scheduler is inactive. Cannot enqueue job."), title=_("Scheduler Inactive"))
⋮...
│def get_sales_invoice_item(return_against_pos_invoice, pos_invoice_item):
⋮...

erpnext\stock\doctype\inventory_dimension\inventory_dimension.py:
│def get_inventory_dimensions():
⋮...
│def field_exists(doctype, fieldname) -> str or None:
│	return frappe.db.get_value("DocField", {"parent": doctype, "fieldname": fieldname}, "name")
⋮...
│class DoNotChangeError(frappe.ValidationError):
│	pass
⋮...
│class CanNotBeChildDoc(frappe.ValidationError):
│	pass
⋮...
│class CanNotBeDefaultDimension(frappe.ValidationError):
│	pass
⋮...
│class InventoryDimension(Document):
⋮...
│	def onload(self):
│		if not self.is_new() and frappe.db.has_column("Stock Ledger Entry", self.target_fieldname):
│			self.set_onload("has_stock_ledger", self.has_stock_ledger())
⋮...
│	def has_stock_ledger(self) -> str:
⋮...
│	def validate(self):
│		self.validate_reference_document()
⋮...
│	def before_save(self):
│		self.do_not_update_document()
│		self.reset_value()
│		self.set_source_and_target_fieldname()
│		self.set_type_of_transaction()
│		self.set_fetch_value_from()
⋮...
│	def set_type_of_transaction(self):
│		if self.apply_to_all_doctypes:
│			self.type_of_transaction = "Both"
⋮...
│	def set_fetch_value_from(self):
│		if self.apply_to_all_doctypes:
│			self.fetch_from_parent = self.reference_document
⋮...
│	def do_not_update_document(self):
⋮...
│	def on_trash(self):
│		self.delete_custom_fields()
⋮...
│	def delete_custom_fields(self):
⋮...
│	def reset_value(self):
⋮...
│	def validate_reference_document(self):
⋮...
│	def set_source_and_target_fieldname(self) -> None:
│		if not self.source_fieldname:
│			self.source_fieldname = scrub(self.dimension_name)
│
│		if not self.target_fieldname:
│			self.target_fieldname = scrub(self.reference_document)
⋮...
│	def on_update(self):
│		self.add_custom_fields()
⋮...
│	def get_insert_after_fieldname(doctype):
⋮...
│	def get_dimension_fields(self, doctype=None):
⋮...
│	def add_custom_fields(self):
⋮...
│	def add_transfer_field(self, doctype, dimension_fields):
⋮...
│def get_inventory_documents(
│	doctype=None, txt=None, searchfield=None, start=None, page_len=None, filters=None
│):
⋮...
│def get_evaluated_inventory_dimension(doc, sl_dict, parent_doc=None):
⋮...
│def get_document_wise_inventory_dimensions(doctype) -> dict:
⋮...
│def delete_dimension(dimension):
│	doc = frappe.get_doc("Inventory Dimension", dimension)
│	doc.delete()
⋮...
│def get_parent_fields(child_doctype, dimension_name):
⋮...

erpnext\setup\doctype\department\department.py:
│def get_children(doctype, parent=None, company=None, is_root=False, include_disabled=False):
⋮...
│def add_node():
⋮...
│def on_doctype_update():
│	frappe.db.add_index("Department", ["lft", "rgt"])
⋮...
│def get_abbreviated_name(name, company):
│	abbr = frappe.get_cached_value("Company", company, "abbr")
│	new_name = f"{name} - {abbr}"
│	return new_name
⋮...
│class Department(NestedSet):
⋮...
│	def autoname(self):
│		root = get_root_of("Department")
│		if root and self.department_name != root:
│			self.name = get_abbreviated_name(self.department_name, self.company)
│		else:
│			self.name = self.department_name
⋮...
│	def validate(self):
│		if not self.parent_department:
│			root = get_root_of("Department")
│			if root:
│				self.parent_department = root
⋮...
│	def before_rename(self, old, new, merge=False):
│		# renaming consistency with abbreviation
│		if frappe.get_cached_value("Company", self.company, "abbr") not in new:
│			new = get_abbreviated_name(new, self.company)
│
│		return new
⋮...
│	def on_update(self):
│		if not (frappe.local.flags.ignore_update_nsm or frappe.flags.in_setup_wizard):
│			super().on_update()
⋮...
│	def on_trash(self):
│		super().on_trash()
│		delete_events(self.doctype, self.name)
⋮...

erpnext\controllers\item_variant.py:
│def create_variant(item, args, use_template_image=False):
⋮...
│class InvalidItemAttributeValueError(frappe.ValidationError):
│	pass
⋮...
│def get_variant(template, args=None, variant=None, manufacturer=None, manufacturer_part_no=None):
⋮...
│def copy_attributes_to_variant(item, variant):
⋮...
│def make_variant_item_code(template_item_code, template_item_name, variant):
⋮...
│class ItemVariantExistsError(frappe.ValidationError):
│	pass
⋮...
│def validate_item_variant_attributes(item, args=None):
⋮...
│def validate_is_incremental(numeric_attribute, attribute, value, item):
⋮...
│def validate_item_attribute_value(attributes_list, attribute, attribute_value, item, from_variant=True):
⋮...
│class ItemTemplateCannotHaveStock(frappe.ValidationError):
│	pass
⋮...
│def make_variant_based_on_manufacturer(template, manufacturer, manufacturer_part_no):
⋮...
│def get_attribute_values(item):
⋮...
│def find_variant(template, args, variant_item_code=None):
⋮...
│def enqueue_multiple_variant_creation(item, args, use_template_image=False):
⋮...
│def create_multiple_variants(item, args, use_template_image=False):
⋮...
│def generate_keyed_value_combinations(args):
⋮...
│def create_variant_doc_for_quick_entry(template, args):
⋮...

erpnext\utilities\transaction_base.py:
│class TransactionBase(StatusUpdater):
⋮...
│def validate_uom_is_integer(doc, uom_field, qty_fields, child_dt=None):
⋮...
│def delete_events(ref_type, ref_name):
⋮...
│class UOMMustBeIntegerError(frappe.ValidationError):
│	pass
⋮...
│	def validate_posting_time(self):
⋮...
│	def validate_uom_is_integer(self, uom_field, qty_fields, child_dt=None):
│		validate_uom_is_integer(self, uom_field, qty_fields, child_dt)
⋮...
│	def validate_with_previous_doc(self, ref):
⋮...
│	def compare_values(self, ref_doc, fields, doc=None):
⋮...
│	def get_prev_doc_reference_details(self, reference_names, reference_doctype, fields):
⋮...
│	def validate_rate_with_reference_doc(self, ref_details):
⋮...
│	def get_reference_details(self, reference_names, reference_doctype):
⋮...
│	def get_link_filters(self, for_doctype):
⋮...
│	def reset_default_field_value(self, default_field: str, child_table: str, child_table_field: str):
⋮...
│	def validate_currency_for_receivable_payable_and_advance_account(self):
⋮...
│	def fetch_item_details(self, item: dict) -> dict:
⋮...
│	def process_item_selection(self, item_idx):
⋮...
│	def set_fetched_values(self, item_obj: object, item_details: dict) -> None:
│		for k, v in item_details.items():
│			if hasattr(item_obj, k):
│				setattr(item_obj, k, v)
⋮...
│	def handle_internal_parties(self, item_obj: object, item_details: dict) -> None:
⋮...
│	def add_taxes_from_item_template(self, item_obj: object, item_details: dict) -> None:
⋮...
│	def set_rate_based_on_price_list(self, item_obj: object, item_details: dict) -> None:
│		if item_obj.price_list_rate and item_obj.discount_percentage:
│			item_obj.rate = flt(
│				item_obj.price_list_rate * (1 - item_obj.discount_percentage / 100.0),
│				item_obj.precision("rate"),
│			)
⋮...
│	def copy_from_first_row(self, row, fields):
│		if self.items and row:
│			fields.extend([x.get("fieldname") for x in get_dimensions(True)[0]])
│			first_row = self.items[0]
│			[setattr(row, k, first_row.get(k)) for k in fields if hasattr(first_row, k)]
⋮...
│	def add_free_item(self, item_obj: object, item_details: dict) -> None:
⋮...
│	def conversion_factor(self, item_obj: object, item_details: dict) -> None:
⋮...
│	def calculate_stock_uom_rate(self, item_obj: object) -> None:
│		if item_obj.rate:
│			item_obj.stock_uom_rate = flt(item_obj.rate) / flt(item_obj.conversion_factor)
⋮...
│	def set_item_rate_and_discounts(self, item_obj: object, item_details: dict) -> None:
⋮...
│	def calculate_net_weight(self):
│		self.total_net_weight = sum([x.get("total_weight") or 0 for x in self.items])
│		self.apply_shipping_rule()
⋮...
│	def _apply_price_list(self, item_obj: object, reset_plc_conversion: bool) -> None:
⋮...

erpnext\accounts\doctype\pricing_rule\pricing_rule.py:
│def make_pricing_rule(doctype, docname):
⋮...
│def get_pricing_rule_for_item(args, doc=None, for_validate=False):
⋮...
│def remove_pricing_rule_for_item(pricing_rules, item_details, item_code=None, rate=None):
⋮...
│def set_transaction_type(args):
⋮...
│class PricingRule(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_duplicate_apply_on(self):
⋮...
│	def validate_mandatory(self):
⋮...
│	def validate_applicable_for_selling_or_buying(self):
⋮...
│	def validate_min_max_qty(self):
│		if self.min_qty and self.max_qty and flt(self.min_qty) > flt(self.max_qty):
│			throw(_("Min Qty can not be greater than Max Qty"))
⋮...
│	def validate_min_max_amt(self):
│		if self.min_amt and self.max_amt and flt(self.min_amt) > flt(self.max_amt):
│			throw(_("Min Amt can not be greater than Max Amt"))
⋮...
│	def validate_recursion(self):
⋮...
│	def cleanup_fields_value(self):
⋮...
│	def validate_rate_or_discount(self):
⋮...
│	def validate_max_discount(self):
│		if self.rate_or_discount == "Discount Percentage" and self.get("items"):
│			for d in self.items:
│				max_discount = frappe.get_cached_value("Item", d.item_code, "max_discount")
│				if max_discount and flt(self.discount_percentage) > flt(max_discount):
│					throw(_("Max discount allowed for item: {0} is {1}%").format(d.item_code, max_discount))
⋮...
│	def validate_price_list_with_currency(self):
│		if self.currency and self.for_price_list:
│			price_list_currency = frappe.db.get_value("Price List", self.for_price_list, "currency", True)
│			if self.currency != price_list_currency:
│				throw(_("Currency should be same as Price List Currency: {0}").format(price_list_currency))
⋮...
│	def validate_dates(self):
│		if self.is_cumulative and not (self.valid_from and self.valid_upto):
│			frappe.throw(_("Valid from and valid upto fields are mandatory for the cumulative"))
│
│		self.validate_from_to_dates("valid_from", "valid_upto")
⋮...
│	def validate_condition(self):
⋮...
│	def validate_mixed_with_recursion(self):
│		if self.mixed_conditions and self.is_recursive:
│			frappe.throw(_("Recursive Discounts with Mixed condition is not supported by the system"))
⋮...
│def apply_pricing_rule(args, doc=None):
⋮...
│def update_pricing_rule_uom(pricing_rule, args):
⋮...
│def update_args_for_pricing_rule(args):
⋮...
│def get_pricing_rule_details(args, pricing_rule):
⋮...
│def apply_price_discount_rule(pricing_rule, item_details, args):
⋮...
│def remove_pricing_rules(item_list):
⋮...
│def get_item_uoms(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\subcontracting\doctype\subcontracting_receipt\test_subcontracting_receipt.py:
│def get_items(**args):
⋮...
│def make_return_subcontracting_receipt(**args):
⋮...
│class UnitTestSubcontractingReceipt(UnitTestCase):
⋮...
│class TestSubcontractingReceipt(IntegrationTestCase):
⋮...
│	def setUp(self):
│		make_subcontracted_items()
│		make_raw_materials()
│		make_service_items()
│		make_bom_for_subcontracted_items()
⋮...
│	def test_subcontracting(self):
⋮...
│	def test_available_qty_for_consumption(self):
⋮...
│	def test_subcontracting_gle_fg_item_rate_zero(self):
⋮...
│	def test_subcontracting_over_receipt(self):
⋮...
│	def test_subcontracting_receipt_partial_return(self):
⋮...
│	def test_subcontracting_receipt_over_return(self):
⋮...
│	def test_subcontracting_receipt_no_gl_entry(self):
⋮...
│	def test_subcontracting_receipt_gl_entry(self):
⋮...
│	def test_subcontracting_receipt_with_zero_service_cost(self):
⋮...
│	def test_supplied_items_consumed_qty(self):
⋮...
│	def test_supplied_items_cost_after_reposting(self):
⋮...
│	def test_subcontracting_receipt_for_batch_raw_materials_without_material_transfer(self):
⋮...
│	def test_subcontracting_receipt_valuation_with_auto_created_serial_batch_bundle(self):
⋮...
│	def test_subcontracting_receipt_valuation_for_fg_with_auto_created_serial_batch_bundle(self):
⋮...
│	def test_subcontracting_receipt_raw_material_rate(self):
⋮...
│	def test_quality_inspection_for_subcontracting_receipt(self):
⋮...
│	def test_scrap_items_for_subcontracting_receipt(self):
⋮...
│	def test_subcontracting_receipt_cancel_with_batch(self):
⋮...
│	def test_auto_create_purchase_receipt(self):
⋮...
│	def test_auto_create_purchase_receipt_with_no_reference_of_po_item(self):
⋮...
│	def test_use_serial_batch_fields_for_subcontracting_receipt(self):
⋮...
│	def test_use_serial_batch_fields_for_subcontracting_receipt_with_rejected_qty(self):
⋮...
│	def test_subcontracting_receipt_for_batch_materials_without_use_serial_batch_fields(self):
⋮...
│	def test_change_batch_for_raw_materials(self):
⋮...

erpnext\assets\doctype\asset_capitalization\asset_capitalization.py:
│def get_warehouse_details(args):
⋮...
│def get_consumed_asset_details(ctx):
⋮...
│class AssetCapitalization(StockController):
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		if self.stock_items:
│			self.set_serial_and_batch_bundle(table_name="stock_items")
⋮...
│	def before_submit(self):
│		self.validate_source_mandatory()
│		self.create_target_asset()
⋮...
│	def on_submit(self):
│		self.make_bundle_using_old_serial_batch_fields()
│		self.update_stock_ledger()
│		self.make_gl_entries()
│		self.repost_future_sle_and_gle()
│		self.update_target_asset()
⋮...
│	def on_cancel(self):
⋮...
│	def set_title(self):
│		self.title = self.target_asset_name or self.target_item_name or self.target_item_code
⋮...
│	def set_missing_values(self, for_validate=False):
⋮...
│	def validate_target_item(self):
⋮...
│	def validate_target_asset(self):
⋮...
│	def validate_consumed_stock_item(self):
⋮...
│	def validate_consumed_asset_item(self):
⋮...
│	def validate_service_item(self):
⋮...
│	def validate_source_mandatory(self):
⋮...
│	def validate_item(self, item):
│		from erpnext.stock.doctype.item.item import validate_end_of_life
│
│		validate_end_of_life(item.name, item.end_of_life, item.disabled)
⋮...
│	def get_asset_for_validation(self, asset):
⋮...
│	def set_warehouse_details(self):
│		for d in self.get("stock_items"):
│			if d.item_code and d.warehouse:
│				args = self.get_args_for_incoming_rate(d)
│				warehouse_details = get_warehouse_details(args)
│				d.update(warehouse_details)
⋮...
│	def set_asset_values(self):
⋮...
│	def get_args_for_incoming_rate(self, item):
⋮...
│	def calculate_totals(self):
⋮...
│	def update_stock_ledger(self):
⋮...
│	def make_gl_entries(self, gl_entries=None, from_repost=False):
⋮...
│	def get_gl_entries(self, warehouse_account=None, default_expense_account=None, default_cost_center=None):
⋮...
│	def get_target_account(self):
⋮...
│	def get_gl_entries_for_consumed_stock_items(self, gl_entries, target_account, target_against, precision):
⋮...
│	def get_gl_entries_for_consumed_asset_items(self, gl_entries, target_account, target_against, precision):
⋮...
│	def get_gl_entries_for_consumed_service_items(
│		self, gl_entries, target_account, target_against, precision
│	):
⋮...
│	def get_gl_entries_for_target_item(self, gl_entries, target_account, target_against, precision):
⋮...
│	def create_target_asset(self):
⋮...
│	def update_target_asset(self):
⋮...
│	def restore_consumed_asset_items(self):
⋮...
│	def set_consumed_asset_status(self, asset):
⋮...
│def get_target_item_details(item_code=None, company=None):
⋮...
│def get_target_asset_details(asset=None, company=None):
⋮...
│def get_consumed_stock_item_details(ctx: ItemDetailsCtx):
⋮...
│def get_service_item_details(ctx):
⋮...
│def get_items_tagged_to_wip_composite_asset(params):
⋮...
│def process_stock_item(d):
⋮...
│def process_fixed_asset(d):
⋮...

erpnext\stock\doctype\stock_reservation_entry\test_stock_reservation_entry.py:
│def create_items() -> dict:
⋮...
│def create_material_receipt(
│	items: dict, warehouse: str = "_Test Warehouse - _TC", qty: float = 100
⋮...
│def make_stock_reservation_entry(**args):
⋮...
│def cancel_all_stock_reservation_entries() -> None:
│	sre_list = frappe.db.get_all("Stock Reservation Entry", filters={"docstatus": 1}, pluck="name")
│
│	for sre in sre_list:
│		frappe.get_doc("Stock Reservation Entry", sre).cancel()
⋮...
│class UnitTestStockReservationEntry(UnitTestCase):
⋮...
│class TestStockReservationEntry(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
│		self.warehouse = "_Test Warehouse - _TC"
│		self.sr_item = make_item(properties={"is_stock_item": 1, "valuation_rate": 100})
│		create_material_receipt(items={self.sr_item.name: self.sr_item}, warehouse=self.warehouse, qty=100)
⋮...
│	def test_validate_stock_reservation_settings(self) -> None:
⋮...
│	def test_get_available_qty_to_reserve(self) -> None:
⋮...
│	def test_update_status(self) -> None:
⋮...
│	def test_update_reserved_qty_in_voucher(self) -> None:
⋮...
│	def test_cant_consume_reserved_stock(self) -> None:
⋮...
│	def test_stock_reservation_against_sales_order(self) -> None:
⋮...
│	def test_auto_reserve_serial_and_batch(self) -> None:
⋮...
│	def test_stock_reservation_from_pick_list(self) -> None:
⋮...
│	def test_stock_reservation_from_purchase_receipt(self) -> None:
⋮...
│	def test_consider_reserved_stock_while_cancelling_an_inward_transaction(self) -> None:
⋮...
│	def tearDown(self) -> None:
│		cancel_all_stock_reservation_entries()
│		return super().tearDown()
⋮...

erpnext\controllers\selling_controller.py:
│class SellingController(StockController):
⋮...
│def set_default_income_account_for_item(obj):
│	for d in obj.get("items"):
│		if d.item_code:
│			if getattr(d, "income_account", None):
│				set_item_default(d.item_code, obj.company, "income_account", d.income_account)
⋮...
│def get_serial_and_batch_bundle(child, parent, delivery_note_child=None):
⋮...
│	def __setup__(self):
│		self.flags.ignore_permlevel_for_fields = ["selling_price_list", "price_list_currency"]
⋮...
│	def onload(self):
⋮...
│	def validate(self):
⋮...
│	def set_missing_values(self, for_validate=False):
│		super().set_missing_values(for_validate)
│
│		# set contact and address details for customer, if they are not mentioned
│		self.set_missing_lead_customer_details(for_validate=for_validate)
│		self.set_price_list_and_item_details(for_validate=for_validate)
⋮...
│	def set_missing_lead_customer_details(self, for_validate=False):
⋮...
│	def set_price_list_and_item_details(self, for_validate=False):
│		self.set_price_list_currency("Selling")
│		self.set_missing_item_details(for_validate=for_validate)
⋮...
│	def remove_shipping_charge(self):
⋮...
│	def set_total_in_words(self):
⋮...
│	def calculate_commission(self):
⋮...
│	def calculate_contribution(self):
⋮...
│	def validate_sales_team(self, sales_team):
⋮...
│	def validate_max_discount(self):
⋮...
│	def set_qty_as_per_stock_uom(self):
⋮...
│	def validate_selling_price(self):
⋮...
│	def get_item_list(self):
⋮...
│	def has_product_bundle(self, item_code):
⋮...
│	def _fetch_product_bundle_items(self, item_code):
⋮...
│	def get_already_delivered_qty(self, current_docname, so, so_detail):
⋮...
│	def get_so_qty_and_warehouse(self, so_detail):
⋮...
│	def check_sales_order_on_hold_or_close(self, ref_fieldname):
│		for d in self.get("items"):
│			if d.get(ref_fieldname):
│				status = frappe.db.get_value("Sales Order", d.get(ref_fieldname), "status")
│				if status in ("Closed", "On Hold") and not self.is_return:
│					frappe.throw(_("Sales Order {0} is {1}").format(d.get(ref_fieldname), status))
⋮...
│	def update_reserved_qty(self):
⋮...
│	def set_incoming_rate(self):
⋮...
│	def update_stock_ledger(self, allow_negative_stock=False):
⋮...
│	def get_sle_for_source_warehouse(self, item_row):
⋮...
│	def get_sle_for_target_warehouse(self, item_row):
⋮...
│	def set_po_nos(self, for_validate=False):
⋮...
│	def set_pos_for_sales_invoice(self):
⋮...
│	def set_pos_for_delivery_note(self):
⋮...
│	def get_po_nos(self, ref_doctype, ref_fieldname, po_nos):
⋮...
│	def set_gross_profit(self):
⋮...
│	def set_customer_address(self):
⋮...
│	def validate_for_duplicate_items(self):
⋮...
│	def validate_target_warehouse(self):
⋮...
│	def validate_items(self):
│		# validate items to see if they have is_sales_item enabled
│		from erpnext.controllers.buying_controller import validate_item_type
│
│		validate_item_type(self, "is_sales_item", "sales")
⋮...
│	def update_stock_reservation_entries(self) -> None:
⋮...

erpnext\accounts\doctype\tax_rule\test_tax_rule.py:
│def make_tax_rule(**args):
⋮...
│class TestTaxRule(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		frappe.db.set_single_value("Shopping Cart Settings", "enabled", 0)
⋮...
│	def tearDownClass(cls):
│		frappe.db.sql("delete from `tabTax Rule`")
⋮...
│	def setUp(self):
│		frappe.db.sql("delete from `tabTax Rule`")
⋮...
│	def test_conflict(self):
⋮...
│	def test_conflict_with_non_overlapping_dates(self):
⋮...
│	def test_for_parent_customer_group(self):
⋮...
│	def test_conflict_with_overlapping_dates(self):
⋮...
│	def test_tax_template(self):
│		tax_rule = make_tax_rule()
│		self.assertEqual(tax_rule.purchase_tax_template, None)
⋮...
│	def test_select_tax_rule_based_on_customer(self):
⋮...
│	def test_select_tax_rule_based_on_tax_category(self):
⋮...
│	def test_select_tax_rule_based_on_better_match(self):
⋮...
│	def test_select_tax_rule_based_on_state_match(self):
⋮...
│	def test_select_tax_rule_based_on_better_priority(self):
⋮...
│	def test_select_tax_rule_based_cross_matching_keys(self):
⋮...
│	def test_select_tax_rule_based_cross_partially_keys(self):
⋮...
│	def test_taxes_fetch_via_tax_rule(self):
⋮...

erpnext\accounts\doctype\subscription\subscription.py:
│def get_prorata_factor(
│	period_end: DateTimeLikeObject,
⋮...
│class InvoiceCancelled(frappe.ValidationError):
│	pass
⋮...
│class InvoiceNotCancelled(frappe.ValidationError):
│	pass
⋮...
│class Subscription(Document):
⋮...
│	def before_insert(self):
│		# update start just before the subscription doc is created
│		self.update_subscription_period(self.start_date)
⋮...
│	def update_subscription_period(self, date: DateTimeLikeObject | None = None):
⋮...
│	def _get_subscription_period(self, date: DateTimeLikeObject | None = None):
│		_current_invoice_start = self.get_current_invoice_start(date)
│		_current_invoice_end = self.get_current_invoice_end(_current_invoice_start)
│
│		return _current_invoice_start, _current_invoice_end
⋮...
│	def get_current_invoice_start(self, date: DateTimeLikeObject | None = None) -> DateTimeLikeObject:
⋮...
│	def get_current_invoice_end(self, date: DateTimeLikeObject | None = None) -> DateTimeLikeObject:
⋮...
│	def validate_plans_billing_cycle(billing_cycle_data: list[dict[str, str]]) -> None:
⋮...
│	def get_billing_cycle_and_interval(self) -> list[dict[str, str]]:
⋮...
│	def get_billing_cycle_data(self) -> dict[str, int]:
⋮...
│	def set_subscription_status(self, posting_date: DateTimeLikeObject | None = None) -> None:
⋮...
│	def is_trialling(self) -> bool:
│		"""
│		Returns `True` if the `Subscription` is in trial period.
│		"""
│		return not self.period_has_passed(self.trial_period_end)
⋮...
│	def period_has_passed(
│		end_date: DateTimeLikeObject, posting_date: DateTimeLikeObject | None = None
⋮...
│	def get_status_for_past_grace_period(self) -> str:
⋮...
│	def is_past_grace_period(self, posting_date: DateTimeLikeObject | None = None) -> bool:
⋮...
│	def current_invoice_is_past_due(self, posting_date: DateTimeLikeObject | None = None) -> bool:
⋮...
│	def invoice_document_type(self) -> str:
│		return "Sales Invoice" if self.party_type == "Customer" else "Purchase Invoice"
⋮...
│	def validate(self) -> None:
⋮...
│	def validate_party_billing_currency(self):
⋮...
│	def validate_trial_period(self) -> None:
⋮...
│	def validate_end_date(self) -> None:
⋮...
│	def validate_to_follow_calendar_months(self) -> None:
⋮...
│	def generate_invoice(
│		self,
│		from_date: DateTimeLikeObject | None = None,
⋮...
│	def create_invoice(
│		self,
│		from_date: DateTimeLikeObject | None = None,
⋮...
│	def get_items_from_plans(self, plans: list[dict[str, str]], prorate: bool | None = None) -> list[dict]:
⋮...
│	def process(self, posting_date: DateTimeLikeObject | None = None) -> bool:
⋮...
│	def can_generate_new_invoice(self, posting_date: DateTimeLikeObject | None = None) -> bool:
⋮...
│	def is_current_invoice_generated(
│		self,
│		_current_start_date: DateTimeLikeObject | None = None,
⋮...
│	def current_invoice(self) -> Document | None:
│		"""
│		Adds property for accessing the current_invoice
│		"""
│		return self.get_current_invoice()
⋮...
│	def get_current_invoice(self) -> Document | None:
⋮...
│	def cancel_subscription_at_period_end(self) -> None:
│		"""
│		Called when `Subscription.cancel_at_period_end` is truthy
│		"""
│		self.status = "Cancelled"
│		self.cancelation_date = nowdate()
⋮...
│	def invoices(self) -> list[dict]:
│		return frappe.get_all(
│			self.invoice_document_type,
│			filters={"subscription": self.name},
│			order_by="from_date asc",
│		)
⋮...
│	def is_paid(invoice: Document) -> bool:
│		"""
│		Return `True` if the given invoice is paid
│		"""
│		return invoice.status == "Paid"
⋮...
│	def has_outstanding_invoice(self) -> int:
⋮...
│	def cancel_subscription(self) -> None:
⋮...
│	def restart_subscription(self, posting_date: DateTimeLikeObject | None = None) -> None:
⋮...
│	def force_fetch_subscription_updates(self):
⋮...
│def is_prorate() -> int:
│	return cint(frappe.db.get_single_value("Subscription Settings", "prorate"))
⋮...
│def process_all(subscription: str | None = None, posting_date: DateTimeLikeObject | None = None) -> None:
⋮...

erpnext\stock\tests\test_valuation.py:
│class TestFIFOValuation(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.queue = FIFOValuation([])
⋮...
│	def tearDown(self):
│		qty, value = self.queue.get_total_stock_and_value()
│		self.assertTotalQty(qty)
│		self.assertTotalValue(value)
⋮...
│	def assertTotalQty(self, qty):
│		self.assertAlmostEqual(sum(q for q, _ in self.queue), qty, msg=f"queue: {self.queue}", places=4)
⋮...
│	def assertTotalValue(self, value):
│		self.assertAlmostEqual(sum(q * r for q, r in self.queue), value, msg=f"queue: {self.queue}", places=2)
⋮...
│	def test_simple_addition(self):
│		self.queue.add_stock(1, 10)
│		self.assertTotalQty(1)
⋮...
│	def test_simple_removal(self):
│		self.queue.add_stock(1, 10)
│		self.queue.remove_stock(1)
│		self.assertTotalQty(0)
⋮...
│	def test_merge_new_stock(self):
│		self.queue.add_stock(1, 10)
│		self.queue.add_stock(1, 10)
│		self.assertEqual(self.queue, [[2, 10]])
⋮...
│	def test_adding_negative_stock_keeps_rate(self):
│		self.queue = FIFOValuation([[-5.0, 100]])
│		self.queue.add_stock(1, 10)
│		self.assertEqual(self.queue, [[-4, 100]])
⋮...
│	def test_adding_negative_stock_updates_rate(self):
│		self.queue = FIFOValuation([[-5.0, 100]])
│		self.queue.add_stock(6, 10)
│		self.assertEqual(self.queue, [[1, 10]])
⋮...
│	def test_negative_stock(self):
⋮...
│	def test_removing_specified_rate(self):
│		self.queue.add_stock(1, 10)
│		self.queue.add_stock(1, 20)
│
│		self.queue.remove_stock(1, 20)
│		self.assertEqual(self.queue, [[1, 10]])
⋮...
│	def test_remove_multiple_bins(self):
⋮...
│	def test_remove_multiple_bins_with_rate(self):
⋮...
│	def test_queue_with_unknown_rate(self):
⋮...
│	def test_rounding_off(self):
│		self.queue.add_stock(1.0, 1.0)
│		self.queue.remove_stock(1.0 - 1e-9)
│		self.assertTotalQty(0)
⋮...
│	def test_rounding_off_near_zero(self):
│		self.assertEqual(round_off_if_near_zero(0), 0)
│		self.assertEqual(round_off_if_near_zero(1), 1)
│		self.assertEqual(round_off_if_near_zero(-1), -1)
│		self.assertEqual(round_off_if_near_zero(-1e-8), 0)
│		self.assertEqual(round_off_if_near_zero(1e-8), 0)
⋮...
│	def test_totals(self):
⋮...
│	def test_fifo_qty_hypothesis(self, stock_queue):
⋮...
│	def test_fifo_qty_value_nonneg_hypothesis(self, stock_queue):
⋮...
│	def test_fifo_qty_value_nonneg_hypothesis_with_outgoing_rate(self, stock_queue, outgoing_rate):
⋮...
│class TestLIFOValuation(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.stack = LIFOValuation([])
⋮...
│	def tearDown(self):
│		qty, value = self.stack.get_total_stock_and_value()
│		self.assertTotalQty(qty)
│		self.assertTotalValue(value)
⋮...
│	def assertTotalQty(self, qty):
│		self.assertAlmostEqual(sum(q for q, _ in self.stack), qty, msg=f"stack: {self.stack}", places=4)
⋮...
│	def assertTotalValue(self, value):
│		self.assertAlmostEqual(sum(q * r for q, r in self.stack), value, msg=f"stack: {self.stack}", places=2)
⋮...
│	def test_simple_addition(self):
│		self.stack.add_stock(1, 10)
│		self.assertTotalQty(1)
⋮...
│	def test_merge_new_stock(self):
│		self.stack.add_stock(1, 10)
│		self.stack.add_stock(1, 10)
│		self.assertEqual(self.stack, [[2, 10]])
⋮...
│	def test_simple_removal(self):
│		self.stack.add_stock(1, 10)
│		self.stack.remove_stock(1)
│		self.assertTotalQty(0)
⋮...
│	def test_adding_negative_stock_keeps_rate(self):
│		self.stack = LIFOValuation([[-5.0, 100]])
│		self.stack.add_stock(1, 10)
│		self.assertEqual(self.stack, [[-4, 100]])
⋮...
│	def test_adding_negative_stock_updates_rate(self):
│		self.stack = LIFOValuation([[-5.0, 100]])
│		self.stack.add_stock(6, 10)
│		self.assertEqual(self.stack, [[1, 10]])
⋮...
│	def test_rounding_off(self):
│		self.stack.add_stock(1.0, 1.0)
│		self.stack.remove_stock(1.0 - 1e-9)
│		self.assertTotalQty(0)
⋮...
│	def test_lifo_consumption(self):
│		self.stack.add_stock(10, 10)
│		self.stack.add_stock(10, 20)
│		consumed = self.stack.remove_stock(15)
│		self.assertEqual(consumed, [[10, 20], [5, 10]])
│		self.assertTotalQty(5)
⋮...
│	def test_lifo_consumption_going_negative(self):
│		self.stack.add_stock(10, 10)
│		self.stack.add_stock(10, 20)
│		consumed = self.stack.remove_stock(25)
│		self.assertEqual(consumed, [[10, 20], [10, 10], [5, 10]])
│		self.assertTotalQty(-5)
⋮...
│	def test_lifo_consumption_multiple(self):
⋮...
│	def test_lifo_qty_hypothesis(self, stock_stack):
⋮...
│	def test_lifo_qty_value_nonneg_hypothesis(self, stock_stack):
⋮...
│class TestLIFOValuationSLE(IntegrationTestCase):
⋮...
│	def setUpClass(cls) -> None:
│		super().setUpClass()
│		make_item(cls.ITEM_CODE, {"valuation_method": "LIFO"})
⋮...
│	def _make_stock_entry(self, qty, rate=None):
⋮...
│	def assertStockQueue(self, se, expected_queue):
⋮...
│	def test_lifo_values(self):
⋮...

erpnext\setup\doctype\transaction_deletion_record\transaction_deletion_record.py:
│def get_doctypes_to_be_ignored():
⋮...
│def is_deletion_doc_running(company: str | None = None, err_msg: str | None = None):
⋮...
│class TransactionDeletionRecord(Document):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def validate(self):
│		frappe.only_for("System Manager")
│		self.validate_doctypes_to_be_ignored()
⋮...
│	def validate_doctypes_to_be_ignored(self):
⋮...
│	def generate_job_name_for_task(self, task=None):
│		method = self.task_to_internal_method_map[task]
│		return f"{self.name}_{method}"
⋮...
│	def generate_job_name_for_next_tasks(self, task=None):
⋮...
│	def generate_job_name_for_all_tasks(self):
│		job_names = []
│		for task in self.task_to_internal_method_map.keys():
│			job_names.append(self.generate_job_name_for_task(task))
│		return job_names
⋮...
│	def before_submit(self):
⋮...
│	def reset_task_flags(self):
⋮...
│	def before_save(self):
│		self.status = ""
│		self.doctypes.clear()
│		self.reset_task_flags()
⋮...
│	def on_submit(self):
│		self.db_set("status", "Queued")
⋮...
│	def on_cancel(self):
│		self.db_set("status", "Cancelled")
⋮...
│	def enqueue_task(self, task: str | None = None):
⋮...
│	def execute_task(self, task_to_execute: str | None = None):
⋮...
│	def delete_notifications(self):
│		self.validate_doc_status()
│		if not self.clear_notifications:
│			clear_notifications()
│			self.db_set("clear_notifications", 1)
│		self.enqueue_task(task="Initialize Summary Table")
⋮...
│	def populate_doctypes_to_be_ignored_table(self):
│		doctypes_to_be_ignored_list = get_doctypes_to_be_ignored()
│		for doctype in doctypes_to_be_ignored_list:
│			self.append("doctypes_to_be_ignored", {"doctype_name": doctype})
⋮...
│	def validate_running_task_for_doc(self, job_names: list | None = None):
⋮...
│	def validate_doc_status(self):
⋮...
│	def start_deletion_tasks(self):
│		# This method is the entry point for the chain of events that follow
│		self.db_set("status", "Running")
│		self.enqueue_task(task="Delete Bins")
⋮...
│	def delete_bins(self):
⋮...
│	def delete_lead_addresses(self):
⋮...
│	def reset_company_values(self):
⋮...
│	def initialize_doctypes_to_be_deleted_table(self):
⋮...
│	def delete_company_transactions(self):
⋮...
│	def get_doctypes_to_be_ignored_list(self):
⋮...
│	def get_doctypes_with_company_field(self, doctypes_to_be_ignored_list):
⋮...
│	def get_all_child_doctypes(self):
│		return frappe.get_all("DocType", filters={"istable": 1}, pluck="name")
⋮...
│	def get_number_of_docs_linked_with_specified_company(self, doctype, company_fieldname):
│		return frappe.db.count(doctype, {company_fieldname: self.company})
⋮...
│	def populate_doctypes_table(self, tables, doctype, fieldname, no_of_docs):
⋮...
│	def delete_child_tables(self, doctype, reference_doc_names):
⋮...
│	def delete_docs_linked_with_specified_company(self, doctype, reference_doc_names):
│		frappe.db.delete(doctype, {"name": ("in", reference_doc_names)})
⋮...
│	def update_naming_series(self, naming_series, doctype_name):
⋮...
│	def delete_version_log(self, doctype, docnames):
│		versions = qb.DocType("Version")
│		qb.from_(versions).delete().where(
│			(versions.ref_doctype == doctype) & (versions.docname.isin(docnames))
│		).run()
⋮...
│	def delete_communications(self, doctype, reference_doc_names):
⋮...
│	def delete_comments(self, doctype, reference_doc_names):
│		if reference_doc_names:
│			comment = qb.DocType("Comment")
│			qb.from_(comment).delete().where(
│				(comment.reference_doctype == doctype) & (comment.reference_name.isin(reference_doc_names))
│			).run()
⋮...
│	def unlink_attachments(self, doctype, reference_doc_names):
⋮...
│def check_for_running_deletion_job(doc, method=None):
⋮...

erpnext\stock\doctype\landed_cost_voucher\test_landed_cost_voucher.py:
│def create_landed_cost_voucher(receipt_document_type, receipt_document, company, charges=50):
⋮...
│def make_landed_cost_voucher(**args):
⋮...
│def distribute_landed_cost_on_items(lcv):
⋮...
│class UnitTestLandedCostVoucher(UnitTestCase):
⋮...
│class TestLandedCostVoucher(IntegrationTestCase):
⋮...
│	def test_landed_cost_voucher(self):
⋮...
│	def assertPurchaseReceiptLCVGLEntries(self, pr):
⋮...
│	def test_landed_cost_voucher_stock_impact(self):
⋮...
│	def test_landed_cost_voucher_for_zero_purchase_rate(self):
⋮...
│	def test_landed_cost_voucher_against_purchase_invoice(self):
⋮...
│	def test_landed_cost_voucher_for_serialized_item(self):
⋮...
│	def test_serialized_lcv_delivered(self):
⋮...
│	def test_landed_cost_voucher_for_odd_numbers(self):
⋮...
│	def test_multiple_landed_cost_voucher_against_pr(self):
⋮...
│	def test_multi_currency_lcv(self):
⋮...
│	def test_asset_lcv(self):
⋮...
│	def test_landed_cost_voucher_with_serial_batch_for_legacy_pr(self):
⋮...
│	def test_do_not_validate_landed_cost_voucher_with_serial_batch_for_legacy_pr(self):
⋮...
│	def test_do_not_validate_against_landed_cost_voucher_for_serial_for_legacy_pr(self):
⋮...

erpnext\stock\doctype\stock_ledger_entry\stock_ledger_entry.py:
│def on_doctype_update():
│	frappe.db.add_index("Stock Ledger Entry", ["voucher_no", "voucher_type"])
│	frappe.db.add_index("Stock Ledger Entry", ["batch_no", "item_code", "warehouse"])
│	frappe.db.add_index("Stock Ledger Entry", ["warehouse", "item_code"], "item_warehouse")
│	frappe.db.add_index("Stock Ledger Entry", ["posting_datetime", "creation"])
⋮...
│class StockFreezeError(frappe.ValidationError):
│	pass
⋮...
│class InventoryDimensionNegativeStockError(frappe.ValidationError):
│	pass
⋮...
│class BackDatedStockTransaction(frappe.ValidationError):
│	pass
⋮...
│class StockLedgerEntry(Document):
⋮...
│	def autoname(self):
⋮...
│	def validate(self):
⋮...
│	def set_posting_datetime(self):
│		from erpnext.stock.utils import get_combine_datetime
│
│		self.posting_datetime = get_combine_datetime(self.posting_date, self.posting_time)
⋮...
│	def validate_inventory_dimension_negative_stock(self):
⋮...
│	def get_available_qty_after_prev_transaction(self, dimension, dimension_value):
⋮...
│	def throw_validation_error(self, diff, dimension, dimension_value):
⋮...
│	def _get_inventory_dimensions(self):
⋮...
│	def on_submit(self):
⋮...
│	def validate_mandatory(self):
⋮...
│	def validate_serial_batch_no_bundle(self):
⋮...
│	def throw_error_message(self, message, exception=frappe.ValidationError):
│		frappe.throw(_(message), exception)
⋮...
│	def check_stock_frozen_date(self):
⋮...
│	def scrub_posting_time(self):
│		if not self.posting_time or self.posting_time == "00:0":
│			self.posting_time = "00:00"
⋮...
│	def validate_batch(self):
⋮...
│	def validate_and_set_fiscal_year(self):
⋮...
│	def block_transactions_against_group_warehouse(self):
│		from erpnext.stock.utils import is_group_warehouse
│
│		is_group_warehouse(self.warehouse)
⋮...
│	def validate_with_last_transaction_posting_time(self):
⋮...
│	def on_cancel(self):
│		msg = _("Individual Stock Ledger Entry cannot be cancelled.")
│		msg += "<br>" + _("Please cancel related transaction.")
│		frappe.throw(msg)
⋮...

erpnext\stock\doctype\packed_item\packed_item.py:
│def on_doctype_update():
│	frappe.db.add_index("Packed Item", ["item_code", "warehouse"])
⋮...
│def make_packing_list(doc):
⋮...
│class PackedItem(Document):
⋮...
│def is_product_bundle(item_code: str) -> bool:
│	return bool(frappe.db.exists("Product Bundle", {"new_item_code": item_code, "disabled": 0}))
⋮...
│def get_product_bundle_items(item_code):
⋮...
│	def set_actual_and_projected_qty(self):
⋮...
│def get_indexed_packed_items_table(doc):
⋮...
│def reset_packing_list(doc):
⋮...
│def add_packed_item_row(doc, packing_item, main_item_row, packed_items_table, reset):
⋮...
│def get_packed_item_details(item_code, company):
⋮...
│def update_packed_item_basic_data(main_item_row, pi_row, packing_item, item_data):
⋮...
│def update_packed_item_stock_data(main_item_row, pi_row, packing_item, item_data, doc):
⋮...
│def update_packed_item_price_data(pi_row, item_data, doc):
⋮...
│def update_packed_item_from_cancelled_doc(main_item_row, packing_item, pi_row, doc):
⋮...
│def get_packed_item_bin_qty(item, warehouse):
⋮...
│def get_cancelled_doc_packed_item_details(old_packed_items):
│	prev_doc_packed_items_map = {}
│	for items in old_packed_items:
│		prev_doc_packed_items_map.setdefault((items.item_code, items.parent_item), []).append(items.as_dict())
│	return prev_doc_packed_items_map
⋮...
│def update_product_bundle_rate(parent_items_price, pi_row, item_row):
⋮...
│def set_product_bundle_rate_amount(doc, parent_items_price):
⋮...
│def get_items_from_product_bundle(row):
⋮...

erpnext\manufacturing\doctype\blanket_order\blanket_order.py:
│def make_order(source_name):
⋮...
│def validate_against_blanket_order(order_doc):
⋮...
│class BlanketOrder(Document):
⋮...
│	def validate(self):
│		self.validate_dates()
│		self.validate_duplicate_items()
│		self.validate_item_qty()
│		self.set_party_item_code()
⋮...
│	def validate_dates(self):
│		if getdate(self.from_date) > getdate(self.to_date):
│			frappe.throw(_("From date cannot be greater than To date"))
⋮...
│	def set_party_item_code(self):
⋮...
│	def get_customer_items_ref(self):
⋮...
│	def get_supplier_items_ref(self):
⋮...
│	def validate_duplicate_items(self):
│		item_list = []
│		for item in self.items:
│			if item.item_code in item_list:
│				frappe.throw(_("Note: Item {0} added multiple times").format(frappe.bold(item.item_code)))
│			item_list.append(item.item_code)
⋮...
│	def update_ordered_qty(self):
⋮...
│	def validate_item_qty(self):
│		for d in self.items:
│			if d.qty < 0:
│				frappe.throw(_("Row {0}: Quantity cannot be negative.").format(d.idx))
⋮...

erpnext\accounts\doctype\payment_reconciliation\payment_reconciliation.py:
│class PaymentReconciliation(Document):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		self.common_filter_conditions = []
│		self.accounting_dimension_filter_conditions = []
│		self.ple_posting_date_filter = []
│		self.dimensions = get_dimensions()[0]
⋮...
│	def load_from_db(self):
⋮...
│	def save(self):
│		return
⋮...
│	def get_list(args):
│		pass
⋮...
│	def get_count(args):
│		pass
⋮...
│	def get_stats(args):
│		pass
⋮...
│	def db_insert(self, *args, **kwargs):
│		pass
⋮...
│	def db_update(self, *args, **kwargs):
│		pass
⋮...
│	def delete(self):
│		pass
⋮...
│	def get_unreconciled_entries(self):
│		self.get_nonreconciled_payment_entries()
│		self.get_invoice_entries()
⋮...
│	def get_nonreconciled_payment_entries(self):
⋮...
│	def get_payment_entries(self):
⋮...
│	def get_jv_entries(self):
⋮...
│	def get_return_invoices(self):
⋮...
│	def get_dr_or_cr_notes(self):
⋮...
│	def add_payment_entries(self, non_reconciled_payments):
⋮...
│	def get_invoice_entries(self):
⋮...
│	def add_invoice_entries(self, non_reconciled_invoices):
⋮...
│	def get_difference_amount(self, payment_entry, invoice, allocated_amount):
⋮...
│	def is_auto_process_enabled(self):
│		return frappe.db.get_single_value("Accounts Settings", "auto_reconcile_payments")
⋮...
│	def calculate_difference_on_allocation_change(self, payment_entry, invoice, allocated_amount):
⋮...
│	def allocate_entries(self, args):
⋮...
│	def update_dimension_values_in_allocated_entries(self, res):
│		for x in self.dimensions:
│			dimension = x.fieldname
│			if self.get(dimension):
│				res[dimension] = self.get(dimension)
│		return res
⋮...
│	def get_allocated_entry(self, pay, inv, allocated_amount):
⋮...
│	def reconcile_allocations(self, skip_ref_details_update_for_pe=False):
⋮...
│	def reconcile(self):
⋮...
│	def get_payment_details(self, row, dr_or_cr):
⋮...
│	def check_mandatory_to_fetch(self):
│		for fieldname in ["company", "party_type", "party", "receivable_payable_account"]:
│			if not self.get(fieldname):
│				frappe.throw(_("Please select {0} first").format(self.meta.get_label(fieldname)))
⋮...
│	def validate_entries(self):
│		if not self.get("invoices"):
│			frappe.throw(_("No records found in the Invoices table"))
│
│		if not self.get("payments"):
│			frappe.throw(_("No records found in the Payments table"))
⋮...
│	def get_invoice_exchange_map(self, invoices, payments):
⋮...
│	def validate_allocation(self):
⋮...
│	def build_dimensions_filter_conditions(self):
│		ple = qb.DocType("Payment Ledger Entry")
│		for x in self.dimensions:
│			dimension = x.fieldname
│			if self.get(dimension):
│				self.accounting_dimension_filter_conditions.append(ple[dimension] == self.get(dimension))
⋮...
│	def build_qb_filter_conditions(self, get_invoices=False, get_return_invoices=False):
⋮...
│	def get_journal_filter_conditions(self):
⋮...
│def reconcile_dr_cr_note(dr_cr_notes, company, active_dimensions=None):
⋮...
│def adjust_allocations_for_taxes(doc):
│	pass
⋮...
│def get_queries_for_dimension_filters(company: str | None = None):
⋮...

erpnext\selling\doctype\customer\test_customer.py:
│def create_internal_customer(customer_name=None, represents_company=None, allowed_to_interact_with=None):
⋮...
│def get_customer_dict(customer_name):
⋮...
│def set_credit_limit(customer, company, credit_limit):
⋮...
│class UnitTestCustomer(UnitTestCase):
⋮...
│class TestCustomer(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		set_credit_limit("_Test Customer", "_Test Company", 0)
⋮...
│	def test_get_customer_group_details(self):
⋮...
│	def test_party_details(self):
⋮...
│	def test_party_details_tax_category(self):
⋮...
│	def test_rename(self):
⋮...
│	def test_freezed_customer(self):
⋮...
│	def test_delete_customer_contact(self):
⋮...
│	def test_disabled_customer(self):
⋮...
│	def test_duplicate_customer(self):
⋮...
│	def get_customer_outstanding_amount(self):
⋮...
│	def test_customer_credit_limit(self):
⋮...
│	def test_customer_credit_limit_after_submit(self):
⋮...
│	def test_customer_credit_limit_on_change(self):
⋮...
│	def test_customer_payment_terms(self):
⋮...
│	def test_parse_full_name(self):
⋮...

erpnext\accounts\doctype\opening_invoice_creation_tool\test_opening_invoice_creation_tool.py:
│def make_customer(customer=None):
⋮...
│def make_company():
⋮...
│class UnitTestOpeningInvoiceCreationTool(UnitTestCase):
⋮...
│class TestOpeningInvoiceCreationTool(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		if not frappe.db.exists("Company", "_Test Opening Invoice Company"):
│			make_company()
│		create_dimension()
│		return super().setUpClass()
⋮...
│	def make_invoices(
│		self,
│		invoice_type="Sales",
│		company=None,
│		party_1=None,
│		party_2=None,
│		invoice_number=None,
│		department=None,
│	):
⋮...
│	def test_opening_sales_invoice_creation(self):
⋮...
│	def check_expected_values(self, invoices, expected_value, invoice_type="Sales"):
⋮...
│	def test_opening_purchase_invoice_creation(self):
⋮...
│	def test_opening_sales_invoice_creation_with_missing_debit_account(self):
⋮...
│	def test_renaming_of_invoice_using_invoice_number_field(self):
⋮...
│	def test_opening_invoice_with_accounting_dimension(self):
⋮...
│	def tearDown(self):
│		disable_dimension()
⋮...
│def get_opening_invoice_creation_dict(**args):
⋮...

erpnext\accounts\doctype\tax_rule\tax_rule.py:
│def get_party_details(party, party_type, args=None):
⋮...
│def get_tax_template(posting_date, args):
⋮...
│class ConflictingTaxRule(frappe.ValidationError):
│	pass
⋮...
│class IncorrectCustomerGroup(frappe.ValidationError):
│	pass
⋮...
│class IncorrectSupplierType(frappe.ValidationError):
│	pass
⋮...
│class TaxRule(Document):
⋮...
│	def validate(self):
│		self.validate_tax_template()
│		self.validate_from_to_dates("from_date", "to_date")
│		self.validate_filters()
⋮...
│	def validate_tax_template(self):
⋮...
│	def validate_filters(self):
⋮...
│def get_customer_group_condition(customer_group):
│	condition = ""
│	customer_groups = ["%s" % (frappe.db.escape(d.name)) for d in get_parent_customer_groups(customer_group)]
│	if customer_groups:
│		condition = ",".join(["%s"] * len(customer_groups)) % (tuple(customer_groups))
│	return condition
⋮...

erpnext\stock\doctype\putaway_rule\test_putaway_rule.py:
│def create_putaway_rule(**args):
⋮...
│class UnitTestPutawayRule(UnitTestCase):
⋮...
│class TestPutawayRule(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def assertUnchangedItemsOnResave(self, doc):
⋮...
│	def test_putaway_rules_priority(self):
⋮...
│	def test_putaway_rules_with_same_priority(self):
⋮...
│	def test_putaway_rules_with_insufficient_capacity(self):
⋮...
│	def test_putaway_rules_multi_uom(self):
⋮...
│	def test_putaway_rules_multi_uom_whole_uom(self):
⋮...
│	def test_putaway_rules_with_reoccurring_item(self):
⋮...
│	def test_validate_over_receipt_in_warehouse(self):
⋮...
│	def test_putaway_rule_on_stock_entry_material_transfer(self):
⋮...
│	def test_putaway_rule_on_stock_entry_material_transfer_reoccuring_item(self):
⋮...
│	def test_putaway_rule_on_stock_entry_material_transfer_batch_serial_item(self):
⋮...
│	def test_putaway_rule_on_stock_entry_material_receipt(self):
⋮...
│	def test_warehouse_capacity_dashbord(self):
⋮...

erpnext\accounts\doctype\budget\test_budget.py:
│def make_budget(**args):
⋮...
│def set_total_expense_zero(posting_date, budget_against_field=None, budget_against_CC=None):
⋮...
│class TestBudget(IntegrationTestCase):
⋮...
│	def test_monthly_budget_crossed_ignore(self):
⋮...
│	def test_monthly_budget_crossed_stop1(self):
⋮...
│	def test_exception_approver_role(self):
⋮...
│	def test_monthly_budget_crossed_for_mr(self):
⋮...
│	def test_monthly_budget_crossed_for_po(self):
⋮...
│	def test_monthly_budget_crossed_stop2(self):
⋮...
│	def test_yearly_budget_crossed_stop1(self):
⋮...
│	def test_yearly_budget_crossed_stop2(self):
⋮...
│	def test_monthly_budget_on_cancellation1(self):
⋮...
│	def test_monthly_budget_on_cancellation2(self):
⋮...
│	def test_monthly_budget_against_group_cost_center(self):
⋮...
│	def test_monthly_budget_against_parent_group_cost_center(self):
⋮...
│	def test_monthly_budget_against_main_cost_center(self):
⋮...

erpnext\assets\doctype\asset_repair\test_asset_repair.py:
│def create_asset_repair(**args):
⋮...
│def num_of_depreciations(asset):
│	return asset.finance_books[0].total_number_of_depreciations
⋮...
│class TestAssetRepair(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		set_depreciation_settings_in_company()
│		create_asset_data()
│		create_item("_Test Stock Item")
│		frappe.db.sql("delete from `tabTax Rule`")
⋮...
│	def test_update_status(self):
⋮...
│	def test_stock_item_total_value(self):
│		asset_repair = create_asset_repair(stock_consumption=1)
│
│		for item in asset_repair.stock_items:
│			total_value = flt(item.valuation_rate) * flt(item.consumed_quantity)
│			self.assertEqual(item.total_value, total_value)
⋮...
│	def test_total_repair_cost(self):
⋮...
│	def test_repair_status_after_submit(self):
│		asset_repair = create_asset_repair(submit=1)
│		self.assertNotEqual(asset_repair.repair_status, "Pending")
⋮...
│	def test_stock_items(self):
│		asset_repair = create_asset_repair(stock_consumption=1)
│		self.assertTrue(asset_repair.stock_consumption)
│		self.assertTrue(asset_repair.stock_items)
⋮...
│	def test_warehouse(self):
│		asset_repair = create_asset_repair(stock_consumption=1)
│		self.assertTrue(asset_repair.stock_consumption)
│		self.assertTrue(asset_repair.stock_items[0].warehouse)
⋮...
│	def test_decrease_stock_quantity(self):
⋮...
│	def test_serialized_item_consumption(self):
⋮...
│	def test_no_increase_in_asset_value_when_not_capitalized(self):
⋮...
│	def test_increase_in_asset_value_due_to_repair_cost_capitalisation(self):
⋮...
│	def test_purchase_invoice(self):
│		asset_repair = create_asset_repair(capitalize_repair_cost=1, item="_Test Non Stock Item", submit=1)
│		self.assertTrue(asset_repair.invoices)
⋮...
│	def test_gl_entries_with_perpetual_inventory(self):
⋮...
│	def test_gl_entries_with_periodical_inventory(self):
⋮...
│	def test_increase_in_asset_life(self):
⋮...
│	def test_asset_repiar_link_in_stock_entry(self):
│		asset = create_asset(calculate_depreciation=1, submit=1)
│		asset_repair = create_asset_repair(asset=asset, stock_consumption=1, submit=1)
│		stock_entry = frappe.get_last_doc("Stock Entry")
│		self.assertEqual(stock_entry.asset_repair, asset_repair.name)
⋮...

erpnext\accounts\doctype\gl_entry\gl_entry.py:
│def on_doctype_update():
│	frappe.db.add_index("GL Entry", ["voucher_type", "voucher_no"])
│	frappe.db.add_index("GL Entry", ["posting_date", "company"])
│	frappe.db.add_index("GL Entry", ["party_type", "party"])
⋮...
│def rename_gle_sle_docs():
│	for doctype in ["GL Entry", "Stock Ledger Entry"]:
│		rename_temporarily_named_docs(doctype)
⋮...
│def validate_balance_type(account, adv_adj=False):
⋮...
│def validate_frozen_account(account, adv_adj=None):
⋮...
│class GLEntry(Document):
⋮...
│	def autoname(self):
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
⋮...
│	def check_mandatory(self):
⋮...
│	def pl_must_have_cost_center(self):
⋮...
│	def validate_dimensions_for_pl_and_bs(self):
⋮...
│	def check_pl_account(self):
⋮...
│	def validate_account_details(self, adv_adj):
⋮...
│	def validate_cost_center(self):
⋮...
│	def validate_party(self):
│		validate_party_frozen_disabled(self.party_type, self.party)
│		validate_account_party_type(self)
⋮...
│	def validate_currency(self):
⋮...
│	def validate_and_set_fiscal_year(self):
│		if not self.fiscal_year:
│			self.fiscal_year = get_fiscal_year(self.posting_date, company=self.company)[0]
⋮...
│	def on_cancel(self):
│		msg = _("Individual GL Entry cannot be cancelled.")
│		msg += "<br>" + _("Please cancel related transaction.")
│		frappe.throw(msg)
⋮...
│def update_outstanding_amt(
│	account, party_type, party, against_voucher_type, against_voucher, on_cancel=False
│):
⋮...
│def update_against_account(voucher_type, voucher_no):
⋮...
│def rename_temporarily_named_docs(doctype):
⋮...

erpnext\accounts\doctype\period_closing_voucher\period_closing_voucher.py:
│def process_gl_and_closing_entries(doc):
⋮...
│def process_cancellation(voucher_type, voucher_no):
⋮...
│def get_previous_closed_period_in_current_year(fiscal_year, company):
⋮...
│class PeriodClosingVoucher(AccountsController):
⋮...
│	def validate(self):
│		self.validate_start_and_end_date()
│		self.check_if_previous_year_closed()
│		self.block_if_future_closing_voucher_exists()
│		self.check_closing_account_type()
│		self.check_closing_account_currency()
⋮...
│	def validate_start_and_end_date(self):
⋮...
│	def check_if_previous_year_closed(self):
⋮...
│	def block_if_future_closing_voucher_exists(self):
⋮...
│	def get_future_closing_voucher(self):
│		return frappe.db.get_value(
│			"Period Closing Voucher",
│			{"period_end_date": (">", self.period_end_date), "docstatus": 1, "company": self.company},
│			"name",
│		)
⋮...
│	def check_closing_account_type(self):
⋮...
│	def check_closing_account_currency(self):
│		account_currency = get_account_currency(self.closing_account_head)
│		company_currency = frappe.get_cached_value("Company", self.company, "default_currency")
│		if account_currency != company_currency:
│			frappe.throw(_("Currency of the Closing Account must be {0}").format(company_currency))
⋮...
│	def on_submit(self):
│		self.db_set("gle_processing_status", "In Progress")
│		self.make_gl_entries()
⋮...
│	def on_cancel(self):
│		self.ignore_linked_doctypes = ("GL Entry", "Stock Ledger Entry", "Payment Ledger Entry")
│		self.block_if_future_closing_voucher_exists()
│		self.db_set("gle_processing_status", "In Progress")
│		self.cancel_gl_entries()
⋮...
│	def make_gl_entries(self):
⋮...
│	def get_pcv_gl_entries(self):
⋮...
│	def get_gle_for_pl_account(self, acc, balances, dimensions):
⋮...
│	def get_gle_for_closing_account(self, dimension_balance, dimensions):
⋮...
│	def update_default_dimensions(self, gl_entry, dimensions):
│		for i, dimension in enumerate(self.accounting_dimension_fields):
│			gl_entry[dimension] = dimensions[i]
⋮...
│	def get_account_balances_based_on_dimensions(self, report_type):
⋮...
│	def get_accounting_dimension_fields(self):
│		default_dimensions = ["cost_center", "finance_book", "project"]
│		self.accounting_dimension_fields = default_dimensions + get_accounting_dimensions()
⋮...
│	def get_gl_entries_for_current_period(self, report_type, only_opening_entries=False, as_iterator=False):
⋮...
│	def set_account_balance_dict(self, gle, acc_bal_dict):
⋮...
│	def get_key(self, gle):
│		return tuple([gle.get(dimension) for dimension in self.accounting_dimension_fields])
⋮...
│	def get_account_closing_balances(self):
│		pl_closing_entries = self.get_closing_entries_for_pl_accounts()
│		bs_closing_entries = self.get_closing_entries_for_balance_sheet_accounts()
│		closing_entries_for_closing_account = self.get_closing_entries_for_closing_account()
│		closing_entries = pl_closing_entries + bs_closing_entries + closing_entries_for_closing_account
│		return closing_entries
⋮...
│	def get_closing_entries_for_pl_accounts(self):
⋮...
│	def get_closing_entries_for_balance_sheet_accounts(self):
⋮...
│	def get_closing_entry(self, account, balances, dimensions):
⋮...
│	def get_closing_entries_for_closing_account(self):
│		closing_entries = copy.deepcopy(self.closing_account_gle)
│		for d in closing_entries:
│			d.period_closing_voucher = self.name
│
│		return closing_entries
⋮...
│	def is_first_period_closing_voucher(self):
⋮...
│	def cancel_gl_entries(self):
⋮...
│	def get_gle_count_against_current_pcv(self):
│		return frappe.db.count(
│			"GL Entry",
│			{"voucher_type": "Period Closing Voucher", "voucher_no": self.name, "is_cancelled": 0},
│		)
⋮...
│def delete_closing_entries(voucher_no):
│	closing_balance = frappe.qb.DocType("Account Closing Balance")
│	frappe.qb.from_(closing_balance).delete().where(
│		closing_balance.period_closing_voucher == voucher_no
│	).run()
⋮...
│def get_period_start_end_date(fiscal_year, company):
⋮...

erpnext\stock\doctype\bin\bin.py:
│def get_bin_details(bin_name):
⋮...
│def on_doctype_update():
│	frappe.db.add_unique("Bin", ["item_code", "warehouse"], constraint_name="unique_item_warehouse")
⋮...
│def update_qty(bin_name, args):
⋮...
│def get_actual_qty(item_code, warehouse):
⋮...
│class Bin(Document):
⋮...
│	def recalculate_qty(self):
⋮...
│	def before_save(self):
│		if self.get("__islocal") or not self.stock_uom:
│			self.stock_uom = frappe.get_cached_value("Item", self.item_code, "stock_uom")
│		self.set_projected_qty()
⋮...
│	def set_projected_qty(self):
⋮...
│	def update_reserved_qty_for_production_plan(self, skip_project_qty_update=False, update_qty=True):
⋮...
│	def update_reserved_qty_for_for_sub_assembly(self):
⋮...
│	def update_reserved_qty_for_production(self):
⋮...
│	def update_reserved_qty_for_sub_contracting(
│		self, subcontract_doctype="Subcontracting Order", update_qty=True
│	):
⋮...
│	def update_reserved_stock(self):
⋮...

erpnext\stock\doctype\batch\test_batch.py:
│def create_batch(item_code, rate, create_item_price_for_batch):
⋮...
│class TestBatch(IntegrationTestCase):
⋮...
│	def make_batch_item(cls, item_name=None):
│		from erpnext.stock.doctype.item.test_item import make_item
│
│		if not frappe.db.exists(item_name):
│			return make_item(item_name, dict(has_batch_no=1, create_new_batch=1, is_stock_item=1))
⋮...
│def make_new_batch(**args):
⋮...
│def create_price_list_for_batch(item_code, batch, rate):
⋮...
│class UnitTestBatch(UnitTestCase):
⋮...
│	def test_item_has_batch_enabled(self):
│		self.assertRaises(
│			ValidationError,
│			frappe.get_doc({"doctype": "Batch", "name": "_test Batch", "item": "_Test Item"}).save,
│		)
⋮...
│	def test_purchase_receipt(self, batch_qty=100):
⋮...
│	def test_batch_stock_levels(self, batch_qty=100):
⋮...
│	def test_stock_entry_incoming(self):
⋮...
│	def test_delivery_note(self):
⋮...
│	def test_batch_negative_stock_error(self):
⋮...
│	def test_stock_entry_outgoing(self):
⋮...
│	def test_batch_split(self):
⋮...
│	def test_get_batch_qty(self):
⋮...
│	def test_total_batch_qty(self):
⋮...
│	def make_new_batch_and_entry(cls, item_name, batch_name, warehouse):
⋮...
│	def test_batch_name_with_naming_series(self):
⋮...
│	def make_new_batch(self, item_name=None, batch_id=None, do_not_insert=0):
⋮...
│	def test_batch_wise_item_price(self):
⋮...
│	def test_basic_batch_wise_valuation(self, batch_qty=100):
⋮...
│	def test_update_batch_properties(self):
⋮...
│	def test_autocreation_of_batches(self):
⋮...

erpnext\crm\report\sales_pipeline_analytics\test_sales_pipeline_analytics.py:
│def create_customer():
│	doc = frappe.db.exists("Customer", "_Test NC")
│	if not doc:
│		doc = frappe.new_doc("Customer")
│		doc.customer_name = "_Test NC"
│		doc.insert()
⋮...
│def create_company():
⋮...
│def create_opportunity():
⋮...
│class TestSalesPipelineAnalytics(IntegrationTestCase):
⋮...
│	def setUp(self):
│		create_company()
│		create_customer()
│		create_opportunity()
⋮...
│	def test_sales_pipeline_analytics(self):
⋮...
│	def check_for_monthly_and_number(self):
⋮...
│	def check_for_monthly_and_amount(self):
⋮...
│	def check_for_quarterly_and_number(self):
⋮...
│	def check_for_quarterly_and_amount(self):
⋮...
│	def check_for_all_filters(self):
⋮...

erpnext\accounts\doctype\process_statement_of_accounts\process_statement_of_accounts.py:
│def get_context(customer, doc):
⋮...
│def get_statement_dict(doc, get_statement_dict=False):
⋮...
│def get_report_pdf(doc, consolidated=True):
⋮...
│def send_emails(document_name, from_scheduler=False, posting_date=None):
⋮...
│class ProcessStatementOfAccounts(Document):
⋮...
│	def validate(self):
⋮...
│def set_ageing(doc, entry):
⋮...
│def get_common_filters(doc):
⋮...
│def get_gl_filters(doc, entry, tax_id, presentation_currency):
⋮...
│def get_ar_filters(doc, entry):
⋮...
│def get_html(doc, filters, entry, col, res, ageing):
⋮...
│def get_customers_based_on_territory_or_customer_group(customer_collection, collection_name):
⋮...
│def get_customers_based_on_sales_person(sales_person):
⋮...
│def get_recipients_and_cc(customer, doc):
⋮...
│def fetch_customers(customer_collection, collection_name, primary_mandatory):
⋮...
│def get_customer_emails(customer_name, primary_mandatory, billing_and_primary=True):
⋮...
│def download_statements(document_name):
⋮...
│def send_auto_email():
⋮...

erpnext\assets\doctype\asset_repair\asset_repair.py:
│class AssetRepair(AccountsController):
⋮...
│def expense_item_pi_query(company):
⋮...
│	def validate(self):
⋮...
│	def validate_dates(self):
│		if self.completion_date and (self.failure_date > self.completion_date):
│			frappe.throw(
│				_("Completion Date can not be before Failure Date. Please adjust the dates accordingly.")
│			)
⋮...
│	def validate_purchase_invoice(self):
│		query = expense_item_pi_query(self.company)
│		purchase_invoice_list = [item[0] for item in query.run()]
│		for pi in self.invoices:
│			if pi.purchase_invoice not in purchase_invoice_list:
│				frappe.throw(_("Expense item not present in Purchase Invoice"))
⋮...
│	def validate_purchase_invoice_repair_cost(self):
│		for pi in self.invoices:
│			if flt(pi.repair_cost) > frappe.db.get_value(
│				"Purchase Invoice", pi.purchase_invoice, "base_net_total"
│			):
│				frappe.throw(_("Repair cost cannot be greater than purchase invoice base net total"))
⋮...
│	def validate_purchase_invoice_expense_account(self):
⋮...
│	def update_status(self):
⋮...
│	def set_stock_items_cost(self):
│		for item in self.get("stock_items"):
│			item.total_value = flt(item.valuation_rate) * flt(item.consumed_quantity)
⋮...
│	def calculate_repair_cost(self):
│		self.repair_cost = sum(flt(pi.repair_cost) for pi in self.invoices)
⋮...
│	def calculate_total_repair_cost(self):
│		self.total_repair_cost = flt(self.repair_cost)
│
│		total_value_of_stock_consumed = self.get_total_value_of_stock_consumed()
│		self.total_repair_cost += total_value_of_stock_consumed
⋮...
│	def before_submit(self):
⋮...
│	def before_cancel(self):
⋮...
│	def after_delete(self):
│		frappe.get_doc("Asset", self.asset).set_status()
⋮...
│	def check_repair_status(self):
│		if self.repair_status == "Pending":
│			frappe.throw(_("Please update Repair Status."))
⋮...
│	def check_for_stock_items_and_warehouse(self):
│		if not self.get("stock_items"):
│			frappe.throw(_("Please enter Stock Items consumed during the Repair."), title=_("Missing Items"))
⋮...
│	def increase_asset_value(self):
⋮...
│	def decrease_asset_value(self):
⋮...
│	def get_total_value_of_stock_consumed(self):
⋮...
│	def decrease_stock_quantity(self):
⋮...
│	def validate_serial_no(self, stock_item):
⋮...
│	def make_gl_entries(self, cancel=False):
│		if flt(self.total_repair_cost) > 0:
│			gl_entries = self.get_gl_entries()
│			make_gl_entries(gl_entries, cancel)
⋮...
│	def get_gl_entries(self):
⋮...
│	def get_gl_entries_for_repair_cost(self, gl_entries, fixed_asset_account):
⋮...
│	def get_gl_entries_for_consumed_items(self, gl_entries, fixed_asset_account):
⋮...
│	def modify_depreciation_schedule(self):
⋮...
│	def calculate_last_schedule_date(self, asset, row, extra_months):
⋮...
│	def revert_depreciation_schedule_on_cancellation(self):
⋮...
│	def calculate_last_schedule_date_before_modification(self, asset, row, extra_months):
⋮...
│def get_downtime(failure_date, completion_date):
│	downtime = time_diff_in_hours(completion_date, failure_date)
│	return round(downtime, 2)
⋮...
│def get_purchase_invoice(doctype, txt, searchfield, start, page_len, filters):
│	query = expense_item_pi_query(filters.get("company"))
│	return query.run(as_list=1)
⋮...

erpnext\accounts\doctype\bank_reconciliation_tool\bank_reconciliation_tool.py:
│def reconcile_vouchers(bank_transaction_name, vouchers):
⋮...
│def get_linked_payments(
│	bank_transaction_name,
│	document_types=None,
│	from_date=None,
│	to_date=None,
│	filter_by_reference_date=None,
│	from_reference_date=None,
│	to_reference_date=None,
│):
⋮...
│def get_bank_transactions(bank_account, from_date=None, to_date=None):
⋮...
│class BankReconciliationTool(Document):
⋮...
│def get_account_balance(bank_account, till_date, company):
⋮...
│def update_bank_transaction(bank_transaction_name, reference_number, party_type=None, party=None):
⋮...
│def create_journal_entry_bts(
│	bank_transaction_name,
│	reference_number=None,
│	reference_date=None,
│	posting_date=None,
│	entry_type=None,
│	second_account=None,
│	mode_of_payment=None,
│	party_type=None,
│	party=None,
│	allow_edit=None,
│):
⋮...
│def create_payment_entry_bts(
│	bank_transaction_name,
│	reference_number=None,
│	reference_date=None,
│	party_type=None,
│	party=None,
│	posting_date=None,
│	mode_of_payment=None,
│	project=None,
│	cost_center=None,
│	allow_edit=None,
│):
⋮...
│def auto_reconcile_vouchers(
│	bank_account,
│	from_date=None,
│	to_date=None,
│	filter_by_reference_date=None,
│	from_reference_date=None,
│	to_reference_date=None,
│):
⋮...
│def start_auto_reconcile(
│	bank_transactions, from_date, to_date, filter_by_reference_date, from_reference_date, to_reference_date
│):
⋮...
│def get_auto_reconcile_message(partially_reconciled, reconciled):
⋮...
│def subtract_allocations(gl_account, vouchers):
⋮...
│def get_allocated_amount(voucher_allocated_amounts, voucher, gl_account):
⋮...
│def check_matching(
│	bank_account,
│	company,
│	transaction,
│	document_types=None,
│	from_date=None,
│	to_date=None,
│	filter_by_reference_date=None,
│	from_reference_date=None,
│	to_reference_date=None,
│):
⋮...
│def get_queries(
│	bank_account,
│	company,
│	transaction,
│	document_types=None,
│	from_date=None,
│	to_date=None,
│	filter_by_reference_date=None,
│	from_reference_date=None,
│	to_reference_date=None,
│	exact_match=None,
│	common_filters=None,
│):
⋮...
│def get_matching_queries(
│	bank_account,
│	company,
│	transaction,
│	document_types=None,
│	exact_match=None,
│	account_from_to=None,
│	from_date=None,
│	to_date=None,
│	filter_by_reference_date=None,
│	from_reference_date=None,
│	to_reference_date=None,
│	common_filters=None,
│):
⋮...
│def get_bt_matching_query(exact_match, transaction):
⋮...
│def get_pe_matching_query(
│	exact_match,
│	account_from_to,
│	transaction,
│	from_date,
│	to_date,
│	filter_by_reference_date,
│	from_reference_date,
│	to_reference_date,
│	common_filters,
│):
⋮...
│def get_je_matching_query(
│	exact_match,
│	transaction,
│	from_date,
│	to_date,
│	filter_by_reference_date,
│	from_reference_date,
│	to_reference_date,
│	common_filters,
│):
⋮...
│def get_si_matching_query(exact_match, currency, common_filters):
⋮...
│def get_pi_matching_query(exact_match, currency, common_filters):
⋮...

erpnext\accounts\deferred_revenue.py:
│def make_gl_entries(
│	doc,
│	credit_account,
│	debit_account,
│	against,
│	amount,
│	base_amount,
│	posting_date,
│	project,
│	account_currency,
│	cost_center,
│	item,
│	deferred_process=None,
│):
⋮...
│def get_already_booked_amount(doc, item):
⋮...
│def send_mail(deferred_process):
⋮...
│def validate_service_stop_date(doc):
⋮...
│def book_deferred_income_or_expense(doc, deferred_process, posting_date=None):
⋮...
│def process_deferred_accounting(posting_date=None):
⋮...
│def build_conditions(process_type, account, company):
⋮...
│def convert_deferred_expense_to_expense(deferred_process, start_date=None, end_date=None, conditions=""):
⋮...
│def convert_deferred_revenue_to_income(deferred_process, start_date=None, end_date=None, conditions=""):
⋮...
│def get_booking_dates(doc, item, posting_date=None, prev_posting_date=None):
⋮...
│def calculate_monthly_amount(
│	doc, item, last_gl_entry, start_date, end_date, total_days, total_booking_days, account_currency
│):
⋮...
│def calculate_amount(doc, item, last_gl_entry, total_days, total_booking_days, account_currency):
⋮...
│def book_revenue_via_journal_entry(
│	doc,
│	credit_account,
│	debit_account,
│	amount,
│	base_amount,
│	posting_date,
│	project,
│	account_currency,
│	cost_center,
│	item,
│	deferred_process=None,
│	submit="No",
│):
⋮...
│def get_deferred_booking_accounts(doctype, voucher_detail_no, dr_or_cr):
⋮...

erpnext\stock\doctype\delivery_trip\delivery_trip.py:
│def get_attachments(delivery_stop):
⋮...
│def get_default_address(out, name):
⋮...
│def get_default_contact(out, name):
⋮...
│class DeliveryTrip(Document):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		self.update_delivery_notes()
⋮...
│	def on_trash(self):
│		self.update_delivery_notes(delete=True)
⋮...
│	def on_submit(self):
│		self.update_status()
⋮...
│	def on_update_after_submit(self):
│		self.update_status()
⋮...
│	def on_cancel(self):
│		self.update_status()
│		self.update_delivery_notes(delete=True)
⋮...
│	def validate_stop_addresses(self):
│		for stop in self.delivery_stops:
│			if not stop.customer_address:
│				stop.customer_address = get_address_display(frappe.get_doc("Address", stop.address).as_dict())
⋮...
│	def validate_delivery_note_not_draft(self):
⋮...
│	def update_status(self):
⋮...
│	def update_delivery_notes(self, delete=False):
⋮...
│	def process_route(self, optimize):
⋮...
│	def form_route_list(self, optimize):
⋮...
│	def rearrange_stops(self, optimized_order, start):
⋮...
│	def get_directions(self, route, optimize):
⋮...
│def get_contact_and_address(name):
⋮...
│def get_contact_display(contact):
⋮...
│def sanitize_address(address):
⋮...
│def notify_customers(delivery_trip):
⋮...
│def get_driver_email(driver):
│	employee = frappe.db.get_value("Driver", driver, "employee")
│	email = frappe.db.get_value("Employee", employee, "prefered_email")
│	return {"email": email}
⋮...

erpnext\accounts\test\accounts_mixin.py:
│class AccountsTestMixin:
⋮...
│	def create_customer(self, customer_name="_Test Customer", currency=None):
⋮...
│	def create_supplier(self, supplier_name="_Test Supplier", currency=None):
⋮...
│	def create_item(self, item_name="_Test Item", is_stock=0, warehouse=None, company=None, valuation_rate=0):
⋮...
│	def create_company(self, company_name="_Test Company", abbr="_TC"):
⋮...
│	def enable_advance_as_liability(self):
│		company = frappe.get_doc("Company", self.company)
│		company.book_advance_payments_in_separate_party_account = True
│		company.default_advance_received_account = self.advance_received
│		company.default_advance_paid_account = self.advance_paid
│		company.save()
⋮...
│	def disable_advance_as_liability(self):
│		company = frappe.get_doc("Company", self.company)
│		company.book_advance_payments_in_separate_party_account = False
│		company.default_advance_paid_account = company.default_advance_received_account = None
│		company.save()
⋮...
│	def identify_default_warehouses(self):
│		for w in frappe.db.get_all(
│			"Warehouse", filters={"company": self.company}, fields=["name", "warehouse_name"]
│		):
│			setattr(self, "warehouse_" + w.warehouse_name.lower().strip().replace(" ", "_"), w.name)
⋮...
│	def create_usd_receivable_account(self):
⋮...
│	def create_usd_payable_account(self):
⋮...
│	def clear_old_entries(self):
⋮...
│	def create_price_list(self):
⋮...

erpnext\www\book_appointment\index.py:
│def get_context(context):
⋮...
│def _deltatime_to_datetime(date, deltatime):
│	time = (datetime.datetime.min + deltatime).time()
│	return datetime.datetime.combine(date.date(), time)
⋮...
│def convert_to_system_timezone(guest_tz, datetimeobject):
│	guest_tz = zoneinfo.ZoneInfo(guest_tz)
│	datetimeobject = datetimeobject.replace(tzinfo=guest_tz)
│	system_tz = zoneinfo.ZoneInfo(get_system_timezone())
│	datetimeobject = datetimeobject.astimezone(system_tz)
│	return datetimeobject
⋮...
│def convert_to_guest_timezone(guest_tz, datetimeobject):
│	guest_tz = zoneinfo.ZoneInfo(guest_tz)
│	local_timezone = zoneinfo.ZoneInfo(get_system_timezone())
│	datetimeobject = datetimeobject.replace(tzinfo=local_timezone)
│	datetimeobject = datetimeobject.astimezone(guest_tz)
│	return datetimeobject
⋮...
│def get_appointment_settings():
⋮...
│def get_timezones():
│	return zoneinfo.available_timezones()
⋮...
│def get_appointment_slots(date, timezone):
⋮...
│def get_available_slots_between(query_start_time, query_end_time, settings):
⋮...
│def create_appointment(date, time, tz, contact):
⋮...
│def filter_timeslots(date, timeslots):
│	filtered_timeslots = []
│	for timeslot in timeslots:
│		if timeslot["time"].date() == date:
│			filtered_timeslots.append(timeslot)
│	return filtered_timeslots
⋮...
│def check_availabilty(timeslot, settings):
│	return frappe.db.count("Appointment", {"scheduled_time": timeslot}) < settings.number_of_agents
⋮...
│def _is_holiday(date, holiday_list):
│	for holiday in holiday_list.holidays:
│		if holiday.holiday_date == date:
│			return True
│	return False
⋮...
│def _get_records(start_time, end_time, settings):
⋮...
│def _datetime_to_deltatime(date_time):
│	midnight = datetime.datetime.combine(date_time.date(), datetime.time.min)
│	return date_time - midnight
⋮...

erpnext\accounts\report\sales_payment_summary\test_sales_payment_summary.py:
│def get_filters():
│	return {"from_date": "1900-01-01", "to_date": today(), "company": "_Test Company"}
⋮...
│def create_sales_invoice_record(qty=1):
⋮...
│def create_records():
⋮...
│class TestSalesPaymentSummary(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
⋮...
│	def test_get_mode_of_payments(self):
⋮...
│	def test_get_mode_of_payments_details(self):
⋮...

erpnext\crm\doctype\opportunity\test_opportunity.py:
│def create_communication(reference_doctype, reference_name, sender, sent_or_received=None, creation=None):
⋮...
│def make_opportunity(**args):
⋮...
│class TestOpportunity(IntegrationTestCase):
⋮...
│	def test_opportunity_status(self):
⋮...
│	def test_make_new_lead_if_required(self):
⋮...
│	def test_opportunity_item(self):
│		opportunity_doc = make_opportunity(with_items=1, rate=1100, qty=2)
│		self.assertEqual(opportunity_doc.total, 2200)
⋮...
│	def test_carry_forward_of_email_and_comments(self):
⋮...
│def make_opportunity_from_lead():
⋮...

erpnext\stock\doctype\quality_inspection\quality_inspection.py:
│def item_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def parse_float(num: str) -> float:
⋮...
│class QualityInspection(Document):
⋮...
│	def validate(self):
⋮...
│	def set_company(self):
│		if self.reference_type and self.reference_name:
│			company = frappe.get_cached_value(self.reference_type, self.reference_name, "company")
│			if company != self.company:
│				self.company = company
⋮...
│	def set_child_row_reference(self):
⋮...
│	def distribute_child_row_reference(self, child_row_references):
⋮...
│	def validate_inspection_required(self):
⋮...
│	def before_submit(self):
│		self.validate_readings_status_mandatory()
⋮...
│	def get_item_specification_details(self):
⋮...
│	def get_quality_inspection_template(self):
⋮...
│	def on_update(self):
│		if (
│			frappe.db.get_single_value("Stock Settings", "action_if_quality_inspection_is_not_submitted")
│			== "Warn"
│		):
│			self.update_qc_reference()
⋮...
│	def on_submit(self):
│		if (
│			frappe.db.get_single_value("Stock Settings", "action_if_quality_inspection_is_not_submitted")
│			== "Stop"
│		):
│			self.update_qc_reference()
⋮...
│	def on_cancel(self):
│		self.ignore_linked_doctypes = "Serial and Batch Bundle"
│
│		self.update_qc_reference()
⋮...
│	def on_trash(self):
│		self.update_qc_reference(remove_reference=True)
⋮...
│	def validate_readings_status_mandatory(self):
│		for reading in self.readings:
│			if not reading.status:
│				frappe.throw(_("Row #{0}: Status is mandatory").format(reading.idx))
⋮...
│	def update_qc_reference(self, remove_reference=False):
⋮...
│	def inspect_and_set_status(self):
⋮...
│	def set_status_based_on_acceptance_values(self, reading):
⋮...
│	def min_max_criteria_passed(self, reading):
⋮...
│	def set_status_based_on_acceptance_formula(self, reading):
⋮...
│	def get_formula_evaluation_data(self, reading):
⋮...
│	def calculate_mean(self, reading):
⋮...
│def quality_inspection_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def make_quality_inspection(source_name, target_doc=None):
⋮...

erpnext\accounts\doctype\chart_of_accounts_importer\chart_of_accounts_importer.py:
│def generate_data_from_csv(file_doc, as_dict=False):
⋮...
│def generate_data_from_excel(file_doc, extension, as_dict=False):
⋮...
│def get_root_types():
│	return ("Asset", "Liability", "Expense", "Income", "Equity")
⋮...
│def get_file(file_name):
⋮...
│def build_forest(data):
⋮...
│class ChartofAccountsImporter(Document):
⋮...
│	def validate(self):
│		if self.import_file:
│			get_coa("Chart of Accounts Importer", "All Accounts", file_name=self.import_file, for_validate=1)
⋮...
│def validate_columns(data):
⋮...
│def validate_company(company):
⋮...
│def import_coa(file_name, company):
⋮...
│def get_coa(doctype, parent, is_root=False, file_name=None, for_validate=0):
⋮...
│def build_response_as_excel(writer):
⋮...
│def download_template(file_type, template_type, company):
⋮...
│def get_template(template_type, company):
⋮...
│def get_sample_template(writer, company):
⋮...
│def validate_accounts(file_doc, extension):
⋮...
│def validate_root(accounts):
⋮...
│def validate_missing_roots(roots):
⋮...
│def get_report_type(root_type):
│	if root_type in ("Asset", "Liability", "Equity"):
│		return "Balance Sheet"
│	else:
│		return "Profit and Loss"
⋮...
│def get_mandatory_group_accounts():
│	return ("Bank", "Cash", "Stock")
⋮...
│def get_mandatory_account_types():
⋮...
│def unset_existing_data(company):
⋮...
│def set_default_accounts(company):
⋮...

erpnext\accounts\doctype\loyalty_program\test_loyalty_program.py:
│def create_sales_invoice_record(qty=1):
⋮...
│def create_records():
⋮...
│def get_points_earned(self):
⋮...
│class TestLoyaltyProgram(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		# create relevant item, customer, loyalty program, etc
│		create_records()
⋮...
│	def test_loyalty_points_earned_single_tier(self):
⋮...
│	def test_loyalty_points_earned_multiple_tier(self):
⋮...
│	def test_cancel_sales_invoice(self):
⋮...
│	def test_sales_invoice_return(self):
⋮...
│	def test_loyalty_points_for_dashboard(self):
│		doc = frappe.get_doc("Customer", "Test Loyalty Customer")
│		company_wise_info = get_dashboard_info("Customer", doc.name, doc.loyalty_program)
│
│		for d in company_wise_info:
│			self.assertTrue(d.get("loyalty_points"))
⋮...
│	def test_tier_selection(self, mock_get_loyalty_details):
⋮...

erpnext\setup\doctype\sales_person\sales_person.py:
│def on_doctype_update():
│	frappe.db.add_index("Sales Person", ["lft", "rgt"])
⋮...
│def get_timeline_data(doctype: str, name: str) -> dict[int, int]:
⋮...
│class SalesPerson(NestedSet):
⋮...
│	def validate(self):
⋮...
│	def onload(self):
│		self.load_dashboard_info()
⋮...
│	def load_dashboard_info(self):
⋮...
│	def on_update(self):
│		super().on_update()
│		self.validate_one_root()
⋮...
│	def validate_sales_person(self):
⋮...
│	def get_email_id(self):
⋮...
│	def validate_employee_id(self):
⋮...

erpnext\accounts\doctype\cost_center\test_cost_center.py:
│def create_cost_center(**args):
⋮...
│class TestCostCenter(IntegrationTestCase):
⋮...
│	def test_cost_center_creation_against_child_node(self):
⋮...

erpnext\stock\doctype\pick_list\test_pick_list.py:
│class UnitTestPickList(UnitTestCase):
⋮...
│class TestPickList(IntegrationTestCase):
⋮...
│	def test_pick_list_picks_warehouse_for_each_item(self):
⋮...
│	def test_pick_list_splits_row_according_to_warehouse_availability(self):
⋮...
│	def test_pick_list_shows_serial_no_for_serialized_item(self):
⋮...
│	def test_pick_list_shows_batch_no_for_batched_item(self):
⋮...
│	def test_pick_list_for_batched_and_serialised_item(self):
⋮...
│	def test_pick_list_for_items_from_multiple_sales_orders(self):
⋮...
│	def test_pick_list_for_items_with_multiple_UOM(self):
⋮...
│	def test_pick_list_grouping_before_print(self):
⋮...
│	def test_multiple_dn_creation(self):
⋮...
│	def test_picklist_with_multi_uom(self):
⋮...
│	def test_picklist_for_batch_item(self):
⋮...
│	def test_picklist_for_serial_item(self):
⋮...
│	def test_picklist_with_bundles(self):
⋮...
│	def test_picklist_with_partial_bundles(self):
⋮...
│	def test_pick_list_status(self):
⋮...
│	def test_pick_list_validation(self):
⋮...
│	def test_pick_list_validation_for_serial_no(self):
⋮...
│	def test_pick_list_validation_for_batch_no(self):
⋮...
│	def test_pick_list_validation_for_batch_no_and_serial_item(self):
⋮...
│	def test_pick_list_validation_for_multiple_batches_and_sales_order(self):
⋮...
│	def test_pick_list_for_multiple_sales_order_with_multiple_batches(self):
⋮...
│	def test_pick_list_for_multiple_sales_order_with_multiple_serial_nos(self):
⋮...
│	def test_pick_list_for_multiple_sales_orders_for_non_serialized_item(self):
⋮...
│	def test_validate_picked_qty_with_manual_option(self):
⋮...
│	def test_over_allowance_picking(self):
⋮...
│	def test_ignore_pricing_rule_in_pick_list(self):
⋮...
│	def test_pick_list_not_reset_batch(self):
⋮...

erpnext\stock\report\stock_balance\test_stock_balance.py:
│def stock_balance(filters):
│	"""Get rows from stock balance report"""
│	return [_dict(row) for row in execute(filters)[1]]
⋮...
│class TestStockBalance(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def assertPartialDictEq(self, expected: dict[str, Any], actual: dict[str, Any]):
│		for k, v in expected.items():
│			self.assertEqual(v, actual[k], msg=f"{expected=}\n{actual=}")
⋮...
│	def generate_stock_ledger(self, item_code: str, movements):
│		for movement in map(_dict, movements):
│			if "to_warehouse" not in movement:
│				movement.to_warehouse = "_Test Warehouse - _TC"
│			make_stock_entry(item_code=item_code, **movement)
⋮...
│	def assertInvariants(self, rows):
⋮...
│	def test_basic_stock_balance(self):
⋮...
│	def test_opening_balance(self):
⋮...
│	def test_uom_converted_info(self):
⋮...
│	def test_item_group(self):
│		self.filters.pop("item_code", None)
│		rows = stock_balance(self.filters.update({"item_group": self.item.item_group}))
│		self.assertTrue(all(r.item_group == self.item.item_group for r in rows))
⋮...
│	def test_child_warehouse_balances(self):
⋮...
│	def test_show_item_attr(self):
⋮...

erpnext\controllers\status_updater.py:
│class OverAllowanceError(frappe.ValidationError):
│	pass
⋮...
│class StatusUpdater(Document):
⋮...
│def validate_status(status, options):
│	if status not in options:
│		frappe.throw(_("Status must be one of {0}").format(comma_or(options)))
⋮...
│def get_allowance_for(
│	item_code,
│	item_allowance=None,
│	global_qty_allowance=None,
│	global_amount_allowance=None,
│	qty_or_amount="qty",
│):
⋮...
│	def update_prevdoc_status(self):
│		self.update_qty()
│		self.validate_qty()
⋮...
│	def set_status(self, update=False, status=None, update_modified=True):
⋮...
│	def get_status(self):
⋮...
│	def validate_qty(self):
⋮...
│	def check_overflow_with_allowance(self, item, args):
⋮...
│	def limits_crossed_error(self, args, item, qty_or_amount):
⋮...
│	def warn_about_bypassing_with_role(self, item, qty_or_amount, role):
⋮...
│	def update_qty(self, update_modified=True):
⋮...
│	def _update_children(self, args, update_modified):
⋮...
│	def _calculate_target_parent_percentage(
│		name, target_parent_dt, target_dt, target_ref_field, target_field
│	):
⋮...
│	def _determine_status(percentage, keyword):
⋮...
│	def _update_percent_field_in_targets(self, args, update_modified=True):
⋮...
│	def _update_percent_field(self, args, update_modified=True):
⋮...
│	def _update_modified(self, args, update_modified):
⋮...
│	def update_billing_status_for_zero_amount_refdoc(self, ref_dt):
⋮...
│	def update_billing_status(self, zero_amount_refdoc, ref_dt, ref_fieldname):
⋮...

erpnext\selling\page\sales_funnel\sales_funnel.py:
│def validate_filters(from_date, to_date, company):
│	if from_date and to_date and (from_date >= to_date):
│		frappe.throw(_("To Date must be greater than From Date"))
│
│	if not company:
│		frappe.throw(_("Please Select a Company"))
⋮...
│def get_opp_by(by_field, from_date, to_date, company):
⋮...
│def get_funnel_data(from_date, to_date, company):
⋮...
│def get_opp_by_utm_source(from_date, to_date, company):
│	return get_opp_by("utm_source", from_date, to_date, company)
⋮...
│def get_opp_by_utm_campaign(from_date, to_date, company):
│	return get_opp_by("utm_campaign", from_date, to_date, company)
⋮...
│def get_opp_by_utm_medium(from_date, to_date, company):
│	return get_opp_by("utm_medium", from_date, to_date, company)
⋮...
│def get_pipeline_data(from_date, to_date, company):
⋮...

erpnext\accounts\doctype\accounting_period\accounting_period.py:
│class OverlapError(frappe.ValidationError):
│	pass
⋮...
│class ClosedAccountingPeriod(frappe.ValidationError):
│	pass
⋮...
│class AccountingPeriod(Document):
⋮...
│	def validate(self):
│		self.validate_overlap()
⋮...
│	def before_insert(self):
│		self.bootstrap_doctypes_for_closing()
⋮...
│	def autoname(self):
│		company_abbr = frappe.get_cached_value("Company", self.company, "abbr")
│		self.name = " - ".join([self.period_name, company_abbr])
⋮...
│	def validate_overlap(self):
⋮...
│	def get_doctypes_for_closing(self):
⋮...
│	def bootstrap_doctypes_for_closing(self):
⋮...
│def validate_accounting_period_on_doc_save(doc, method=None):
⋮...

erpnext\accounts\doctype\pos_closing_entry\test_pos_closing_entry.py:
│def init_user_and_profile(**args):
⋮...
│def get_test_item_qty(pos_profile):
⋮...
│class TestPOSClosingEntry(IntegrationTestCase):
⋮...
│	def setUp(self):
│		# Make stock available for POS Sales
│		make_stock_entry(target="_Test Warehouse - _TC", qty=2, basic_rate=100)
⋮...
│	def tearDown(self):
│		frappe.set_user("Administrator")
│		frappe.db.sql("delete from `tabPOS Profile`")
⋮...
│	def test_pos_closing_entry(self):
⋮...
│	def test_pos_closing_without_item_code(self):
⋮...
│	def test_pos_qty_for_item(self):
⋮...
│	def test_cancelling_of_pos_closing_entry(self):
⋮...
│	def test_pos_closing_for_required_accounting_dimension_in_pos_profile(self):
⋮...
│	def test_merging_into_sales_invoice_for_batched_item(self):
⋮...

erpnext\accounts\doctype\process_payment_reconciliation\process_payment_reconciliation.py:
│def is_job_running(job_name: str) -> bool:
│	jobs = frappe.db.get_all("RQ Job", filters={"status": ["in", ["started", "queued"]]})
│	for x in jobs:
│		if x.job_name == job_name:
│			return True
│	return False
⋮...
│def get_next_allocation(log: str) -> list:
⋮...
│def get_pr_instance(doc: str):
⋮...
│class ProcessPaymentReconciliation(Document):
⋮...
│	def validate(self):
│		self.validate_receivable_payable_account()
│		self.validate_bank_cash_account()
⋮...
│	def validate_receivable_payable_account(self):
⋮...
│	def validate_bank_cash_account(self):
⋮...
│	def before_save(self):
│		self.status = ""
│		self.error_log = ""
⋮...
│	def on_submit(self):
│		self.db_set("status", "Queued")
│		self.db_set("error_log", None)
⋮...
│	def on_cancel(self):
│		self.db_set("status", "Cancelled")
│		log = frappe.db.get_value("Process Payment Reconciliation Log", filters={"process_pr": self.name})
│		if log:
│			frappe.db.set_value("Process Payment Reconciliation Log", log, "status", "Cancelled")
⋮...
│def get_reconciled_count(docname: str | None = None) -> float:
⋮...
│def pause_job_for_doc(docname: str | None = None):
│	if docname:
│		frappe.db.set_value("Process Payment Reconciliation", docname, "status", "Paused")
│		log = frappe.db.get_value("Process Payment Reconciliation Log", filters={"process_pr": docname})
│		if log:
│			frappe.db.set_value("Process Payment Reconciliation Log", log, "status", "Paused")
⋮...
│def trigger_job_for_doc(docname: str | None = None):
⋮...
│def trigger_reconciliation_for_queued_docs():
⋮...
│def reconcile_based_on_filters(doc: None | str = None) -> None:
⋮...
│def fetch_and_allocate(doc: str) -> None:
⋮...
│def reconcile(doc: None | str = None) -> None:
⋮...
│def is_any_doc_running(for_filter: str | dict | None = None) -> str | None:
⋮...

erpnext\maintenance\doctype\maintenance_schedule\test_maintenance_schedule.py:
│def get_events(ms):
│	return frappe.get_all(
│		"Event Participants",
│		filters={"reference_doctype": ms.doctype, "reference_docname": ms.name, "parenttype": "Event"},
│	)
⋮...
│def make_maintenance_schedule(**args):
⋮...
│def make_serial_item_with_serial(self, item_code):
⋮...
│class TestMaintenanceSchedule(IntegrationTestCase):
⋮...
│	def test_events_should_be_created_and_deleted(self):
⋮...
│	def test_make_schedule(self):
⋮...
│	def test_serial_no_filters(self):
⋮...
│	def test_schedule_with_serials(self):
⋮...

erpnext\stock\doctype\shipment\test_shipment.py:
│def create_material_receipt(item, company):
⋮...
│def get_shipment_customer():
⋮...
│def get_shipment_company():
│	return frappe.get_doc("Company", "_Test Company")
⋮...
│def create_shipment_address(address_title, company_name, postal_code):
⋮...
│class UnitTestShipment(UnitTestCase):
⋮...
│class TestShipment(IntegrationTestCase):
⋮...
│	def test_shipment_from_delivery_note(self):
⋮...
│	def test_get_total_weight(self):
⋮...
│def create_test_delivery_note():
⋮...
│def create_test_shipment(delivery_notes=None):
⋮...
│def get_shipment_customer_contact(customer_name):
⋮...
│def get_shipment_customer_address(customer_name):
⋮...
│def get_shipment_company_address(company_name):
⋮...
│def get_shipment_item(company_name):
⋮...
│def create_customer_contact(fname, lname):
⋮...
│def create_shipment_customer(customer_name):
⋮...
│def create_shipment_item(item_name, company_name):
⋮...

erpnext\accounts\report\accounts_receivable\test_accounts_receivable.py:
│class TestAccountsReceivable(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
│		self.create_usd_receivable_account()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_sales_invoice(self, no_payment_schedule=False, do_not_submit=False, **args):
⋮...
│	def create_payment_entry(self, docname, do_not_submit=False):
⋮...
│	def create_credit_note(self, docname, do_not_submit=False):
⋮...
│	def test_pos_receivable(self):
⋮...
│	def test_accounts_receivable_with_payment(self):
⋮...
│	def test_accounts_receivable_without_payment(self):
⋮...
│	def test_accounts_receivable_with_partial_payment(self):
⋮...
│	def test_cr_note_flag_to_update_self(self):
⋮...
│	def test_payment_againt_po_in_receivable_report(self):
⋮...
│	def test_exchange_revaluation_for_party(self):
⋮...
│	def test_payment_against_credit_note(self):
⋮...
│	def test_group_by_party(self):
⋮...
│	def test_future_payments(self):
⋮...
│	def test_sales_person(self):
⋮...
│	def test_cost_center_filter(self):
⋮...
│	def test_customer_group_filter(self):
⋮...
│	def test_multi_customer_group_filter(self):
⋮...
│	def test_party_account_filter(self):
⋮...
│	def test_usd_customer_filter(self):
⋮...
│	def test_multi_select_party_filter(self):
⋮...
│	def test_report_output_if_party_is_missing(self):
⋮...
│	def test_future_payments_on_foreign_currency(self):
⋮...
│	def test_accounts_receivable_output_for_minor_outstanding(self):
⋮...
│	def test_cost_center_on_report_output(self):
⋮...

erpnext\maintenance\doctype\maintenance_schedule\maintenance_schedule.py:
│def make_maintenance_visit(source_name, target_doc=None, item_name=None, s_id=None):
⋮...
│def get_serial_nos_from_schedule(item_code, schedule=None):
⋮...
│class MaintenanceSchedule(TransactionBase):
⋮...
│	def generate_schedule(self):
⋮...
│	def validate_end_date_visits(self):
⋮...
│	def on_submit(self):
⋮...
│	def create_schedule_list(self, start_date, end_date, no_of_visit, sales_person):
⋮...
│	def validate_schedule_date_for_holiday_list(self, schedule_date, sales_person):
⋮...
│	def validate_dates_with_periodicity(self):
⋮...
│	def validate_maintenance_detail(self):
⋮...
│	def validate_sales_order(self):
⋮...
│	def validate_items_table_change(self):
⋮...
│	def validate_no_of_visits(self):
│		return len(self.schedules) != sum(d.no_of_visits for d in self.items)
⋮...
│	def validate(self):
⋮...
│	def validate_serial_no_bundle(self):
⋮...
│	def on_update(self):
│		self.db_set("status", "Draft")
⋮...
│	def update_amc_date(self, serial_nos, amc_expiry_date=None):
│		for serial_no in serial_nos:
│			serial_no_doc = frappe.get_doc("Serial No", serial_no)
│			serial_no_doc.amc_expiry_date = amc_expiry_date
│			serial_no_doc.save()
⋮...
│	def validate_serial_no(self, item_code, serial_nos, amc_start_date):
⋮...
│	def validate_schedule(self):
⋮...
│	def check_serial_no_added(self):
⋮...
│	def on_cancel(self):
⋮...
│	def on_trash(self):
│		delete_events(self.doctype, self.name)
⋮...
│	def get_pending_data(self, data_type, s_date=None, item_name=None):
⋮...

erpnext\crm\utils.py:
│def get_linked_prospect(reference_doctype, reference_name):
⋮...
│def copy_comments(doctype, docname, doc):
⋮...
│def link_communications(doctype, docname, doc):
│	communication_list = get_linked_communication_list(doctype, docname)
│
│	for communication in communication_list:
│		communication_doc = frappe.get_doc("Communication", communication)
│		communication_doc.add_link(doc.doctype, doc.name, autosave=True)
⋮...
│def get_linked_communication_list(doctype, docname):
⋮...
│def get_open_todos(ref_doctype, ref_docname):
⋮...
│def get_open_events(ref_doctype, ref_docname):
⋮...
│class CRMNote(Document):
⋮...
│def update_lead_phone_numbers(contact, method):
⋮...
│def link_communications_with_prospect(communication, method):
⋮...
│def update_modified_timestamp(communication, method):
⋮...
│def link_events_with_prospect(event, method):
⋮...
│def link_open_tasks(ref_doctype, ref_docname, doc):
⋮...
│def link_open_events(ref_doctype, ref_docname, doc):
│	events = get_open_events(ref_doctype, ref_docname)
│	for event in events:
│		event_doc = frappe.get_doc("Event", event.name)
│		event_doc.add_participant(doc.doctype, doc.name)
│		event_doc.save()
⋮...
│def get_open_activities(ref_doctype, ref_docname):
│	tasks = get_open_todos(ref_doctype, ref_docname)
│	events = get_open_events(ref_doctype, ref_docname)
│
│	return {"tasks": tasks, "events": events}
⋮...
│def open_leads_opportunities_based_on_todays_event():
⋮...
│	def add_note(self, note):
│		self.append("notes", {"note": note, "added_by": frappe.session.user, "added_on": now()})
│		self.save()
│		notify_mentions(self.doctype, self.name, note)
⋮...
│	def edit_note(self, note, row_id):
│		for d in self.notes:
│			if cstr(d.name) == row_id:
│				d.note = note
│				d.db_update()
⋮...
│	def delete_note(self, row_id):
│		for d in self.notes:
│			if cstr(d.name) == row_id:
│				self.remove(d)
│				break
│		self.save()
⋮...

erpnext\accounts\doctype\bank_transaction\bank_transaction.py:
│def get_total_allocated_amount(docs):
⋮...
│def get_reconciled_bank_transactions(doctype, docname):
│	return frappe.get_all(
│		"Bank Transaction Payments",
│		filters={"payment_document": doctype, "payment_entry": docname},
│		pluck="parent",
│	)
⋮...
│class BankTransaction(Document):
⋮...
│	def before_validate(self):
│		self.update_allocated_amount()
⋮...
│	def validate(self):
│		self.validate_duplicate_references()
│		self.validate_currency()
⋮...
│	def validate_currency(self):
⋮...
│	def set_status(self):
⋮...
│	def validate_duplicate_references(self):
⋮...
│	def update_allocated_amount(self):
⋮...
│	def delink_old_payment_entries(self):
⋮...
│	def before_submit(self):
│		self.allocate_payment_entries()
│		self.set_status()
│
│		if frappe.db.get_single_value("Accounts Settings", "enable_party_matching"):
│			self.auto_set_party()
⋮...
│	def before_update_after_submit(self):
│		self.validate_duplicate_references()
│		self.update_allocated_amount()
│		self.delink_old_payment_entries()
│		self.allocate_payment_entries()
│		self.set_status()
⋮...
│	def on_cancel(self):
│		for payment_entry in self.payment_entries:
│			self.delink_payment_entry(payment_entry)
│
│		self.set_status()
⋮...
│	def add_payment_entries(self, vouchers):
⋮...
│	def allocate_payment_entries(self):
⋮...
│	def remove_payment_entries(self):
│		for payment_entry in self.payment_entries:
│			self.remove_payment_entry(payment_entry)
│
│		self.save()  # runs before_update_after_submit
⋮...
│	def remove_payment_entry(self, payment_entry):
│		"Clear payment entry and clearance"
│		self.delink_payment_entry(payment_entry)
│		self.remove(payment_entry)
⋮...
│	def delink_payment_entry(self, payment_entry):
│		if payment_entry.payment_document == "Bank Transaction":
│			self.update_linked_bank_transaction(payment_entry.payment_entry, allocated_amount=None)
│		else:
│			self.clear_linked_payment_entry(payment_entry, clearance_date=None)
⋮...
│	def clear_linked_payment_entry(self, payment_entry, clearance_date=None):
⋮...
│	def update_linked_bank_transaction(self, bank_transaction_name, allocated_amount=None):
⋮...
│	def auto_set_party(self):
⋮...
│def get_doctypes_for_bank_reconciliation():
│	"""Get Bank Reconciliation doctypes from all the apps"""
│	return frappe.get_hooks("bank_reconciliation_doctypes")
⋮...
│def get_clearance_details(transaction, payment_entry, bt_allocations, gl_entries, gl_bank_account):
⋮...
│def get_related_bank_gl_entries(docs):
⋮...
│def remove_from_bank_transaction(doctype, docname):
⋮...

erpnext\accounts\doctype\repost_accounting_ledger\repost_accounting_ledger.py:
│def validate_docs_for_deferred_accounting(sales_docs, purchase_docs):
⋮...
│def validate_docs_for_voucher_types(doc_voucher_types):
⋮...
│def get_allowed_types_from_settings():
⋮...
│class RepostAccountingLedger(Document):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		self._allowed_types = get_allowed_types_from_settings()
⋮...
│	def validate(self):
│		self.validate_vouchers()
│		self.validate_for_closed_fiscal_year()
│		self.validate_for_deferred_accounting()
⋮...
│	def validate_for_deferred_accounting(self):
│		sales_docs = [x.voucher_no for x in self.vouchers if x.voucher_type == "Sales Invoice"]
│		purchase_docs = [x.voucher_no for x in self.vouchers if x.voucher_type == "Purchase Invoice"]
│		validate_docs_for_deferred_accounting(sales_docs, purchase_docs)
⋮...
│	def validate_for_closed_fiscal_year(self):
⋮...
│	def validate_vouchers(self):
│		if self.vouchers:
│			validate_docs_for_voucher_types([x.voucher_type for x in self.vouchers])
⋮...
│	def get_existing_ledger_entries(self):
⋮...
│	def generate_preview_data(self):
⋮...
│	def generate_preview(self):
⋮...
│	def on_submit(self):
⋮...
│def start_repost(account_repost_doc=str) -> None:
⋮...
│def get_repost_allowed_types(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\stock\doctype\stock_closing_entry\stock_closing_entry.py:
│class StockClosing:
⋮...
│def prepare_closing_stock_balance(name):
⋮...
│class StockClosingEntry(Document):
⋮...
│	def before_save(self):
│		self.set_status()
⋮...
│	def set_status(self, save=False):
⋮...
│	def validate(self):
│		self.validate_duplicate()
⋮...
│	def validate_duplicate(self):
⋮...
│	def on_submit(self):
│		self.set_status(save=True)
│		self.enqueue_job()
⋮...
│	def on_cancel(self):
│		self.set_status(save=True)
│		self.remove_stock_closing()
⋮...
│	def remove_stock_closing(self):
│		table = frappe.qb.DocType("Stock Closing Balance")
│		frappe.qb.from_(table).delete().where(table.stock_closing_entry == self.name).run()
⋮...
│	def enqueue_job(self):
⋮...
│	def regenerate_closing_balance(self):
│		self.remove_stock_closing()
│		self.enqueue_job()
⋮...
│	def create_stock_closing_balance_entries(self):
⋮...
│	def get_prepared_data(self):
⋮...
│	def __init__(self, company, from_date, to_date, **kwargs):
⋮...
│	def get_stock_closing_entries(self):
⋮...
│	def update_fifo_queue(self, fifo_queue, actual_qty, posting_date):
⋮...
│	def get_initialized_entry(self, row, dimension_fields):
⋮...
│	def get_sle_entries(self):
⋮...
│	def get_entries(self, doctype, fields, filters, **kwargs):
⋮...
│	def get_last_stock_closing_entry(self):
⋮...
│	def get_keys(self, row):
⋮...
│	def get_stock_closing_balance(self, kwargs, for_batch=False):
⋮...

erpnext\selling\doctype\product_bundle\test_product_bundle.py:
│def make_product_bundle(parent, items, qty=None):
⋮...

erpnext\crm\frappe_crm_api.py:
│def create_customer(customer_data=None):
⋮...
│def create_address(doctype, docname, address):
⋮...
│def create_contacts(contacts, organization=None, link_doctype=None, link_docname=None):
⋮...
│def link_doc(doc, link_doctype, link_docname):
⋮...
│def create_custom_fields_for_frappe_crm():
⋮...
│def create_prospect_against_crm_deal():
⋮...
│def contact_exists(email, mobile_no):
⋮...

erpnext\manufacturing\doctype\job_card\test_job_card.py:
│def create_bom_with_multiple_operations():
⋮...
│def make_wo_with_transfer_against_jc():
⋮...
│class UnitTestJobCard(UnitTestCase):
⋮...
│class TestJobCard(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.make_bom_for_jc_tests()
│		self.transfer_material_against: Literal["Work Order", "Job Card"] = "Work Order"
│		self.source_warehouse = None
│		self._work_order = None
⋮...
│	def make_bom_for_jc_tests(self):
⋮...
│	def work_order(self) -> WorkOrder:
⋮...
│	def generate_required_stock(self, work_order: WorkOrder) -> None:
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_job_card_operations(self):
⋮...
│	def test_job_card_with_different_work_station(self):
⋮...
│	def test_job_card_overlap(self):
⋮...
│	def test_job_card_overlap_with_capacity(self):
⋮...
│	def test_job_card_multiple_materials_transfer(self):
⋮...
│	def test_job_card_excess_material_transfer(self):
⋮...
│	def test_job_card_excess_material_transfer_block(self):
⋮...
│	def test_job_card_excess_material_transfer_with_no_reference(self):
⋮...
│	def test_job_card_partial_material_transfer(self):
⋮...
│	def test_job_card_material_transfer_correctness(self):
⋮...
│	def test_corrective_costing(self):
⋮...
│	def test_if_corrective_jc_ops_cost_is_added_to_manufacture_stock_entry(self):
⋮...
│	def test_job_card_statuses(self):
⋮...
│	def test_job_card_material_request_and_bom_details(self):
⋮...
│	def test_job_card_proccess_qty_and_completed_qty(self):
⋮...

erpnext\accounts\doctype\cost_center\cost_center.py:
│def on_doctype_update():
│	frappe.db.add_index("Cost Center", ["lft", "rgt"])
⋮...
│class CostCenter(NestedSet):
⋮...
│	def autoname(self):
│		from erpnext.accounts.utils import get_autoname_with_number
│
│		self.name = get_autoname_with_number(self.cost_center_number, self.cost_center_name, self.company)
⋮...
│	def validate(self):
│		self.validate_mandatory()
│		self.validate_parent_cost_center()
⋮...
│	def validate_mandatory(self):
│		if self.cost_center_name != self.company and not self.parent_cost_center:
│			frappe.throw(_("Please enter parent cost center"))
│		elif self.cost_center_name == self.company and self.parent_cost_center:
│			frappe.throw(_("Root cannot have a parent cost center"))
⋮...
│	def validate_parent_cost_center(self):
⋮...
│	def convert_group_to_ledger(self):
⋮...
│	def convert_ledger_to_group(self):
⋮...
│	def check_gle_exists(self):
│		return frappe.db.get_value("GL Entry", {"cost_center": self.name})
⋮...
│	def check_if_child_exists(self):
│		return frappe.db.sql(
│			"select name from `tabCost Center` where \
│			parent_cost_center = %s and docstatus != 2",
│			self.name,
│		)
⋮...
│	def if_allocation_exists_against_cost_center(self):
│		return frappe.db.get_value(
│			"Cost Center Allocation", filters={"main_cost_center": self.name, "docstatus": 1}
│		)
⋮...
│	def check_if_part_of_cost_center_allocation(self):
│		return frappe.db.get_value(
│			"Cost Center Allocation Percentage", filters={"cost_center": self.name, "docstatus": 1}
│		)
⋮...
│	def before_rename(self, olddn, newdn, merge=False):
⋮...
│	def after_rename(self, olddn, newdn, merge=False):
⋮...
│def get_name_with_number(new_account, account_number):
│	if account_number and not new_account[0].isdigit():
│		new_account = account_number + " - " + new_account
│	return new_account
⋮...

erpnext\accounts\doctype\exchange_rate_revaluation\exchange_rate_revaluation.py:
│def get_account_details(
│	company, posting_date, account, party_type=None, party=None, rounding_loss_allowance: float | None = None
⋮...
│class ExchangeRateRevaluation(Document):
⋮...
│	def validate(self):
│		self.validate_rounding_loss_allowance()
│		self.set_total_gain_loss()
⋮...
│	def validate_rounding_loss_allowance(self):
│		if self.rounding_loss_allowance < 0 or self.rounding_loss_allowance >= 1:
│			frappe.throw(_("Rounding Loss Allowance should be between 0 and 1"))
⋮...
│	def set_total_gain_loss(self):
⋮...
│	def validate_mandatory(self):
│		if not (self.company and self.posting_date):
│			frappe.throw(_("Please select Company and Posting Date to getting entries"))
⋮...
│	def before_submit(self):
│		self.remove_accounts_without_gain_loss()
⋮...
│	def remove_accounts_without_gain_loss(self):
⋮...
│	def on_cancel(self):
│		self.ignore_linked_doctypes = "GL Entry"
⋮...
│	def check_journal_entry_condition(self):
⋮...
│	def fetch_and_calculate_accounts_data(self):
│		accounts = self.get_accounts_data()
│		if accounts:
│			for acc in accounts:
│				self.append("accounts", acc)
⋮...
│	def get_accounts_data(self):
⋮...
│	def get_account_balance_from_gle(
│		company, posting_date, account, party_type, party, rounding_loss_allowance
│	):
⋮...
│	def calculate_new_account_balance(company, posting_date, account_details):
⋮...
│	def throw_invalid_response_message(self, account_details):
│		if account_details:
│			message = _("No outstanding invoices require exchange rate revaluation")
│		else:
│			message = _("No outstanding invoices found")
│		frappe.msgprint(message)
⋮...
│	def get_for_unrealized_gain_loss_account(self):
⋮...
│	def make_jv_entries(self):
⋮...
│	def make_jv_for_zero_balance(self):
⋮...
│	def make_jv_for_revaluation(self):
⋮...
│def calculate_exchange_rate_using_last_gle(company, account, party_type, party):
⋮...

erpnext\edi\doctype\common_code\common_code.py:
│def on_doctype_update():
│	frappe.db.add_index("Common Code", ["code_list", "common_code"])
⋮...
│class CommonCode(Document):
⋮...
│	def validate(self):
│		self.validate_distinct_references()
⋮...
│	def validate_distinct_references(self):
⋮...
│	def from_genericode(self, column_map: dict, xml_element: "etree.Element"):
⋮...
│def simple_hash(input_string, length=6):
│	return hashlib.blake2b(input_string.encode(), digest_size=length // 2).hexdigest()
⋮...
│def import_genericode(code_list: str, file_name: str, column_map: dict, filters: dict | None = None):
⋮...

erpnext\buying\doctype\supplier_scorecard\supplier_scorecard.py:
│def get_timeline_data(doctype, name):
⋮...
│def make_all_scorecards(docname):
⋮...
│def get_scorecard_date(period, start_date):
⋮...
│class SupplierScorecard(Document):
⋮...
│	def validate(self):
│		self.validate_standings()
│		self.validate_criteria_weights()
│		self.calculate_total_score()
│		self.update_standing()
⋮...
│	def on_update(self):
│		score = make_all_scorecards(self.name)
│		if score > 0:
│			self.save()
⋮...
│	def validate_standings(self):
⋮...
│	def validate_criteria_weights(self):
⋮...
│	def calculate_total_score(self):
⋮...
│	def update_standing(self):
⋮...
│def daterange(start_date, end_date):
│	for n in range(int((end_date - start_date).days) + 1):
│		yield start_date + timedelta(n)
⋮...
│def refresh_scorecards():
⋮...
│def make_default_records():
⋮...

erpnext\accounts\report\trial_balance\test_trial_balance.py:
│def create_company(**args):
⋮...
│def disable_dimension(**args):
│	args = frappe._dict(args)
│	document_type = args.document_type or "Branch"
│	dimension = frappe.get_doc("Accounting Dimension", document_type)
│	dimension.disabled = 1
│	dimension.save()
⋮...
│def create_accounting_dimension(**args):
⋮...
│def clear_dimension_defaults(dimension_name):
│	accounting_dimension = frappe.get_doc("Accounting Dimension", dimension_name)
│	accounting_dimension.dimension_defaults = []
│	accounting_dimension.save()
⋮...
│class TestTrialBalance(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_offsetting_entries_for_accounting_dimensions(self):
⋮...
│	def tearDown(self):
│		clear_dimension_defaults("Branch")
│		disable_dimension()
⋮...

erpnext\manufacturing\doctype\bom_creator\test_bom_creator.py:
│def create_items():
⋮...
│def make_bom_creator(**kwargs):
⋮...
│class UnitTestBomCreator(UnitTestCase):
⋮...
│class TestBOMCreator(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
│		create_items()
⋮...
│	def test_bom_sub_assembly(self):
⋮...
│	def test_bom_raw_material(self):
⋮...
│	def test_convert_to_sub_assembly(self):
⋮...
│	def test_make_boms_from_bom_creator(self):
⋮...

erpnext\accounts\doctype\bank_transaction\test_bank_transaction.py:
│def create_bank_account(
│	bank_name="Citi Bank", gl_account="_Test Bank - _TC", bank_account_name="Checking Account"
│):
⋮...
│def create_gl_account(gl_account_name="_Test Bank - _TC"):
⋮...
│def add_transactions(bank_account="_Test Bank - _TC"):
⋮...
│def create_loan_and_repayment():
⋮...
│class UnitTestBankTransaction(UnitTestCase):
⋮...
│class TestBankTransaction(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_linked_payments(self):
⋮...
│	def test_reconcile(self):
⋮...
│	def test_cancel_voucher(self):
⋮...
│	def test_debit_credit_output(self):
⋮...
│	def test_already_reconciled(self):
⋮...
│	def test_clear_sales_invoice(self):
⋮...
│	def test_matching_loan_repayment(self):
⋮...
│def add_vouchers(gl_account="_Test Bank - _TC"):
⋮...

erpnext\accounts\doctype\invoice_discounting\invoice_discounting.py:
│def get_invoices(filters):
⋮...
│def get_party_account_based_on_invoice_discounting(sales_invoice):
⋮...
│class InvoiceDiscounting(AccountsController):
⋮...
│	def validate(self):
│		self.validate_mandatory()
│		self.validate_invoices()
│		self.calculate_total_amount()
│		self.set_status()
│		self.set_end_date()
⋮...
│	def set_end_date(self):
│		if self.loan_start_date and self.loan_period:
│			self.loan_end_date = add_days(self.loan_start_date, self.loan_period)
⋮...
│	def validate_mandatory(self):
│		if self.docstatus == 1 and not (self.loan_start_date and self.loan_period):
│			frappe.throw(_("Loan Start Date and Loan Period are mandatory to save the Invoice Discounting"))
⋮...
│	def validate_invoices(self):
⋮...
│	def calculate_total_amount(self):
│		self.total_amount = sum(flt(d.outstanding_amount) for d in self.invoices)
⋮...
│	def on_submit(self):
│		self.update_sales_invoice()
│		self.make_gl_entries()
⋮...
│	def on_cancel(self):
│		self.set_status(cancel=1)
│		self.update_sales_invoice()
│		self.make_gl_entries()
⋮...
│	def set_status(self, status=None, cancel=0):
⋮...
│	def update_sales_invoice(self):
⋮...
│	def make_gl_entries(self):
⋮...
│	def create_disbursement_entry(self):
⋮...
│	def close_loan(self):
⋮...

erpnext\accounts\doctype\promotional_scheme\promotional_scheme.py:
│def prepare_pricing_rule(
│	args, doc, child_doc, discount_fields, d, docname=None, applicable_for=None, value=None
│):
⋮...
│class TransactionExists(frappe.ValidationError):
│	pass
⋮...
│def get_pricing_rules(doc, rules=None):
⋮...
│def _get_pricing_rules(doc, child_doc, discount_fields, rules=None):
⋮...
│def get_pricing_rule_docname(
│	row: dict, applicable_for: str | None = None, applicable_for_value: str | None = None
⋮...
│class PromotionalScheme(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_applicable_for(self):
⋮...
│	def validate_pricing_rules(self):
⋮...
│	def get_invalid_pricing_rules(self):
⋮...
│	def on_update(self):
⋮...
│	def validate_mixed_with_recursion(self):
⋮...
│	def update_pricing_rules(self, pricing_rules):
⋮...
│	def on_trash(self):
│		for rule in frappe.get_all("Pricing Rule", {"promotional_scheme": self.name}):
│			frappe.delete_doc("Pricing Rule", rule.name)
⋮...
│def raise_for_transaction_exists(name):
│	msg = f"""You can't change the {frappe.bold(_('Applicable For'))}
│		because transactions are present against the Promotional Scheme {frappe.bold(name)}. """
│	msg += "Kindly disable this Promotional Scheme and create new for new Applicable For."
│
│	frappe.throw(_(msg), TransactionExists)
⋮...
│def set_args(args, pr, doc, child_doc, discount_fields, child_doc_fields):
⋮...
│def get_args_for_pricing_rule(doc):
⋮...

erpnext\templates\pages\projects.py:
│def get_context(context):
⋮...
│def get_attachments(project):
│	return frappe.get_all(
│		"File",
│		filters={"attached_to_name": project, "attached_to_doctype": "Project", "is_private": 0},
│		fields=["file_name", "file_url", "file_size"],
│	)
⋮...
│def get_tasks(project, start=0, search=None, item_status=None):
⋮...
│def get_timesheets(project, start=0, search=None):
⋮...
│def get_task_html(project, start=0, item_status=None):
⋮...
│def get_timesheet_html(project, start=0):
│	return frappe.render_template(
│		"erpnext/templates/includes/projects/project_timesheets.html",
│		{"doc": {"timesheets": get_timesheets(project, start)}},
│		is_path=True,
│	)
⋮...

erpnext\manufacturing\doctype\blanket_order\test_blanket_order.py:
│def make_blanket_order(**args):
⋮...
│class UnitTestBlanketOrder(UnitTestCase):
⋮...
│class TestBlanketOrder(IntegrationTestCase):
⋮...
│	def setUp(self):
│		frappe.flags.args = frappe._dict()
⋮...
│	def test_sales_order_creation(self):
⋮...
│	def test_purchase_order_creation(self):
⋮...
│	def test_blanket_order_allowance(self):
⋮...
│	def test_party_item_code(self):
⋮...

erpnext\buying\doctype\supplier\test_supplier.py:
│def create_supplier(**args):
⋮...
│class UnitTestSupplier(UnitTestCase):
⋮...
│class TestSupplier(IntegrationTestCase):
⋮...
│	def test_get_supplier_group_details(self):
⋮...
│	def test_supplier_default_payment_terms(self):
⋮...
│	def test_supplier_disabled(self):
⋮...
│	def test_supplier_country(self):
⋮...
│	def test_party_details_tax_category(self):
⋮...
│class TestSupplierPortal(IntegrationTestCase):
⋮...
│	def test_portal_user_can_access_supplier_data(self):
⋮...

erpnext\startup\boot.py:
│def bootinfo(bootinfo):
│	if bootinfo.get("user") and bootinfo["user"].get("name"):
│		bootinfo["user"]["employee"] = ""
│		employee = frappe.db.get_value("Employee", {"user_id": bootinfo["user"]["name"]}, "name")
│		if employee:
│			bootinfo["user"]["employee"] = employee
⋮...
│def boot_session(bootinfo):
⋮...
│def update_page_info(bootinfo):
⋮...

erpnext\stock\doctype\quality_inspection\test_quality_inspection.py:
│def create_quality_inspection(**args):
⋮...
│def create_quality_inspection_parameter(parameter):
│	if not frappe.db.exists("Quality Inspection Parameter", parameter):
│		frappe.get_doc(
│			{"doctype": "Quality Inspection Parameter", "parameter": parameter, "description": parameter}
│		).insert()
⋮...
│class UnitTestQualityInspection(UnitTestCase):
⋮...
│class TestQualityInspection(IntegrationTestCase):
⋮...
│	def setUp(self):
│		super().setUp()
│		create_item("_Test Item with QA")
│		frappe.db.set_value("Item", "_Test Item with QA", "inspection_required_before_delivery", 1)
⋮...
│	def test_qa_for_delivery(self):
⋮...
│	def test_qa_not_submit(self):
⋮...
│	def test_value_based_qi_readings(self):
⋮...
│	def test_formula_based_qi_readings(self):
⋮...
│	def test_make_quality_inspections_from_linked_document(self):
⋮...
│	def test_rejected_qi_validation(self):
⋮...
│	def test_qi_status(self):
⋮...
│	def test_diff_number_format(self):
⋮...
│	def test_delete_quality_inspection_linked_with_stock_entry(self):
⋮...

erpnext\buying\doctype\request_for_quotation\test_request_for_quotation.py:
│def make_request_for_quotation(**args) -> "RequestforQuotation":
⋮...
│def get_supplier_data():
│	return [
│		{"supplier": "_Test Supplier", "supplier_name": "_Test Supplier"},
│		{"supplier": "_Test Supplier 1", "supplier_name": "_Test Supplier 1"},
│	]
⋮...
│class UnitTestRequestForQuotation(UnitTestCase):
⋮...
│class TestRequestforQuotation(IntegrationTestCase):
⋮...
│	def test_rfq_qty(self):
⋮...
│	def test_quote_status(self):
⋮...
│	def test_make_supplier_quotation(self):
⋮...
│	def test_make_supplier_quotation_with_special_characters(self):
⋮...
│	def test_make_supplier_quotation_from_portal(self):
⋮...
│	def test_make_multi_uom_supplier_quotation(self):
⋮...
│	def test_make_rfq_from_opportunity(self):
⋮...
│	def test_get_link(self):
│		rfq = make_request_for_quotation()
│		parsed_link = urlparse(rfq.get_link())
│		self.assertEqual(parsed_link.path, f"/rfq/{rfq.name}")
⋮...
│	def test_get_pdf(self):
│		rfq = make_request_for_quotation()
│		get_pdf(rfq.name, rfq.get("suppliers")[0].supplier)
│		self.assertEqual(frappe.local.response.type, "pdf")
⋮...
│	def test_portal_user_with_new_supplier(self):
⋮...

erpnext\manufacturing\report\bom_stock_calculated\test_bom_stock_calculated.py:
│def create_items():
⋮...
│def get_expected_data(bom, qty_to_make):
⋮...
│class TestBOMStockCalculated(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.fg_item, self.rm_items = create_items()
│		self.boms = create_boms(self.fg_item, self.rm_items)
⋮...
│	def test_bom_stock_calculated(self):
⋮...
│def create_boms(fg_item, rm_items):
⋮...

erpnext\stock\doctype\delivery_trip\test_delivery_trip.py:
│def create_address(driver):
⋮...
│def create_driver():
⋮...
│class UnitTestDeliveryTrip(UnitTestCase):
⋮...
│class TestDeliveryTrip(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.sql("delete from `tabDriver`")
│		frappe.db.sql("delete from `tabVehicle`")
│		frappe.db.sql("delete from `tabEmail Template`")
│		frappe.db.sql("delete from `tabDelivery Trip`")
│		return super().tearDown()
⋮...
│	def test_delivery_trip_notify_customers(self):
│		notify_customers(delivery_trip=self.delivery_trip.name)
│		self.delivery_trip.load_from_db()
│		self.assertEqual(self.delivery_trip.email_notification_sent, 1)
⋮...
│	def test_unoptimized_route_list_without_locks(self):
│		route_list = self.delivery_trip.form_route_list(optimize=False)
│
│		# Return a single list of destinations, from home address and back
│		self.assertEqual(len(route_list), 1)
│		self.assertEqual(len(route_list[0]), 4)
⋮...
│	def test_unoptimized_route_list_with_locks(self):
⋮...
│	def test_optimized_route_list_without_locks(self):
⋮...
│	def test_optimized_route_list_with_locks(self):
⋮...
│	def test_delivery_trip_status_draft(self):
│		self.assertEqual(self.delivery_trip.status, "Draft")
⋮...
│	def test_delivery_trip_status_scheduled(self):
│		self.delivery_trip.submit()
│		self.assertEqual(self.delivery_trip.status, "Scheduled")
⋮...
│	def test_delivery_trip_status_cancelled(self):
│		self.delivery_trip.submit()
│		self.delivery_trip.cancel()
│		self.assertEqual(self.delivery_trip.status, "Cancelled")
⋮...
│	def test_delivery_trip_status_in_transit(self):
│		self.delivery_trip.submit()
│		self.delivery_trip.delivery_stops[0].visited = 1
│		self.delivery_trip.save()
│		self.assertEqual(self.delivery_trip.status, "In Transit")
⋮...
│	def test_delivery_trip_status_completed(self):
⋮...
│def create_delivery_notification():
⋮...
│def create_vehicle():
⋮...
│def create_delivery_trip(driver, address, contact=None):
⋮...

erpnext\crm\doctype\lead\test_lead.py:
│def make_lead(**args):
⋮...
│def create_event(subject, starts_on, reference_type, reference_name):
⋮...
│class TestLead(IntegrationTestCase):
⋮...
│	def test_make_customer(self):
⋮...
│	def test_make_customer_from_organization(self):
⋮...
│	def test_create_lead_and_unlinking_dynamic_links(self):
⋮...
│	def test_prospect_creation_from_lead(self):
⋮...
│	def test_opportunity_from_lead(self):
⋮...
│	def test_copy_events_from_lead_to_prospect(self):
⋮...
│def create_todo(description, reference_type, reference_name):
⋮...

erpnext\manufacturing\report\bom_stock_report\test_bom_stock_report.py:
│def create_items():
⋮...
│def get_expected_data(bom, warehouse, qty_to_produce, show_exploded_view=False):
⋮...
│class TestBomStockReport(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.warehouse = "_Test Warehouse - _TC"
│		self.fg_item, self.rm_items = create_items()
│		make_stock_entry(target=self.warehouse, item_code=self.rm_items[0], qty=20, basic_rate=100)
│		make_stock_entry(target=self.warehouse, item_code=self.rm_items[1], qty=40, basic_rate=200)
│		self.bom = make_bom(item=self.fg_item, quantity=1, raw_materials=self.rm_items, rm_qty=10)
⋮...
│	def test_bom_stock_report(self):
⋮...

erpnext\controllers\tests\test_queries.py:
│def add_default_params(func, doctype):
│	return partial(func, doctype=doctype, txt="", searchfield="name", start=0, page_len=20, filters=None)
⋮...
│class TestQueries(IntegrationTestCase):
⋮...
│	def assert_nested_in(self, item, container):
│		self.assertIn(item, [vals for tuples in container for vals in tuples])
⋮...
│	def test_employee_query(self):
│		query = add_default_params(queries.employee_query, "Employee")
│
│		self.assertGreaterEqual(len(query(txt="_Test Employee")), 3)
│		self.assertGreaterEqual(len(query(txt="_Test Employee 1")), 1)
⋮...
│	def test_lead_query(self):
│		query = add_default_params(queries.lead_query, "Lead")
│
│		self.assertGreaterEqual(len(query(txt="_Test Lead")), 4)
│		self.assertEqual(len(query(txt="_Test Lead 4")), 1)
⋮...
│	def test_item_query(self):
⋮...
│	def test_bom_qury(self):
│		query = add_default_params(queries.bom, "BOM")
│
│		self.assertGreaterEqual(len(query(txt="_Test Item Home Desktop Manufactured")), 1)
⋮...
│	def test_project_query(self):
│		query = add_default_params(queries.get_project_name, "Project")
│
│		self.assertGreaterEqual(len(query(txt="_Test Project")), 1)
⋮...
│	def test_account_query(self):
│		query = add_default_params(queries.get_account_list, "Account")
│
│		debtor_accounts = query(txt="Debtors", filters={"company": "_Test Company"})
│		self.assert_nested_in("Debtors - _TC", debtor_accounts)
⋮...
│	def test_income_account_query(self):
│		query = add_default_params(queries.get_income_account, "Account")
│
│		self.assertGreaterEqual(len(query(filters={"company": "_Test Company"})), 1)
⋮...
│	def test_expense_account_query(self):
│		query = add_default_params(queries.get_expense_account, "Account")
│
│		self.assertGreaterEqual(len(query(filters={"company": "_Test Company"})), 1)
⋮...
│	def test_warehouse_query(self):
│		query = add_default_params(queries.warehouse_query, "Account")
│
│		wh = query(filters=[["Bin", "item_code", "=", "_Test Item"]])
│		self.assertGreaterEqual(len(wh), 1)
⋮...
│	def test_default_uoms(self):
│		self.assertGreaterEqual(frappe.db.count("UOM", {"enabled": 1}), 10)
⋮...
│	def test_employee_query_with_user_permissions(self):
⋮...

erpnext\quality_management\doctype\quality_review\quality_review.py:
│def create_review(goal):
│	goal = frappe.get_doc("Quality Goal", goal)
│
│	review = frappe.get_doc({"doctype": "Quality Review", "goal": goal.name, "date": frappe.utils.getdate()})
│
│	review.insert(ignore_permissions=True)
⋮...
│def review():
⋮...
│class QualityReview(Document):
⋮...
│	def validate(self):
⋮...
│	def set_status(self):
⋮...
│def get_quarter(month):
│	if month in ["January", "April", "July", "October"]:
│		return True
│	else:
│		return False
⋮...

erpnext\setup\demo.py:
│def get_warehouse(company):
│	warehouses = frappe.db.get_all("Warehouse", {"company": company, "is_group": 0})
│	return warehouses[randint(0, 3)].name
⋮...
│def read_data_file_using_hooks(doctype):
│	path = os.path.join(os.path.dirname(__file__), "demo_data")
│	with open(os.path.join(path, doctype + ".json")) as f:
│		data = f.read()
│
│	return data
⋮...
│def setup_demo_data():
⋮...
│def get_random_date(start_date, start_range, end_range):
│	return add_days(start_date, randint(start_range, end_range))
⋮...
│def clear_demo_data():
⋮...
│def create_demo_company():
⋮...
│def process_masters():
│	for doctype in frappe.get_hooks("demo_master_doctypes"):
│		data = read_data_file_using_hooks(doctype)
│		if data:
│			for item in json.loads(data):
│				create_demo_record(item)
⋮...
│def create_demo_record(doctype):
│	frappe.get_doc(doctype).insert(ignore_permissions=True)
⋮...
│def make_transactions(company):
⋮...
│def create_transaction(doctype, company, start_date):
⋮...
│def convert_order_to_invoices():
⋮...
│def create_transaction_deletion_record(company):
⋮...
│def clear_masters():
│	for doctype in frappe.get_hooks("demo_master_doctypes")[::-1]:
│		data = read_data_file_using_hooks(doctype)
│		if data:
│			for item in json.loads(data):
│				clear_demo_record(item)
⋮...
│def clear_demo_record(document):
⋮...
│def delete_company(company):
│	frappe.db.set_single_value("Global Defaults", "demo_company", "")
│	frappe.delete_doc("Company", company, ignore_permissions=True)
⋮...

erpnext\setup\doctype\item_group\item_group.py:
│def get_item_group_defaults(item, company):
⋮...
│def get_child_item_groups(item_group_name):
⋮...
│class ItemGroup(NestedSet):
⋮...
│	def validate(self):
│		if not self.parent_item_group and not frappe.flags.in_test:
│			if frappe.db.exists("Item Group", _("All Item Groups")):
│				self.parent_item_group = _("All Item Groups")
│		self.validate_item_group_defaults()
│		self.check_item_tax()
⋮...
│	def check_item_tax(self):
⋮...
│	def on_update(self):
│		NestedSet.on_update(self)
│		self.validate_one_root()
│		self.delete_child_item_groups_key()
⋮...
│	def on_trash(self):
│		NestedSet.on_trash(self, allow_root_deletion=True)
│		self.delete_child_item_groups_key()
⋮...
│	def delete_child_item_groups_key(self):
│		frappe.cache().hdel("child_item_groups", self.name)
⋮...
│	def validate_item_group_defaults(self):
│		from erpnext.stock.doctype.item.item import validate_item_default_company_links
│
│		validate_item_default_company_links(self.item_group_defaults)
⋮...

erpnext\accounts\doctype\payment_request\test_payment_request.py:
│class UnitTestPaymentRequest(UnitTestCase):
⋮...
│class TestPaymentRequest(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_payment_request_linkings(self):
⋮...
│	def test_payment_channels(self):
⋮...
│	def test_payment_entry_against_purchase_invoice(self):
⋮...
│	def test_multiple_payment_entry_against_purchase_invoice(self):
⋮...
│	def test_payment_entry(self):
⋮...
│	def test_status(self):
⋮...
│	def test_multiple_payment_entries_against_sales_order(self):
⋮...
│	def test_conversion_on_foreign_currency_accounts(self):
⋮...
│	def test_multiple_payment_if_partially_paid_for_same_currency(self):
⋮...
│	def test_multiple_payment_if_partially_paid_for_multi_currency(self):
⋮...
│	def test_single_payment_with_payment_term_for_same_currency(self):
⋮...
│	def test_single_payment_with_payment_term_for_multi_currency(self):
⋮...
│	def test_payment_cancel_process(self):
⋮...
│	def test_partial_paid_invoice_with_payment_request(self):
⋮...
│	def test_partial_paid_invoice_with_more_payment_entry(self):
⋮...
│	def test_consider_journal_entry_and_return_invoice(self):
⋮...
│def test_partial_paid_invoice_with_submitted_payment_entry(self):
⋮...

erpnext\accounts\doctype\loyalty_program\loyalty_program.py:
│def get_loyalty_program_details_with_points(
│	customer,
│	loyalty_program=None,
│	expiry_date=None,
│	company=None,
│	silent=False,
│	include_expired_entry=False,
│	current_transaction_amount=0,
│):
⋮...
│def validate_loyalty_points(ref_doc, points_to_redeem):
⋮...
│def get_loyalty_details(
│	customer, loyalty_program, expiry_date=None, company=None, include_expired_entry=False
│):
⋮...
│class LoyaltyProgram(Document):
⋮...
│	def validate(self):
│		self.validate_lowest_tier()
⋮...
│	def validate_lowest_tier(self):
⋮...
│def get_loyalty_program_details(
│	customer,
│	loyalty_program=None,
│	expiry_date=None,
│	company=None,
│	silent=False,
│	include_expired_entry=False,
│):
⋮...
│def get_redeemption_factor(loyalty_program=None, customer=None):
⋮...

erpnext\accounts\doctype\cost_center_allocation\test_cost_center_allocation.py:
│def create_cost_center_allocation(
│	company,
│	main_cost_center,
│	allocation_percentages,
│	valid_from=None,
│	valid_upto=None,
│	save=True,
│	submit=True,
│):
⋮...
│class TestCostCenterAllocation(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_gle_based_on_cost_center_allocation(self):
⋮...
│	def test_main_cost_center_cant_be_child(self):
⋮...
│	def test_invalid_main_cost_center(self):
⋮...
│	def test_if_child_cost_center_has_any_allocation_record(self):
⋮...
│	def test_total_percentage(self):
⋮...
│	def test_valid_from_based_on_existing_gle(self):
⋮...
│	def test_multiple_cost_center_allocation_on_same_main_cost_center(self):
⋮...

erpnext\setup\install.py:
│def make_default_operations():
│	for operation in ["Assembly"]:
│		if not frappe.db.exists("Operation", operation):
│			doc = frappe.get_doc({"doctype": "Operation", "name": operation})
│			doc.flags.ignore_mandatory = True
│			doc.insert(ignore_permissions=True)
⋮...
│def setup_currency_exchange():
⋮...
│def create_marketgin_campagin_custom_fields():
⋮...
│def create_default_success_action():
│	for success_action in get_default_success_action():
│		if not frappe.db.exists("Success Action", success_action.get("ref_doctype")):
│			doc = frappe.get_doc(success_action)
│			doc.insert(ignore_permissions=True)
⋮...
│def create_default_energy_point_rules():
⋮...
│def add_standard_navbar_items():
⋮...
│def after_install():
⋮...
│def check_setup_wizard_not_completed():
│	if cint(frappe.db.get_single_value("System Settings", "setup_complete") or 0):
│		message = """ERPNext can only be installed on a fresh site where the setup wizard is not completed.
│You can reinstall this site (after saving your data) using: bench --site [sitename] reinstall"""
│		frappe.throw(message)  # nosemgrep
⋮...
│def set_single_defaults():
⋮...
│def create_print_setting_custom_fields():
⋮...
│def add_company_to_session_defaults():
│	settings = frappe.get_single("Session Default Settings")
│	settings.append("session_defaults", {"ref_doctype": "Company"})
│	settings.save()
⋮...
│def add_app_name():
│	frappe.db.set_single_value("System Settings", "app_name", "ERPNext")
⋮...
│def update_roles():
│	website_user_roles = ("Customer", "Supplier")
│	for role in website_user_roles:
│		frappe.db.set_value("Role", role, "desk_access", 0)
⋮...
│def create_default_role_profiles():
⋮...

erpnext\accounts\doctype\pos_profile\pos_profile.py:
│def get_child_nodes(group_type, root):
⋮...
│def get_item_groups(pos_profile):
⋮...
│class POSProfile(Document):
⋮...
│	def validate(self):
│		self.validate_default_profile()
│		self.validate_all_link_fields()
│		self.validate_duplicate_groups()
│		self.validate_payment_methods()
│		self.validate_accounting_dimensions()
⋮...
│	def validate_accounting_dimensions(self):
⋮...
│	def validate_default_profile(self):
⋮...
│	def validate_all_link_fields(self):
⋮...
│	def validate_duplicate_groups(self):
⋮...
│	def validate_payment_methods(self):
⋮...
│	def on_update(self):
│		self.set_defaults()
⋮...
│	def on_trash(self):
│		self.set_defaults(include_current_pos=False)
⋮...
│	def set_defaults(self, include_current_pos=True):
⋮...
│def get_permitted_nodes(group_type):
⋮...
│def pos_profile_query(doctype, txt, searchfield, start, page_len, filters):
⋮...
│def set_default_profile(pos_profile, company):
⋮...

erpnext\subcontracting\doctype\subcontracting_order\test_subcontracting_order.py:
│def create_subcontracting_order(**args):
⋮...
│class UnitTestSubcontractingOrder(UnitTestCase):
⋮...
│class TestSubcontractingOrder(IntegrationTestCase):
⋮...
│	def setUp(self):
│		make_subcontracted_items()
│		make_raw_materials()
│		make_service_items()
│		make_bom_for_subcontracted_items()
⋮...
│	def test_set_missing_values(self):
⋮...
│	def test_update_status(self):
⋮...
│	def test_make_rm_stock_entry(self):
⋮...
│	def test_make_rm_stock_entry_for_serial_items(self):
⋮...
│	def test_make_rm_stock_entry_for_batch_items(self):
⋮...
│	def test_make_rm_stock_entry_for_batch_items_with_less_transfer(self):
⋮...
│	def test_update_reserved_qty_for_subcontracting(self):
⋮...
│	def test_exploded_items(self):
⋮...
│	def test_backflush_based_on_stock_entry(self):
⋮...
│	def test_supplied_qty(self):
⋮...
│	def test_get_materials_from_supplier(self):
⋮...
│	def test_ordered_qty_for_subcontracting_order(self):
⋮...
│	def test_requested_qty_for_subcontracting_order(self):
⋮...
│	def test_subcontracting_order_rm_required_items_for_precision(self):
⋮...

erpnext\accounts\doctype\bank_transaction\test_auto_match_party.py:
│def create_supplier_for_match(supplier_name="John Doe & Co.", iban=None, account_no=None):
⋮...
│def create_bank_transaction(
│	description=None,
│	withdrawal=0,
│	deposit=0,
│	transaction_id=None,
│	party_name=None,
│	account_no=None,
│	iban=None,
│):
⋮...
│class UnitTestBankTransaction(UnitTestCase):
⋮...
│class TestAutoMatchParty(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		create_bank_account()
│		frappe.db.set_single_value("Accounts Settings", "enable_party_matching", 1)
│		frappe.db.set_single_value("Accounts Settings", "enable_fuzzy_matching", 1)
│		return super().setUpClass()
⋮...
│	def tearDownClass(cls):
│		frappe.db.set_single_value("Accounts Settings", "enable_party_matching", 0)
│		frappe.db.set_single_value("Accounts Settings", "enable_fuzzy_matching", 0)
⋮...
│	def test_match_by_account_number(self):
⋮...
│	def test_match_by_iban(self):
⋮...
│	def test_match_by_party_name(self):
⋮...
│	def test_match_by_description(self):
⋮...
│	def test_skip_match_if_multiple_close_results(self):
⋮...

erpnext\erpnext_integrations\doctype\plaid_settings\plaid_settings.py:
│def add_bank_accounts(response, bank, company):
⋮...
│def add_account_type(account_type):
│	try:
│		frappe.get_doc({"doctype": "Bank Account Type", "account_type": account_type}).insert()
│	except Exception:
│		frappe.throw(frappe.get_traceback())
⋮...
│def add_account_subtype(account_subtype):
│	try:
│		frappe.get_doc({"doctype": "Bank Account Subtype", "account_subtype": account_subtype}).insert()
│	except Exception:
│		frappe.throw(frappe.get_traceback())
⋮...
│def new_bank_transaction(transaction):
⋮...
│def get_company(bank_account_name):
⋮...
│class PlaidSettings(Document):
⋮...
│	def get_link_token():
│		plaid = PlaidConnector()
│		return plaid.get_link_token()
⋮...
│def get_plaid_configuration():
⋮...
│def add_institution(token, response):
⋮...
│def sync_transactions(bank, bank_account):
⋮...
│def get_transactions(bank, bank_account=None, start_date=None, end_date=None):
⋮...
│def automatic_synchronization():
│	settings = frappe.get_doc("Plaid Settings", "Plaid Settings")
│	if settings.enabled == 1 and settings.automatic_sync == 1:
│		enqueue_synchronization()
⋮...
│def enqueue_synchronization():
⋮...
│def get_link_token_for_update(access_token):
│	plaid = PlaidConnector(access_token)
│	return plaid.get_link_token(update_mode=True)
⋮...
│def update_bank_account_ids(response):
│	data = json.loads(response)
│	institution_name = data["institution"]["name"]
│	bank = frappe.get_doc("Bank", institution_name).as_dict()
│	bank_account_name = f"{data['account']['name']} - {institution_name}"
│	return add_bank_accounts(response, bank, get_company(bank_account_name))
⋮...

erpnext\accounts\doctype\invoice_discounting\test_invoice_discounting.py:
│def create_invoice_discounting(invoices, **args):
⋮...
│class TestInvoiceDiscounting(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_total_amount(self):
⋮...
│	def test_gl_entries_in_base_currency(self):
⋮...
│	def test_loan_on_submit(self):
⋮...
│	def test_on_disbursed(self):
⋮...
│	def test_on_close_after_loan_period(self):
⋮...
│	def test_on_close_after_loan_period_after_inv_payment(self):
⋮...
│	def test_on_close_before_loan_period(self):
⋮...
│	def test_make_payment_before_loan_period(self):
⋮...
│	def test_make_payment_before_after_period(self):
⋮...

erpnext\templates\pages\rfq.py:
│def get_context(context):
⋮...
│def check_supplier_has_docname_access(supplier):
⋮...
│def get_supplier():
│	doctype = frappe.form_dict.doctype
│	parties_doctype = "Request for Quotation Supplier" if doctype == "Request for Quotation" else doctype
│	customers, suppliers = get_customers_suppliers(parties_doctype, frappe.session.user)
│
│	return suppliers[0] if suppliers else ""
⋮...
│def unauthorized_user(supplier):
│	status = check_supplier_has_docname_access(supplier) or False
│	if status is False:
│		frappe.throw(_("Not Permitted"), frappe.PermissionError)
⋮...
│def update_supplier_details(context):
⋮...
│def get_link_quotation(supplier, rfq):
⋮...

erpnext\accounts\doctype\payment_ledger_entry\test_payment_ledger_entry.py:
│class UnitTestPaymentLedgerEntry(UnitTestCase):
⋮...
│class TestPaymentLedgerEntry(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.ple = qb.DocType("Payment Ledger Entry")
│		self.create_company()
│		self.create_item()
│		self.create_customer()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_company(self):
⋮...
│	def create_item(self):
│		item_name = "_Test PL Item"
│		item = create_item(
│			item_code=item_name, is_stock_item=0, company=self.company, warehouse=self.warehouse
│		)
│		self.item = item if isinstance(item, str) else item.item_code
⋮...
│	def create_customer(self):
⋮...
│	def create_sales_invoice(
│		self, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False
│	):
⋮...
│	def create_payment_entry(self, amount=100, posting_date=None):
⋮...
│	def create_sales_order(self, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False):
⋮...
│	def clear_old_entries(self):
⋮...
│	def create_journal_entry(self, acc1=None, acc2=None, amount=0, posting_date=None, cost_center=None):
⋮...
│	def test_payment_against_invoice(self):
⋮...
│	def test_partial_payment_against_invoice(self):
⋮...
│	def test_cr_note_against_invoice(self):
⋮...
│	def test_je_against_inv_and_note(self):
⋮...
│	def test_multi_payment_unlink_on_invoice_cancellation(self):
⋮...
│	def test_multi_je_unlink_on_invoice_cancellation(self):
⋮...
│	def test_advance_payment_unlink_on_order_cancellation(self):
⋮...

erpnext\accounts\doctype\bank_statement_import\bank_statement_import.py:
│def start_import(data_import, bank_account, import_file_path, google_sheets_url, bank, template_options):
⋮...
│class BankStatementImport(DataImport):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
⋮...
│	def validate(self):
⋮...
│	def start_import(self):
⋮...
│def get_preview_from_template(data_import, import_file=None, google_sheets_url=None):
│	return frappe.get_doc("Bank Statement Import", data_import).get_preview_from_template(
│		import_file, google_sheets_url
│	)
⋮...
│def form_start_import(data_import):
│	job_id = frappe.get_doc("Bank Statement Import", data_import).start_import()
│	return job_id is not None
⋮...
│def download_errored_template(data_import_name):
│	data_import = frappe.get_doc("Bank Statement Import", data_import_name)
│	data_import.export_errored_rows()
⋮...
│def download_import_log(data_import_name):
│	return frappe.get_doc("Bank Statement Import", data_import_name).download_import_log()
⋮...
│def parse_data_from_template(raw_data):
⋮...
│def update_mapping_db(bank, template_options):
⋮...
│def add_bank_account(data, bank_account):
⋮...
│def write_files(import_file, data):
⋮...
│def write_xlsx(data, sheet_name, wb=None, column_widths=None, file_path=None):
⋮...
│def get_import_status(docname):
⋮...
│def get_import_logs(docname: str):
⋮...
│def upload_bank_statement(**args):
⋮...

erpnext\accounts\doctype\accounting_dimension\test_accounting_dimension.py:
│def disable_dimension():
⋮...
│def create_dimension():
⋮...
│class TestAccountingDimension(IntegrationTestCase):
⋮...
│	def setUp(self):
│		create_dimension()
⋮...
│	def test_dimension_against_sales_invoice(self):
⋮...
│	def test_dimension_against_journal_entry(self):
⋮...
│	def test_mandatory(self):
⋮...
│	def tearDown(self):
│		disable_dimension()
│		frappe.flags.accounting_dimensions_details = None
│		frappe.flags.dimension_filter_map = None
⋮...

erpnext\templates\pages\order.py:
│def get_context(context):
⋮...
│def get_attachments(dt, dn):
│	return frappe.get_all(
│		"File",
│		fields=["name", "file_name", "file_url", "is_private"],
│		filters={"attached_to_name": dn, "attached_to_doctype": dt, "is_private": 0},
│	)
⋮...
│def get_payment_details(doc):
⋮...

erpnext\accounts\doctype\pos_closing_entry\pos_closing_entry.py:
│def make_closing_entry_from_opening(opening_entry):
⋮...
│class POSClosingEntry(StatusUpdater):
⋮...
│	def validate(self):
⋮...
│	def validate_duplicate_pos_invoices(self):
⋮...
│	def validate_pos_invoices(self):
⋮...
│	def get_payment_reconciliation_details(self):
│		currency = frappe.get_cached_value("Company", self.company, "default_currency")
│		return frappe.render_template(
│			"erpnext/accounts/doctype/pos_closing_entry/closing_voucher_details.html",
│			{"data": self, "currency": currency},
│		)
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
│		unconsolidate_pos_invoices(closing_entry=self)
⋮...
│	def retry(self):
│		consolidate_pos_invoices(closing_entry=self)
⋮...
│	def update_opening_entry(self, for_cancel=False):
│		opening_entry = frappe.get_doc("POS Opening Entry", self.pos_opening_entry)
│		opening_entry.pos_closing_entry = self.name if not for_cancel else None
│		opening_entry.set_status()
│		opening_entry.save()
⋮...
│def get_cashiers(doctype, txt, searchfield, start, page_len, filters):
│	cashiers_list = frappe.get_all("POS Profile User", filters=filters, fields=["user"], as_list=1)
│	return [c for c in cashiers_list]
⋮...
│def get_pos_invoices(start, end, pos_profile, user):
⋮...

erpnext\accounts\doctype\pos_profile\test_pos_profile.py:
│def make_pos_profile(**args):
⋮...
│class TestPOSProfile(IntegrationTestCase):
⋮...
│	def test_pos_profile(self):
⋮...
│def get_customers_list(pos_profile=None):
⋮...
│def get_items_list(pos_profile, company):
⋮...

erpnext\buying\utils.py:
│def check_on_hold_or_closed_status(doctype, docname) -> None:
│	status = frappe.db.get_value(doctype, docname, "status")
│
│	if status in ("Closed", "On Hold"):
│		frappe.throw(_("{0} {1} status is {2}").format(doctype, docname, status), frappe.InvalidStatusError)
⋮...
│def validate_for_items(doc) -> None:
⋮...
│def update_last_purchase_rate(doc, is_submit) -> None:
⋮...
│def set_stock_levels(row) -> None:
⋮...
│def validate_item_and_get_basic_data(row) -> dict:
⋮...
│def validate_stock_item_warehouse(row, item) -> None:
⋮...
│def get_linked_material_requests(items):
⋮...

erpnext\accounts\doctype\cost_center_allocation\cost_center_allocation.py:
│class MainCostCenterCantBeChild(frappe.ValidationError):
│	pass
⋮...
│class InvalidMainCostCenter(frappe.ValidationError):
│	pass
⋮...
│class InvalidChildCostCenter(frappe.ValidationError):
│	pass
⋮...
│class WrongPercentageAllocation(frappe.ValidationError):
│	pass
⋮...
│class InvalidDateError(frappe.ValidationError):
│	pass
⋮...
│class CostCenterAllocation(Document):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		self._skip_from_date_validation = False
⋮...
│	def validate(self):
⋮...
│	def validate_total_allocation_percentage(self):
│		total_percentage = sum([flt(d.percentage) for d in self.get("allocation_percentages", [])])
│
│		if total_percentage != 100:
│			frappe.throw(_("Total percentage against cost centers should be 100"), WrongPercentageAllocation)
⋮...
│	def validate_from_date_based_on_existing_gle(self):
⋮...
│	def validate_backdated_allocation(self):
⋮...
│	def validate_main_cost_center(self):
⋮...
│	def validate_child_cost_centers(self):
⋮...

erpnext\templates\pages\search_help.py:
│def get_context(context):
⋮...
│def get_help_results_sections(text):
⋮...
│def get_response(api, text):
│	response = requests.get(api.base_url + "/" + api.query_route, data={api.search_term_param_name: text})
│
│	response.raise_for_status()
│	return response.json()
⋮...
│def get_topics_data(api, response_json):
⋮...
│def prepare_api_results(api, topics_data):
⋮...
│def prepare_doctype_results(api, raw):
⋮...

erpnext\setup\doctype\employee\test_employee.py:
│def make_employee(user, company=None, **kwargs):
⋮...
│class TestEmployee(IntegrationTestCase):
⋮...
│	def test_employee_status_left(self):
⋮...
│	def test_user_has_employee(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...

erpnext\accounts\doctype\opening_invoice_creation_tool\opening_invoice_creation_tool.py:
│def get_temporary_opening_account(company=None):
⋮...
│def start_import(invoices):
⋮...
│class OpeningInvoiceCreationTool(Document):
⋮...
│	def onload(self):
│		"""Load the Opening Invoice summary"""
│		summary, max_count = self.get_opening_invoice_summary()
│		self.set_onload("opening_invoices_summary", summary)
│		self.set_onload("max_count", max_count)
│		self.set_onload("temporary_opening_account", get_temporary_opening_account(self.company))
⋮...
│	def get_opening_invoice_summary(self):
⋮...
│	def validate_company(self):
│		if not self.company:
│			frappe.throw(_("Please select the Company"))
⋮...
│	def set_missing_values(self, row):
⋮...
│	def validate_mandatory_invoice_fields(self, row):
⋮...
│	def get_invoices(self):
⋮...
│	def add_party(self, party_type, party):
⋮...
│	def get_invoice_dict(self, row=None):
⋮...
│	def make_invoices(self):
⋮...
│def publish(index, total, doctype):
⋮...

erpnext\accounts\doctype\bank_transaction\auto_match_party.py:
│class AutoMatchParty:
⋮...
│	def __init__(self, **kwargs) -> None:
│		self.__dict__.update(kwargs)
⋮...
│	def get(self, key):
│		return self.__dict__.get(key, None)
⋮...
│	def match(self) -> tuple | None:
⋮...
│class AutoMatchbyAccountIBAN:
⋮...
│	def __init__(self, **kwargs) -> None:
│		self.__dict__.update(kwargs)
⋮...
│	def get(self, key):
│		return self.__dict__.get(key, None)
⋮...
│	def match(self):
│		if not (self.bank_party_account_number or self.bank_party_iban):
│			return None
│
│		return self.match_account_in_party()
⋮...
│	def match_account_in_party(self) -> tuple | None:
⋮...
│	def get_or_filters(self, party: str | None = None) -> dict:
⋮...
│class AutoMatchbyPartyNameDescription:
⋮...
│	def __init__(self, **kwargs) -> None:
│		self.__dict__.update(kwargs)
⋮...
│	def get(self, key):
│		return self.__dict__.get(key, None)
⋮...
│	def match(self) -> tuple | None:
│		# fuzzy search by customer/supplier & employee
│		if not (self.bank_party_name or self.description):
│			return None
│
│		return self.match_party_name_desc_in_party()
⋮...
│	def match_party_name_desc_in_party(self) -> tuple | None:
⋮...
│	def fuzzy_search_and_return_result(self, party, names, field) -> tuple | None:
⋮...
│	def process_fuzzy_result(self, result: list | None):
⋮...
│def get_parties_in_order(deposit: float) -> list:
│	return (
│		["Customer", "Supplier", "Employee"]  # most -> least likely to pay us
│		if flt(deposit) > 0
│		else ["Supplier", "Employee", "Customer"]  # most -> least likely to receive from us
│	)
⋮...

erpnext\accounts\doctype\payment_ledger_entry\payment_ledger_entry.py:
│def on_doctype_update():
│	frappe.db.add_index("Payment Ledger Entry", ["against_voucher_no", "against_voucher_type"])
│	frappe.db.add_index("Payment Ledger Entry", ["voucher_no", "voucher_type"])
⋮...
│class PaymentLedgerEntry(Document):
⋮...
│	def validate_account(self):
⋮...
│	def validate_account_details(self):
⋮...
│	def validate_allowed_dimensions(self):
⋮...
│	def validate_dimensions_for_pl_and_bs(self):
⋮...
│	def validate(self):
│		self.validate_account()
⋮...
│	def on_update(self):
⋮...

erpnext\crm\doctype\appointment\appointment.py:
│class Appointment(Document):
⋮...
│	def find_lead_by_email(self):
⋮...
│	def find_customer_by_email(self):
⋮...
│	def before_insert(self):
⋮...
│	def after_insert(self):
⋮...
│	def send_confirmation_email(self):
⋮...
│	def on_change(self):
⋮...
│	def set_verified(self, email):
⋮...
│	def create_lead_and_link(self):
⋮...
│	def auto_assign(self):
⋮...
│	def get_assignee_from_latest_opportunity(self):
⋮...
│	def create_calendar_event(self):
⋮...
│	def _get_verify_url(self):
│		verify_route = "/book_appointment/verify"
│		params = {"email": self.customer_email, "appointment": self.name}
│		return get_url(verify_route + "?" + get_signed_params(params))
⋮...
│	def assign_agent(self, agent):
│		if not frappe.has_permission(doc=self, user=agent):
│			add_docshare(self.doctype, self.name, agent, flags={"ignore_share_permission": True})
│
│		add_assignment({"doctype": self.doctype, "name": self.name, "assign_to": [agent]})
⋮...
│def _get_agents_sorted_by_asc_workload(date):
⋮...
│def _get_agent_list_as_strings():
│	agent_list_as_strings = []
│	agent_list = frappe.get_doc("Appointment Booking Settings").agent_list
│	for agent in agent_list:
│		agent_list_as_strings.append(agent.user)
│	return agent_list_as_strings
⋮...
│def _check_agent_availability(agent_email, scheduled_time):
│	appointemnts_at_scheduled_time = frappe.get_all("Appointment", filters={"scheduled_time": scheduled_time})
│	for appointment in appointemnts_at_scheduled_time:
│		if appointment._assign == agent_email:
│			return False
│	return True
⋮...
│def _get_employee_from_user(user):
│	employee_docname = frappe.db.get_value("Employee", {"user_id": user})
│	if employee_docname:
│		return frappe.get_doc("Employee", employee_docname)
│	return None
⋮...

erpnext\accounts\report\gross_profit\test_gross_profit.py:
│class TestGrossProfit(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_company(self):
⋮...
│	def create_item(self):
│		item = create_item(
│			item_code="_Test GP Item", is_stock_item=1, company=self.company, warehouse=self.warehouse
│		)
│		self.item = item if isinstance(item, str) else item.item_code
⋮...
│	def create_bundle(self):
⋮...
│	def create_customer(self):
⋮...
│	def create_sales_invoice(
│		self, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False
│	):
⋮...
│	def create_delivery_note(
│		self, item=None, qty=1, rate=100, posting_date=None, do_not_save=False, do_not_submit=False
│	):
⋮...
│	def clear_old_entries(self):
⋮...
│	def test_invoice_without_only_delivery_note(self):
⋮...
│	def test_bundled_delivery_note_with_different_warehouses(self):
⋮...
│	def test_order_connected_dn_and_inv(self):
⋮...
│	def test_crnote_against_invoice_with_multiple_instances_of_same_item(self):
⋮...
│	def test_standalone_cr_notes(self):
⋮...
│	def test_different_rates_in_si_and_dn(self):
⋮...
│	def test_valuation_rate_without_previous_sle(self):
⋮...
│	def test_gross_profit_groupby_invoices(self):
⋮...

erpnext\stock\doctype\packing_slip\test_packing_slip.py:
│def create_items():
⋮...
│class UnitTestPackingSlip(UnitTestCase):
⋮...
│class TestPackingSlip(IntegrationTestCase):
⋮...
│	def test_packing_slip(self):
⋮...

erpnext\accounts\doctype\dunning\test_dunning.py:
│def create_dunning(overdue_days, dunning_type_name=None):
⋮...
│def create_dunning_type(title, fee, interest, is_default):
⋮...
│def get_income_account(company):
⋮...
│class UnitTestDunning(UnitTestCase):
⋮...
│class TestDunning(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		create_dunning_type("First Notice", fee=0.0, interest=0.0, is_default=1)
│		create_dunning_type("Second Notice", fee=10.0, interest=10.0, is_default=0)
│		unlink_payment_on_cancel_of_invoice()
⋮...
│	def tearDownClass(cls):
│		unlink_payment_on_cancel_of_invoice(0)
│		super().tearDownClass()
⋮...
│	def test_dunning_without_fees(self):
⋮...
│	def test_dunning_with_fees_and_interest(self):
⋮...
│	def test_dunning_with_payment_entry(self):
⋮...
│	def test_fetch_overdue_payments(self):
⋮...
│	def test_dunning_and_payment_against_partially_due_invoice(self):
⋮...
│def create_payment_terms_template_for_dunning():
⋮...

erpnext\stock\__init__.py:
│def get_warehouse_account_map(company=None):
⋮...
│def get_warehouse_account(warehouse, warehouse_account=None):
⋮...
│def get_company_default_inventory_account(company):
│	return frappe.get_cached_value("Company", company, "default_inventory_account")
⋮...

erpnext\manufacturing\doctype\routing\test_routing.py:
│def create_routing(**args):
⋮...
│def setup_bom(**args):
⋮...
│def setup_operations(rows):
⋮...
│class UnitTestRouting(UnitTestCase):
⋮...
│class TestRouting(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		cls.item_code = "Test Routing Item - A"
⋮...
│	def tearDownClass(cls):
│		frappe.db.sql("delete from tabBOM where item=%s", cls.item_code)
⋮...
│	def test_sequence_id(self):
⋮...
│	def test_update_bom_operation_time(self):
⋮...

erpnext\assets\doctype\asset_activity\asset_activity.py:
│def add_asset_activity(asset, subject):
⋮...
│class AssetActivity(Document):
⋮...

erpnext\stock\doctype\packed_item\test_packed_item.py:
│def create_product_bundle(
│	quantities: list[int] | None = None, warehouse: str | None = None
⋮...
│class UnitTestPackedItem(UnitTestCase):
⋮...
│class TestPackedItem(IntegrationTestCase):
⋮...
│	def setUpClass(cls) -> None:
⋮...
│	def test_adding_bundle_item(self):
⋮...
│	def test_updating_bundle_item(self):
⋮...
│	def test_recurring_bundle_item(self):
⋮...
│	def test_bundle_item_cumulative_price(self):
⋮...
│	def test_newly_mapped_doc_packed_items(self):
⋮...
│	def test_reposting_packed_items(self):
⋮...
│	def assertReturns(self, original, returned):
⋮...
│	def test_returning_full_bundles(self):
⋮...
│	def test_returning_partial_bundles(self):
⋮...
│	def test_returning_partial_bundle_qty(self):
⋮...

erpnext\stock\doctype\putaway_rule\putaway_rule.py:
│def add_row(item, to_allocate, warehouse, updated_table, rule=None):
⋮...
│def apply_putaway_rule(doctype, items, company, sync=None, purpose=None):
⋮...
│class PutawayRule(Document):
⋮...
│	def validate(self):
│		self.validate_duplicate_rule()
│		self.validate_warehouse_and_company()
│		self.validate_capacity()
│		self.validate_priority()
│		self.set_stock_capacity()
⋮...
│	def validate_duplicate_rule(self):
⋮...
│	def validate_priority(self):
│		if self.priority < 1:
│			frappe.throw(_("Priority cannot be lesser than 1."), title=_("Invalid Priority"))
⋮...
│	def validate_warehouse_and_company(self):
⋮...
│	def validate_capacity(self):
⋮...
│	def set_stock_capacity(self):
│		self.stock_capacity = (flt(self.conversion_factor) or 1) * flt(self.capacity)
⋮...
│def get_available_putaway_capacity(rule):
⋮...
│def _items_changed(old, new, doctype: str) -> bool:
⋮...
│def get_ordered_putaway_rules(item_code, company, source_warehouse=None):
⋮...
│def show_unassigned_items_message(items_not_accomodated):
⋮...

erpnext\stock\report\stock_ageing\test_stock_ageing.py:
│class TestStockAgeing(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
│		self.filters = frappe._dict(company="_Test Company", to_date="2021-12-10", ranges=["30", "60", "90"])
⋮...
│	def test_normal_inward_outward_queue(self):
⋮...
│	def test_insufficient_balance(self):
⋮...
│	def test_basic_stock_reconciliation(self):
⋮...
│	def test_sequential_stock_reco_same_warehouse(self):
⋮...
│	def test_sequential_stock_reco_different_warehouse(self):
⋮...
│	def test_repack_entry_same_item_split_rows(self):
⋮...
│	def test_repack_entry_same_item_overconsume(self):
⋮...
│	def test_repack_entry_same_item_overconsume_with_split_rows(self):
⋮...
│	def test_repack_entry_same_item_overproduce(self):
⋮...
│	def test_repack_entry_same_item_overproduce_with_split_rows(self):
⋮...
│	def test_negative_stock_same_voucher(self):
⋮...
│	def test_precision(self):
⋮...
│	def test_ageing_stock_valuation(self):
⋮...
│def generate_item_and_item_wh_wise_slots(filters, sle):
⋮...

erpnext\buying\doctype\supplier\supplier.py:
│class Supplier(TransactionBase):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
│		self.load_dashboard_info()
⋮...
│	def before_save(self):
│		if not self.on_hold:
│			self.hold_type = ""
│			self.release_date = ""
│		elif self.on_hold and not self.hold_type:
│			self.hold_type = "All"
⋮...
│	def load_dashboard_info(self):
│		info = get_dashboard_info(self.doctype, self.name)
│		self.set_onload("dashboard_info", info)
⋮...
│	def autoname(self):
⋮...
│	def on_update(self):
│		self.create_primary_contact()
│		self.create_primary_address()
⋮...
│	def add_role_for_user(self):
│		for portal_user in self.portal_users:
│			add_role_for_portal_user(portal_user, "Supplier")
⋮...
│	def _add_supplier_role(self, portal_user):
⋮...
│	def validate(self):
⋮...
│	def get_supplier_group_details(self):
⋮...
│	def validate_internal_supplier(self):
⋮...
│	def create_primary_contact(self):
⋮...
│	def create_primary_address(self):
⋮...
│	def on_trash(self):
⋮...
│	def after_rename(self, olddn, newdn, merge=False):
│		if frappe.defaults.get_global_default("supp_master_name") == "Supplier Name":
│			self.db_set("supplier_name", newdn)
⋮...
│def get_supplier_primary_contact(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\stock\doctype\repost_item_valuation\test_repost_item_valuation.py:
│class TestRepostItemValuation(IntegrationTestCase, StockTestMixin):
⋮...
│	def tearDown(self):
│		frappe.flags.dont_execute_stock_reposts = False
⋮...
│	def test_repost_time_slot(self):
⋮...
│	def test_clear_old_logs(self):
⋮...
│	def test_create_item_wise_repost_item_valuation_entries(self):
⋮...
│	def test_deduplication(self):
⋮...
│	def test_stock_freeze_validation(self):
⋮...
│	def test_prevention_of_cancelled_transaction_riv(self):
⋮...
│	def test_queue_progress_serialization(self):
│		# Make sure set/tuple -> list behaviour is retained.
│		self.assertEqual(
│			[["a", "b"], ["c", "d"]],
│			sorted(frappe.parse_json(frappe.as_json(set([("a", "b"), ("c", "d")])))),
│		)
⋮...
│	def test_gl_repost_progress(self):
⋮...
│	def test_gl_complete_gl_reposting(self):
⋮...
│	def test_duplicate_ple_on_repost(self):
⋮...
│	def test_account_freeze_validation(self):
⋮...
│	def test_create_repost_entry_for_cancelled_document(self):
⋮...
│	def test_repost_item_valuation_for_closing_stock_balance(self):
⋮...
│	def test_remove_attached_file(self):
⋮...

erpnext\accounts\doctype\bank_account\bank_account.py:
│def get_party_bank_account(party_type, party):
│	return frappe.db.get_value(
│		"Bank Account",
│		{"party_type": party_type, "party": party, "is_default": 1, "disabled": 0},
│		"name",
│	)
⋮...
│class BankAccount(Document):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
⋮...
│	def autoname(self):
│		self.name = self.account_name + " - " + self.bank
⋮...
│	def on_trash(self):
│		delete_contact_and_address("Bank Account", self.name)
⋮...
│	def validate(self):
│		self.validate_company()
│		self.validate_iban()
│		self.validate_account()
│		self.update_default_bank_account()
⋮...
│	def validate_account(self):
⋮...
│	def validate_company(self):
│		if self.is_company_account and not self.company:
│			frappe.throw(_("Company is mandatory for company account"))
⋮...
│	def validate_iban(self):
⋮...
│	def update_default_bank_account(self):
⋮...
│def make_bank_account(doctype, docname):
│	doc = frappe.new_doc("Bank Account")
│	doc.party_type = doctype
│	doc.party = docname
│
│	return doc
⋮...
│def get_default_company_bank_account(company, party_type, party):
⋮...
│def get_bank_account_details(bank_account):
│	return frappe.get_cached_value(
│		"Bank Account", bank_account, ["account", "bank", "bank_account_no"], as_dict=1
│	)
⋮...

erpnext\manufacturing\doctype\bom_update_log\bom_updation_utils.py:
│def set_values_in_log(log_name: str, values: dict[str, Any], commit: bool = False) -> None:
⋮...
│def handle_exception(doc: "BOMUpdateLog") -> None:
│	"Rolls back and fails BOM Update Log."
│
│	frappe.db.rollback()
│	error_log = doc.log_error("BOM Update Tool Error")
│	set_values_in_log(doc.name, {"status": "Failed", "error_log": error_log.name})
⋮...
│def get_ancestor_boms(new_bom: str, bom_list: list | None = None) -> list:
⋮...
│def replace_bom(boms: dict, log_name: str) -> None:
⋮...
│def update_cost_in_level(doc: "BOMUpdateLog", bom_list: list[str], batch_name: int | str) -> None:
⋮...
│def update_new_bom_in_bom_items(unit_cost: float, current_bom: str, new_bom: str) -> None:
⋮...
│def get_bom_unit_cost(bom_name: str) -> float:
⋮...
│def update_cost_in_boms(bom_list: list[str]) -> None:
⋮...
│def get_next_higher_level_boms(child_boms: list[str], processed_boms: dict[str, bool]) -> list[str]:
⋮...
│def get_leaf_boms() -> list[str]:
⋮...
│def _generate_dependence_map() -> defaultdict:
⋮...

erpnext\setup\doctype\item_group\test_item_group.py:
│class TestItem(IntegrationTestCase):
⋮...
│	def test_basic_tree(self, records=None):
⋮...
│	def test_recursion(self):
⋮...
│	def test_rebuild_tree(self):
│		rebuild_tree("Item Group")
│		self.test_basic_tree()
⋮...
│	def test_move_group_into_another(self):
⋮...
│	def test_move_group_into_root(self):
⋮...
│	def test_move_leaf_into_another_group(self):
⋮...
│	def test_delete_leaf(self):
⋮...
│	def test_delete_group(self):
│		# cannot delete group with child, but can delete leaf
│		self.assertRaises(NestedSetChildExistsError, frappe.delete_doc, "Item Group", "_Test Item Group B")
⋮...
│	def test_merge_groups(self):
⋮...
│	def test_merge_leaves(self):
⋮...
│	def test_merge_leaf_into_group(self):
⋮...
│	def test_merge_group_into_leaf(self):
⋮...
│	def _move_it_back(self):
│		group_b = frappe.get_doc("Item Group", "_Test Item Group B")
│		group_b.parent_item_group = "All Item Groups"
│		group_b.save()
│		self.test_basic_tree()
⋮...
│	def _get_no_of_children(self, item_group):
⋮...
│	def _print_tree(self):
│		import json
│
│		print(json.dumps(frappe.db.sql("select name, lft, rgt from `tabItem Group` order by lft"), indent=1))
⋮...

erpnext\accounts\doctype\share_transfer\share_transfer.py:
│class ShareDontExists(ValidationError):
│	pass
⋮...
│class ShareTransfer(Document):
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def validate(self):
⋮...
│	def basic_validations(self):
⋮...
│	def share_exists(self, shareholder):
⋮...
│	def folio_no_validation(self):
⋮...
│	def autoname_folio(self, shareholder, is_company=False):
⋮...
│	def remove_shares(self, shareholder):
⋮...
│	def return_share_balance_entry(self, from_no, to_no, rate):
⋮...
│	def get_shareholder_doc(self, shareholder):
⋮...
│	def get_company_shareholder(self):
⋮...
│def make_jv_entry(
│	company,
│	account,
│	amount,
│	payment_account,
│	credit_applicant_type,
│	credit_applicant,
│	debit_applicant_type,
│	debit_applicant,
│):
⋮...

erpnext\quality_management\doctype\quality_procedure\test_quality_procedure.py:
│def create_procedure(kwargs=None):
⋮...
│class UnitTestQualityProcedure(UnitTestCase):
⋮...
│class TestQualityProcedure(IntegrationTestCase):
⋮...
│	def test_add_node(self):
⋮...
│	def test_remove_parent_from_old_child(self):
⋮...
│	def remove_child_from_old_parent(self):
⋮...

erpnext\www\support\index.py:
│def get_context(context):
⋮...
│def get_favorite_articles_by_page_view():
⋮...
│def get_favorite_articles(favorite_articles):
⋮...
│def get_help_article_list():
⋮...

erpnext\stock\doctype\item_price\test_item_price.py:
│class UnitTestItemPrice(UnitTestCase):
⋮...
│class TestItemPrice(IntegrationTestCase):
⋮...
│	def setUp(self):
│		super().setUp()
│		frappe.db.sql("delete from `tabItem Price`")
│		make_test_records_for_doctype("Item Price", force=True)
⋮...
│	def test_template_item_price(self):
⋮...
│	def test_duplicate_item(self):
│		doc = frappe.copy_doc(self.globalTestRecords["Item Price"][0])
│		self.assertRaises(ItemPriceDuplicateItem, doc.save)
⋮...
│	def test_addition_of_new_fields(self):
⋮...
│	def test_dates_validation_error(self):
⋮...
│	def test_price_in_a_qty(self):
⋮...
│	def test_price_with_no_qty(self):
⋮...
│	def test_prices_at_date(self):
⋮...
│	def test_prices_at_invalid_date(self):
⋮...
│	def test_prices_outside_of_date(self):
⋮...
│	def test_lowest_price_when_no_date_provided(self):
⋮...
│	def test_invalid_item(self):
│		doc = frappe.copy_doc(self.globalTestRecords["Item Price"][1])
│		# Enter invalid item code
│		doc.item_code = "This is not an item code"
│		# Valid item codes must already exist
│		self.assertRaises(frappe.ValidationError, doc.save)
⋮...
│	def test_invalid_price_list(self):
│		doc = frappe.copy_doc(self.globalTestRecords["Item Price"][1])
│		# Check for invalid price list
│		doc.price_list = "This is not a price list"
│		# Valid price list must already exist
│		self.assertRaises(frappe.ValidationError, doc.save)
⋮...
│	def test_empty_duplicate_validation(self):
⋮...

erpnext\stock\doctype\serial_no\test_serial_no.py:
│def get_auto_serial_nos(kwargs):
⋮...
│class UnitTestSerialNo(UnitTestCase):
⋮...
│class TestSerialNo(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_cannot_create_direct(self):
⋮...
│	def test_inter_company_transfer(self):
⋮...
│	def test_inter_company_transfer_intermediate_cancellation(self):
⋮...
│	def test_inter_company_transfer_fallback_on_cancel(self):
⋮...
│	def test_correct_serial_no_incoming_rate(self):
⋮...
│	def test_auto_fetch(self):
⋮...

erpnext\accounts\doctype\promotional_scheme\test_promotional_scheme.py:
│def make_promotional_scheme(**args):
⋮...
│class TestPromotionalScheme(IntegrationTestCase):
⋮...
│	def setUp(self):
│		if frappe.db.exists("Promotional Scheme", "_Test Scheme"):
│			frappe.delete_doc("Promotional Scheme", "_Test Scheme")
⋮...
│	def test_promotional_scheme(self):
⋮...
│	def test_promotional_scheme_without_applicable_for(self):
⋮...
│	def test_change_applicable_for_in_promotional_scheme(self):
⋮...
│	def test_change_applicable_for_values_in_promotional_scheme(self):
⋮...
│	def test_min_max_amount_configuration(self):
⋮...
│	def test_pricing_rule_for_product_discount_slabs(self):
⋮...
│	def test_validation_on_recurse_with_mixed_condition(self):
⋮...

erpnext\setup\doctype\customer_group\customer_group.py:
│def on_doctype_update():
│	frappe.db.add_index("Customer Group", ["lft", "rgt"])
⋮...
│class CustomerGroup(NestedSet):
⋮...
│	def validate(self):
│		if not self.parent_customer_group:
│			self.parent_customer_group = get_root_of("Customer Group")
│		self.validate_currency_for_receivable_and_advance_account()
⋮...
│	def validate_currency_for_receivable_and_advance_account(self):
⋮...
│	def on_update(self):
│		super().on_update()
│		self.validate_one_root()
⋮...
│def get_parent_customer_groups(customer_group):
⋮...

erpnext\assets\doctype\asset_value_adjustment\asset_value_adjustment.py:
│class AssetValueAdjustment(Document):
⋮...
│	def validate(self):
│		self.validate_date()
│		self.set_current_asset_value()
│		self.set_difference_amount()
⋮...
│	def on_submit(self):
⋮...
│	def on_cancel(self):
⋮...
│	def validate_date(self):
⋮...
│	def set_difference_amount(self):
│		self.difference_amount = flt(self.new_asset_value - self.current_asset_value)
⋮...
│	def set_value_after_depreciation(self):
│		frappe.db.set_value("Asset", self.asset, "value_after_depreciation", self.new_asset_value)
⋮...
│	def set_current_asset_value(self):
│		if not self.current_asset_value and self.asset:
│			self.current_asset_value = get_asset_value_after_depreciation(self.asset, self.finance_book)
⋮...
│	def make_depreciation_entry(self):
⋮...
│	def update_asset(self, asset_value=None):
⋮...
│def get_value_of_accounting_dimensions(asset_name):
│	dimension_fields = [*frappe.get_list("Accounting Dimension", pluck="fieldname"), "cost_center"]
│	return frappe.db.get_value("Asset", asset_name, fieldname=dimension_fields, as_dict=True)
⋮...

erpnext\accounts\doctype\account\chart_of_accounts\chart_of_accounts.py:
│def get_chart(chart_template, existing_company=None):
⋮...
│def create_charts(
│	company, chart_template=None, existing_company=None, custom_chart=None, from_coa_importer=None
│):
⋮...
│def identify_is_group(child):
⋮...
│def build_account_tree(tree, parent, all_accounts):
⋮...
│def build_tree_from_json(chart_template, chart_data=None, from_coa_importer=False):
⋮...
│def add_suffix_if_duplicate(account_name, account_number, accounts):
⋮...
│def get_charts_for_country(country, with_standard=False):
⋮...
│def get_account_tree_from_existing_company(existing_company):
⋮...
│def validate_bank_account(coa, bank_account):
⋮...

erpnext\manufacturing\doctype\bom_update_log\bom_update_log.py:
│class BOMMissingError(frappe.ValidationError):
│	pass
⋮...
│class BOMUpdateLog(Document):
⋮...
│	def clear_old_logs(days=None):
⋮...
│	def validate(self):
⋮...
│	def validate_boms_are_specified(self):
⋮...
│	def validate_same_bom(self):
│		if cstr(self.current_bom) == cstr(self.new_bom):
│			frappe.throw(_("Current BOM and New BOM can not be same"))
⋮...
│	def validate_bom_items(self):
│		current_bom_item = frappe.db.get_value("BOM", self.current_bom, "item")
│		new_bom_item = frappe.db.get_value("BOM", self.new_bom, "item")
│
│		if current_bom_item != new_bom_item:
│			frappe.throw(_("The selected BOMs are not for the same item"))
⋮...
│	def validate_bom_cost_update_in_progress(self):
⋮...
│	def on_submit(self):
⋮...
│def run_replace_bom_job(
│	doc: "BOMUpdateLog",
⋮...
│def process_boms_cost_level_wise(
│	update_doc: "BOMUpdateLog", parent_boms: list[str] | None = None
⋮...
│def queue_bom_cost_jobs(current_boms_list: list[str], update_doc: "BOMUpdateLog", current_level: int) -> None:
⋮...
│def resume_bom_cost_update_jobs():
⋮...
│def get_processed_current_boms(
│	log: dict[str, Any], bom_batches: dict[str, Any]
⋮...

erpnext\stock\doctype\landed_cost_voucher\landed_cost_voucher.py:
│class LandedCostVoucher(Document):
⋮...
│	def get_items_from_purchase_receipts(self):
⋮...
│	def validate(self):
⋮...
│	def validate_line_items(self):
⋮...
│	def check_mandatory(self):
│		if not self.get("purchase_receipts"):
│			frappe.throw(_("Please enter Receipt Document"))
⋮...
│	def validate_receipt_documents(self):
⋮...
│	def set_total_taxes_and_charges(self):
│		self.total_taxes_and_charges = sum(flt(d.base_amount) for d in self.get("taxes"))
⋮...
│	def set_applicable_charges_on_item(self):
⋮...
│	def validate_applicable_charges_for_item(self):
⋮...
│	def on_submit(self):
│		self.validate_applicable_charges_for_item()
│		self.update_landed_cost()
⋮...
│	def on_cancel(self):
│		self.update_landed_cost()
⋮...
│	def update_landed_cost(self):
⋮...
│	def validate_asset_qty_and_status(self, receipt_document_type, receipt_document):
⋮...
│	def update_rate_in_serial_no_for_non_asset_items(self, receipt_document):
⋮...
│def get_pr_items(purchase_receipt):
⋮...

erpnext\support\report\issue_analytics\test_issue_analytics.py:
│def create_records():
⋮...
│class TestIssueAnalytics(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
⋮...
│	def test_issue_analytics(self):
⋮...
│	def compare_result_for_customer(self):
⋮...
│	def compare_result_for_issue_type(self):
⋮...
│	def compare_result_for_issue_priority(self):
⋮...
│	def compare_result_for_assignment(self):
⋮...
│def create_issue_types():
│	for entry in ["Bug", "Service Request", "Discomfort"]:
│		if not frappe.db.exists("Issue Type", entry):
│			frappe.get_doc({"doctype": "Issue Type", "__newname": entry}).insert()
⋮...

erpnext\accounts\doctype\shipping_rule\shipping_rule.py:
│class OverlappingConditionError(frappe.ValidationError):
│	pass
⋮...
│class FromGreaterThanToError(frappe.ValidationError):
│	pass
⋮...
│class ManyBlankToValuesError(frappe.ValidationError):
│	pass
⋮...
│class ShippingRule(Document):
⋮...
│	def validate(self):
│		self.validate_from_to_values()
│		self.sort_shipping_rule_conditions()
│		self.validate_overlapping_shipping_rule_conditions()
⋮...
│	def validate_from_to_values(self):
⋮...
│	def apply(self, doc):
⋮...
│	def get_shipping_amount_from_rules(self, value):
│		for condition in self.get("conditions"):
│			if not condition.to_value or (flt(condition.from_value) <= flt(value) <= flt(condition.to_value)):
│				return condition.shipping_amount
│
│		return 0.0
⋮...
│	def validate_countries(self, doc):
⋮...
│	def add_shipping_rule_to_tax_table(self, doc, shipping_amount):
⋮...
│	def sort_shipping_rule_conditions(self):
│		"""Sort Shipping Rule Conditions based on increasing From Value"""
│		self.shipping_rules_conditions = sorted(self.conditions, key=lambda d: flt(d.from_value))
│		for i, d in enumerate(self.conditions):
│			d.idx = i + 1
⋮...
│	def validate_overlapping_shipping_rule_conditions(self):
⋮...

erpnext\www\payment_setup_certification.py:
│def get_context(context):
│	if frappe.session.user != "Guest":
│		context.all_certifications = get_all_certifications_of_a_member()
│		context.show_sidebar = True
⋮...
│def get_all_certifications_of_a_member():
⋮...

erpnext\templates\pages\material_request_info.py:
│def get_context(context):
⋮...
│def get_more_items_info(items, material_request):
⋮...

erpnext\accounts\doctype\bisect_accounting_statements\bisect_accounting_statements.py:
│class BisectAccountingStatements(Document):
⋮...
│	def validate(self):
│		self.validate_dates()
⋮...
│	def validate_dates(self):
⋮...
│	def bfs(self, from_date: datetime, to_date: datetime):
⋮...
│	def dfs(self, from_date: datetime, to_date: datetime):
⋮...
│	def build_tree(self):
⋮...
│	def get_report_summary(self):
⋮...
│	def update_node(self):
⋮...
│	def current_node_has_summary_info(self):
│		"Assertion method"
│		return frappe.db.get_value("Bisect Nodes", self.current_node, "generated")
⋮...
│	def fetch_summary_info_from_current_node(self):
│		current_node = frappe.get_doc("Bisect Nodes", self.current_node)
│		self.p_l_summary = current_node.balance_sheet_summary
│		self.b_s_summary = current_node.profit_loss_summary
│		self.difference = abs(self.p_l_summary - self.b_s_summary)
⋮...
│	def fetch_or_calculate(self):
│		if self.current_node_has_summary_info():
│			self.fetch_summary_info_from_current_node()
│		else:
│			self.get_report_summary()
│			self.update_node()
⋮...
│	def bisect_left(self):
⋮...
│	def bisect_right(self):
⋮...
│	def move_up(self):
⋮...

erpnext\stock\doctype\stock_settings\stock_settings.py:
│class StockSettings(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_warehouses(self):
⋮...
│	def cant_change_valuation_method(self):
⋮...
│	def validate_clean_description_html(self):
⋮...
│	def validate_pending_reposts(self):
│		if self.stock_frozen_upto:
│			check_pending_reposting(self.stock_frozen_upto)
⋮...
│	def validate_stock_reservation(self):
⋮...
│	def on_update(self):
│		self.toggle_warehouse_field_for_inter_warehouse_transfer()
⋮...
│	def change_precision_for_for_sales(self):
⋮...
│	def change_precision_for_purchase(self):
⋮...
│	def make_property_setter_for_precision(doctypes):
⋮...
│	def toggle_warehouse_field_for_inter_warehouse_transfer(self):
⋮...
│def clean_all_descriptions():
│	for item in frappe.get_all("Item", ["name", "description"]):
│		if item.description:
│			clean_description = clean_html(item.description)
│		if item.description != clean_description:
│			frappe.db.set_value("Item", item.name, "description", clean_description)
⋮...
│def get_enable_stock_uom_editing():
⋮...

erpnext\assets\doctype\asset_depreciation_schedule\test_asset_depreciation_schedule.py:
│class UnitTestAssetDepreciationSchedule(UnitTestCase):
⋮...
│class TestAssetDepreciationSchedule(IntegrationTestCase):
⋮...
│	def setUp(self):
│		create_asset_data()
⋮...
│	def test_throw_error_if_another_asset_depr_schedule_exist(self):
⋮...
│	def test_daily_prorata_based_depr_on_sl_method(self):
⋮...
│	def test_schedule_for_slm_for_existing_asset_daily_pro_rata_enabled(self):
⋮...
│	def test_schedule_for_slm_for_existing_asset(self):
⋮...
│	def test_schedule_sl_method_for_existing_asset_with_frequency_of_3_months(self):
⋮...
│	def test_daily_prorata_based_depr_after_enabling_configuration(self):
⋮...
│	def test_for_daily_prorata_based_depreciation_wdv_method_frequency_3_months(self):
⋮...
│	def test_for_daily_prorata_based_depreciation_wdv_method_frequency_6_months(self):
⋮...
│	def test_for_daily_prorata_based_depreciation_wdv_method_frequency_12_months(self):
⋮...
│	def test_update_total_number_of_booked_depreciations(self):
⋮...
│	def test_schedule_for_wdv_method_for_existing_asset(self):
⋮...

erpnext\buying\doctype\supplier_scorecard_period\supplier_scorecard_period.py:
│def make_supplier_scorecard(source_name, target_doc=None):
⋮...
│def import_string_path(path):
│	components = path.split(".")
│	mod = __import__(components[0])
│	for comp in components[1:]:
│		mod = getattr(mod, comp)
│	return mod
⋮...
│class SupplierScorecardPeriod(Document):
⋮...
│	def validate(self):
│		self.validate_criteria_weights()
│		self.calculate_variables()
│		self.calculate_criteria()
│		self.calculate_score()
⋮...
│	def validate_criteria_weights(self):
⋮...
│	def calculate_variables(self):
⋮...
│	def calculate_criteria(self):
⋮...
│	def calculate_score(self):
│		myscore = 0
│		for crit in self.criteria:
│			myscore += crit.score * crit.weight / 100.0
│		self.total_score = myscore
⋮...
│	def calculate_weighted_score(self, weighing_function):
⋮...
│	def get_eval_statement(self, formula):
⋮...

erpnext\telephony\doctype\call_log\call_log.py:
│def get_employees_with_number(number):
⋮...
│class CallLog(Document):
⋮...
│	def validate(self):
│		deduplicate_dynamic_links(self)
⋮...
│	def before_insert(self):
⋮...
│	def after_insert(self):
│		self.trigger_call_popup()
⋮...
│	def on_update(self):
⋮...
│	def is_incoming_call(self):
│		return self.type == "Incoming"
⋮...
│	def add_link(self, link_type, link_name):
│		self.append("links", {"link_doctype": link_type, "link_name": link_name})
⋮...
│	def trigger_call_popup(self):
⋮...
│	def update_received_by(self):
│		if employees := get_employees_with_number(self.get("to")):
│			self.call_received_by = employees[0].get("name")
│			self.employee_user_id = employees[0].get("user_id")
⋮...
│def add_call_summary_and_call_type(call_log, summary, call_type):
│	doc = frappe.get_doc("Call Log", call_log)
│	doc.type_of_call = call_type
│	doc.save()
│	doc.add_comment("Comment", frappe.bold(_("Call Summary")) + "<br><br>" + summary)
⋮...
│def link_existing_conversations(doc, state):
⋮...
│def get_linked_call_logs(doctype, docname):
⋮...

erpnext\accounts\report\tax_withholding_details\test_tax_withholding_details.py:
│def create_tax_category(category="TCS", rate=0.075, account="TCS - _TC", cumulative_threshold=0):
⋮...
│class TestTaxWithholdingDetails(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.clear_old_entries()
│		create_tax_accounts()
⋮...
│	def test_tax_withholding_for_customers(self):
⋮...
│	def test_single_account_for_multiple_categories(self):
⋮...
│	def test_date_filters_in_multiple_tax_withholding_rules(self):
⋮...
│	def check_expected_values(self, result, expected_values):
⋮...
│	def tearDown(self):
│		self.clear_old_entries()
⋮...
│def create_tax_accounts():
⋮...
│def create_tcs_payment_entry():
⋮...
│def create_tcs_journal_entry():
⋮...

erpnext\stock\reorder_item.py:
│def reorder_item():
⋮...
│def get_email_list(company):
⋮...
│def _reorder_item():
⋮...
│def get_items_for_reorder() -> dict[str, list]:
⋮...
│def get_reorder_levels_for_variants(itemwise_reorder):
⋮...
│def get_item_warehouse_projected_qty(items_to_consider):
⋮...
│def create_material_request(material_requests):
⋮...
│def send_email_notification(company_wise_mr):
⋮...
│def get_comapny_wise_users(company):
⋮...
│def notify_errors(exceptions_list):
⋮...

erpnext\templates\pages\timelog_info.py:
│def get_context(context):
│	context.no_cache = 1
│
│	timelog = frappe.get_doc("Time Log", frappe.form_dict.timelog)
│
│	context.doc = timelog
⋮...

erpnext\www\book_appointment\verify\index.py:
│def get_context(context):
⋮...

erpnext\setup\setup_wizard\setup_wizard.py:
│def fin(args):
│	frappe.local.message_log = []
│	login_as_first_user(args)
⋮...
│def stage_fixtures(args):
│	fixtures.install(args.get("country"))
⋮...
│def setup_company(args):
│	fixtures.install_company(args)
⋮...
│def setup_defaults(args):
│	fixtures.install_defaults(frappe._dict(args))
⋮...
│def get_setup_stages(args=None):
⋮...
│def setup_demo(args):
│	if args.get("setup_demo"):
│		frappe.enqueue(setup_demo_data, enqueue_after_commit=True, at_front=True)
⋮...
│def login_as_first_user(args):
│	if args.get("email") and hasattr(frappe.local, "login_manager"):
│		frappe.local.login_manager.login_as(args.get("email"))
⋮...
│def setup_complete(args=None):
│	stage_fixtures(args)
│	setup_company(args)
│	setup_defaults(args)
│	fin(args)
⋮...

erpnext\stock\deprecated_serial_batch.py:
│class DeprecatedSerialNoValuation:
⋮...
│	def calculate_stock_value_from_deprecarated_ledgers(self):
⋮...
│	def get_filterd_serial_nos(self):
⋮...
│	def get_incoming_value_for_serial_nos(self, serial_nos):
⋮...
│def has_sle_for_serial_nos(item_code):
⋮...
│class DeprecatedBatchNoValuation:
⋮...
│	def calculate_avg_rate_from_deprecarated_ledgers(self):
│		entries = self.get_sle_for_batches()
│		for ledger in entries:
│			self.stock_value_differece[ledger.batch_no] += flt(ledger.batch_value)
│			self.available_qty[ledger.batch_no] += flt(ledger.batch_qty)
⋮...
│	def get_sle_for_batches(self):
⋮...
│	def calculate_avg_rate_for_non_batchwise_valuation(self):
⋮...
│	def set_balance_value_for_non_batchwise_valuation_batches(self):
│		self.last_sle = self.get_last_sle_for_non_batch()
│		self.set_balance_value_from_sl_entries()
│		self.set_balance_value_from_bundle()
⋮...
│	def set_balance_value_from_sl_entries(self) -> None:
⋮...
│	def get_last_sle_for_non_batch(self):
⋮...
│	def set_balance_value_from_bundle(self) -> None:
⋮...

erpnext\utilities\web_form\addresses\addresses.py:
│def get_context(context):
│	# do your magic here
│	context.show_sidebar = True
⋮...

erpnext\setup\doctype\currency_exchange\test_currency_exchange.py:
│def save_new_records(test_records):
⋮...
│def patched_requests_get(*args, **kwargs):
⋮...
│class TestCurrencyExchange(IntegrationTestCase):
⋮...
│	def clear_cache(self):
│		cache = frappe.cache()
│		for date in test_exchange_values.keys():
│			key = "currency_exchange_rate_{}:{}:{}".format(date, "USD", "INR")
│			cache.delete(key)
⋮...
│	def tearDown(self):
│		frappe.db.set_single_value("Accounts Settings", "allow_stale", 1)
│		self.clear_cache()
⋮...
│	def test_exchange_rate(self, mock_get):
⋮...
│	def test_exchange_rate_via_exchangerate_host(self, mock_get):
⋮...
│	def test_exchange_rate_strict(self, mock_get):
⋮...
│	def test_exchange_rate_strict_switched(self, mock_get):
⋮...

erpnext\accounts\notification\notification_for_new_fiscal_year\notification_for_new_fiscal_year.py:
│def get_context(context):
│	# do your magic here
│	pass
⋮...

erpnext\controllers\tests\test_qty_based_taxes.py:
│def uuid4():
│	return str(_uuid4())
⋮...
│class TestTaxes(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_taxes(self):
⋮...
│	def tearDown(self):
⋮...

erpnext\templates\pages\task_info.py:
│def get_context(context):
⋮...

erpnext\manufacturing\notification\material_request_receipt_notification\material_request_receipt_notification.py:
│def get_context(context):
│	# do your magic here
│	pass
⋮...

erpnext\selling\doctype\installation_note\installation_note.py:
│class InstallationNote(TransactionBase):
⋮...
│	def __init__(self, *args, **kwargs):
⋮...
│	def validate(self):
⋮...
│	def is_serial_no_added(self, item_code, serial_no):
│		has_serial_no = frappe.db.get_value("Item", item_code, "has_serial_no")
│		if has_serial_no == 1 and not serial_no:
│			frappe.throw(_("Serial No is mandatory for Item {0}").format(item_code))
│		elif has_serial_no != 1 and cstr(serial_no).strip():
│			frappe.throw(_("Item {0} is not a serialized Item").format(item_code))
⋮...
│	def is_serial_no_exist(self, item_code, serial_no):
│		for x in serial_no:
│			if not frappe.db.exists("Serial No", x):
│				frappe.throw(_("Serial No {0} does not exist").format(x))
⋮...
│	def get_prevdoc_serial_no(self, prevdoc_detail_docname):
│		serial_nos = frappe.db.get_value("Delivery Note Item", prevdoc_detail_docname, "serial_no")
│		return get_valid_serial_nos(serial_nos)
⋮...
│	def is_serial_no_match(self, cur_s_no, prevdoc_s_no, prevdoc_docname):
│		for sr in cur_s_no:
│			if sr not in prevdoc_s_no:
│				frappe.throw(
│					_("Serial No {0} does not belong to Delivery Note {1}").format(sr, prevdoc_docname)
│				)
⋮...
│	def validate_serial_no(self):
⋮...
│	def validate_installation_date(self):
⋮...
│	def check_item_table(self):
│		if not (self.get("items")):
│			frappe.throw(_("Please pull items from Delivery Note"))
⋮...
│	def on_update(self):
│		self.db_set("status", "Draft")
⋮...
│	def on_submit(self):
│		self.validate_serial_no()
│		self.update_prevdoc_status()
│		self.db_set("status", "Submitted")
⋮...
│	def on_cancel(self):
│		self.update_prevdoc_status()
│		self.db_set("status", "Cancelled")
⋮...

erpnext\accounts\doctype\unreconcile_payment\test_unreconcile_payment.py:
│class TestUnreconcilePayment(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_usd_receivable_account()
│		self.create_item()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_sales_invoice(self, do_not_submit=False):
⋮...
│	def create_payment_entry(self):
⋮...
│	def create_sales_order(self):
⋮...
│	def test_01_unreconcile_invoice(self):
⋮...
│	def test_02_unreconcile_one_payment_among_multi_payments(self):
⋮...
│	def test_03_unreconciliation_on_multi_currency_invoice(self):
⋮...
│	def test_04_unreconciliation_on_multi_currency_invoice(self):
⋮...
│	def test_05_unreconcile_order(self):
⋮...
│	def test_06_unreconcile_advance_from_payment_entry(self):
⋮...
│	def test_07_adv_from_so_to_invoice(self):
⋮...

erpnext\crm\doctype\contract\test_contract.py:
│class TestContract(IntegrationTestCase):
⋮...
│	def setUp(self):
│		frappe.db.sql("delete from `tabContract`")
│		self.contract_doc = get_contract()
⋮...
│	def test_validate_start_date_before_end_date(self):
│		self.contract_doc.start_date = nowdate()
│		self.contract_doc.end_date = add_days(nowdate(), -1)
│
│		self.assertRaises(frappe.ValidationError, self.contract_doc.insert)
⋮...
│	def test_unsigned_contract_status(self):
│		self.contract_doc.insert()
│		self.assertEqual(self.contract_doc.status, "Unsigned")
⋮...
│	def test_active_signed_contract_status(self):
⋮...
│	def test_past_inactive_signed_contract_status(self):
⋮...
│	def test_future_inactive_signed_contract_status(self):
⋮...
│	def test_contract_status_with_no_fulfilment_terms(self):
│		self.contract_doc.contract_term = "_Test Customer Contract"
│		self.contract_doc.insert()
│
│		self.assertEqual(self.contract_doc.fulfilment_status, "N/A")
⋮...
│	def test_unfulfilled_contract_status(self):
│		self.contract_doc.contract_term = "_Test Customer Contract with Requirements"
│		self.contract_doc.requires_fulfilment = 1
│		self.contract_doc.save()
│		self.assertEqual(self.contract_doc.fulfilment_status, "Unfulfilled")
⋮...
│	def test_fulfilled_contract_status(self):
⋮...
│	def test_partially_fulfilled_contract_status(self):
⋮...
│	def test_lapsed_contract_status(self):
⋮...
│def get_contract():
│	doc = frappe.new_doc("Contract")
│	doc.party_type = "Customer"
│	doc.party_name = "_Test Customer"
│	doc.contract_terms = "This is a test customer contract."
│	return doc
⋮...

erpnext\manufacturing\doctype\bom_update_tool\bom_update_tool.py:
│def enqueue_replace_bom(boms: dict | str | None = None, args: dict | str | None = None) -> "BOMUpdateLog":
⋮...
│def create_bom_update_log(
│	boms: dict[str, str] | None = None,
⋮...
│class BOMUpdateTool(Document):
⋮...
│def enqueue_update_cost() -> "BOMUpdateLog":
│	"""Returns a BOM Update Log (that queues a job) for BOM Cost Updation."""
│	update_log = create_bom_update_log(update_type="Update Cost")
│	return update_log
⋮...
│def auto_update_latest_price_in_all_boms() -> None:
⋮...
│def is_older_log(log: dict) -> bool:
│	no_of_days = date_diff(get_datetime(now()), get_datetime(log.creation))
│	return no_of_days > 10
⋮...

erpnext\utilities\doctype\video\video.py:
│def get_id_from_url(url):
⋮...
│def batch_update_youtube_data():
⋮...
│class Video(Document):
⋮...
│	def validate(self):
│		if self.provider == "YouTube" and is_tracking_enabled():
│			self.set_video_id()
│			self.set_youtube_statistics()
⋮...
│	def set_video_id(self):
│		if self.url and not self.get("youtube_video_id"):
│			self.youtube_video_id = get_id_from_url(self.url)
⋮...
│	def set_youtube_statistics(self):
⋮...
│def is_tracking_enabled():
│	return frappe.db.get_single_value("Video Settings", "enable_youtube_tracking")
⋮...
│def get_frequency(value):
⋮...
│def update_youtube_data():
⋮...
│def get_formatted_ids(video_list):
⋮...

erpnext\manufacturing\doctype\work_order_item\work_order_item.py:
│def on_doctype_update():
│	frappe.db.add_index("Work Order Item", ["item_code", "source_warehouse"])
⋮...
│class WorkOrderItem(Document):
⋮...

erpnext\assets\doctype\asset_category\asset_category.py:
│def get_asset_category_account(
│	fieldname, item=None, asset=None, account=None, asset_category=None, company=None
│):
⋮...
│class AssetCategory(Document):
⋮...
│	def validate(self):
│		self.validate_finance_books()
│		self.validate_account_types()
│		self.validate_account_currency()
│		self.valide_cwip_account()
⋮...
│	def validate_finance_books(self):
⋮...
│	def validate_account_currency(self):
⋮...
│	def validate_account_types(self):
⋮...
│	def valide_cwip_account(self):
⋮...

erpnext\setup\doctype\company\test_company.py:
│class TestCompany(IntegrationTestCase):
⋮...
│	def test_coa_based_on_existing_company(self):
⋮...
│	def test_coa_based_on_country_template(self):
⋮...
│	def delete_mode_of_payment(self, company):
│		frappe.db.sql(
│			""" delete from `tabMode of Payment Account`
│			where company =%s """,
│			(company),
│		)
⋮...
│	def test_basic_tree(self, records=None):
⋮...
│	def test_primary_address(self):
⋮...
│	def get_no_of_children(self, company):
⋮...
│	def test_change_parent_company(self):
⋮...
│	def test_demo_data(self):
⋮...
│def create_company_communication(doctype, docname):
⋮...
│def create_child_company():
⋮...
│def create_test_lead_in_company(company):
⋮...

erpnext\accounts\doctype\repost_accounting_ledger\test_repost_accounting_ledger.py:
│def update_repost_settings():
⋮...
│class TestRepostAccountingLedger(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		cls.enterClassContext(cls.change_settings("Selling Settings", validate_selling_price=0))
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
│		update_repost_settings()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_01_basic_functions(self):
⋮...
│	def test_02_deferred_accounting_valiations(self):
⋮...
│	def test_04_pcv_validation(self):
⋮...
│	def test_03_deletion_flag_and_preview_function(self):
⋮...
│	def test_05_without_deletion_flag(self):
⋮...
│	def test_06_repost_purchase_receipt(self):
⋮...

erpnext\crm\doctype\email_campaign\email_campaign.py:
│def send_mail(entry, email_campaign):
⋮...
│class EmailCampaign(Document):
⋮...
│	def validate(self):
⋮...
│	def set_date(self):
⋮...
│	def validate_lead(self):
│		lead_email_id = frappe.db.get_value("Lead", self.recipient, "email_id")
│		if not lead_email_id:
│			lead_name = frappe.db.get_value("Lead", self.recipient, "lead_name")
│			frappe.throw(_("Please set an email id for the Lead {0}").format(lead_name))
⋮...
│	def validate_email_campaign_already_exists(self):
⋮...
│	def update_status(self):
⋮...
│def send_email_to_leads_or_contacts():
⋮...
│def unsubscribe_recipient(unsubscribe, method):
│	if unsubscribe.reference_doctype == "Email Campaign":
│		frappe.db.set_value("Email Campaign", unsubscribe.reference_name, "status", "Unsubscribed")
⋮...
│def set_email_campaign_status():
│	email_campaigns = frappe.get_all("Email Campaign", filters={"status": ("!=", "Unsubscribed")})
│	for entry in email_campaigns:
│		email_campaign = frappe.get_doc("Email Campaign", entry.name)
│		email_campaign.update_status()
│		email_campaign.save()
⋮...

erpnext\selling\doctype\sales_order_item\sales_order_item.py:
│def on_doctype_update():
│	frappe.db.add_index("Sales Order Item", ["item_code", "warehouse"])
⋮...
│class SalesOrderItem(Document):
⋮...

erpnext\stock\doctype\material_request_item\material_request_item.py:
│def on_doctype_update():
│	frappe.db.add_index("Material Request Item", ["item_code", "warehouse"])
⋮...
│class MaterialRequestItem(Document):
⋮...

erpnext\startup\leaderboard.py:
│def parse_date_range(date_range):
│	if date_range:
│		date_range = frappe.parse_json(date_range)
│		return date_range[0], date_range[1]
│
│	return None, None
⋮...
│def get_leaderboards():
⋮...
│def get_all_customers(date_range, company, field, limit=None):
⋮...
│def get_all_items(date_range, company, field, limit=None):
⋮...
│def get_all_suppliers(date_range, company, field, limit=None):
⋮...
│def get_all_sales_partner(date_range, company, field, limit=None):
⋮...
│def get_all_sales_person(date_range, company, field=None, limit=0):
⋮...
│def get_date_condition(date_range, field):
⋮...

erpnext\assets\doctype\asset_maintenance\asset_maintenance.py:
│def calculate_next_due_date(
│	periodicity, start_date=None, end_date=None, last_completion_date=None, next_due_date=None
│):
⋮...
│class AssetMaintenance(Document):
⋮...
│	def validate(self):
⋮...
│	def on_update(self):
│		for task in self.get("asset_maintenance_tasks"):
│			assign_tasks(self.name, task.assign_to, task.maintenance_task, task.next_due_date)
│		self.sync_maintenance_tasks()
⋮...
│	def after_delete(self):
│		asset = frappe.get_doc("Asset", self.asset_name)
│		if asset.status == "In Maintenance":
│			asset.set_status()
⋮...
│	def sync_maintenance_tasks(self):
⋮...
│def assign_tasks(asset_maintenance_name, assign_to_member, maintenance_task, next_due_date):
⋮...
│def update_maintenance_log(asset_maintenance, item_code, item_name, task):
⋮...
│def get_team_members(doctype, txt, searchfield, start, page_len, filters):
│	return frappe.db.get_values(
│		"Maintenance Team Member", {"parent": filters.get("maintenance_team")}, "team_member"
│	)
⋮...
│def get_maintenance_log(asset_name):
⋮...

erpnext\assets\doctype\asset_shift_allocation\asset_shift_allocation.py:
│def find_subsets_with_sum(numbers, k, target_sum, current_subset, result):
⋮...
│class AssetShiftAllocation(Document):
⋮...
│	def after_insert(self):
│		self.fetch_and_set_depr_schedule()
⋮...
│	def validate(self):
│		self.asset_depr_schedule_doc = get_asset_depr_schedule_doc(self.asset, "Active", self.finance_book)
│
│		self.validate_invalid_shift_change()
│		self.update_depr_schedule()
⋮...
│	def on_submit(self):
│		self.create_new_asset_depr_schedule()
⋮...
│	def fetch_and_set_depr_schedule(self):
⋮...
│	def validate_invalid_shift_change(self):
⋮...
│	def update_depr_schedule(self):
⋮...
│	def allocate_shift_diff_in_depr_schedule(self):
⋮...
│	def create_new_asset_depr_schedule(self):
⋮...

erpnext\manufacturing\doctype\workstation\test_workstation.py:
│def make_workstation(*args, **kwargs):
⋮...
│class UnitTestWorkstation(UnitTestCase):
⋮...
│class TestWorkstation(IntegrationTestCase):
⋮...
│	def test_validate_timings(self):
⋮...
│	def test_update_bom_operation_rate(self):
⋮...

erpnext\buying\doctype\purchase_order_item\purchase_order_item.py:
│def on_doctype_update():
│	frappe.db.add_index("Purchase Order Item", ["item_code", "warehouse"])
⋮...
│class PurchaseOrderItem(Document):
⋮...

erpnext\accounts\doctype\dunning\dunning.py:
│class Dunning(AccountsController):
⋮...
│	def validate(self):
│		self.validate_same_currency()
│		self.validate_overdue_payments()
│		self.validate_totals()
│		self.set_party_details()
│		self.set_dunning_level()
⋮...
│	def validate_same_currency(self):
⋮...
│	def validate_overdue_payments(self):
│		daily_interest = self.rate_of_interest / 100 / 365
│
│		for row in self.overdue_payments:
│			row.overdue_days = (getdate(self.posting_date) - getdate(row.due_date)).days or 0
│			row.interest = row.outstanding * daily_interest * row.overdue_days
⋮...
│	def validate_totals(self):
│		self.total_outstanding = sum(row.outstanding for row in self.overdue_payments)
│		self.total_interest = sum(row.interest for row in self.overdue_payments)
│		self.dunning_amount = self.total_interest + self.dunning_fee
│		self.base_dunning_amount = self.dunning_amount * self.conversion_rate
│		self.grand_total = self.total_outstanding + self.dunning_amount
⋮...
│	def set_party_details(self):
⋮...
│	def set_dunning_level(self):
⋮...
│	def on_cancel(self):
⋮...
│def resolve_dunning(doc, state):
⋮...
│def get_linked_dunnings_as_per_state(sales_invoice, state):
⋮...
│def get_dunning_letter_text(dunning_type: str, doc: str | dict, language: str | None = None) -> dict:
⋮...

erpnext\accounts\doctype\bank_clearance\test_bank_clearance.py:
│def add_transactions():
│	make_payment_entry()
⋮...
│def make_payment_entry():
⋮...
│class TestBankClearance(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
⋮...
│	def test_bank_clearance(self):
⋮...
│	def test_bank_clearance_with_loan(self):
⋮...
│	def test_update_clearance_date_on_si(self):
⋮...
│def make_bank_account():
⋮...
│def make_pos_sales_invoice():
⋮...

erpnext\selling\report\sales_order_analysis\test_sales_order_analysis.py:
│class TestSalesOrderAnalysis(IntegrationTestCase):
⋮...
│	def create_sales_order(self, transaction_date, do_not_save=False, do_not_submit=False):
⋮...
│	def create_sales_invoice(self, so, do_not_save=False, do_not_submit=False):
⋮...
│	def create_delivery_note(self, so, do_not_save=False, do_not_submit=False):
⋮...
│	def test_01_so_to_deliver_and_bill(self):
⋮...
│	def test_02_so_to_deliver(self):
⋮...
│	def test_03_so_to_bill(self):
⋮...
│	def test_04_so_completed(self):
⋮...
│	def test_05_all_so_status(self):
⋮...
│	def test_06_so_pending_delivery_with_multiple_delivery_notes(self):
⋮...
│	def test_07_so_delivered_with_multiple_delivery_notes(self):
⋮...

erpnext\setup\setup_wizard\operations\taxes_setup.py:
│def make_taxes_and_charges_template(company_name, doctype, template):
⋮...
│def get_or_create_account(company_name, account):
⋮...
│def setup_taxes_and_charges(company_name: str, country: str):
⋮...
│def simple_to_detailed(templates):
⋮...
│def from_detailed_data(company_name, data):
⋮...
│def update_regional_tax_settings(country, company):
⋮...
│def make_item_tax_template(company_name, template):
⋮...
│def get_or_create_tax_group(company_name, root_type):
⋮...
│def make_tax_category(tax_category):
⋮...

erpnext\crm\doctype\prospect\test_prospect.py:
│def make_address(**args):
⋮...
│class TestProspect(IntegrationTestCase):
⋮...
│	def test_add_lead_to_prospect_and_address_linking(self):
⋮...
│	def test_make_customer_from_prospect(self):
⋮...
│def make_prospect(**args):
⋮...

erpnext\manufacturing\doctype\bom_update_log\test_bom_update_log.py:
│def update_cost_in_all_boms_in_test():
⋮...
│class UnitTestBomUpdateLog(UnitTestCase):
⋮...
│class TestBOMUpdateLog(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_bom_update_log_validate(self):
⋮...
│	def test_bom_update_log_completion(self):
│		"Test if BOM Update Log handles job completion correctly."
│
│		log = enqueue_replace_bom(boms=self.boms)
│		log.reload()
│		self.assertEqual(log.status, "Completed")
⋮...
│	def test_bom_replace_for_root_bom(self):
⋮...
│def remove_bom(item_code):
⋮...

erpnext\bulk_transaction\doctype\bulk_transaction_log\bulk_transaction_log.py:
│def serialize_transaction_log(data):
⋮...
│class BulkTransactionLog(Document):
⋮...
│	def db_insert(self, *args, **kwargs):
│		pass
⋮...
│	def load_from_db(self):
⋮...
│	def get_list(args):
⋮...
│	def get_count(args):
│		pass
⋮...
│	def get_stats(args):
│		pass
⋮...
│	def db_update(self, *args, **kwargs):
│		pass
⋮...
│	def delete(self):
│		pass
⋮...
│def parse_list_filters(args):
⋮...

erpnext\accounts\doctype\pos_invoice_merge_log\test_pos_invoice_merge_log.py:
│class UnitTestPosInvoiceMergeLog(UnitTestCase):
⋮...
│class TestPOSInvoiceMergeLog(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		cls.enterClassContext(cls.change_settings("Selling Settings", validate_selling_price=0))
⋮...
│	def test_consolidated_invoice_creation(self):
⋮...
│	def test_consolidated_credit_note_creation(self):
⋮...
│	def test_consolidated_invoice_item_taxes(self):
⋮...
│	def test_consolidation_round_off_error_1(self):
⋮...
│	def test_consolidation_round_off_error_2(self):
⋮...
│	def test_consolidation_round_off_error_3(self):
⋮...
│	def test_consolidation_rounding_adjustment(self):
⋮...
│	def test_serial_no_case_1(self):
⋮...

erpnext\stock\report\stock_analytics\test_stock_analytics.py:
│def stock_analytics(filters):
│	col, data, *_ = execute(filters)
│	return col, data
⋮...
│class TestStockAnalyticsReport(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
│		self.item = make_item().name
│		self.warehouse = "_Test Warehouse - _TC"
⋮...
│	def assert_single_item_report(self, movement, expected_buckets):
⋮...
│	def generate_stock(self, movement):
│		for qty, posting_date in movement:
│			args = {"item": self.item, "qty": abs(qty), "posting_date": posting_date}
│			args["to_warehouse" if qty > 0 else "from_warehouse"] = self.warehouse
│			make_stock_entry(**args)
⋮...
│	def compare_analytics_row(self, report_row, columns, expected_buckets):
⋮...
│	def test_get_period_date_ranges(self):
⋮...
│	def test_get_period_date_ranges_yearly(self):
⋮...
│	def test_basic_report_functionality(self):
⋮...
│	def test_empty_month_in_between(self):
⋮...
│	def test_multi_month_missings(self):
⋮...

erpnext\accounts\doctype\process_statement_of_accounts\test_process_statement_of_accounts.py:
│def create_process_soa(**args):
⋮...
│class TestProcessStatementOfAccounts(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		cls.enterClassContext(cls.change_settings("Selling Settings", validate_selling_price=0))
⋮...
│	def setUp(self):
⋮...
│	def test_process_soa_for_gl(self):
⋮...
│	def test_process_soa_for_ar(self):
⋮...
│	def test_auto_email_for_process_soa_ar(self):
⋮...
│	def check_ageing_summary(self, ageing, expected_ageing):
│		for age_range in expected_ageing:
│			self.assertEqual(expected_ageing[age_range], ageing.get(age_range))
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...

erpnext\buying\doctype\supplier_scorecard\test_supplier_scorecard.py:
│def make_supplier_scorecard():
⋮...
│def delete_test_scorecards():
⋮...
│class UnitTestSupplierScorecard(UnitTestCase):
⋮...
│class TestSupplierScorecard(IntegrationTestCase):
⋮...
│	def test_create_scorecard(self):
│		doc = make_supplier_scorecard().insert()
│		self.assertEqual(doc.name, valid_scorecard[0].get("supplier"))
⋮...
│	def test_criteria_weight(self):
│		delete_test_scorecards()
│		my_doc = make_supplier_scorecard()
│		for d in my_doc.criteria:
│			d.weight = 0
│		self.assertRaises(frappe.ValidationError, my_doc.insert)
⋮...

erpnext\maintenance\doctype\maintenance_visit\maintenance_visit.py:
│class MaintenanceVisit(TransactionBase):
⋮...
│	def validate_serial_no(self):
│		for d in self.get("purposes"):
│			if d.serial_no and not frappe.db.exists("Serial No", d.serial_no):
│				frappe.throw(_("Serial No {0} does not exist").format(d.serial_no))
⋮...
│	def validate_purpose_table(self):
│		if not self.purposes:
│			frappe.throw(_("Add Items in the Purpose Table"), title=_("Purposes Required"))
⋮...
│	def validate_maintenance_date(self):
⋮...
│	def validate(self):
│		self.validate_serial_no()
│		self.validate_maintenance_date()
│		self.validate_purpose_table()
⋮...
│	def update_status_and_actual_date(self, cancel=False):
⋮...
│	def update_customer_issue(self, flag):
⋮...
│	def check_if_last_visit(self):
⋮...
│	def on_submit(self):
│		self.update_customer_issue(1)
│		self.db_set("status", "Submitted")
│		self.update_status_and_actual_date()
⋮...
│	def on_cancel(self):
│		self.check_if_last_visit()
│		self.db_set("status", "Cancelled")
│		self.update_status_and_actual_date(cancel=True)
⋮...
│	def on_update(self):
│		pass
⋮...

erpnext\assets\doctype\asset_maintenance\test_asset_maintenance.py:
│def set_depreciation_settings_in_company():
⋮...
│class TestAssetMaintenance(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_create_asset_maintenance_with_log(self):
⋮...
│def get_maintenance_tasks():
⋮...

erpnext\subcontracting\doctype\subcontracting_bom\subcontracting_bom.py:
│def get_subcontracting_boms_for_finished_goods(fg_items: str | list) -> dict:
⋮...
│class SubcontractingBOM(Document):
⋮...
│	def validate(self):
│		self.validate_finished_good()
│		self.validate_service_item()
│		self.validate_is_active()
⋮...
│	def before_save(self):
│		self.set_conversion_factor()
⋮...
│	def validate_finished_good(self):
⋮...
│	def validate_service_item(self):
⋮...
│	def validate_is_active(self):
⋮...
│	def set_conversion_factor(self):
│		self.conversion_factor = flt(self.service_item_qty) / flt(self.finished_good_qty)
⋮...
│def get_subcontracting_boms_for_service_item(service_item: str) -> dict:
⋮...

erpnext\stock\doctype\stock_entry_type\stock_entry_type.py:
│class StockEntryType(Document):
⋮...
│	def validate(self):
│		self.validate_standard_type()
│		if self.add_to_transit and self.purpose != "Material Transfer":
│			self.add_to_transit = 0
⋮...
│	def validate_standard_type(self):
⋮...
│class ManufactureEntry:
⋮...
│	def __init__(self, kwargs) -> None:
│		for key, value in kwargs.items():
│			setattr(self, key, value)
⋮...
│	def make_stock_entry(self):
⋮...
│	def prepare_source_warehouse(self):
⋮...
│	def add_raw_materials(self):
⋮...
│	def get_items_from_job_card(self):
⋮...
│	def add_finished_good(self):
⋮...

erpnext\assets\doctype\asset_value_adjustment\test_asset_value_adjustment.py:
│def make_asset_value_adjustment(**args):
⋮...
│class TestAssetValueAdjustment(IntegrationTestCase):
⋮...
│	def setUp(self):
│		create_asset_data()
│		frappe.db.set_value(
│			"Company", "_Test Company", "capital_work_in_progress_account", "CWIP Account - _TC"
│		)
⋮...
│	def test_current_asset_value(self):
⋮...
│	def test_asset_depreciation_value_adjustment(self):
⋮...
│	def test_depreciation_after_cancelling_asset_repair(self):
⋮...
│	def test_difference_amount(self):
⋮...
│def make_difference_account(**args):
⋮...

erpnext\tests\utils.py:
│def if_lending_app_installed(function):
⋮...
│def execute_script_report(
│	report_name: ReportName,
⋮...
│def create_test_contact_and_address():
⋮...
│def if_lending_app_not_installed(function):
⋮...

erpnext\accounts\doctype\sales_invoice_item\sales_invoice_item.py:
│class SalesInvoiceItem(Document):
⋮...
│	def validate_cost_center(self, company: str):
⋮...
│	def set_actual_qty(self):
⋮...
│	def set_income_account_for_fixed_asset(self, company: str):
⋮...

erpnext\stock\tests\test_utils.py:
│class StockTestMixin:
⋮...
│	def make_item(self, item_code=None, properties=None, *args, **kwargs):
│		from erpnext.stock.doctype.item.test_item import make_item
│
│		return make_item(item_code, properties, *args, **kwargs)
⋮...
│	def assertSLEs(self, doc, expected_sles, sle_filters=None):
⋮...
│	def assertGLEs(self, doc, expected_gles, gle_filters=None, order_by=None):
⋮...
│class TestStockUtilities(IntegrationTestCase, StockTestMixin):
⋮...
│	def test_barcode_scanning(self):
⋮...

erpnext\accounts\doctype\repost_payment_ledger\repost_payment_ledger.py:
│def repost_ple_for_voucher(voucher_type, voucher_no, gle_map=None):
│	if voucher_type and voucher_no and gle_map:
│		_delete_pl_entries(voucher_type, voucher_no)
│		create_payment_ledger_entry(gle_map, cancel=0)
⋮...
│def start_payment_ledger_repost(docname=None):
⋮...
│class RepostPaymentLedger(Document):
⋮...
│	def __init__(self, *args, **kwargs):
│		super().__init__(*args, **kwargs)
│		self.vouchers = []
⋮...
│	def before_validate(self):
│		self.load_vouchers_based_on_filters()
│		self.set_status()
⋮...
│	def load_vouchers_based_on_filters(self):
│		if not self.add_manually:
│			self.repost_vouchers.clear()
│			self.get_vouchers()
│			self.extend("repost_vouchers", copy.deepcopy(self.vouchers))
⋮...
│	def get_vouchers(self):
⋮...
│	def set_status(self):
│		if self.docstatus == 0:
│			self.repost_status = "Queued"
⋮...
│	def on_submit(self):
│		execute_repost_payment_ledger(self.name)
│		frappe.msgprint(_("Repost started in the background"))
⋮...
│def execute_repost_payment_ledger(docname):
⋮...

erpnext\stock\doctype\item_price\item_price.py:
│class ItemPriceDuplicateItem(frappe.ValidationError):
│	pass
⋮...
│class ItemPrice(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_item(self):
⋮...
│	def update_price_list_details(self):
⋮...
│	def update_item_details(self):
│		if self.item_code:
│			self.item_name, self.item_description = frappe.db.get_value(
│				"Item", self.item_code, ["item_name", "description"]
│			)
⋮...
│	def validate_item_template(self):
│		if frappe.get_cached_value("Item", self.item_code, "has_variants"):
│			msg = f"Item Price cannot be created for the template item {bold(self.item_code)}"
│
│			frappe.throw(_(msg))
⋮...
│	def check_duplicates(self):
⋮...
│	def before_save(self):
⋮...

erpnext\edi\doctype\code_list\code_list.py:
│class CodeList(Document):
⋮...
│	def on_trash(self):
│		if not frappe.flags.in_bulk_delete:
│			self.__delete_linked_docs()
⋮...
│	def __delete_linked_docs(self):
⋮...
│	def get_codes_for(self, doctype: str, name: str) -> tuple[str]:
│		"""Get the applicable codes for a doctype and name"""
│		return get_codes_for(self.name, doctype, name)
⋮...
│	def get_docnames_for(self, doctype: str, code: str) -> tuple[str]:
│		"""Get the mapped docnames for a doctype and code"""
│		return get_docnames_for(self.name, doctype, code)
⋮...
│	def get_default_code(self) -> str | None:
⋮...
│	def from_genericode(self, root: "Element"):
⋮...
│def get_codes_for(code_list: str, doctype: str, name: str) -> tuple[str]:
⋮...
│def get_docnames_for(code_list: str, doctype: str, code: str) -> tuple[str]:
⋮...
│def get_default_code(code_list: str) -> str | None:
│	"""Return the default common code for a given code list"""
│	code_id = frappe.db.get_value("Code List", code_list, "default_common_code")
│	return frappe.db.get_value("Common Code", code_id, "common_code") if code_id else None
⋮...

erpnext\assets\doctype\asset_movement\test_asset_movement.py:
│def create_asset_movement(**args):
⋮...
│class TestAssetMovement(IntegrationTestCase):
⋮...
│	def setUp(self):
│		frappe.db.set_value(
│			"Company", "_Test Company", "capital_work_in_progress_account", "CWIP Account - _TC"
│		)
│		create_asset_data()
│		make_location()
⋮...
│	def test_movement(self):
⋮...
│	def test_last_movement_cancellation(self):
⋮...
│def make_location():
│	for location in ["Pune", "Mumbai", "Nagpur"]:
│		if not frappe.db.exists("Location", location):
│			frappe.get_doc({"doctype": "Location", "location_name": location}).insert(ignore_permissions=True)
⋮...

erpnext\setup\doctype\brand\brand.py:
│def get_brand_defaults(item, company):
⋮...
│class Brand(Document):
⋮...

erpnext\selling\report\sales_person_target_variance_based_on_item_group\test_sales_person_target_variance_based_on_item_group.py:
│def create_sales_target_doc(
│	sales_field_dt, sales_field_name, sales_field_value, fiscal_year, distribution_id
│):
⋮...
│def create_target_distribution(fiscal_year):
│	distribution = frappe.new_doc("Monthly Distribution")
│	distribution.distribution_id = "Target Report Distribution"
│	distribution.fiscal_year = fiscal_year
│	distribution.get_months()
│	return distribution.insert()
⋮...
│class TestSalesPersonTargetVarianceBasedOnItemGroup(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.fiscal_year = get_fiscal_year(nowdate())[0]
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_achieved_target_and_variance(self):
⋮...

erpnext\accounts\doctype\fiscal_year\fiscal_year.py:
│class FiscalYear(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_dates(self):
⋮...
│	def on_update(self):
│		check_duplicate_fiscal_year(self)
│		frappe.cache().delete_value("fiscal_years")
⋮...
│	def on_trash(self):
│		frappe.cache().delete_value("fiscal_years")
⋮...
│	def validate_overlap(self):
⋮...
│def check_duplicate_fiscal_year(doc):
⋮...
│def auto_create_fiscal_year():
⋮...
│def get_from_and_to_date(fiscal_year):
│	fields = ["year_start_date", "year_end_date"]
│	cached_results = frappe.get_cached_value("Fiscal Year", fiscal_year, fields, as_dict=1)
│	return dict(from_date=cached_results.year_start_date, to_date=cached_results.year_end_date)
⋮...

erpnext\accounts\doctype\advance_payment_ledger_entry\test_advance_payment_ledger_entry.py:
│class TestAdvancePaymentLedgerEntry(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_usd_receivable_account()
│		self.create_usd_payable_account()
│		self.create_item()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_sales_order(self, qty=1, rate=100, currency="INR", do_not_submit=False):
⋮...
│	def create_purchase_order(self, qty=1, rate=100, currency="INR", do_not_submit=False):
⋮...
│	def test_so_advance_paid_and_currency_with_payment(self):
⋮...
│	def test_so_advance_paid_and_currency_with_journal(self):
⋮...
│	def test_po_advance_paid_and_currency_with_payment(self):
⋮...
│	def test_po_advance_paid_and_currency_with_journal(self):
⋮...

erpnext\stock\doctype\stock_reposting_settings\stock_reposting_settings.py:
│def create_repost_item_valuation(item_code, warehouse, posting_date):
⋮...
│class StockRepostingSettings(Document):
⋮...
│	def validate(self):
│		self.set_minimum_reposting_time_slot()
⋮...
│	def before_save(self):
│		if self.do_reposting_for_each_stock_transaction:
│			self.item_based_reposting = 1
⋮...
│	def set_minimum_reposting_time_slot(self):
⋮...
│	def convert_to_item_wh_reposting(self):
⋮...
│def get_reposting_entries():
│	return frappe.get_all(
│		"Repost Item Valuation",
│		fields=["voucher_no", "name"],
│		filters={"status": ("in", ["Queued", "In Progress"]), "docstatus": 1, "based_on": "Transaction"},
│	)
⋮...
│def get_stock_ledgers(vouchers):
│	return frappe.get_all(
│		"Stock Ledger Entry",
│		fields=["item_code", "warehouse", "posting_date"],
│		filters={"voucher_no": ("in", vouchers)},
│	)
⋮...

erpnext\stock\doctype\item_attribute\item_attribute.py:
│class ItemAttributeIncrementError(frappe.ValidationError):
│	pass
⋮...
│class ItemAttribute(Document):
⋮...
│	def validate(self):
│		frappe.flags.attribute_values = None
│		self.validate_numeric()
│		self.validate_duplication()
⋮...
│	def on_update(self):
│		self.validate_exising_items()
│		self.set_enabled_disabled_in_items()
⋮...
│	def set_enabled_disabled_in_items(self):
⋮...
│	def validate_exising_items(self):
⋮...
│	def validate_numeric(self):
⋮...
│	def validate_duplication(self):
⋮...

erpnext\buying\doctype\supplier_scorecard_criteria\supplier_scorecard_criteria.py:
│def _get_variables(criteria):
⋮...
│class InvalidFormulaVariable(frappe.ValidationError):
│	pass
⋮...
│class SupplierScorecardCriteria(Document):
⋮...
│	def validate(self):
│		self.validate_variables()
│		self.validate_formula()
⋮...
│	def validate_variables(self):
│		# make sure all the variables exist
│		_get_variables(self)
⋮...
│	def validate_formula(self):
⋮...
│def get_criteria_list():
⋮...
│def get_variables(criteria_name):
│	criteria = frappe.get_doc("Supplier Scorecard Criteria", criteria_name)
│	return _get_variables(criteria)
⋮...

erpnext\accounts\doctype\pos_invoice_item\pos_invoice_item.py:
│class POSInvoiceItem(SalesInvoiceItem):
⋮...

erpnext\accounts\doctype\pos_opening_entry\test_pos_opening_entry.py:
│def create_opening_entry(pos_profile, user):
⋮...
│class TestPOSOpeningEntry(IntegrationTestCase):
│	pass
⋮...

erpnext\assets\doctype\asset_maintenance_log\asset_maintenance_log.py:
│class AssetMaintenanceLog(Document):
⋮...
│	def validate(self):
⋮...
│	def on_submit(self):
│		if self.maintenance_status not in ["Completed", "Cancelled"]:
│			frappe.throw(_("Maintenance Status has to be Cancelled or Completed to Submit"))
│		self.update_maintenance_task()
⋮...
│	def update_maintenance_task(self):
⋮...
│def update_asset_maintenance_log_status():
⋮...
│def get_maintenance_tasks(doctype, txt, searchfield, start, page_len, filters):
│	asset_maintenance_tasks = frappe.db.get_values(
│		"Asset Maintenance Task", {"parent": filters.get("asset_maintenance")}, "maintenance_task"
│	)
│	return asset_maintenance_tasks
⋮...

erpnext\erpnext_integrations\doctype\plaid_settings\plaid_connector.py:
│class PlaidConnector:
⋮...
│	def __init__(self, access_token=None):
⋮...
│	def get_access_token(self, public_token):
│		if public_token is None:
│			frappe.log_error("Plaid: Public token is missing")
│		response = self.client.Item.public_token.exchange(public_token)
│		access_token = response["access_token"]
│		return access_token
⋮...
│	def get_token_request(self, update_mode=False):
⋮...
│	def get_link_token(self, update_mode=False):
⋮...
│	def get_transactions(self, start_date, end_date, account_id=None):
⋮...

erpnext\setup\setup_wizard\operations\defaults_setup.py:
│def get_fy_details(fy_start_date, fy_end_date):
⋮...
│def set_default_settings(args):
⋮...
│def set_no_copy_fields_in_variant_settings():
│	# set no copy fields of an item doctype to item variant settings
│	doc = frappe.get_doc("Item Variant Settings")
│	doc.set_default_fields()
│	doc.save()
⋮...
│def create_price_lists(args):
⋮...
│def create_employee_for_self(args):
⋮...
│def create_territories():
⋮...
│def create_feed_and_todo():
│	"""update Activity feed and create todo for creation of item, customer, vendor"""
│	return
⋮...

erpnext\accounts\test\test_utils.py:
│class TestUtils(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		make_test_objects("Address", ADDRESS_RECORDS)
⋮...
│	def tearDownClass(cls):
│		frappe.db.rollback()
⋮...
│	def test_get_party_shipping_address(self):
│		address = get_party_shipping_address("Customer", "_Test Customer 1")
│		self.assertEqual(address, "_Test Billing Address 2 Title-Billing")
⋮...
│	def test_get_party_shipping_address2(self):
│		address = get_party_shipping_address("Customer", "_Test Customer 2")
│		self.assertEqual(address, "_Test Shipping Address 2 Title-Shipping")
⋮...
│	def test_get_voucher_wise_gl_entry(self):
⋮...
│	def test_stock_voucher_sorting(self):
⋮...
│	def test_update_reference_in_payment_entry(self):
⋮...
│	def test_naming_series_variable_parsing(self):
⋮...

erpnext\accounts\report\deferred_revenue_and_expense\test_deferred_revenue_and_expense.py:
│class TestDeferredRevenueAndExpense(IntegrationTestCase, AccountsTestMixin):
⋮...
│	def clear_old_entries(self):
⋮...
│	def setup_deferred_accounts_and_items(self):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer("_Test Customer")
│		self.create_supplier("_Test Furniture Supplier")
│		self.setup_deferred_accounts_and_items()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_deferred_revenue(self):
⋮...
│	def test_deferred_expense(self):
⋮...
│	def test_zero_months(self):
⋮...
│	def test_zero_amount(self):
⋮...

erpnext\accounts\doctype\exchange_rate_revaluation\test_exchange_rate_revaluation.py:
│class TestExchangeRateRevaluation(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def set_system_and_company_settings(self):
⋮...
│	def test_01_revaluation_of_forex_balance(self):
⋮...
│	def test_02_accounts_only_with_base_currency_balance(self):
⋮...
│	def test_03_accounts_only_with_account_currency_balance(self):
⋮...
│	def test_04_get_account_details_function(self):
⋮...

erpnext\selling\report\payment_terms_status_for_sales_order\test_payment_terms_status_for_sales_order.py:
│class TestPaymentTermsStatusForSalesOrder(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_payment_terms_template(self):
⋮...
│	def test_01_payment_terms_status(self):
⋮...
│	def create_exchange_rate(self, date):
⋮...
│	def test_02_alternate_currency(self):
⋮...
│	def test_03_group_filters(self):
⋮...
│	def test_04_due_date_filter(self):
⋮...

erpnext\accounts\doctype\sales_taxes_and_charges_template\sales_taxes_and_charges_template.py:
│def valdiate_taxes_and_charges_template(doc):
⋮...
│class SalesTaxesandChargesTemplate(Document):
⋮...
│	def validate(self):
│		valdiate_taxes_and_charges_template(self)
⋮...
│	def autoname(self):
│		if self.company and self.title:
│			abbr = frappe.get_cached_value("Company", self.company, "abbr")
│			self.name = f"{self.title} - {abbr}"
⋮...
│	def set_missing_values(self):
│		for data in self.taxes:
│			if data.charge_type == "On Net Total" and flt(data.rate) == 0.0:
│				data.rate = frappe.get_cached_value("Account", data.account_head, "tax_rate")
⋮...
│def validate_disabled(doc):
│	if doc.is_default and doc.disabled:
│		frappe.throw(_("Disabled template must not be default template"))
⋮...
│def validate_for_tax_category(doc):
⋮...

erpnext\accounts\doctype\ledger_health\test_ledger_health.py:
│class TestLedgerHealth(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.configure_monitoring_tool()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def configure_monitoring_tool(self):
⋮...
│	def clear_old_entries(self):
│		super().clear_old_entries()
│		lh = qb.DocType("Ledger Health")
│		qb.from_(lh).delete().run()
⋮...
│	def create_journal(self):
⋮...
│	def test_debit_credit_mismatch(self):
⋮...
│	def test_gl_and_pl_mismatch(self):
⋮...

erpnext\accounts\doctype\unreconcile_payment\unreconcile_payment.py:
│class UnreconcilePayment(Document):
⋮...
│	def validate(self):
│		self.supported_types = ["Payment Entry", "Journal Entry"]
│		if self.voucher_type not in self.supported_types:
│			frappe.throw(_("Only {0} are supported").format(comma_and(self.supported_types)))
⋮...
│	def get_allocations_from_payment(self):
⋮...
│	def add_references(self):
│		allocations = self.get_allocations_from_payment()
│
│		for alloc in allocations:
│			self.append("allocations", alloc)
⋮...
│	def on_submit(self):
⋮...
│def doc_has_references(doctype: str | None = None, docname: str | None = None):
⋮...
│def get_linked_payments_for_doc(
│	company: str | None = None, doctype: str | None = None, docname: str | None = None
⋮...
│def create_unreconcile_doc_for_selection(selections=None):
⋮...

erpnext\setup\default_success_action.py:
│def get_message(doctype):
│	# Properly format the string with translated doctype
│	return _("{0} has been submitted successfully").format(doctype)
⋮...
│def get_first_success_message(doctype):
│	# Reuse the get_message function for consistency
│	return get_message(doctype)
⋮...
│def get_default_success_action():
⋮...

erpnext\accounts\report\customer_ledger_summary\test_customer_ledger_summary.py:
│class TestCustomerLedgerSummary(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_sales_invoice(self, do_not_submit=False, **args):
⋮...
│	def create_payment_entry(self, docname, do_not_submit=False):
⋮...
│	def create_credit_note(self, docname, do_not_submit=False):
⋮...
│	def test_ledger_summary_basic_output(self):
⋮...
│	def test_summary_with_return_and_payment(self):
⋮...

erpnext\support\doctype\warranty_claim\warranty_claim.py:
│def make_maintenance_visit(source_name, target_doc=None):
⋮...
│class WarrantyClaim(TransactionBase):
⋮...
│	def validate(self):
⋮...
│	def on_cancel(self):
⋮...
│	def on_update(self):
│		pass
⋮...

erpnext\stock\doctype\price_list\price_list.py:
│class PriceList(Document):
⋮...
│	def validate(self):
│		if not cint(self.buying) and not cint(self.selling):
│			throw(_("Price List must be applicable for Buying or Selling"))
⋮...
│	def on_update(self):
│		self.set_default_if_missing()
│		self.update_item_price()
│		self.delete_price_list_details_key()
⋮...
│	def set_default_if_missing(self):
⋮...
│	def update_item_price(self):
│		frappe.db.sql(
│			"""update `tabItem Price` set currency=%s,
│			buying=%s, selling=%s, modified=NOW() where price_list=%s""",
│			(self.currency, cint(self.buying), cint(self.selling), self.name),
│		)
⋮...
│	def on_trash(self):
⋮...
│	def delete_price_list_details_key(self):
│		frappe.cache().hdel("price_list_details", self.name)
⋮...
│def get_price_list_details(price_list):
⋮...

erpnext\accounts\doctype\pricing_rule_detail\pricing_rule_detail.py:
│class PricingRuleDetail(Document):
⋮...

erpnext\assets\doctype\asset_movement\asset_movement.py:
│class AssetMovement(Document):
⋮...
│	def validate(self):
│		self.validate_asset()
│		self.validate_location()
│		self.validate_employee()
⋮...
│	def validate_asset(self):
⋮...
│	def validate_location(self):
⋮...
│	def validate_employee(self):
⋮...
│	def on_submit(self):
│		self.set_latest_location_and_custodian_in_asset()
⋮...
│	def on_cancel(self):
│		self.set_latest_location_and_custodian_in_asset()
⋮...
│	def set_latest_location_and_custodian_in_asset(self):
⋮...

erpnext\controllers\tests\test_item_variant.py:
│def make_item_variant():
⋮...
│class TestItemVariant(IntegrationTestCase):
│	def test_tables_in_template_copied_to_variant(self):
│		fields = [{"field_name": "quality_inspection_template"}]
│		set_item_variant_settings(fields)
│		variant = make_item_variant()
│		self.assertEqual(variant.get("quality_inspection_template"), "_Test QC Template")
⋮...
│	def test_tables_in_template_copied_to_variant(self):
│		fields = [{"field_name": "quality_inspection_template"}]
│		set_item_variant_settings(fields)
│		variant = make_item_variant()
│		self.assertEqual(variant.get("quality_inspection_template"), "_Test QC Template")
⋮...
│def create_variant_with_tables(item, args):
⋮...
│def make_quality_inspection_template():
⋮...

erpnext\setup\doctype\holiday_list\test_holiday_list.py:
│def make_holiday_list(name, from_date=None, to_date=None, holiday_dates=None):
⋮...
│class TestHolidayList(IntegrationTestCase):
⋮...
│	def test_holiday_list(self):
⋮...
│	def test_weekly_off(self):
⋮...
│	def test_local_holidays(self):
⋮...
│	def test_localized_country_names(self):
⋮...
│def set_holiday_list(holiday_list, company_name):
⋮...

erpnext\accounts\report\profit_and_loss_statement\test_profit_and_loss_statement.py:
│class TestProfitAndLossStatement(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_sales_invoice(self, qty=1, rate=150, no_payment_schedule=False, do_not_submit=False):
⋮...
│	def get_fiscal_year(self):
│		active_fy = frappe.db.get_all(
│			"Fiscal Year",
│			filters={"disabled": 0, "year_start_date": ("<=", today()), "year_end_date": (">=", today())},
│		)[0]
│		return frappe.get_doc("Fiscal Year", active_fy.name)
⋮...
│	def get_report_filters(self):
⋮...
│	def test_profit_and_loss_output_and_summary(self):
⋮...
│	def test_p_and_l_export(self):
⋮...

erpnext\accounts\doctype\accounting_dimension_filter\test_accounting_dimension_filter.py:
│class TestAccountingDimensionFilter(unittest.TestCase):
⋮...
│	def setUp(self):
│		create_dimension()
│		create_accounting_dimension_filter()
│		self.invoice_list = []
⋮...
│	def test_allowed_dimension_validation(self):
⋮...
│	def test_mandatory_dimension_validation(self):
⋮...
│	def tearDown(self):
⋮...
│def create_accounting_dimension_filter():
⋮...
│def disable_dimension_filter():
⋮...

erpnext\manufacturing\doctype\operation\test_operation.py:
│def make_operation(*args, **kwargs):
⋮...
│class TestOperation(IntegrationTestCase):
│	pass
⋮...

erpnext\buying\doctype\supplier_scorecard_criteria\test_supplier_scorecard_criteria.py:
│def delete_test_scorecards():
⋮...
│class UnitTestSupplierScorecardCriteria(UnitTestCase):
⋮...
│class TestSupplierScorecardCriteria(IntegrationTestCase):
⋮...
│	def test_variables_exist(self):
│		delete_test_scorecards()
│		for d in test_good_criteria:
│			frappe.get_doc(d).insert()
│
│		self.assertRaises(frappe.ValidationError, frappe.get_doc(test_bad_criteria[0]).insert)
⋮...
│	def test_formula_validate(self):
│		delete_test_scorecards()
│		self.assertRaises(frappe.ValidationError, frappe.get_doc(test_bad_criteria[1]).insert)
│		self.assertRaises(frappe.ValidationError, frappe.get_doc(test_bad_criteria[2]).insert)
⋮...

erpnext\erpnext_integrations\doctype\plaid_settings\test_plaid_settings.py:
│class TestPlaidSettings(IntegrationTestCase):
⋮...
│	def setUp(self):
│		pass
⋮...
│	def tearDown(self):
⋮...
│	def test_plaid_disabled(self):
│		frappe.db.set_single_value("Plaid Settings", "enabled", 0)
│		self.assertTrue(get_plaid_configuration() == "disabled")
⋮...
│	def test_add_account_type(self):
│		add_account_type("brokerage")
│		self.assertEqual(frappe.get_doc("Bank Account Type", "brokerage").name, "brokerage")
⋮...
│	def test_add_account_subtype(self):
│		add_account_subtype("loan")
│		self.assertEqual(frappe.get_doc("Bank Account Subtype", "loan").name, "loan")
⋮...
│	def test_new_transaction(self):
⋮...

erpnext\accounts\doctype\shipping_rule\test_shipping_rule.py:
│def create_shipping_rule(shipping_rule_type, shipping_rule_name):
⋮...
│class TestShippingRule(IntegrationTestCase):
⋮...
│	def test_from_greater_than_to(self):
│		shipping_rule = frappe.copy_doc(self.globalTestRecords["Shipping Rule"][0])
│		shipping_rule.name = self.globalTestRecords["Shipping Rule"][0].get("name")
│		shipping_rule.get("conditions")[0].from_value = 101
│		self.assertRaises(FromGreaterThanToError, shipping_rule.insert)
⋮...
│	def test_many_zero_to_values(self):
│		shipping_rule = frappe.copy_doc(self.globalTestRecords["Shipping Rule"][0])
│		shipping_rule.name = self.globalTestRecords["Shipping Rule"][0].get("name")
│		shipping_rule.get("conditions")[0].to_value = 0
│		self.assertRaises(ManyBlankToValuesError, shipping_rule.insert)
⋮...
│	def test_overlapping_conditions(self):
⋮...

erpnext\accounts\doctype\accounting_dimension_filter\accounting_dimension_filter.py:
│def get_dimension_filter_map():
⋮...
│class AccountingDimensionFilter(Document):
⋮...
│	def before_save(self):
│		# If restriction is not applied on values, then remove all the dimensions and set allow_or_restrict to Restrict
│		if not self.apply_restriction_on_values:
│			self.allow_or_restrict = "Restrict"
│			self.set("dimensions", [])
⋮...
│	def validate(self):
│		self.validate_applicable_accounts()
⋮...
│	def validate_applicable_accounts(self):
⋮...
│def build_map(map_object, dimension, account, filter_value, allow_or_restrict, is_mandatory):
⋮...

erpnext\quality_management\doctype\quality_goal\test_quality_goal.py:
│def get_quality_goal():
⋮...
│class TestQualityGoal(IntegrationTestCase):
│	def test_quality_goal(self):
│		# no code, just a basic sanity check
│		goal = get_quality_goal()
│		self.assertTrue(goal)
│		goal.delete()
⋮...
│	def test_quality_goal(self):
│		# no code, just a basic sanity check
│		goal = get_quality_goal()
│		self.assertTrue(goal)
│		goal.delete()
⋮...

erpnext\accounts\doctype\currency_exchange_settings\currency_exchange_settings.py:
│def get_api_endpoint(service_provider: str | None = None, use_http: bool = False):
⋮...
│class CurrencyExchangeSettings(Document):
⋮...
│	def validate(self):
│		self.set_parameters_and_result()
│		if frappe.flags.in_test or frappe.flags.in_install or frappe.flags.in_setup_wizard:
│			return
│		response, value = self.validate_parameters()
│		self.validate_result(response, value)
⋮...
│	def set_parameters_and_result(self):
⋮...
│	def validate_parameters(self):
⋮...
│	def validate_result(self, response, value):
⋮...

erpnext\accounts\doctype\loyalty_point_entry\test_loyalty_point_entry.py:
│class TestLoyaltyPointEntry(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
⋮...
│	def tearDownClass(cls):
│		# Delete all Loyalty Point Entries
│		frappe.db.sql("DELETE FROM `tabLoyalty Point Entry` WHERE customer = %s", cls.customer_name)
│		frappe.db.sql("DELETE FROM `tabSales Invoice` WHERE customer = %s", cls.customer_name)
│		frappe.db.commit()
⋮...
│	def create_test_invoice(self, redeem=None):
⋮...
│	def test_add_loyalty_points(self):
│		self.create_test_invoice()
│		doc = frappe.get_last_doc("Loyalty Point Entry")
│		self.assertEqual(doc.loyalty_points, 10)
⋮...
│	def test_add_loyalty_points_with_discretionary_reason(self):
⋮...
│	def test_redeem_loyalty_points(self):
⋮...

erpnext\accounts\doctype\accounting_period\test_accounting_period.py:
│def create_accounting_period(**args):
⋮...
│class TestAccountingPeriod(IntegrationTestCase):
⋮...
│	def test_overlap(self):
⋮...
│	def test_accounting_period(self):
│		ap1 = create_accounting_period(period_name="Test Accounting Period 2")
│		ap1.save()
│
│		doc = create_sales_invoice(do_not_save=1, cost_center="_Test Company - _TC", warehouse="Stores - _TC")
│		self.assertRaises(ClosedAccountingPeriod, doc.save)
⋮...
│	def tearDown(self):
│		for d in frappe.get_all("Accounting Period"):
│			frappe.delete_doc("Accounting Period", d.name)
⋮...

erpnext\accounts\doctype\subscription_plan\subscription_plan.py:
│def get_plan_rate(
│	plan, quantity=1, customer=None, start_date=None, end_date=None, prorate_factor=1, party=None
│):
⋮...
│class SubscriptionPlan(Document):
⋮...
│	def validate(self):
│		self.validate_interval_count()
⋮...
│	def validate_interval_count(self):
│		if self.billing_interval_count < 1:
│			frappe.throw(_("Billing Interval Count cannot be less than 1"))
⋮...
│def get_prorate_factor(start_date, end_date):
⋮...

erpnext\selling\doctype\party_specific_item\test_party_specific_item.py:
│def create_party_specific_item(**args):
⋮...
│class UnitTestPartySpecificItem(UnitTestCase):
⋮...
│class TestPartySpecificItem(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.customer = frappe.get_last_doc("Customer")
│		self.supplier = frappe.get_last_doc("Supplier")
│		self.item = frappe.get_last_doc("Item")
⋮...
│	def test_item_query_for_customer(self):
⋮...
│	def test_item_query_for_supplier(self):
⋮...

erpnext\accounts\doctype\party_link\party_link.py:
│def create_party_link(primary_role, primary_party, secondary_party):
⋮...
│class PartyLink(Document):
⋮...
│	def validate(self):
⋮...

erpnext\crm\doctype\utils.py:
│def strip_number(number):
⋮...
│def get_last_interaction(contact=None, lead=None):
⋮...
│def get_last_issue_from_customer(customer_name):
⋮...
│def get_scheduled_employees_for_popup(communication_medium):
⋮...

erpnext\support\doctype\issue_priority\test_issue_priority.py:
│def insert_priority(name):
│	if not frappe.db.exists("Issue Priority", name):
│		frappe.get_doc({"doctype": "Issue Priority", "name": name}).insert(ignore_permissions=True)
⋮...
│def make_priorities():
│	insert_priority("Low")
│	insert_priority("Medium")
│	insert_priority("High")
⋮...
│class TestIssuePriority(IntegrationTestCase):
⋮...
│	def test_priorities(self):
│		make_priorities()
│		priorities = frappe.get_list("Issue Priority")
│
│		for priority in priorities:
│			self.assertIn(priority.name, ["Low", "Medium", "High"])
⋮...

erpnext\assets\doctype\depreciation_schedule\depreciation_schedule.py:
│class DepreciationSchedule(Document):
⋮...

erpnext\crm\report\opportunity_summary_by_sales_stage\test_opportunity_summary_by_sales_stage.py:
│class TestOpportunitySummaryBySalesStage(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		create_company()
│		create_customer()
│		create_opportunity()
⋮...
│	def test_opportunity_summary_by_sales_stage(self):
│		self.check_for_opportunity_owner()
│		self.check_for_source()
│		self.check_for_opportunity_type()
│		self.check_all_filters()
⋮...
│	def check_for_opportunity_owner(self):
⋮...
│	def check_for_source(self):
⋮...
│	def check_for_opportunity_type(self):
⋮...
│	def check_all_filters(self):
⋮...

erpnext\accounts\custom\address.py:
│class ERPNextAddress(Address):
⋮...
│	def validate(self):
│		self.validate_reference()
│		self.update_compnay_address()
│		super().validate()
⋮...
│	def link_address(self):
│		"""Link address based on owner"""
│		if self.is_your_company_address:
│			return
│
│		return super().link_address()
⋮...
│	def update_compnay_address(self):
│		for link in self.get("links"):
│			if link.link_doctype == "Company":
│				self.is_your_company_address = 1
⋮...
│	def validate_reference(self):
⋮...
│	def on_update(self):
⋮...
│def get_shipping_address(company, address=None):
⋮...

erpnext\selling\doctype\product_bundle\product_bundle.py:
│class ProductBundle(Document):
⋮...
│	def autoname(self):
│		self.name = self.new_item_code
⋮...
│	def validate(self):
│		self.validate_main_item()
│		self.validate_child_items()
│		from erpnext.utilities.transaction_base import validate_uom_is_integer
│
│		validate_uom_is_integer(self, "uom", "qty")
⋮...
│	def on_trash(self):
⋮...
│	def validate_main_item(self):
│		"""Validates, main Item is not a stock item"""
│		if frappe.db.get_value("Item", self.new_item_code, "is_stock_item"):
│			frappe.throw(_("Parent Item {0} must not be a Stock Item").format(self.new_item_code))
│		if frappe.db.get_value("Item", self.new_item_code, "is_fixed_asset"):
│			frappe.throw(_("Parent Item {0} must not be a Fixed Asset").format(self.new_item_code))
⋮...
│	def validate_child_items(self):
⋮...
│def get_new_item_code(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\accounts\report\sales_register\test_sales_register.py:
│class TestItemWiseSalesRegister(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
│		self.create_child_cost_center()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_child_cost_center(self):
⋮...
│	def create_sales_invoice(self, rate=100, do_not_submit=False):
⋮...
│	def test_basic_report_output(self):
⋮...
│	def test_journal_with_cost_center_filter(self):
⋮...

erpnext\crm\doctype\appointment_booking_settings\appointment_booking_settings.py:
│class AppointmentBookingSettings(Document):
⋮...
│	def validate(self):
│		self.validate_availability_of_slots()
⋮...
│	def save(self):
│		self.number_of_agents = len(self.agent_list)
│		super().save()
⋮...
│	def validate_availability_of_slots(self):
⋮...
│	def validate_from_and_to_time(self, from_time, to_time, record):
│		if from_time > to_time:
│			err_msg = _("<b>From Time</b> cannot be later than <b>To Time</b> for {0}").format(
│				record.day_of_week
│			)
│			frappe.throw(_(err_msg))
⋮...
│	def duration_is_divisible(self, from_time, to_time):
│		timedelta = to_time - from_time
│		if timedelta.total_seconds() % (self.appointment_duration * 60):
│			frappe.throw(_("The difference between from time and To Time must be a multiple of Appointment"))
⋮...

erpnext\crm\doctype\appointment\test_appointment.py:
│def create_test_appointment():
⋮...
│class TestAppointment(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		frappe.db.delete("Lead", {"email_id": LEAD_EMAIL})
⋮...
│	def setUp(self):
│		self.test_appointment = create_test_appointment()
│		self.test_appointment.set_verified(self.test_appointment.customer_email)
⋮...
│	def test_calendar_event_created(self):
│		cal_event = frappe.get_doc("Event", self.test_appointment.calendar_event)
│		self.assertEqual(cal_event.starts_on, self.test_appointment.scheduled_time)
⋮...
│	def test_lead_linked(self):
│		self.assertTrue(self.test_appointment.party)
⋮...

erpnext\quality_management\doctype\quality_goal\quality_goal.py:
│class QualityGoal(Document):
⋮...
│	def validate(self):
│		pass
⋮...

erpnext\accounts\report\general_ledger\test_general_ledger.py:
│class TestGeneralLedger(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.company = "_Test Company"
│		self.clear_old_entries()
⋮...
│	def clear_old_entries(self):
⋮...
│	def test_foreign_account_balance_after_exchange_rate_revaluation(self):
⋮...
│	def test_ignore_exchange_rate_journals_filter(self):
⋮...
│	def test_ignore_cr_dr_notes_filter(self):
⋮...

erpnext\accounts\doctype\pos_invoice_reference\pos_invoice_reference.py:
│class POSInvoiceReference(Document):
⋮...

erpnext\accounts\doctype\payment_order\test_payment_order.py:
│class UnitTestPaymentOrder(UnitTestCase):
⋮...
│class TestPaymentOrder(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_payment_order_creation_against_payment_entry(self):
⋮...
│def create_payment_order_against_payment_entry(ref_doc, order_type, bank_account):
⋮...

erpnext\maintenance\doctype\maintenance_visit\test_maintenance_visit.py:
│def make_maintenance_visit():
⋮...
│class TestMaintenanceVisit(IntegrationTestCase):
│	pass
⋮...
│def make_sales_person(name):
│	sales_person = frappe.get_doc({"doctype": "Sales Person", "sales_person_name": name})
│	sales_person.insert(ignore_if_duplicate=True)
│
│	return sales_person
⋮...

erpnext\regional\address_template\test_regional_address_template.py:
│def ensure_country(country):
⋮...
│class TestRegionalAddressTemplate(TestCase):
⋮...
│	def test_get_address_templates(self):
│		"""Get the countries and paths from the templates directory."""
│		templates = get_address_templates()
│		self.assertIsInstance(templates, list)
│		self.assertIsInstance(templates[0], tuple)
⋮...
│	def test_create_address_template(self):
│		"""Create a new Address Template."""
│		country = ensure_country("Germany")
│		update_address_template(country.name, "TEST")
│		doc = frappe.get_doc("Address Template", country.name)
│		self.assertEqual(doc.template, "TEST")
⋮...
│	def test_update_address_template(self):
⋮...

erpnext\telephony\doctype\incoming_call_settings\incoming_call_settings.py:
│class IncomingCallSettings(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_call_schedule_timeslot(self, schedule: list):
⋮...
│	def validate_call_schedule_overlaps(self, schedule: list):
⋮...
│	def check_timeslots_overlap(ts1: tuple[int, int], ts2: tuple[int, int]) -> bool:
│		if (ts1[0] < ts2[0] and ts1[1] <= ts2[0]) or (ts1[0] >= ts2[1] and ts1[1] > ts2[1]):
│			return False
│		return True
⋮...
│	def time_to_seconds(time: str) -> int:
│		"""Convert time string of format HH:MM:SS into seconds"""
│		date_time = datetime.strptime(time, "%H:%M:%S")
│		return date_time - datetime(1900, 1, 1)
⋮...

erpnext\selling\report\sales_analytics\test_analytics.py:
│class TestAnalytics(IntegrationTestCase):
⋮...
│	def test_sales_analytics(self):
⋮...
│	def compare_result_for_customer(self):
⋮...
│	def compare_result_for_customer_group(self):
⋮...
│	def compare_result_for_customer_based_on_quantity(self):
⋮...
│def create_sales_orders():
⋮...

erpnext\selling\doctype\selling_settings\selling_settings.py:
│class SellingSettings(Document):
⋮...
│	def on_update(self):
│		self.toggle_hide_tax_id()
│		self.toggle_editable_rate_for_bundle_items()
│		self.toggle_discount_accounting_fields()
⋮...
│	def validate(self):
⋮...
│	def toggle_hide_tax_id(self):
⋮...
│	def toggle_editable_rate_for_bundle_items(self):
⋮...
│	def toggle_discount_accounting_fields(self):
⋮...

erpnext\accounts\doctype\account_closing_balance\account_closing_balance.py:
│def make_closing_entries(closing_entries, voucher_name, company, closing_date):
⋮...
│class AccountClosingBalance(Document):
⋮...
│def aggregate_with_last_account_closing_balance(entries, accounting_dimensions):
⋮...
│def generate_key(entry, accounting_dimensions):
⋮...
│def get_previous_closing_entries(company, closing_date, accounting_dimensions):
⋮...

erpnext\manufacturing\doctype\manufacturing_settings\manufacturing_settings.py:
│def get_mins_between_operations():
│	return relativedelta(
│		minutes=cint(frappe.db.get_single_value("Manufacturing Settings", "mins_between_operations")) or 10
│	)
⋮...
│class ManufacturingSettings(Document):
⋮...
│	def before_save(self):
│		self.reset_values()
⋮...
│	def reset_values(self):
│		if self.backflush_raw_materials_based_on != "BOM" and self.validate_components_quantities_per_bom:
│			self.validate_components_quantities_per_bom = 0
⋮...
│def is_material_consumption_enabled():
⋮...

erpnext\stock\doctype\item_alternative\item_alternative.py:
│class ItemAlternative(Document):
⋮...
│	def validate(self):
│		self.has_alternative_item()
│		self.validate_alternative_item()
│		self.validate_duplicate()
⋮...
│	def has_alternative_item(self):
│		if self.item_code and not frappe.db.get_value("Item", self.item_code, "allow_alternative_item"):
│			frappe.throw(_("Not allow to set alternative item for the item {0}").format(self.item_code))
⋮...
│	def validate_alternative_item(self):
⋮...
│	def validate_duplicate(self):
⋮...
│def get_alternative_items(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\accounts\doctype\cashier_closing\cashier_closing.py:
│class CashierClosing(Document):
⋮...
│	def validate(self):
│		self.validate_time()
⋮...
│	def before_save(self):
│		self.get_outstanding()
│		self.make_calculations()
⋮...
│	def get_outstanding(self):
⋮...
│	def make_calculations(self):
⋮...
│	def validate_time(self):
│		if self.from_time >= self.time:
│			frappe.throw(_("From Time Should Be Less Than To Time"))
⋮...

erpnext\accounts\doctype\pos_opening_entry\pos_opening_entry.py:
│class POSOpeningEntry(StatusUpdater):
⋮...
│	def validate(self):
│		self.validate_pos_profile_and_cashier()
│		self.validate_payment_method_account()
│		self.set_status()
⋮...
│	def validate_pos_profile_and_cashier(self):
⋮...
│	def validate_payment_method_account(self):
⋮...
│	def on_submit(self):
│		self.set_status(update=True)
⋮...
│	def on_cancel(self):
│		self.set_status(update=True)
⋮...

erpnext\accounts\doctype\ledger_merge\ledger_merge.py:
│def start_merge(docname):
⋮...
│class LedgerMerge(Document):
⋮...
│	def start_merge(self):
⋮...
│def form_start_merge(docname):
│	return frappe.get_doc("Ledger Merge", docname).start_merge()
⋮...

erpnext\buying\report\requested_items_to_order_and_receive\test_requested_items_to_order_and_receive.py:
│class TestRequestedItemsToOrderAndReceive(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
⋮...
│	def tearDown(self) -> None:
│		frappe.db.rollback()
⋮...
│	def test_date_range(self):
│		data = get_data(self.filters)
│		self.assertEqual(len(data), 2)  # MRs today should be fetched
│
│		data = get_data(self.filters.update({"from_date": add_days(today(), 10)}))
│		self.assertEqual(len(data), 0)  # MRs today should not be fetched as from date is in future
⋮...
│	def test_ordered_received_material_requests(self):
⋮...
│	def setup_material_request(self, order=False, receive=False, days=0):
⋮...

erpnext\accounts\report\supplier_ledger_summary\test_supplier_ledger_summary.py:
│class TestSupplierLedgerSummary(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_supplier()
│		self.create_item()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_purchase_invoice(self, do_not_submit=False):
⋮...
│	def test_basic_supplier_ledger_summary(self):
⋮...
│	def test_supplier_ledger_summary_with_filters(self):
⋮...

erpnext\setup\setup_wizard\data\dashboard_charts.py:
│def get_account(account_type, company):
│	accounts = frappe.get_list("Account", filters={"account_type": account_type, "company": company})
│	if accounts:
│		return accounts[0].name
⋮...
│def get_company_for_dashboards():
⋮...
│def get_default_dashboards():
⋮...

erpnext\accounts\doctype\coupon_code\test_coupon_code.py:
│def test_create_test_data():
⋮...
│class TestCouponCode(IntegrationTestCase):
⋮...
│	def setUp(self):
│		test_create_test_data()
⋮...
│	def tearDown(self):
│		frappe.set_user("Administrator")
⋮...
│	def test_sales_order_with_coupon_code(self):
⋮...
│	def test_coupon_without_max_use(self):
⋮...

erpnext\stock\doctype\item_alternative\test_item_alternative.py:
│class UnitTestItemAlternative(UnitTestCase):
⋮...
│class TestItemAlternative(IntegrationTestCase):
⋮...
│	def setUp(self):
│		super().setUp()
│		make_items()
⋮...
│	def test_alternative_item_for_subcontract_rm(self):
⋮...
│	def test_alternative_item_for_production_rm(self):
⋮...
│def make_items():
⋮...

erpnext\assets\doctype\asset_shift_allocation\test_asset_shift_allocation.py:
│class UnitTestAssetShiftAllocation(UnitTestCase):
⋮...
│class TestAssetShiftAllocation(IntegrationTestCase):
⋮...
│	def setUpClass(cls):
│		super().setUpClass()
│		create_asset_shift_factors()
⋮...
│	def tearDownClass(cls):
│		frappe.db.rollback()
⋮...
│	def test_asset_shift_allocation(self):
⋮...
│def create_asset_shift_factors():
⋮...

erpnext\stock\doctype\item_manufacturer\item_manufacturer.py:
│class ItemManufacturer(Document):
⋮...
│	def validate(self):
│		self.validate_duplicate_entry()
│		self.manage_default_item_manufacturer()
⋮...
│	def on_trash(self):
│		self.manage_default_item_manufacturer(delete=True)
⋮...
│	def validate_duplicate_entry(self):
⋮...
│	def manage_default_item_manufacturer(self, delete=False):
⋮...
│def get_item_manufacturer_part_no(item_code, manufacturer):
│	return frappe.db.get_value(
│		"Item Manufacturer",
│		{"item_code": item_code, "manufacturer": manufacturer},
│		"manufacturer_part_no",
│	)
⋮...

erpnext\accounts\doctype\accounts_settings\accounts_settings.py:
│class AccountsSettings(Document):
⋮...
│	def validate(self):
⋮...
│	def validate_stale_days(self):
│		if not self.allow_stale and cint(self.stale_days) <= 0:
│			frappe.msgprint(
│				_("Stale Days should start from 1."), title="Error", indicator="red", raise_exception=1
│			)
⋮...
│	def enable_payment_schedule_in_print(self):
⋮...
│	def validate_pending_reposts(self):
│		if self.acc_frozen_upto:
│			check_pending_reposting(self.acc_frozen_upto)
⋮...
│	def validate_and_sync_auto_reconcile_config(self):
⋮...

erpnext\setup\doctype\authorization_control\authorization_control.py:
│class AuthorizationControl(TransactionBase):
⋮...
│	def get_appr_user_role(self, det, doctype_name, total, based_on, condition, master_name, company):
⋮...
│	def validate_auth_rule(self, doctype_name, total, based_on, cond, company, master_name=""):
⋮...
│	def bifurcate_based_on_type(self, doctype_name, total, av_dis, based_on, doc_obj, val, company):
⋮...
│	def validate_approving_authority(self, doctype_name, company, total, doc_obj=""):
⋮...
│	def get_value_based_rule(self, doctype_name, employee, total_claimed_amount, company):
⋮...

erpnext\selling\doctype\sales_team\sales_team.py:
│class SalesTeam(Document):
⋮...

erpnext\accounts\doctype\bank_reconciliation_tool\test_bank_reconciliation_tool.py:
│class TestBankReconciliationTool(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_bank_account(self):
⋮...
│	def test_auto_reconcile(self):
⋮...

erpnext\accounts\report\general_and_payment_ledger_comparison\test_general_and_payment_ledger_comparison.py:
│class TestGeneralAndPaymentLedger(IntegrationTestCase, AccountsTestMixin):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.cleanup()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def cleanup(self):
⋮...
│	def test_01_basic_report_functionality(self):
⋮...

erpnext\controllers\tests\test_reactivity.py:
│class TestReactivity(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def disable_dimensions(self):
│		res = frappe.db.get_all("Accounting Dimension", filters={"disabled": False})
│		for x in res:
│			dim = frappe.get_doc("Accounting Dimension", x.name)
│			dim.disabled = True
│			dim.save()
⋮...
│	def test_01_basic_item_details(self):
⋮...

erpnext\accounts\doctype\monthly_distribution\monthly_distribution.py:
│class MonthlyDistribution(Document):
⋮...
│	def get_months(self):
⋮...
│	def validate(self):
│		total = sum(flt(d.percentage_allocation) for d in self.get("percentages"))
│
│		if flt(total, 2) != 100.0:
│			frappe.throw(_("Percentage Allocation should be equal to 100%") + f" ({flt(total, 2)!s}%)")
⋮...
│def get_periodwise_distribution_data(distribution_id, period_list, periodicity):
⋮...
│def get_percentage(doc, start_date, period):
⋮...

erpnext\setup\doctype\sales_partner\sales_partner.py:
│class SalesPartner(WebsiteGenerator):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
⋮...
│	def autoname(self):
│		self.name = self.partner_name
⋮...
│	def validate(self):
│		if not self.route:
│			self.route = "partners/" + self.scrub(self.partner_name)
│		super().validate()
│		if self.partner_website and not self.partner_website.startswith("http"):
│			self.partner_website = "http://" + self.partner_website
⋮...
│	def get_context(self, context):
⋮...

erpnext\utilities\naming.py:
│def set_by_naming_series(doctype, fieldname, naming_series, hide_name_field=True, make_mandatory=1):
⋮...
│class NamingSeriesNotSetError(frappe.ValidationError):
│	pass
⋮...

erpnext\manufacturing\doctype\bom_update_tool\test_bom_update_tool.py:
│class UnitTestBomUpdateTool(UnitTestCase):
⋮...
│class TestBOMUpdateTool(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_replace_bom(self):
⋮...
│	def test_bom_cost(self):
⋮...

erpnext\accounts\doctype\purchase_taxes_and_charges\purchase_taxes_and_charges.py:
│class PurchaseTaxesandCharges(Document):
⋮...

erpnext\accounts\doctype\payment_schedule\payment_schedule.py:
│class PaymentSchedule(Document):
⋮...

erpnext\portal\utils.py:
│def party_exists(doctype, user):
⋮...
│def set_default_role(doc, method):
⋮...
│def create_customer_or_supplier():
⋮...
│def create_party_contact(doctype, fullname, user, party_name):
⋮...

erpnext\manufacturing\doctype\workstation_type\workstation_type.py:
│def get_workstations(workstation_type):
│	workstations = frappe.get_all(
│		"Workstation", filters={"workstation_type": workstation_type}, order_by="creation"
│	)
│
│	return [workstation.name for workstation in workstations]
⋮...
│class WorkstationType(Document):
⋮...
│	def before_save(self):
│		self.set_hour_rate()
⋮...
│	def set_hour_rate(self):
⋮...

erpnext\manufacturing\doctype\plant_floor\plant_floor.py:
│class PlantFloor(Document):
⋮...
│	def make_stock_entry(self, kwargs):
⋮...
│	def get_item_details(self, kwargs) -> list[dict]:
⋮...
│def get_stock_summary(warehouse, start=0, item_code=None, item_group=None):
⋮...
│def get_stock_details(warehouse, start=0, item_code=None, item_group=None):
⋮...

erpnext\accounts\doctype\process_deferred_accounting\test_process_deferred_accounting.py:
│def change_acc_settings(acc_frozen_upto="", book_deferred_entries_based_on="Days"):
│	acc_settings = frappe.get_doc("Accounts Settings", "Accounts Settings")
│	acc_settings.acc_frozen_upto = acc_frozen_upto
│	acc_settings.book_deferred_entries_based_on = book_deferred_entries_based_on
│	acc_settings.save()
⋮...
│class TestProcessDeferredAccounting(IntegrationTestCase):
⋮...
│	def test_creation_of_ledger_entry_on_submit(self):
⋮...
│	def test_pda_submission_and_cancellation(self):
⋮...

erpnext\setup\doctype\global_defaults\global_defaults.py:
│class GlobalDefaults(Document):
⋮...
│	def on_update(self):
⋮...
│	def get_defaults(self):
│		return frappe.defaults.get_defaults()
⋮...
│	def toggle_rounded_total(self):
⋮...
│	def toggle_in_words(self):
⋮...

erpnext\accounts\doctype\payment_gateway_account\payment_gateway_account.py:
│class PaymentGatewayAccount(Document):
⋮...
│	def autoname(self):
│		self.name = self.payment_gateway + " - " + self.currency
⋮...
│	def validate(self):
│		self.currency = frappe.get_cached_value("Account", self.payment_account, "account_currency")
│
│		self.update_default_payment_gateway()
│		self.set_as_default_if_not_set()
⋮...
│	def update_default_payment_gateway(self):
│		if self.is_default:
│			frappe.db.sql(
│				"""update `tabPayment Gateway Account` set is_default = 0
│				where is_default = 1 """
│			)
⋮...
│	def set_as_default_if_not_set(self):
│		if not frappe.db.get_value(
│			"Payment Gateway Account", {"is_default": 1, "name": ("!=", self.name)}, "name"
│		):
│			self.is_default = 1
⋮...

erpnext\accounts\doctype\sales_taxes_and_charges\sales_taxes_and_charges.py:
│class SalesTaxesandCharges(Document):
⋮...

erpnext\manufacturing\report\test_reports.py:
│class TestManufacturingReports(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.setup_default_filters()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def setup_default_filters(self):
⋮...
│	def test_execute_all_manufacturing_reports(self):
⋮...

erpnext\setup\doctype\supplier_group\supplier_group.py:
│class SupplierGroup(NestedSet):
⋮...
│	def validate(self):
│		if not self.parent_supplier_group:
│			self.parent_supplier_group = get_root_of("Supplier Group")
│		self.validate_currency_for_payable_and_advance_account()
⋮...
│	def validate_currency_for_payable_and_advance_account(self):
⋮...
│	def on_update(self):
│		NestedSet.on_update(self)
│		self.validate_one_root()
⋮...
│	def on_trash(self):
│		NestedSet.validate_if_child_exists(self)
│		frappe.utils.nestedset.update_nsm(self)
⋮...

erpnext\accounts\report\payment_ledger\test_payment_ledger.py:
│class TestPaymentLedger(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.cleanup()
⋮...
│	def cleanup(self):
⋮...
│	def create_company(self):
⋮...
│	def test_unpaid_invoice_outstanding(self):
⋮...

erpnext\accounts\doctype\gl_entry\test_gl_entry.py:
│class TestGLEntry(IntegrationTestCase):
⋮...
│	def test_round_off_entry(self):
⋮...
│	def test_rename_entries(self):
⋮...
│	def test_validate_account_party_type(self):
⋮...
│	def test_validate_account_party_type_shareholder(self):
⋮...

erpnext\accounts\report\item_wise_purchase_register\test_item_wise_purchase_register.py:
│class TestItemWisePurchaseRegister(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_supplier()
│		self.create_item()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_purchase_invoice(self, do_not_submit=False):
⋮...
│	def test_basic_report_output(self):
⋮...

erpnext\accounts\doctype\payment_terms_template\test_payment_terms_template.py:
│class TestPaymentTermsTemplate(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		frappe.delete_doc("Payment Terms Template", "_Test Payment Terms Template For Test", force=1)
⋮...
│	def test_create_template(self):
⋮...
│	def test_credit_days(self):
⋮...
│	def test_duplicate_terms(self):
⋮...

erpnext\accounts\report\accounts_receivable_summary\test_accounts_receivable_summary.py:
│class TestAccountsReceivable(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.maxDiff = None
│		self.create_company()
│		self.create_customer()
│		self.create_item()
│		self.clear_old_entries()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_01_receivable_summary_output(self):
⋮...
│	def test_02_various_filters_and_output(self):
⋮...

erpnext\accounts\report\item_wise_sales_register\test_item_wise_sales_register.py:
│class TestItemWiseSalesRegister(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def create_sales_invoice(self, do_not_submit=False):
⋮...
│	def test_basic_report_output(self):
⋮...

erpnext\regional\doctype\lower_deduction_certificate\lower_deduction_certificate.py:
│class LowerDeductionCertificate(Document):
⋮...
│	def validate(self):
│		self.validate_dates()
│		self.validate_supplier_against_tax_category()
⋮...
│	def validate_dates(self):
⋮...
│	def validate_supplier_against_tax_category(self):
⋮...
│	def are_dates_overlapping(self, duplicate_certificate):
⋮...

erpnext\accounts\doctype\mode_of_payment\mode_of_payment.py:
│class ModeofPayment(Document):
⋮...
│	def validate(self):
│		self.validate_accounts()
│		self.validate_repeating_companies()
│		self.validate_pos_mode_of_payment()
⋮...
│	def validate_repeating_companies(self):
⋮...
│	def validate_accounts(self):
⋮...
│	def validate_pos_mode_of_payment(self):
⋮...

erpnext\stock\doctype\stock_settings\test_stock_settings.py:
│class UnitTestStockSettings(UnitTestCase):
⋮...
│class TestStockSettings(IntegrationTestCase):
⋮...
│	def setUp(self):
│		super().setUp()
│		frappe.db.set_single_value("Stock Settings", "clean_description_html", 0)
⋮...
│	def test_settings(self):
⋮...
│	def test_clean_html(self):
⋮...

erpnext\accounts\report\accounts_payable\test_accounts_payable.py:
│class TestAccountsPayable(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.create_company()
│		self.create_customer()
│		self.create_item()
│		self.create_supplier(currency="USD", supplier_name="Test Supplier2")
│		self.create_usd_payable_account()
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_accounts_payable_for_foreign_currency_supplier(self):
⋮...
│	def create_purchase_invoice(self, do_not_submit=False):
⋮...

erpnext\stock\doctype\landed_cost_taxes_and_charges\landed_cost_taxes_and_charges.py:
│class LandedCostTaxesandCharges(Document):
⋮...

erpnext\buying\doctype\supplier_scorecard_variable\test_supplier_scorecard_variable.py:
│class UnitTestSupplierScorecardVariable(UnitTestCase):
⋮...
│class TestSupplierScorecardVariable(IntegrationTestCase):
⋮...
│	def test_variable_exist(self):
│		for d in test_existing_variables:
│			my_doc = frappe.get_doc("Supplier Scorecard Variable", d.get("name"))
│			self.assertEqual(my_doc.param_name, d.get("param_name"))
│			self.assertEqual(my_doc.variable_label, d.get("variable_label"))
│			self.assertEqual(my_doc.path, d.get("path"))
⋮...
│	def test_path_exists(self):
⋮...

erpnext\stock\doctype\item_default\item_default.py:
│class ItemDefault(Document):
⋮...

erpnext\accounts\doctype\bank_transaction\bank_transaction_upload.py:
│def upload_bank_statement():
⋮...
│def create_bank_entries(columns, data, bank_account):
⋮...
│def get_header_mapping(columns, bank_account):
⋮...
│def get_bank_mapping(bank_account):
⋮...

erpnext\accounts\doctype\bank_clearance\bank_clearance.py:
│class BankClearance(Document):
⋮...
│	def get_payment_entries(self):
⋮...
│	def update_clearance_date(self):
⋮...
│def get_payment_entries_for_bank_clearance(
│	from_date, to_date, account, bank_account, include_reconciled_entries, include_pos_transactions
│):
⋮...

erpnext\buying\doctype\buying_settings\buying_settings.py:
│class BuyingSettings(Document):
⋮...
│	def validate(self):
⋮...
│	def before_save(self):
│		self.check_maintain_same_rate()
⋮...
│	def check_maintain_same_rate(self):
│		if self.maintain_same_rate:
│			self.set_landed_cost_based_on_purchase_invoice_rate = 0
⋮...

erpnext\controllers\tests\test_mapper.py:
│class TestMapper(IntegrationTestCase):
⋮...
│	def test_map_docs(self):
⋮...
│	def make_quotation(self, item_list, customer):
⋮...
│	def make_sales_order(self):
⋮...

erpnext\stock\doctype\bin\test_bin.py:
│class UnitTestBin(UnitTestCase):
⋮...
│class TestBin(IntegrationTestCase):
⋮...
│	def test_concurrent_inserts(self):
⋮...
│	def test_index_exists(self):
│		indexes = frappe.db.sql("show index from tabBin where Non_unique = 0", as_dict=1)
│		if not any(index.get("Key_name") == "unique_item_warehouse" for index in indexes):
│			self.fail("Expected unique index on item-warehouse")
⋮...

erpnext\utilities\__init__.py:
│def payment_app_import_guard():
⋮...
│def update_doctypes():
⋮...
│def get_site_info(site_info):
⋮...

erpnext\accounts\doctype\bank_guarantee\bank_guarantee.py:
│class BankGuarantee(Document):
⋮...
│	def validate(self):
│		if not (self.customer or self.supplier):
│			frappe.throw(_("Select the customer or supplier."))
⋮...
│	def on_submit(self):
⋮...
│def get_voucher_details(bank_guarantee_type: str, reference_name: str):
⋮...

erpnext\selling\doctype\sms_center\sms_center.py:
│class SMSCenter(Document):
⋮...
│	def create_receiver_list(self):
⋮...
│	def get_receiver_nos(self):
⋮...
│	def send_sms(self):
⋮...

erpnext\accounts\doctype\payment_terms_template\payment_terms_template.py:
│class PaymentTermsTemplate(Document):
⋮...
│	def validate(self):
│		self.validate_invoice_portion()
│		self.validate_terms()
⋮...
│	def validate_invoice_portion(self):
⋮...
│	def validate_terms(self):
⋮...

erpnext\stock\doctype\item_variant_settings\item_variant_settings.py:
│class ItemVariantSettings(Document):
⋮...
│	def set_default_fields(self):
⋮...
│	def remove_invalid_fields_for_copy_fields_in_variants(self):
⋮...
│	def validate(self):
│		for d in self.fields:
│			if d.field_name in self.invalid_fields_for_copy_fields_in_variants:
│				frappe.throw(
│					_("Cannot set the field <b>{0}</b> for copying in variants").format(d.field_name)
│				)
⋮...

erpnext\tests\test_init.py:
│class TestInit(IntegrationTestCase):
⋮...
│	def test_encode_company_abbr(self):
⋮...
│	def test_translation_files(self):
│		from frappe.tests.test_translate import verify_translation_files
│
│		verify_translation_files("erpnext")
⋮...
│	def test_patches(self):
│		from frappe.tests.test_patches import check_patch_files
│
│		check_patch_files("erpnext")
⋮...

erpnext\accounts\doctype\purchase_invoice_item\purchase_invoice_item.py:
│class PurchaseInvoiceItem(Document):
⋮...

erpnext\tests\test_zform_loads.py:
│class TestFormLoads(IntegrationTestCase):
⋮...
│	def test_load(self):
⋮...
│	def assertFormLoad(self, doctype, docname):
⋮...
│	def assertDocPrint(self, doctype, docname):
⋮...

erpnext\stock\doctype\item_attribute\test_item_attribute.py:
│class UnitTestItemAttribute(UnitTestCase):
⋮...
│class TestItemAttribute(IntegrationTestCase):
⋮...
│	def setUp(self):
│		super().setUp()
│		if frappe.db.exists("Item Attribute", "_Test_Length"):
│			frappe.delete_doc("Item Attribute", "_Test_Length")
⋮...
│	def test_numeric_item_attribute(self):
⋮...

erpnext\accounts\doctype\process_deferred_accounting\process_deferred_accounting.py:
│class ProcessDeferredAccounting(Document):
⋮...
│	def validate(self):
│		if self.end_date < self.start_date:
│			frappe.throw(_("End date cannot be before start date"))
⋮...
│	def on_submit(self):
│		conditions = build_conditions(self.type, self.account, self.company)
│		if self.type == "Income":
│			convert_deferred_revenue_to_income(self.name, self.start_date, self.end_date, conditions)
│		else:
│			convert_deferred_expense_to_expense(self.name, self.start_date, self.end_date, conditions)
⋮...
│	def on_cancel(self):
⋮...

erpnext\quality_management\doctype\quality_review\test_quality_review.py:
│class TestQualityReview(IntegrationTestCase):
⋮...
│	def test_review_creation(self):
⋮...

erpnext\accounts\doctype\shareholder\shareholder.py:
│class Shareholder(Document):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
⋮...
│	def on_trash(self):
│		delete_contact_and_address("Shareholder", self.name)
⋮...
│	def before_save(self):
│		for entry in self.share_balance:
│			entry.amount = entry.no_of_shares * entry.rate
⋮...

erpnext\setup\doctype\authorization_rule\authorization_rule.py:
│class AuthorizationRule(Document):
⋮...
│	def check_duplicate_entry(self):
⋮...
│	def validate_rule(self):
⋮...
│	def validate(self):
│		self.check_duplicate_entry()
│		self.validate_rule()
│		if not self.value:
│			self.value = 0.0
⋮...

erpnext\stock\report\available_serial_no\test_available_serial_no.py:
│class TestStockLedgerReeport(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
⋮...
│	def tearDown(self) -> None:
│		frappe.db.rollback()
⋮...
│	def test_available_serial_no(self):
⋮...

.github\helper\documentation.py:
│def is_valid_url(url: str) -> bool:
│	parts = urlparse(url)
│	return all((parts.scheme, parts.netloc, parts.path))
⋮...
│def is_documentation_link(word: str) -> bool:
⋮...
│def contains_documentation_link(body: str) -> bool:
│	return any(is_documentation_link(word) for line in body.splitlines() for word in line.split())
⋮...
│def check_pull_request(number: str) -> "tuple[int, str]":
⋮...

erpnext\stock\doctype\stock_reposting_settings\test_stock_reposting_settings.py:
│class TestStockRepostingSettings(IntegrationTestCase):
⋮...
│	def test_notify_reposting_error_to_role(self):
⋮...
│	def test_do_reposting_for_each_stock_transaction(self):
⋮...
│	def test_do_not_reposting_for_each_stock_transaction(self):
⋮...

erpnext\buying\doctype\supplier_quotation\test_supplier_quotation.py:
│class UnitTestSupplierQuotation(UnitTestCase):
⋮...
│class TestPurchaseOrder(IntegrationTestCase):
⋮...
│	def test_supplier_quotation_qty(self):
⋮...
│	def test_make_purchase_order(self):
⋮...

erpnext\subcontracting\doctype\subcontracting_bom\test_subcontracting_bom.py:
│def create_subcontracting_bom(**kwargs):
⋮...
│class UnitTestSubcontractingBom(UnitTestCase):
⋮...
│class TestSubcontractingBOM(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\ledger_merge\test_ledger_merge.py:
│class TestLedgerMerge(IntegrationTestCase):
⋮...
│	def test_merge_success(self):
⋮...
│	def test_partial_merge_success(self):
⋮...
│	def tearDown(self):
⋮...

erpnext\controllers\tests\test_transaction_base.py:
│class TestUtils(IntegrationTestCase):
⋮...
│	def test_reset_default_field_value(self):
⋮...
│	def test_reset_default_field_value_in_mfg_stock_entry(self):
⋮...
│	def test_reset_default_field_value_in_transfer_stock_entry(self):
⋮...

erpnext\accounts\doctype\party_account\party_account.py:
│class PartyAccount(Document):
⋮...

erpnext\accounts\doctype\item_tax_template\item_tax_template.py:
│class ItemTaxTemplate(Document):
⋮...
│	def validate(self):
│		self.validate_tax_accounts()
⋮...
│	def autoname(self):
│		if self.company and self.title:
│			abbr = frappe.get_cached_value("Company", self.company, "abbr")
│			self.name = f"{self.title} - {abbr}"
⋮...
│	def validate_tax_accounts(self):
⋮...

erpnext\selling\report\sales_partner_target_variance_based_on_item_group\test_sales_partner_target_variance_based_on_item_group.py:
│class TestSalesPartnerTargetVarianceBasedOnItemGroup(IntegrationTestCase):
⋮...
│	def setUp(self):
│		self.fiscal_year = get_fiscal_year(nowdate())[0]
⋮...
│	def tearDown(self):
│		frappe.db.rollback()
⋮...
│	def test_achieved_target_and_variance_for_partner(self):
⋮...

erpnext\stock\report\reserved_stock\test_reserved_stock.py:
│class TestReservedStock(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
│		super().setUp()
│		self.stock_qty = 100
│		self.warehouse = "_Test Warehouse - _TC"
⋮...
│	def tearDown(self) -> None:
│		cancel_all_stock_reservation_entries()
│		return super().tearDown()
⋮...
│	def test_reserved_stock_report(self):
⋮...

erpnext\setup\setup_wizard\operations\company_setup.py:
│def get_fy_details(fy_start_date, fy_end_date):
⋮...
│def create_fiscal_year_and_company(args):
⋮...

erpnext\accounts\doctype\finance_book\test_finance_book.py:
│def create_finance_book():
⋮...
│class TestFinanceBook(IntegrationTestCase):
⋮...
│	def test_finance_book(self):
⋮...

erpnext\regional\united_states\test_united_states.py:
│class TestUnitedStates(IntegrationTestCase):
⋮...
│	def test_irs_1099_custom_field(self):
⋮...
│	def test_irs_1099_report(self):
⋮...
│def make_payment_entry_to_irs_1099_supplier():
⋮...

erpnext\accounts\doctype\bank\bank.py:
│class Bank(Document):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
⋮...
│	def on_trash(self):
│		delete_contact_and_address("Bank", self.name)
⋮...

erpnext\accounts\doctype\fiscal_year\test_fiscal_year.py:
│class TestFiscalYear(IntegrationTestCase):
⋮...
│	def test_extra_year(self):
⋮...
│def test_record_generator():
⋮...

erpnext\utilities\doctype\video_settings\video_settings.py:
│class VideoSettings(Document):
⋮...
│	def validate(self):
│		self.validate_youtube_api_key()
⋮...
│	def validate_youtube_api_key(self):
⋮...

erpnext\setup\doctype\currency_exchange\currency_exchange.py:
│class CurrencyExchange(Document):
⋮...
│	def autoname(self):
⋮...
│	def validate(self):
⋮...

erpnext\stock\doctype\stock_entry_type\test_stock_entry_type.py:
│class TestStockEntryType(IntegrationTestCase):
⋮...
│	def test_stock_entry_type_non_standard(self):
⋮...
│	def test_stock_entry_type_is_standard(self):
⋮...

erpnext\accounts\doctype\process_subscription\process_subscription.py:
│class ProcessSubscription(Document):
⋮...
│	def on_submit(self):
│		process_all(subscription=self.subscription, posting_date=self.posting_date)
⋮...
│def create_subscription_process(
│	subscription: str | None = None, posting_date: DateTimeLikeObject | None = None
⋮...

erpnext\assets\doctype\asset_shift_factor\asset_shift_factor.py:
│class AssetShiftFactor(Document):
⋮...
│	def validate(self):
│		self.validate_default()
⋮...
│	def validate_default(self):
⋮...

erpnext\crm\doctype\contract_template\contract_template.py:
│class ContractTemplate(Document):
⋮...
│	def validate(self):
│		if self.contract_terms:
│			validate_template(self.contract_terms)
⋮...
│def get_contract_template(template_name, doc):
⋮...

erpnext\edi\doctype\code_list\code_list_import.py:
│def import_genericode():
⋮...
│def process_genericode_import(
│	code_list_name: str,
⋮...
│def get_genericode_columns_and_examples(root):
⋮...

erpnext\quality_management\doctype\quality_feedback\quality_feedback.py:
│class QualityFeedback(Document):
⋮...
│	def set_parameters(self):
│		if self.template and not getattr(self, "parameters", []):
│			for d in frappe.get_doc("Quality Feedback Template", self.template).parameters:
│				self.append("parameters", dict(parameter=d.parameter, rating=1))
⋮...
│	def validate(self):
│		if not self.document_name:
│			self.document_type = "User"
│			self.document_name = frappe.session.user
│		self.set_parameters()
⋮...

erpnext\tests\test_regional.py:
│def test_method():
│	return "original"
⋮...
│class TestInit(IntegrationTestCase):
│	def test_regional_overrides(self):
│		frappe.flags.country = "Maldives"
│		self.assertEqual(test_method(), "original")
⋮...
│	def test_regional_overrides(self):
│		frappe.flags.country = "Maldives"
│		self.assertEqual(test_method(), "original")
⋮...

erpnext\setup\doctype\employee_group\test_employee_group.py:
│class TestEmployeeGroup(IntegrationTestCase):
│	pass
⋮...
│def make_employee_group():
⋮...
│def get_employee_group():
│	employee_group = frappe.db.exists("Employee Group", "_Test Employee Group")
│	return employee_group
⋮...

erpnext\controllers\tests\test_distributed_discount.py:
│class TestTaxesAndTotals(AccountsTestMixin, IntegrationTestCase):
⋮...
│	def test_distributed_discount_amount(self):
⋮...
│	def test_distributed_discount_amount_with_taxes(self):
⋮...

erpnext\buying\report\subcontracted_item_to_be_received\test_subcontracted_item_to_be_received.py:
│class TestSubcontractedItemToBeReceived(IntegrationTestCase):
⋮...
│	def test_pending_and_received_qty(self):
⋮...
│def make_subcontracting_receipt_against_sco(sco, quantity=5):
│	scr = make_subcontracting_receipt(sco)
│	scr.items[0].qty = quantity
│	scr.insert()
│	scr.submit()
⋮...

erpnext\stock\report\stock_ledger\test_stock_ledger_report.py:
│class TestStockLedgerReeport(IntegrationTestCase):
⋮...
│	def setUp(self) -> None:
⋮...
│	def tearDown(self) -> None:
│		frappe.db.rollback()
⋮...

erpnext\accounts\doctype\accounts_settings\test_accounts_settings.py:
│class TestAccountsSettings(IntegrationTestCase):
⋮...
│	def tearDown(self):
│		# Just in case `save` method succeeds, we need to take things back to default so that other tests
│		# don't break
│		cur_settings = frappe.get_doc("Accounts Settings", "Accounts Settings")
│		cur_settings.allow_stale = 1
│		cur_settings.save()
⋮...
│	def test_stale_days(self):
⋮...

erpnext\selling\report\pending_so_items_for_purchase_request\test_pending_so_items_for_purchase_request.py:
│class TestPendingSOItemsForPurchaseRequest(IntegrationTestCase):
⋮...
│	def test_result_for_partial_material_request(self):
⋮...
│	def test_result_for_so_item(self):
│		so = make_sales_order()
│		report = execute()
│		l = len(report[1])
│		self.assertEqual(so.items[0].qty, report[1][l - 1]["pending_qty"])
⋮...

erpnext\accounts\doctype\pos_settings\pos_settings.py:
│class POSSettings(Document):
⋮...
│	def validate(self):
│		self.validate_invoice_fields()
⋮...
│	def validate_invoice_fields(self):
⋮...

erpnext\buying\doctype\supplier_scorecard_standing\supplier_scorecard_standing.py:
│class SupplierScorecardStanding(Document):
⋮...
│def get_scoring_standing(standing_name):
│	standing = frappe.get_doc("Supplier Scorecard Standing", standing_name)
│
│	return standing
⋮...
│def get_standings_list():
⋮...

erpnext\buying\report\subcontracted_raw_materials_to_be_transferred\test_subcontracted_raw_materials_to_be_transferred.py:
│class TestSubcontractedItemToBeTransferred(IntegrationTestCase):
⋮...
│	def test_pending_and_transferred_qty(self):
⋮...
│def transfer_subcontracted_raw_materials(sco):
⋮...

erpnext\stock\tests\test_get_item_details.py:
│class TestGetItemDetail(IntegrationTestCase):
⋮...
│	def test_get_item_detail_purchase_order(self):
⋮...
│	def test_fetch_price_from_list_rate_on_doc_save(self):
⋮...

erpnext\setup\doctype\department\test_department.py:
│class TestDepartment(IntegrationTestCase):
│	def test_remove_department_data(self):
│		doc = create_department("Test Department")
│		frappe.delete_doc("Department", doc.name)
⋮...
│	def test_remove_department_data(self):
│		doc = create_department("Test Department")
│		frappe.delete_doc("Department", doc.name)
⋮...
│def create_department(department_name, parent_department=None):
⋮...

erpnext\erpnext_integrations\utils.py:
│def validate_webhooks_request(doctype, hmac_key, secret_key="secret"):
⋮...
│def get_webhook_address(connector_name, method, exclude_uri=False, force_https=False):
⋮...
│def get_tracking_url(carrier, tracking_number):
⋮...

erpnext\accounts\doctype\coupon_code\coupon_code.py:
│class CouponCode(Document):
⋮...
│	def autoname(self):
⋮...
│	def validate(self):
│		if self.coupon_type == "Gift Card":
│			self.maximum_use = 1
│			if not self.customer:
│				frappe.throw(_("Please select the customer."))
⋮...

erpnext\accounts\doctype\purchase_taxes_and_charges_template\purchase_taxes_and_charges_template.py:
│class PurchaseTaxesandChargesTemplate(Document):
⋮...
│	def validate(self):
│		valdiate_taxes_and_charges_template(self)
⋮...
│	def autoname(self):
│		if self.company and self.title:
│			abbr = frappe.get_cached_value("Company", self.company, "abbr")
│			self.name = f"{self.title} - {abbr}"
⋮...

erpnext\utilities\doctype\rename_tool\rename_tool.py:
│class RenameTool(Document):
⋮...
│def get_doctypes():
│	return frappe.db.sql_list(
│		"""select name from tabDocType
│		where allow_rename=1 and module!='Core' order by name"""
│	)
⋮...
│def upload(select_doctype=None, rows=None):
⋮...

erpnext\manufacturing\doctype\workstation_type\test_workstation_type.py:
│class UnitTestWorkstationType(UnitTestCase):
⋮...
│class TestWorkstationType(IntegrationTestCase):
│	pass
⋮...
│def create_workstation_type(**args):
⋮...

erpnext\setup\doctype\terms_and_conditions\terms_and_conditions.py:
│class TermsandConditions(Document):
⋮...
│	def validate(self):
│		if self.terms:
│			validate_template(self.terms)
│		if not cint(self.buying) and not cint(self.selling) and not cint(self.hr) and not cint(self.disabled):
│			throw(_("At least one of the Applicable Modules should be selected"))
⋮...
│def get_terms_and_conditions(template_name, doc):
⋮...

erpnext\accounts\doctype\loyalty_point_entry\loyalty_point_entry.py:
│class LoyaltyPointEntry(Document):
⋮...
│def get_loyalty_point_entries(customer, loyalty_program, company, expiry_date=None):
⋮...
│def get_redemption_details(customer, loyalty_program, company):
⋮...

erpnext\assets\doctype\asset_category\test_asset_category.py:
│class TestAssetCategory(IntegrationTestCase):
⋮...
│	def test_mandatory_fields(self):
⋮...
│	def test_cwip_accounting(self):
⋮...

erpnext\accounts\report\non_billed_report.py:
│def get_ordered_to_be_billed_data(args, filters=None):
⋮...
│def get_project_field(doctype, child_doctype, party):
│	if party == "supplier":
│		return child_doctype.project
│	return doctype.project
⋮...

erpnext\setup\doctype\vehicle\test_vehicle.py:
│class TestVehicle(IntegrationTestCase):
⋮...
│	def test_make_vehicle(self):
⋮...
│	def test_renaming_vehicle(self):
⋮...

erpnext\controllers\tests\test_item_wise_tax_details.py:
│class TestTaxesAndTotals(FrappeTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_item_wise_tax_detail(self):
⋮...

erpnext\controllers\print_settings.py:
│def set_print_templates_for_item_table(doc, settings):
⋮...
│def set_print_templates_for_taxes(doc, settings):
⋮...
│def format_columns(display_columns, compact_fields):
⋮...

erpnext\accounts\doctype\share_transfer\test_share_transfer.py:
│class TestShareTransfer(IntegrationTestCase):
⋮...
│	def setUp(self):
⋮...
│	def test_invalid_share_transfer(self):
⋮...

erpnext\stock\doctype\quality_inspection_template\quality_inspection_template.py:
│def get_template_details(template):
⋮...
│class QualityInspectionTemplate(Document):
⋮...

erpnext\stock\doctype\stock_closing_balance\test_stock_closing_balance.py:
│class UnitTestStockClosingBalance(UnitTestCase):
⋮...
│class IntegrationTestStockClosingBalance(IntegrationTestCase):
⋮...

erpnext\stock\report\test_reports.py:
│class TestReports(IntegrationTestCase):
⋮...
│	def test_execute_all_stock_reports(self):
⋮...

erpnext\regional\__init__.py:
│def check_deletion_permission(doc, method):
│	region = get_region(doc.company)
│	if region in ["Nepal"] and doc.docstatus != 0:
│		frappe.throw(_("Deletion is not permitted for country {0}").format(region))
⋮...
│def create_transaction_log(doc, method):
⋮...

erpnext\selling\doctype\customer_credit_limit\customer_credit_limit.py:
│class CustomerCreditLimit(Document):
⋮...

erpnext\accounts\report\bank_reconciliation_statement\test_bank_reconciliation_statement.py:
│class TestBankReconciliationStatement(IntegrationTestCase):
⋮...
│	def test_loan_entries_in_bank_reco_statement(self):
⋮...

erpnext\tests\test_activation.py:
│class TestActivation(IntegrationTestCase):
│	def test_activation(self):
│		levels = get_level()
│		self.assertTrue(levels)
⋮...
│	def test_activation(self):
│		levels = get_level()
│		self.assertTrue(levels)
⋮...

erpnext\crm\doctype\crm_settings\crm_settings.py:
│class CRMSettings(Document):
⋮...
│	def validate(self):
│		frappe.db.set_default("campaign_naming_by", self.get("campaign_naming_by", ""))
⋮...

erpnext\stock\doctype\serial_and_batch_entry\serial_and_batch_entry.py:
│class SerialandBatchEntry(Document):
⋮...

erpnext\accounts\doctype\pricing_rule_item_group\pricing_rule_item_group.py:
│class PricingRuleItemGroup(Document):
⋮...

erpnext\accounts\test\test_reports.py:
│class TestReports(IntegrationTestCase):
⋮...
│	def test_execute_all_accounts_reports(self):
⋮...

erpnext\accounts\doctype\payment_reconciliation_invoice\payment_reconciliation_invoice.py:
│class PaymentReconciliationInvoice(Document):
⋮...
│	def get_list(args):
│		pass
⋮...

erpnext\setup\doctype\driver\driver.py:
│class Driver(Document):
⋮...
│	def validate(self):
│		if self.employee:
│			self.user = frappe.get_value("Employee", self.employee, "user_id")
⋮...

erpnext\accounts\doctype\process_payment_reconciliation\test_process_payment_reconciliation.py:
│class UnitTestProcessPaymentReconciliation(UnitTestCase):
⋮...
│class TestProcessPaymentReconciliation(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\allowed_to_transact_with\allowed_to_transact_with.py:
│class AllowedToTransactWith(Document):
⋮...

erpnext\accounts\doctype\payment_reconciliation_payment\payment_reconciliation_payment.py:
│class PaymentReconciliationPayment(Document):
⋮...
│	def get_list(args):
│		pass
⋮...

erpnext\selling\doctype\selling_settings\test_selling_settings.py:
│class TestSellingSettings(IntegrationTestCase):
│	def test_defaults_populated(self):
│		# Setup default values are not populated on migrate, this test checks
│		# if setup was completed correctly
│		default = frappe.db.get_single_value("Selling Settings", "maintain_same_rate_action")
│		self.assertEqual("Stop", default)
⋮...
│	def test_defaults_populated(self):
│		# Setup default values are not populated on migrate, this test checks
│		# if setup was completed correctly
│		default = frappe.db.get_single_value("Selling Settings", "maintain_same_rate_action")
│		self.assertEqual("Stop", default)
⋮...

erpnext\manufacturing\doctype\plant_floor\test_plant_floor.py:
│class UnitTestPlantFloor(UnitTestCase):
⋮...
│class TestPlantFloor(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\sales_invoice_payment\sales_invoice_payment.py:
│class SalesInvoicePayment(Document):
⋮...

erpnext\assets\doctype\asset_activity\test_asset_activity.py:
│class UnitTestAssetActivity(UnitTestCase):
⋮...
│class TestAssetActivity(IntegrationTestCase):
│	pass
⋮...

erpnext\utilities\product.py:
│def get_price(item_code, price_list, customer_group, company, qty=1, party=None):
⋮...
│def get_item_codes_by_attributes(attribute_filters, template_item_code=None):
⋮...

erpnext\accounts\doctype\process_payment_reconciliation_log\test_process_payment_reconciliation_log.py:
│class UnitTestProcessPaymentReconciliationLog(UnitTestCase):
⋮...
│class TestProcessPaymentReconciliationLog(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\repost_payment_ledger\test_repost_payment_ledger.py:
│class UnitTestRepostPaymentLedger(UnitTestCase):
⋮...
│class TestRepostPaymentLedger(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\incoterm\test_incoterm.py:
│class UnitTestIncoterm(UnitTestCase):
⋮...
│class TestIncoterm(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\ledger_health_monitor\test_ledger_health_monitor.py:
│class UnitTestLedgerHealthMonitor(UnitTestCase):
⋮...
│class TestLedgerHealthMonitor(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\item_tax\item_tax.py:
│class ItemTax(Document):
⋮...

erpnext\assets\doctype\location\test_location.py:
│class TestLocation(IntegrationTestCase):
⋮...
│	def runTest(self):
⋮...

erpnext\stock\doctype\stock_closing_entry\test_stock_closing_entry.py:
│class UnitTestStockClosingEntry(UnitTestCase):
⋮...
│class IntegrationTestStockClosingEntry(IntegrationTestCase):
⋮...

erpnext\crm\doctype\crm_note\crm_note.py:
│class CRMNote(Document):
⋮...

erpnext\accounts\doctype\subscription_plan_detail\subscription_plan_detail.py:
│class SubscriptionPlanDetail(Document):
⋮...

erpnext\buying\doctype\supplier_scorecard_scoring_criteria\supplier_scorecard_scoring_criteria.py:
│class SupplierScorecardScoringCriteria(Document):
⋮...

erpnext\bulk_transaction\doctype\bulk_transaction_log\test_bulk_transaction_log.py:
│class UnitTestBulkTransactionLog(UnitTestCase):
⋮...
│class TestBulkTransactionLog(IntegrationTestCase):
│	pass
⋮...

erpnext\buying\doctype\purchase_receipt_item_supplied\purchase_receipt_item_supplied.py:
│class PurchaseReceiptItemSupplied(Document):
⋮...

erpnext\accounts\doctype\repost_accounting_ledger_settings\test_repost_accounting_ledger_settings.py:
│class UnitTestRepostAccountingLedgerSettings(UnitTestCase):
⋮...
│class TestRepostAccountingLedgerSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\quick_stock_balance\quick_stock_balance.py:
│class QuickStockBalance(Document):
⋮...
│def get_stock_item_details(warehouse, date, item=None, barcode=None):
⋮...

erpnext\selling\doctype\party_specific_item\party_specific_item.py:
│class PartySpecificItem(Document):
⋮...
│	def validate(self):
⋮...

erpnext\setup\doctype\target_detail\target_detail.py:
│class TargetDetail(Document):
⋮...

erpnext\assets\doctype\asset_shift_factor\test_asset_shift_factor.py:
│class UnitTestAssetShiftFactor(UnitTestCase):
⋮...
│class TestAssetShiftFactor(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\job_card_time_log\job_card_time_log.py:
│class JobCardTimeLog(Document):
⋮...

erpnext\accounts\doctype\dunning_type\dunning_type.py:
│class DunningType(Document):
⋮...
│	def autoname(self):
│		company_abbr = frappe.get_value("Company", self.company, "abbr")
│		self.name = f"{self.dunning_type} - {company_abbr}"
⋮...

erpnext\accounts\test_party.py:
│class PartyTestCase(IntegrationTestCase):
⋮...
│	def test_get_default_price_list_should_return_none_for_invalid_group(self):
⋮...

erpnext\tests\test_notifications.py:
│class TestNotifications(IntegrationTestCase):
⋮...
│	def test_get_notifications_for_targets(self):
⋮...

erpnext\accounts\doctype\bisect_accounting_statements\test_bisect_accounting_statements.py:
│class UnitTestBisectAccountingStatements(UnitTestCase):
⋮...
│class TestBisectAccountingStatements(IntegrationTestCase):
│	pass
⋮...

erpnext\utilities\doctype\portal_user\portal_user.py:
│class PortalUser(Document):
⋮...

erpnext\accounts\doctype\bank_account\test_bank_account.py:
│class TestBankAccount(IntegrationTestCase):
⋮...
│	def test_validate_iban(self):
⋮...

erpnext\accounts\doctype\cheque_print_template\cheque_print_template.py:
│class ChequePrintTemplate(Document):
⋮...
│def create_or_update_cheque_print_format(template_name):
⋮...

erpnext\accounts\doctype\account_closing_balance\test_account_closing_balance.py:
│class UnitTestAccountClosingBalance(UnitTestCase):
⋮...
│class TestAccountClosingBalance(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\pricing_rule_item_code\pricing_rule_item_code.py:
│class PricingRuleItemCode(Document):
⋮...

erpnext\manufacturing\doctype\downtime_entry\downtime_entry.py:
│class DowntimeEntry(Document):
⋮...
│	def validate(self):
│		if self.from_time and self.to_time:
│			self.downtime = time_diff_in_hours(self.to_time, self.from_time) * 60
⋮...

erpnext\accounts\doctype\journal_entry_template\journal_entry_template.py:
│class JournalEntryTemplate(Document):
⋮...
│def get_naming_series():
│	return frappe.get_meta("Journal Entry").get_field("naming_series").options
⋮...

erpnext\setup\doctype\party_type\party_type.py:
│class PartyType(Document):
⋮...
│def get_party_type(doctype, txt, searchfield, start, page_len, filters):
⋮...

erpnext\tests\test_perf.py:
│class TestPerformance(IntegrationTestCase):
⋮...
│	def test_ensure_indexes(self):
⋮...

erpnext\accounts\doctype\payment_entry_reference\payment_entry_reference.py:
│class PaymentEntryReference(Document):
⋮...
│	def payment_request_outstanding(self):
│		if not self.payment_request:
│			return
│
│		return frappe.db.get_value("Payment Request", self.payment_request, "outstanding_amount")
⋮...

erpnext\stock\doctype\manufacturer\manufacturer.py:
│class Manufacturer(Document):
⋮...
│	def onload(self):
│		"""Load address and contacts in `__onload`"""
│		load_address_and_contact(self)
⋮...

erpnext\accounts\doctype\sales_invoice_timesheet\sales_invoice_timesheet.py:
│class SalesInvoiceTimesheet(Document):
⋮...

erpnext\stock\report\item_shortage_report\test_item_shortage_report.py:
│class TestItemShortageReport(IntegrationTestCase):
⋮...
│	def test_item_shortage_report(self):
⋮...

erpnext\quality_management\doctype\quality_action\quality_action.py:
│class QualityAction(Document):
⋮...
│	def validate(self):
│		self.status = "Open" if any([d.status == "Open" for d in self.resolutions]) else "Completed"
⋮...

erpnext\quality_management\doctype\quality_feedback\test_quality_feedback.py:
│class TestQualityFeedback(IntegrationTestCase):
⋮...
│	def test_quality_feedback(self):
⋮...

erpnext\bulk_transaction\doctype\bulk_transaction_log_detail\test_bulk_transaction_log_detail.py:
│class UnitTestBulkTransactionLogDetail(UnitTestCase):
⋮...
│class TestBulkTransactionLogDetail(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\process_subscription\test_process_subscription.py:
│class UnitTestProcessSubscription(UnitTestCase):
⋮...
│class TestProcessSubscription(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\sales_invoice_advance\sales_invoice_advance.py:
│class SalesInvoiceAdvance(Document):
⋮...

erpnext\accounts\doctype\pricing_rule_brand\pricing_rule_brand.py:
│class PricingRuleBrand(Document):
⋮...

erpnext\accounts\doctype\payment_reconciliation_allocation\payment_reconciliation_allocation.py:
│class PaymentReconciliationAllocation(Document):
⋮...
│	def get_list(args):
│		pass
⋮...

erpnext\tests\test_point_of_sale.py:
│class TestPointOfSale(IntegrationTestCase):
⋮...
│	def test_item_search(self):
⋮...

erpnext\accounts\doctype\bisect_nodes\test_bisect_nodes.py:
│class UnitTestBisectNodes(UnitTestCase):
⋮...
│class TestBisectNodes(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\bom_creator_item\bom_creator_item.py:
│class BOMCreatorItem(Document):
⋮...

erpnext\stock\doctype\warehouse_type\warehouse_type.py:
│class WarehouseType(Document):
⋮...

erpnext\stock\doctype\packing_slip_item\packing_slip_item.py:
│class PackingSlipItem(Document):
⋮...

erpnext\edi\doctype\code_list\test_code_list.py:
│class TestCodeList(FrappeTestCase):
│	pass
⋮...

erpnext\accounts\doctype\purchase_invoice_advance\purchase_invoice_advance.py:
│class PurchaseInvoiceAdvance(Document):
⋮...

erpnext\crm\doctype\appointment_booking_settings\test_appointment_booking_settings.py:
│class TestAppointmentBookingSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\account\chart_of_accounts\verified\standard_chart_of_accounts_with_account_number.py:
│def get():
⋮...

erpnext\stock\doctype\quality_inspection_template\test_quality_inspection_template.py:
│class TestQualityInspectionTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\assets\doctype\asset_category_account\asset_category_account.py:
│class AssetCategoryAccount(Document):
⋮...

erpnext\stock\doctype\variant_field\variant_field.py:
│class VariantField(Document):
⋮...

erpnext\support\doctype\issue_type\test_issue_type.py:
│class TestIssueType(IntegrationTestCase):
│	pass
⋮...

erpnext\subcontracting\doctype\subcontracting_order_supplied_item\subcontracting_order_supplied_item.py:
│class SubcontractingOrderSuppliedItem(Document):
⋮...

erpnext\accounts\doctype\bank_transaction_payments\bank_transaction_payments.py:
│class BankTransactionPayments(Document):
⋮...

erpnext\crm\doctype\opportunity_type\test_opportunity_type.py:
│class TestOpportunityType(IntegrationTestCase):
│	pass
⋮...

erpnext\telephony\doctype\telephony_call_type\test_telephony_call_type.py:
│class TestTelephonyCallType(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\loyalty_program_collection\loyalty_program_collection.py:
│class LoyaltyProgramCollection(Document):
⋮...

erpnext\manufacturing\doctype\job_card_item\job_card_item.py:
│class JobCardItem(Document):
⋮...

erpnext\accounts\doctype\bank_statement_import\test_bank_statement_import.py:
│class TestBankStatementImport(IntegrationTestCase):
│	pass
⋮...

erpnext\assets\doctype\maintenance_team_member\test_maintenance_team_member.py:
│class TestMaintenanceTeamMember(IntegrationTestCase):
│	pass
⋮...

erpnext\crm\doctype\campaign\test_campaign.py:
│class TestCampaign(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\bank_guarantee\test_bank_guarantee.py:
│class TestBankGuarantee(IntegrationTestCase):
│	pass
⋮...

erpnext\regional\doctype\lower_deduction_certificate\test_lower_deduction_certificate.py:
│class TestLowerDeductionCertificate(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\quality_inspection_parameter_group\quality_inspection_parameter_group.py:
│class QualityInspectionParameterGroup(Document):
⋮...

erpnext\setup\doctype\uom_conversion_factor\uom_conversion_factor.py:
│class UOMConversionFactor(Document):
⋮...

erpnext\setup\doctype\employee_external_work_history\employee_external_work_history.py:
│class EmployeeExternalWorkHistory(Document):
⋮...

erpnext\manufacturing\doctype\material_request_plan_item\test_material_request_plan_item.py:
│class TestMaterialRequestPlanItem(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\variant_field\test_variant_field.py:
│class TestVariantField(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\shipping_rule_condition\shipping_rule_condition.py:
│class ShippingRuleCondition(Document):
⋮...

erpnext\buying\doctype\purchase_order_item_supplied\purchase_order_item_supplied.py:
│class PurchaseOrderItemSupplied(Document):
⋮...

erpnext\crm\doctype\market_segment\test_market_segment.py:
│class TestMarketSegment(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\dunning_letter_text\dunning_letter_text.py:
│class DunningLetterText(Document):
⋮...

erpnext\stock\doctype\quality_inspection_parameter\quality_inspection_parameter.py:
│class QualityInspectionParameter(Document):
⋮...

erpnext\stock\doctype\uom_category\uom_category.py:
│class UOMCategory(Document):
⋮...

erpnext\stock\doctype\quality_inspection_parameter\test_quality_inspection_parameter.py:
│class TestQualityInspectionParameter(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\item_tax_template_detail\item_tax_template_detail.py:
│class ItemTaxTemplateDetail(Document):
⋮...

erpnext\assets\doctype\asset_maintenance_team\asset_maintenance_team.py:
│class AssetMaintenanceTeam(Document):
⋮...

erpnext\accounts\doctype\advance_payment_ledger_entry\advance_payment_ledger_entry.py:
│class AdvancePaymentLedgerEntry(Document):
⋮...

erpnext\crm\doctype\prospect_lead\prospect_lead.py:
│class ProspectLead(Document):
⋮...

erpnext\accounts\doctype\tax_withholding_account\tax_withholding_account.py:
│class TaxWithholdingAccount(Document):
⋮...

erpnext\support\doctype\support_settings\test_support_settings.py:
│class TestSupportSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\downtime_entry\test_downtime_entry.py:
│class TestDowntimeEntry(IntegrationTestCase):
│	pass
⋮...

erpnext\regional\doctype\uae_vat_settings\uae_vat_settings.py:
│class UAEVATSettings(Document):
⋮...

erpnext\setup\doctype\party_type\test_party_type.py:
│class TestPartyType(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\stock_entry_detail\stock_entry_detail.py:
│class StockEntryDetail(Document):
⋮...

erpnext\crm\doctype\availability_of_slots\availability_of_slots.py:
│class AvailabilityOfSlots(Document):
⋮...

erpnext\accounts\doctype\promotional_scheme_price_discount\promotional_scheme_price_discount.py:
│class PromotionalSchemePriceDiscount(Document):
⋮...

erpnext\accounts\doctype\supplier_group_item\supplier_group_item.py:
│class SupplierGroupItem(Document):
⋮...

erpnext\accounts\doctype\campaign_item\campaign_item.py:
│class CampaignItem(Document):
⋮...

erpnext\accounts\doctype\repost_allowed_types\repost_allowed_types.py:
│class RepostAllowedTypes(Document):
⋮...

erpnext\accounts\doctype\opening_invoice_creation_tool_item\opening_invoice_creation_tool_item.py:
│class OpeningInvoiceCreationToolItem(Document):
⋮...

erpnext\accounts\doctype\bank_account_type\test_bank_account_type.py:
│class TestBankAccountType(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\bom_explosion_item\bom_explosion_item.py:
│class BOMExplosionItem(Document):
⋮...

erpnext\stock\doctype\stock_reconciliation_item\stock_reconciliation_item.py:
│class StockReconciliationItem(Document):
⋮...

erpnext\manufacturing\doctype\workstation_working_hour\workstation_working_hour.py:
│class WorkstationWorkingHour(Document):
⋮...

erpnext\setup\doctype\employee_group_table\employee_group_table.py:
│class EmployeeGroupTable(Document):
⋮...

erpnext\manufacturing\doctype\sub_operation\test_sub_operation.py:
│class TestSubOperation(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\driving_license_category\driving_license_category.py:
│class DrivingLicenseCategory(Document):
⋮...

erpnext\telephony\doctype\voice_call_settings\test_voice_call_settings.py:
│class TestVoiceCallSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\telephony\doctype\call_log\test_call_log.py:
│class TestCallLog(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\shareholder\test_shareholder.py:
│class TestShareholder(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\pos_item_group\pos_item_group.py:
│class POSItemGroup(Document):
⋮...

erpnext\telephony\doctype\incoming_call_handling_schedule\incoming_call_handling_schedule.py:
│class IncomingCallHandlingSchedule(Document):
⋮...

erpnext\quality_management\doctype\non_conformance\non_conformance.py:
│class NonConformance(Document):
⋮...

erpnext\accounts\doctype\bank_clearance_detail\bank_clearance_detail.py:
│class BankClearanceDetail(Document):
⋮...

erpnext\commands\__init__.py:
│def call_command(cmd, context):
│	return click.Context(cmd, obj=context).forward(cmd)
⋮...

erpnext\accounts\doctype\unreconcile_payment_entries\unreconcile_payment_entries.py:
│class UnreconcilePaymentEntries(Document):
⋮...

erpnext\stock\doctype\item_attribute_value\item_attribute_value.py:
│class ItemAttributeValue(Document):
⋮...

erpnext\accounts\doctype\process_statement_of_accounts_cc\process_statement_of_accounts_cc.py:
│class ProcessStatementOfAccountsCC(Document):
⋮...

erpnext\stock\doctype\item_manufacturer\test_item_manufacturer.py:
│class TestItemManufacturer(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\item_tax_template\test_item_tax_template.py:
│class TestItemTaxTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\maintenance\doctype\maintenance_schedule_item\maintenance_schedule_item.py:
│class MaintenanceScheduleItem(Document):
⋮...

erpnext\accounts\doctype\payment_term\test_payment_term.py:
│class TestPaymentTerm(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\bank_account_type\bank_account_type.py:
│class BankAccountType(Document):
⋮...

erpnext\accounts\doctype\share_type\share_type.py:
│class ShareType(Document):
⋮...

erpnext\quality_management\doctype\quality_meeting_agenda\test_quality_meeting_agenda.py:
│class TestQualityMeetingAgenda(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\bank\test_bank.py:
│class TestBank(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\loyalty_point_entry_redemption\loyalty_point_entry_redemption.py:
│class LoyaltyPointEntryRedemption(Document):
⋮...

erpnext\setup\doctype\website_item_group\website_item_group.py:
│class WebsiteItemGroup(Document):
⋮...

erpnext\setup\doctype\branch\branch.py:
│class Branch(Document):
⋮...

erpnext\quality_management\doctype\quality_feedback_template\test_quality_feedback_template.py:
│class TestQualityFeedbackTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\crm\doctype\opportunity_lost_reason\opportunity_lost_reason.py:
│class OpportunityLostReason(Document):
⋮...

erpnext\utilities\doctype\video_settings\test_video_settings.py:
│class TestVideoSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\bom_website_operation\bom_website_operation.py:
│class BOMWebsiteOperation(Document):
⋮...

erpnext\regional\doctype\uae_vat_settings\test_uae_vat_settings.py:
│class TestUAEVATSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\regional\doctype\south_africa_vat_settings\south_africa_vat_settings.py:
│class SouthAfricaVATSettings(Document):
⋮...

erpnext\accounts\doctype\repost_payment_ledger_items\repost_payment_ledger_items.py:
│class RepostPaymentLedgerItems(Document):
⋮...

erpnext\accounts\doctype\psoa_project\psoa_project.py:
│class PSOAProject(Document):
⋮...

erpnext\stock\doctype\landed_cost_purchase_receipt\landed_cost_purchase_receipt.py:
│class LandedCostPurchaseReceipt(Document):
⋮...

erpnext\selling\doctype\installation_note_item\installation_note_item.py:
│class InstallationNoteItem(Document):
⋮...

erpnext\selling\doctype\product_bundle_item\product_bundle_item.py:
│class ProductBundleItem(Document):
⋮...

erpnext\accounts\doctype\dunning_type\test_dunning_type.py:
│class TestDunningType(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\price_list_country\price_list_country.py:
│class PriceListCountry(Document):
⋮...

erpnext\crm\doctype\appointment_booking_slots\appointment_booking_slots.py:
│class AppointmentBookingSlots(Document):
⋮...

erpnext\accounts\doctype\tax_withholding_rate\tax_withholding_rate.py:
│class TaxWithholdingRate(Document):
⋮...

erpnext\setup\doctype\authorization_rule\test_authorization_rule.py:
│class TestAuthorizationRule(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\driver\test_driver.py:
│class TestDriver(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\exchange_rate_revaluation_account\exchange_rate_revaluation_account.py:
│class ExchangeRateRevaluationAccount(Document):
⋮...

erpnext\telephony\doctype\telephony_call_type\telephony_call_type.py:
│class TelephonyCallType(Document):
⋮...

erpnext\accounts\doctype\tax_category\tax_category.py:
│class TaxCategory(Document):
⋮...

erpnext\quality_management\doctype\quality_meeting\quality_meeting.py:
│class QualityMeeting(Document):
⋮...

erpnext\accounts\doctype\currency_exchange_settings_result\currency_exchange_settings_result.py:
│class CurrencyExchangeSettingsResult(Document):
⋮...

erpnext\accounts\doctype\psoa_cost_center\psoa_cost_center.py:
│class PSOACostCenter(Document):
⋮...

erpnext\accounts\doctype\advance_taxes_and_charges\advance_taxes_and_charges.py:
│class AdvanceTaxesandCharges(Document):
⋮...

erpnext\accounts\doctype\process_payment_reconciliation_log\process_payment_reconciliation_log.py:
│class ProcessPaymentReconciliationLog(Document):
⋮...

erpnext\manufacturing\doctype\job_card_operation\job_card_operation.py:
│class JobCardOperation(Document):
⋮...

erpnext\accounts\doctype\promotional_scheme_product_discount\promotional_scheme_product_discount.py:
│class PromotionalSchemeProductDiscount(Document):
⋮...

erpnext\accounts\doctype\subscription_plan\test_subscription_plan.py:
│class TestSubscriptionPlan(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\bom_item\bom_item.py:
│class BOMItem(Document):
⋮...

erpnext\crm\doctype\crm_settings\test_crm_settings.py:
│class TestCRMSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\shipment_parcel_template\shipment_parcel_template.py:
│class ShipmentParcelTemplate(Document):
⋮...

erpnext\stock\doctype\delivery_note_item\delivery_note_item.py:
│class DeliveryNoteItem(Document):
⋮...

erpnext\accounts\doctype\subscription_settings\test_subscription_settings.py:
│class TestSubscriptionSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\quotation_lost_reason\quotation_lost_reason.py:
│class QuotationLostReason(Document):
⋮...

erpnext\buying\doctype\supplier_scorecard_scoring_standing\supplier_scorecard_scoring_standing.py:
│class SupplierScorecardScoringStanding(Document):
⋮...

erpnext\accounts\doctype\allowed_dimension\allowed_dimension.py:
│class AllowedDimension(Document):
⋮...

erpnext\stock\doctype\quality_inspection_parameter_group\test_quality_inspection_parameter_group.py:
│class TestQualityInspectionParameterGroup(IntegrationTestCase):
│	pass
⋮...

erpnext\crm\doctype\lost_reason_detail\lost_reason_detail.py:
│class LostReasonDetail(Document):
⋮...

erpnext\buying\doctype\request_for_quotation_supplier\request_for_quotation_supplier.py:
│class RequestforQuotationSupplier(Document):
⋮...

erpnext\portal\doctype\website_attribute\website_attribute.py:
│class WebsiteAttribute(Document):
⋮...

erpnext\crm\doctype\contract_fulfilment_checklist\test_contract_fulfilment_checklist.py:
│class TestContractFulfilmentChecklist(IntegrationTestCase):
│	pass
⋮...

erpnext\selling\doctype\installation_note\test_installation_note.py:
│class TestInstallationNote(IntegrationTestCase):
│	pass
⋮...

erpnext\selling\doctype\quotation_item\quotation_item.py:
│class QuotationItem(Document):
⋮...

erpnext\accounts\doctype\pos_closing_entry_detail\pos_closing_entry_detail.py:
│class POSClosingEntryDetail(Document):
⋮...

erpnext\accounts\doctype\cashier_closing_payments\cashier_closing_payments.py:
│class CashierClosingPayments(Document):
⋮...

erpnext\quality_management\doctype\quality_action_resolution\quality_action_resolution.py:
│class QualityActionResolution(Document):
⋮...

erpnext\support\doctype\sla_fulfilled_on_status\sla_fulfilled_on_status.py:
│class SLAFulfilledOnStatus(Document):
⋮...

erpnext\manufacturing\doctype\production_plan_item\production_plan_item.py:
│class ProductionPlanItem(Document):
⋮...

erpnext\stock\doctype\shipment_parcel\shipment_parcel.py:
│class ShipmentParcel(Document):
⋮...

erpnext\manufacturing\doctype\bom_website_item\bom_website_item.py:
│class BOMWebsiteItem(Document):
⋮...

erpnext\accounts\doctype\pos_settings\test_pos_settings.py:
│class TestPOSSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\item_website_specification\item_website_specification.py:
│class ItemWebsiteSpecification(Document):
⋮...

erpnext\manufacturing\doctype\blanket_order_item\blanket_order_item.py:
│class BlanketOrderItem(Document):
⋮...

erpnext\accounts\doctype\pos_customer_group\pos_customer_group.py:
│class POSCustomerGroup(Document):
⋮...

erpnext\stock\doctype\shipment_delivery_note\shipment_delivery_note.py:
│class ShipmentDeliveryNote(Document):
⋮...

erpnext\accounts\doctype\bank_transaction_mapping\bank_transaction_mapping.py:
│class BankTransactionMapping(Document):
⋮...

erpnext\crm\doctype\opportunity_item\opportunity_item.py:
│class OpportunityItem(Document):
⋮...

erpnext\stock\doctype\item_variant_settings\test_item_variant_settings.py:
│class TestItemVariantSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\startup\notifications.py:
│def get_notification_config():
⋮...

erpnext\assets\doctype\asset_finance_book\asset_finance_book.py:
│class AssetFinanceBook(Document):
⋮...

erpnext\subcontracting\doctype\subcontracting_order_service_item\subcontracting_order_service_item.py:
│class SubcontractingOrderServiceItem(Document):
⋮...

erpnext\accounts\doctype\advance_tax\advance_tax.py:
│class AdvanceTax(Document):
⋮...

erpnext\assets\doctype\asset_capitalization_service_item\asset_capitalization_service_item.py:
│class AssetCapitalizationServiceItem(Document):
⋮...

erpnext\accounts\doctype\pos_profile_user\pos_profile_user.py:
│class POSProfileUser(Document):
⋮...

erpnext\stock\doctype\delivery_stop\delivery_stop.py:
│class DeliveryStop(Document):
⋮...

erpnext\accounts\doctype\repost_accounting_ledger_settings\repost_accounting_ledger_settings.py:
│class RepostAccountingLedgerSettings(Document):
⋮...

erpnext\quality_management\doctype\quality_procedure_process\quality_procedure_process.py:
│class QualityProcedureProcess(Document):
⋮...

erpnext\support\doctype\service_level_priority\service_level_priority.py:
│class ServiceLevelPriority(Document):
⋮...

erpnext\setup\doctype\designation\designation.py:
│class Designation(Document):
⋮...

erpnext\gettext\extractors\lines_from_txt_file.py:
│def extract(fileobj, *args, **kwargs):
│	"""Split file into lines and yield one translation unit per line."""
│	for line_no, line in enumerate(fileobj.readlines()):
│		yield line_no + 1, "_", line.decode().strip(), []
⋮...

erpnext\manufacturing\doctype\production_plan_material_request_warehouse\production_plan_material_request_warehouse.py:
│class ProductionPlanMaterialRequestWarehouse(Document):
⋮...

erpnext\support\doctype\pause_sla_on_status\pause_sla_on_status.py:
│class PauseSLAOnStatus(Document):
⋮...

erpnext\accounts\doctype\sales_taxes_and_charges_template\test_sales_taxes_and_charges_template.py:
│class TestSalesTaxesandChargesTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\support\doctype\warranty_claim\test_warranty_claim.py:
│class TestWarrantyClaim(IntegrationTestCase):
│	pass
⋮...

erpnext\maintenance\doctype\maintenance_visit_purpose\maintenance_visit_purpose.py:
│class MaintenanceVisitPurpose(Document):
⋮...

erpnext\accounts\doctype\chart_of_accounts_importer\test_chart_of_accounts_importer.py:
│class TestChartofAccountsImporter(IntegrationTestCase):
│	pass
⋮...

erpnext\portal\doctype\website_filter_field\website_filter_field.py:
│class WebsiteFilterField(Document):
⋮...

erpnext\stock\doctype\customs_tariff_number\test_customs_tariff_number.py:
│class TestCustomsTariffNumber(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\email_digest_recipient\email_digest_recipient.py:
│class EmailDigestRecipient(Document):
⋮...

erpnext\accounts\doctype\process_payment_reconciliation_log_allocations\process_payment_reconciliation_log_allocations.py:
│class ProcessPaymentReconciliationLogAllocations(Document):
⋮...

erpnext\assets\doctype\asset_capitalization_asset_item\asset_capitalization_asset_item.py:
│class AssetCapitalizationAssetItem(Document):
⋮...

erpnext\setup\doctype\transaction_deletion_record_item\transaction_deletion_record_item.py:
│class TransactionDeletionRecordItem(Document):
⋮...

erpnext\assets\doctype\asset_maintenance_team\test_asset_maintenance_team.py:
│class TestAssetMaintenanceTeam(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\monthly_distribution_percentage\monthly_distribution_percentage.py:
│class MonthlyDistributionPercentage(Document):
⋮...

erpnext\selling\doctype\industry_type\industry_type.py:
│class IndustryType(Document):
⋮...

erpnext\accounts\doctype\pos_opening_entry_detail\pos_opening_entry_detail.py:
│class POSOpeningEntryDetail(Document):
⋮...

erpnext\accounts\doctype\supplier_item\supplier_item.py:
│class SupplierItem(Document):
⋮...

erpnext\accounts\doctype\ledger_merge_accounts\ledger_merge_accounts.py:
│class LedgerMergeAccounts(Document):
⋮...

erpnext\edi\doctype\common_code\test_common_code.py:
│class TestCommonCode(FrappeTestCase):
│	pass
⋮...

erpnext\accounts\doctype\customer_group_item\customer_group_item.py:
│class CustomerGroupItem(Document):
⋮...

erpnext\accounts\doctype\bank_account_subtype\test_bank_account_subtype.py:
│class TestBankAccountSubtype(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\bom_operation\bom_operation.py:
│class BOMOperation(Document):
⋮...

erpnext\telephony\doctype\incoming_call_settings\test_incoming_call_settings.py:
│class TestIncomingCallSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\quality_management\doctype\non_conformance\test_non_conformance.py:
│class TestNonConformance(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\customs_tariff_number\customs_tariff_number.py:
│class CustomsTariffNumber(Document):
⋮...

erpnext\crm\doctype\sales_stage\test_sales_stage.py:
│class TestSalesStage(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\item_reorder\item_reorder.py:
│class ItemReorder(Document):
⋮...

erpnext\accounts\doctype\south_africa_vat_account\south_africa_vat_account.py:
│class SouthAfricaVATAccount(Document):
⋮...

erpnext\crm\doctype\market_segment\market_segment.py:
│class MarketSegment(Document):
⋮...

erpnext\accounts\doctype\finance_book\finance_book.py:
│class FinanceBook(Document):
⋮...

erpnext\accounts\doctype\account\chart_of_accounts\verified\standard_chart_of_accounts.py:
│def get():
⋮...

erpnext\accounts\doctype\share_balance\share_balance.py:
│class ShareBalance(Document):
⋮...

erpnext\accounts\doctype\purchase_taxes_and_charges_template\test_purchase_taxes_and_charges_template.py:
│class TestPurchaseTaxesandChargesTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\delivery_settings\delivery_settings.py:
│class DeliverySettings(Document):
⋮...

erpnext\accounts\doctype\journal_entry_account\journal_entry_account.py:
│class JournalEntryAccount(Document):
⋮...

erpnext\accounts\doctype\subscription_invoice\subscription_invoice.py:
│class SubscriptionInvoice(Document):
⋮...

erpnext\accounts\doctype\party_link\test_party_link.py:
│class TestPartyLink(IntegrationTestCase):
│	pass
⋮...

erpnext\quality_management\doctype\quality_feedback_template_parameter\quality_feedback_template_parameter.py:
│class QualityFeedbackTemplateParameter(Document):
⋮...

erpnext\accounts\doctype\payment_term\payment_term.py:
│class PaymentTerm(Document):
⋮...

erpnext\accounts\doctype\share_type\test_share_type.py:
│class TestShareType(IntegrationTestCase):
│	pass
⋮...

erpnext\buying\doctype\buying_settings\test_buying_settings.py:
│class TestBuyingSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\cheque_print_template\test_cheque_print_template.py:
│class TestChequePrintTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\crm\doctype\competitor\test_competitor.py:
│class TestCompetitor(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\designation\test_designation.py:
│def create_designation(**args):
⋮...

erpnext\crm\doctype\opportunity_type\opportunity_type.py:
│class OpportunityType(Document):
⋮...

erpnext\accounts\doctype\closed_document\closed_document.py:
│class ClosedDocument(Document):
⋮...

erpnext\telephony\doctype\voice_call_settings\voice_call_settings.py:
│class VoiceCallSettings(Document):
⋮...

erpnext\accounts\doctype\applicable_on_account\applicable_on_account.py:
│class ApplicableOnAccount(Document):
⋮...

erpnext\quality_management\doctype\quality_review_objective\quality_review_objective.py:
│class QualityReviewObjective(Document):
⋮...

erpnext\quality_management\doctype\quality_feedback_parameter\quality_feedback_parameter.py:
│class QualityFeedbackParameter(Document):
⋮...

erpnext\setup\doctype\uom_conversion_factor\test_uom_conversion_factor.py:
│class TestUOMConversionFactor(IntegrationTestCase):
│	pass
⋮...

erpnext\regional\doctype\import_supplier_invoice\test_import_supplier_invoice.py:
│class TestImportSupplierInvoice(IntegrationTestCase):
│	pass
⋮...

erpnext\assets\doctype\asset_capitalization_stock_item\asset_capitalization_stock_item.py:
│class AssetCapitalizationStockItem(Document):
⋮...

erpnext\manufacturing\doctype\bom_scrap_item\bom_scrap_item.py:
│class BOMScrapItem(Document):
⋮...

erpnext\stock\doctype\item_quality_inspection_parameter\item_quality_inspection_parameter.py:
│class ItemQualityInspectionParameter(Document):
⋮...

erpnext\setup\doctype\print_heading\print_heading.py:
│class PrintHeading(Document):
⋮...

erpnext\selling\doctype\sales_partner_type\test_sales_partner_type.py:
│class TestSalesPartnerType(IntegrationTestCase):
│	pass
⋮...

erpnext\buying\doctype\supplier_scorecard_period\test_supplier_scorecard_period.py:
│class TestSupplierScorecardPeriod(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\employee_group\employee_group.py:
│class EmployeeGroup(Document):
⋮...

erpnext\stock\doctype\pick_list_item\pick_list_item.py:
│class PickListItem(Document):
⋮...

erpnext\crm\doctype\sales_stage\sales_stage.py:
│class SalesStage(Document):
⋮...

erpnext\accounts\doctype\monthly_distribution\test_monthly_distribution.py:
│class TestMonthlyDistribution(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\accounting_dimension_detail\accounting_dimension_detail.py:
│class AccountingDimensionDetail(Document):
⋮...

erpnext\accounts\doctype\pos_profile_user\test_pos_profile_user.py:
│class TestPOSProfileUser(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\mode_of_payment_account\mode_of_payment_account.py:
│class ModeofPaymentAccount(Document):
⋮...

erpnext\maintenance\doctype\maintenance_schedule_detail\maintenance_schedule_detail.py:
│class MaintenanceScheduleDetail(Document):
⋮...

erpnext\assets\doctype\maintenance_team_member\maintenance_team_member.py:
│class MaintenanceTeamMember(Document):
⋮...

erpnext\crm\doctype\opportunity_lost_reason_detail\opportunity_lost_reason_detail.py:
│class OpportunityLostReasonDetail(Document):
⋮...

erpnext\assets\doctype\asset_maintenance_log\test_asset_maintenance_log.py:
│class TestAssetMaintenanceLog(IntegrationTestCase):
│	pass
⋮...

erpnext\communication\doctype\communication_medium\communication_medium.py:
│class CommunicationMedium(Document):
⋮...

erpnext\buying\report\procurement_tracker\test_procurement_tracker.py:
│class TestProcurementTracker(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\overdue_payment\overdue_payment.py:
│class OverduePayment(Document):
⋮...

erpnext\accounts\doctype\subscription_settings\subscription_settings.py:
│class SubscriptionSettings(Document):
⋮...

erpnext\manufacturing\doctype\bom_update_batch\bom_update_batch.py:
│class BOMUpdateBatch(Document):
⋮...

erpnext\buying\doctype\supplier_scorecard_standing\test_supplier_scorecard_standing.py:
│class TestSupplierScorecardStanding(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\quotation_lost_reason_detail\quotation_lost_reason_detail.py:
│class QuotationLostReasonDetail(Document):
⋮...

erpnext\quality_management\doctype\quality_action\test_quality_action.py:
│class TestQualityAction(IntegrationTestCase):
│	# quality action has no code
│	pass
⋮...

erpnext\stock\doctype\item_customer_detail\item_customer_detail.py:
│class ItemCustomerDetail(Document):
⋮...

erpnext\accounts\doctype\currency_exchange_settings\test_currency_exchange_settings.py:
│class TestCurrencyExchangeSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\pos_field\pos_field.py:
│class POSField(Document):
⋮...

erpnext\assets\doctype\asset_maintenance_task\asset_maintenance_task.py:
│class AssetMaintenanceTask(Document):
⋮...

erpnext\stock\doctype\item_barcode\item_barcode.py:
│class ItemBarcode(Document):
⋮...

erpnext\accounts\doctype\journal_entry_template_account\journal_entry_template_account.py:
│class JournalEntryTemplateAccount(Document):
⋮...

erpnext\crm\doctype\competitor_detail\competitor_detail.py:
│class CompetitorDetail(Document):
⋮...

erpnext\stock\doctype\uom_conversion_detail\uom_conversion_detail.py:
│class UOMConversionDetail(Document):
⋮...

erpnext\manufacturing\doctype\manufacturing_settings\test_manufacturing_settings.py:
│class TestManufacturingSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\sales_partner_item\sales_partner_item.py:
│class SalesPartnerItem(Document):
⋮...

erpnext\accounts\doctype\currency_exchange_settings_details\currency_exchange_settings_details.py:
│class CurrencyExchangeSettingsDetails(Document):
⋮...

erpnext\crm\doctype\email_campaign\test_email_campaign.py:
│class TestEmailCampaign(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\production_plan_sub_assembly_item\production_plan_sub_assembly_item.py:
│class ProductionPlanSubAssemblyItem(Document):
⋮...

erpnext\accounts\doctype\payment_order_reference\payment_order_reference.py:
│class PaymentOrderReference(Document):
⋮...

erpnext\setup\doctype\holiday\holiday.py:
│class Holiday(Document):
⋮...

erpnext\stock\dashboard_chart_source\warehouse_wise_stock_value\warehouse_wise_stock_value.py:
│def get(
│	chart_name=None,
│	chart=None,
│	no_cache=None,
│	filters=None,
│	from_date=None,
│	to_date=None,
│	timespan=None,
│	time_interval=None,
│	heatmap_year=None,
│):
⋮...

erpnext\accounts\doctype\tax_category\test_tax_category.py:
│class TestTaxCategory(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\bank_account_subtype\bank_account_subtype.py:
│class BankAccountSubtype(Document):
⋮...

erpnext\selling\doctype\sales_partner_type\sales_partner_type.py:
│class SalesPartnerType(Document):
⋮...

erpnext\stock\doctype\quality_inspection_reading\quality_inspection_reading.py:
│class QualityInspectionReading(Document):
⋮...

erpnext\accounts\doctype\customer_item\customer_item.py:
│class CustomerItem(Document):
⋮...

erpnext\accounts\doctype\subscription_invoice\test_subscription_invoice.py:
│class TestSubscriptionInvoice(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\bisect_nodes\bisect_nodes.py:
│class BisectNodes(Document):
⋮...

erpnext\support\doctype\support_settings\support_settings.py:
│class SupportSettings(Document):
⋮...

erpnext\stock\doctype\item_variant\item_variant.py:
│class ItemVariant(Document):
⋮...

erpnext\stock\doctype\item_supplier\item_supplier.py:
│class ItemSupplier(Document):
⋮...

erpnext\communication\doctype\communication_medium_timeslot\communication_medium_timeslot.py:
│class CommunicationMediumTimeslot(Document):
⋮...

erpnext\buying\doctype\supplier_quotation_item\supplier_quotation_item.py:
│class SupplierQuotationItem(Document):
⋮...

erpnext\manufacturing\doctype\job_card_scrap_item\job_card_scrap_item.py:
│class JobCardScrapItem(Document):
⋮...

erpnext\stock\doctype\uom_category\test_uom_category.py:
│class TestUOMCategory(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\transaction_deletion_record_details\transaction_deletion_record_details.py:
│class TransactionDeletionRecordDetails(Document):
⋮...

erpnext\manufacturing\doctype\sub_operation\sub_operation.py:
│class SubOperation(Document):
⋮...

erpnext\accounts\doctype\pos_payment_method\pos_payment_method.py:
│class POSPaymentMethod(Document):
⋮...

erpnext\manufacturing\doctype\production_plan_item_reference\production_plan_item_reference.py:
│class ProductionPlanItemReference(Document):
⋮...

erpnext\stock\doctype\item_variant_attribute\item_variant_attribute.py:
│class ItemVariantAttribute(Document):
⋮...

erpnext\regional\doctype\south_africa_vat_settings\test_south_africa_vat_settings.py:
│class TestSouthAfricaVATSettings(IntegrationTestCase):
│	pass
⋮...

erpnext\templates\utils.py:
│def send_message(sender, message, subject="Website Query"):
⋮...

erpnext\stock\doctype\warehouse_type\test_warehouse_type.py:
│class TestWarehouseType(IntegrationTestCase):
│	pass
⋮...

erpnext\crm\doctype\contract_template_fulfilment_terms\contract_template_fulfilment_terms.py:
│class ContractTemplateFulfilmentTerms(Document):
⋮...

erpnext\accounts\doctype\mode_of_payment\test_mode_of_payment.py:
│class TestModeofPayment(IntegrationTestCase):
│	pass
⋮...

erpnext\quality_management\doctype\quality_meeting\test_quality_meeting.py:
│class TestQualityMeeting(IntegrationTestCase):
│	# nothing to test
│	pass
⋮...

erpnext\buying\doctype\request_for_quotation_item\request_for_quotation_item.py:
│class RequestforQuotationItem(Document):
⋮...

erpnext\accounts\doctype\ledger_health\ledger_health.py:
│class LedgerHealth(Document):
⋮...

erpnext\support\doctype\issue_type\issue_type.py:
│class IssueType(Document):
⋮...

erpnext\crm\doctype\campaign_email_schedule\campaign_email_schedule.py:
│class CampaignEmailSchedule(Document):
⋮...

erpnext\buying\doctype\supplier_scorecard_scoring_variable\supplier_scorecard_scoring_variable.py:
│class SupplierScorecardScoringVariable(Document):
⋮...

erpnext\stock\doctype\manufacturer\test_manufacturer.py:
│class TestManufacturer(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\ledger_health_monitor_company\ledger_health_monitor_company.py:
│class LedgerHealthMonitorCompany(Document):
⋮...

erpnext\accounts\doctype\ledger_health_monitor\ledger_health_monitor.py:
│class LedgerHealthMonitor(Document):
⋮...

erpnext\accounts\doctype\fiscal_year_company\fiscal_year_company.py:
│class FiscalYearCompany(Document):
⋮...

erpnext\manufacturing\doctype\production_plan_material_request_warehouse\test_production_plan_material_request_warehouse.py:
│class TestProductionPlanMaterialRequestWarehouse(IntegrationTestCase):
│	pass
⋮...

erpnext\stock\doctype\landed_cost_item\landed_cost_item.py:
│class LandedCostItem(Document):
⋮...

erpnext\accounts\doctype\territory_item\territory_item.py:
│class TerritoryItem(Document):
⋮...

erpnext\stock\doctype\delivery_settings\test_delivery_settings.py:
│class TestDeliverySettings(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\email_digest\test_email_digest.py:
│class TestEmailDigest(IntegrationTestCase):
│	pass
⋮...

erpnext\crm\doctype\contract_template\test_contract_template.py:
│class TestContractTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\accounts\doctype\payment_gateway_account\test_payment_gateway_account.py:
│class TestPaymentGatewayAccount(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\default_energy_point_rules.py:
│def get_default_energy_point_rules():
⋮...

erpnext\accounts\doctype\budget_account\budget_account.py:
│class BudgetAccount(Document):
⋮...

erpnext\accounts\doctype\tax_withheld_vouchers\tax_withheld_vouchers.py:
│class TaxWithheldVouchers(Document):
⋮...

erpnext\subcontracting\doctype\subcontracting_receipt_supplied_item\subcontracting_receipt_supplied_item.py:
│class SubcontractingReceiptSuppliedItem(Document):
⋮...

erpnext\accounts\doctype\payment_terms_template_detail\payment_terms_template_detail.py:
│class PaymentTermsTemplateDetail(Document):
⋮...

erpnext\regional\doctype\uae_vat_account\uae_vat_account.py:
│class UAEVATAccount(Document):
⋮...

erpnext\crm\doctype\contract_fulfilment_checklist\contract_fulfilment_checklist.py:
│class ContractFulfilmentChecklist(Document):
⋮...

erpnext\accounts\doctype\pos_search_fields\pos_search_fields.py:
│class POSSearchFields(Document):
⋮...

erpnext\support\doctype\issue_priority\issue_priority.py:
│class IssuePriority(Document):
⋮...

erpnext\startup\filters.py:
│def get_filters_config():
⋮...

erpnext\subcontracting\doctype\subcontracting_order_item\subcontracting_order_item.py:
│class SubcontractingOrderItem(Document):
⋮...

erpnext\manufacturing\doctype\production_plan_sales_order\production_plan_sales_order.py:
│class ProductionPlanSalesOrder(Document):
⋮...

erpnext\accounts\doctype\journal_entry_template\test_journal_entry_template.py:
│class TestJournalEntryTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\subcontracting\doctype\subcontracting_receipt_item\subcontracting_receipt_item.py:
│class SubcontractingReceiptItem(Document):
⋮...

erpnext\stock\doctype\shipment_parcel_template\test_shipment_parcel_template.py:
│class TestShipmentParcelTemplate(IntegrationTestCase):
│	pass
⋮...

erpnext\assets\doctype\asset_repair_purchase_invoice\asset_repair_purchase_invoice.py:
│class AssetRepairPurchaseInvoice(Document):
⋮...

erpnext\gettext\extractors\uom_data.py:
│def extract(fileobj, *args, **kwargs):
⋮...

erpnext\accounts\doctype\discounted_invoice\discounted_invoice.py:
│class DiscountedInvoice(Document):
⋮...

erpnext\assets\doctype\asset_repair_consumed_item\asset_repair_consumed_item.py:
│class AssetRepairConsumedItem(Document):
⋮...

erpnext\quality_management\doctype\quality_meeting_minutes\quality_meeting_minutes.py:
│class QualityMeetingMinutes(Document):
⋮...

erpnext\support\doctype\support_search_source\support_search_source.py:
│class SupportSearchSource(Document):
⋮...

erpnext\utilities\doctype\video\test_video.py:
│class TestVideo(IntegrationTestCase):
│	pass
⋮...

erpnext\setup\doctype\employee_education\employee_education.py:
│class EmployeeEducation(Document):
⋮...

erpnext\manufacturing\doctype\production_plan_material_request\production_plan_material_request.py:
│class ProductionPlanMaterialRequest(Document):
⋮...

erpnext\assets\doctype\linked_location\linked_location.py:
│class LinkedLocation(Document):
⋮...

erpnext\accounts\doctype\repost_accounting_ledger_items\repost_accounting_ledger_items.py:
│class RepostAccountingLedgerItems(Document):
⋮...

erpnext\stock\doctype\stock_closing_balance\stock_closing_balance.py:
│class StockClosingBalance(Document):
⋮...

erpnext\crm\doctype\prospect_opportunity\prospect_opportunity.py:
│class ProspectOpportunity(Document):
⋮...

erpnext\manufacturing\doctype\job_card_scheduled_time\job_card_scheduled_time.py:
│class JobCardScheduledTime(Document):
⋮...

erpnext\quality_management\doctype\quality_meeting_agenda\quality_meeting_agenda.py:
│class QualityMeetingAgenda(Document):
⋮...

erpnext\setup\doctype\employee_internal_work_history\employee_internal_work_history.py:
│class EmployeeInternalWorkHistory(Document):
⋮...

erpnext\quality_management\doctype\quality_feedback_template\quality_feedback_template.py:
│class QualityFeedbackTemplate(Document):
⋮...

erpnext\stock\doctype\purchase_receipt_item\purchase_receipt_item.py:
│class PurchaseReceiptItem(Document):
⋮...

erpnext\assets\doctype\asset_movement_item\asset_movement_item.py:
│class AssetMovementItem(Document):
⋮...

erpnext\accounts\doctype\cashier_closing\test_cashier_closing.py:
│class TestCashierClosing(IntegrationTestCase):
│	pass
⋮...

erpnext\manufacturing\doctype\work_order_operation\work_order_operation.py:
│class WorkOrderOperation(Document):
⋮...

erpnext\accounts\doctype\shipping_rule_country\shipping_rule_country.py:
│class ShippingRuleCountry(Document):
⋮...

erpnext\accounts\doctype\pos_closing_entry_taxes\pos_closing_entry_taxes.py:
│class POSClosingEntryTaxes(Document):
⋮...

erpnext\bulk_transaction\doctype\bulk_transaction_log_detail\bulk_transaction_log_detail.py:
│class BulkTransactionLogDetail(Document):
⋮...

erpnext\accounts\doctype\cost_center_allocation_percentage\cost_center_allocation_percentage.py:
│class CostCenterAllocationPercentage(Document):
⋮...

erpnext\manufacturing\doctype\material_request_plan_item\material_request_plan_item.py:
│class MaterialRequestPlanItem(Document):
⋮...

erpnext\accounts\doctype\payment_entry_deduction\payment_entry_deduction.py:
│class PaymentEntryDeduction(Document):
⋮...

erpnext\quality_management\doctype\quality_goal_objective\quality_goal_objective.py:
│class QualityGoalObjective(Document):
⋮...

erpnext\accounts\doctype\process_statement_of_accounts_customer\process_statement_of_accounts_customer.py:
│class ProcessStatementOfAccountsCustomer(Document):
⋮...

erpnext\setup\doctype\global_defaults\test_global_defaults.py:
│class TestGlobalDefaults(IntegrationTestCase):
│	pass
⋮...

erpnext\support\doctype\service_day\service_day.py:
│class ServiceDay(Document):
⋮...