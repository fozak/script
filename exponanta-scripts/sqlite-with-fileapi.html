<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Local SQLite File Storage</title>
<style>
body { 
  font-family: monospace; 
  padding: 20px; 
  display: flex; 
  flex-direction: column;
}
button { 
  padding: 8px 16px; 
  margin: 5px; 
  font-family: monospace;
}
.file-item { 
  padding: 5px; 
  cursor: pointer; 
  color: blue; 
  border: 1px solid #ddd; 
  margin: 2px;
}
.file-item:hover { background: #f0f0f0; }
iframe { 
  width: 100%; 
  height: 300px; 
  border: 1px solid #ccc; 
  margin-top: 10px; 
}
#status { 
  padding: 10px; 
  background: #f0f0f0; 
  margin: 10px 0; 
  white-space: break-spaces;
}
.error { background: yellow; color: red; }
.success { background: #d4edda; color: #155724; }
</style>
</head>
<body>

<h1>Local SQLite File Storage</h1>

<div>
  <input type="file" id="dbInput" accept=".sqlite,.db" title="Pick SQLite DB file">
  <button id="newDb">New DB</button>
</div>

<div>
  <input type="file" id="fileInput" multiple disabled title="Add files to DB">
  <button id="saveDb" disabled>Save DB</button>
</div>

<div id="status">Select or create a database first</div>
<div id="fileList"></div>
<iframe id="preview"></iframe>

<script src="jswasm/sqlite3.js"></script>
<script>
let db;
let dbFileName = 'files.sqlite';
let fileHandle;
let sqlite3;

// Initialize SQLite
sqlite3InitModule().then(sqlite3_ => {
  sqlite3 = sqlite3_;
  console.log('SQLite3 initialized:', sqlite3.version.libVersion);
  
  // Check for File System Access API
  if ('showOpenFilePicker' in window) {
    console.log('File System Access API available');
  }
  
  setStatus('SQLite ready. Pick existing DB or create new one.');
  
}).catch(err => {
  setStatus('Failed to initialize SQLite: ' + err.message, 'error');
});

// Pick existing SQLite file
document.getElementById('dbInput').onchange = async (e) => {
  const file = e.target.files[0];
  if (!file || !sqlite3) return;
  
  try {
    setStatus('Loading database file...');
    dbFileName = file.name;
    const arrayBuffer = await file.arrayBuffer();
    const data = new Uint8Array(arrayBuffer);
    
    console.log(`File: ${file.name}, size: ${data.length} bytes`);
    
    // Create database from file data
    if (data.length > 0) {
      try {
        db = new sqlite3.oo1.DB(data);
        console.log('Database loaded from existing file');
      } catch (e) {
        console.log('File not valid SQLite, creating new:', e.message);
        db = new sqlite3.oo1.DB();
      }
    } else {
      console.log('Empty file, creating new database');
      db = new sqlite3.oo1.DB();
    }
    
    // Create table
    db.exec(`CREATE TABLE IF NOT EXISTS files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      content BLOB NOT NULL,
      size INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    
    console.log('Files table ready');
    
    document.getElementById('fileInput').disabled = false;
    document.getElementById('saveDb').disabled = false;
    setStatus(`Database ready: ${dbFileName}`, 'success');
    updateFileList();
    
  } catch (error) {
    console.error('Database load error:', error);
    setStatus(`Error: ${error.message}`, 'error');
  }
};

// Create new database
document.getElementById('newDb').onclick = async () => {
  if (!sqlite3) return;
  
  try {
    db = new sqlite3.oo1.DB();
    
    db.exec(`CREATE TABLE files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      content BLOB NOT NULL,
      size INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    
    document.getElementById('fileInput').disabled = false;
    document.getElementById('saveDb').disabled = false;
    setStatus('New database created', 'success');
    updateFileList();
    
  } catch (error) {
    console.error('New DB error:', error);
    setStatus(`Error creating DB: ${error.message}`, 'error');
  }
};

// Add files to database
document.getElementById('fileInput').onchange = async (e) => {
  if (!db) return;
  
  try {
    let count = 0;
    for (const file of e.target.files) {
      const arrayBuffer = await file.arrayBuffer();
      const content = new Uint8Array(arrayBuffer);
      
      // Use prepare/bind/step for BLOB data
      const stmt = db.prepare("INSERT INTO files (name, content, size) VALUES (?, ?, ?)");
      stmt.bind([file.name, content, file.size]);
      stmt.step();
      stmt.finalize();
      
      console.log(`Added: ${file.name} (${file.size} bytes)`);
      count++;
    }
    
    setStatus(`Added ${count} files to database`, 'success');
    updateFileList();
    
  } catch (error) {
    console.error('Add files error:', error);
    setStatus(`Error adding files: ${error.message}`, 'error');
  }
};

// Update file list
function updateFileList() {
  if (!db) return;
  
  const list = document.getElementById('fileList');
  list.innerHTML = '';
  
  try {
    const result = db.exec("SELECT id, name, size, created_at FROM files ORDER BY id DESC");
    
    if (result.length > 0 && result[0].values.length > 0) {
      result[0].values.forEach(([id, name, size, created]) => {
        const div = document.createElement('div');
        div.className = 'file-item';
        div.innerHTML = `${name} (${(size/1024).toFixed(1)} KB)`;
        div.onclick = () => previewFile(id);
        list.appendChild(div);
      });
    } else {
      list.innerHTML = 'No files in database';
    }
    
  } catch (error) {
    list.innerHTML = 'Error loading file list';
    console.error(error);
  }
}

// Preview file
function previewFile(id) {
  if (!db) return;
  
  try {
    const result = db.exec({
      sql: "SELECT name, content FROM files WHERE id = ?",
      bind: [id]
    });
    
    if (result.length > 0 && result[0].values.length > 0) {
      const [name, content] = result[0].values[0];
      const blob = new Blob([content], { 
        type: name.endsWith('.html') ? 'text/html' : 'text/plain' 
      });
      const url = URL.createObjectURL(blob);
      document.getElementById('preview').src = url;
      
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setStatus(`Previewing: ${name}`);
    }
    
  } catch (error) {
    setStatus(`Preview error: ${error.message}`, 'error');
  }
}

// Save database
document.getElementById('saveDb').onclick = async () => {
  if (!db) return;
  
  if (fileHandle) {
    await saveToFileHandle();
  } else {
    saveAsDownload();
  }
};

// Save using File Handle (direct write)
async function saveToFileHandle() {
  try {
    const data = db.export();
    const writable = await fileHandle.createWritable();
    await writable.write(data);
    await writable.close();
    setStatus(`Saved directly to ${dbFileName}`, 'success');
  } catch (error) {
    setStatus(`Direct save failed: ${error.message}`, 'error');
    saveAsDownload();
  }
}

// Save as download
function saveAsDownload() {
  const data = db.export();
  const blob = new Blob([data], { type: 'application/x-sqlite3' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = dbFileName;
  a.click();
  
  URL.revokeObjectURL(url);
  setStatus(`Database downloaded as ${dbFileName}`, 'success');
}

function setStatus(message, type = '') {
  const status = document.getElementById('status');
  status.textContent = message;
  status.className = type;
  console.log(message);
}
</script>

</body>
</html>