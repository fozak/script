<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Local SQLite File Storage</title>
<style>
body { 
  font-family: monospace; 
  padding: 20px; 
  display: flex; 
  flex-direction: column;
}
button { 
  padding: 8px 16px; 
  margin: 5px; 
  font-family: monospace;
}
.file-item { 
  padding: 5px; 
  cursor: pointer; 
  color: blue; 
  border: 1px solid #ddd; 
  margin: 2px;
}
.file-item:hover { background: #f0f0f0; }
iframe { 
  width: 100%; 
  height: 300px; 
  border: 1px solid #ccc; 
  margin-top: 10px; 
}
#status { 
  padding: 10px; 
  background: #f0f0f0; 
  margin: 10px 0; 
  white-space: break-spaces;
}
.error { background: yellow; color: red; }
.success { background: #d4edda; color: #155724; }
</style>
</head>
<body>

<h1>Local SQLite File Storage</h1>

<div>
  <input type="file" id="dbInput" accept=".sqlite,.db" title="Pick SQLite DB file">
  <button id="newDb">New DB</button>
</div>

<div>
  <input type="file" id="fileInput" multiple disabled title="Add files to DB">
  <button id="saveDb" disabled>Save DB</button>
</div>

<div id="status">Select or create a database first</div>
<div id="fileList"></div>
<iframe id="preview"></iframe>

<script src="jswasm/sqlite3.js"></script>
<script>
let db;
let dbFileName = 'files.sqlite';
let fileHandle;

// Initialize SQLite
sqlite3InitModule().then(sqlite3 => {
  console.log('SQLite3 initialized:', sqlite3.version.libVersion);
  
  // Try to use OPFS if available
  if (sqlite3.opfs) {
    console.log('OPFS available');
  }
  
  // Check for File System Access API
  if ('showOpenFilePicker' in window) {
    console.log('File System Access API available');
  }
  
  setStatus('SQLite ready. Pick existing DB or create new one.');
  
}).catch(err => {
  setStatus('Failed to initialize SQLite: ' + err.message, 'error');
});

// Pick existing SQLite file
document.getElementById('dbInput').onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    setStatus('Loading database file...');
    dbFileName = file.name;
    const arrayBuffer = await file.arrayBuffer();
    const data = new Uint8Array(arrayBuffer);
    
    console.log(`File size: ${data.length} bytes`);
    
    // Try to get persistent file handle if supported
    if ('showOpenFilePicker' in window) {
      try {
        const [fileHandle_] = await window.showOpenFilePicker({
          types: [{ accept: { 'application/x-sqlite3': ['.sqlite', '.db'] } }]
        });
        fileHandle = fileHandle_;
        console.log('Got persistent file handle');
      } catch (e) {
        console.log('File handle not available, using traditional method');
      }
    }
    
    const sqlite3 = await sqlite3InitModule();
    
    // Create database from file data
    try {
      db = new sqlite3.oo1.DB(data);
      console.log('Database loaded from file');
    } catch (e) {
      console.log('Invalid SQLite file, creating new database');
      db = new sqlite3.oo1.DB();
    }
    
    // Ensure files table exists
    try {
      db.exec(`CREATE TABLE IF NOT EXISTS files (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        content BLOB NOT NULL,
        size INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )`);
      console.log('Files table ready');
    } catch (e) {
      console.log('Table creation failed:', e.message);
    }
    
    document.getElementById('fileInput').disabled = false;
    document.getElementById('saveDb').disabled = false;
    setStatus(`Loaded: ${dbFileName}`, 'success');
    updateFileList();
    
  } catch (error) {
    console.error('Full error:', error);
    setStatus(`Error loading DB: ${error.message}`, 'error');
  }
};

// Create new database
document.getElementById('newDb').onclick = async () => {
  try {
    const sqlite3 = await sqlite3InitModule();
    db = new sqlite3.oo1.DB();
    
    db.exec(`CREATE TABLE files (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      content BLOB NOT NULL,
      size INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )`);
    
    document.getElementById('fileInput').disabled = false;
    document.getElementById('saveDb').disabled = false;
    setStatus('New database created', 'success');
    updateFileList();
    
  } catch (error) {
    setStatus(`Error creating DB: ${error.message}`, 'error');
  }
};

// Add files to database
document.getElementById('fileInput').onchange = async (e) => {
  if (!db) return;
  
  try {
    let count = 0;
    for (const file of e.target.files) {
      const arrayBuffer = await file.arrayBuffer();
      const content = new Uint8Array(arrayBuffer);
      
      db.exec({
        sql: "INSERT INTO files (name, content, size) VALUES (?, ?, ?)",
        bind: [file.name, content, file.size]
      });
      
      count++;
    }
    
    setStatus(`Added ${count} files to database`, 'success');
    updateFileList();
    
    // Auto-save if we have a file handle
    if (fileHandle) {
      await saveToFileHandle();
    }
    
  } catch (error) {
    setStatus(`Error adding files: ${error.message}`, 'error');
  }
};

// Update file list
function updateFileList() {
  if (!db) return;
  
  const list = document.getElementById('fileList');
  list.innerHTML = '';
  
  try {
    const result = db.exec("SELECT id, name, size, created_at FROM files ORDER BY id DESC");
    
    if (result.length > 0 && result[0].values.length > 0) {
      result[0].values.forEach(([id, name, size, created]) => {
        const div = document.createElement('div');
        div.className = 'file-item';
        div.innerHTML = `${name} (${(size/1024).toFixed(1)} KB)`;
        div.onclick = () => previewFile(id);
        list.appendChild(div);
      });
    } else {
      list.innerHTML = 'No files in database';
    }
    
  } catch (error) {
    list.innerHTML = 'Error loading file list';
    console.error(error);
  }
}

// Preview file
function previewFile(id) {
  if (!db) return;
  
  try {
    const result = db.exec({
      sql: "SELECT name, content FROM files WHERE id = ?",
      bind: [id]
    });
    
    if (result.length > 0 && result[0].values.length > 0) {
      const [name, content] = result[0].values[0];
      const blob = new Blob([content], { 
        type: name.endsWith('.html') ? 'text/html' : 'text/plain' 
      });
      const url = URL.createObjectURL(blob);
      document.getElementById('preview').src = url;
      
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setStatus(`Previewing: ${name}`);
    }
    
  } catch (error) {
    setStatus(`Preview error: ${error.message}`, 'error');
  }
}

// Save database
document.getElementById('saveDb').onclick = async () => {
  if (!db) return;
  
  if (fileHandle) {
    await saveToFileHandle();
  } else {
    saveAsDownload();
  }
};

// Save using File Handle (direct write)
async function saveToFileHandle() {
  try {
    const data = db.export();
    const writable = await fileHandle.createWritable();
    await writable.write(data);
    await writable.close();
    setStatus(`Saved directly to ${dbFileName}`, 'success');
  } catch (error) {
    setStatus(`Direct save failed: ${error.message}`, 'error');
    saveAsDownload();
  }
}

// Save as download
function saveAsDownload() {
  const data = db.export();
  const blob = new Blob([data], { type: 'application/x-sqlite3' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = dbFileName;
  a.click();
  
  URL.revokeObjectURL(url);
  setStatus(`Database downloaded as ${dbFileName}`, 'success');
}

function setStatus(message, type = '') {
  const status = document.getElementById('status');
  status.textContent = message;
  status.className = type;
  console.log(message);
}
</script>

</body>
</html>