var S9 = Object.defineProperty;
var E9 = Object.getPrototypeOf;
var x9 = Reflect.get;
var vx = De => {
    throw TypeError(De)
}
;
var C9 = (De, We, ft) => We in De ? S9(De, We, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: ft
}) : De[We] = ft;
var J = (De, We, ft) => C9(De, typeof We != "symbol" ? We + "" : We, ft)
  , _x = (De, We, ft) => We.has(De) || vx("Cannot " + ft)
  , Ir = (De, We) => Object(We) !== We ? vx('Cannot use the "in" operator on this value') : De.has(We)
  , o = (De, We, ft) => (_x(De, We, "read from private field"),
ft ? ft.call(De) : We.get(De))
  , b = (De, We, ft) => We.has(De) ? vx("Cannot add the same private member more than once") : We instanceof WeakSet ? We.add(De) : We.set(De, ft)
  , S = (De, We, ft, Ic) => (_x(De, We, "write to private field"),
Ic ? Ic.call(De, ft) : We.set(De, ft),
ft)
  , P = (De, We, ft) => (_x(De, We, "access private method"),
ft);
var _d = (De, We, ft, Ic) => ({
    set _(Fg) {
        S(De, We, Fg, ft)
    },
    get _() {
        return o(De, We, Ic)
    }
})
  , GN = (De, We, ft) => x9(E9(De), ft, We);
(function() {
    "use strict";
    var ON, RN, na, Xs, MN, NN, sa, Ys, Qs, _s, $N, Qf, ep, yo, wo, ia, aa, vo, tp, vb, zu, rp, np, Sx, Vu, _o, sp, ip, LN, oa, Gu, ap, So, Ju, FN, op, cp, up, lp, Zu, Xu, Eo, Ex, JN, Jn, xo, Co, ko, hp, Po, To, Ss, e$, t$, r$, n$, Yu, Qu, mr, el, tl, rl, nl, Eb, sl, il, Kb, ei, Ao, ti, al, fp, ca, Io, pp, mp, Oo, rn, Ro, ol, gp, ua, yp, jN, wp, la, bp, cl, vp, Mo, _p, No, nn, Sp, $o, Ep, ri, i$, a$, Ax, ni, xp, Cp, kp, Pp, Tp, ul, ll, dl, Ap, Lo, _n, kb, Ip, Op, Fo, hl, Rp, jo, fl, si, Zn, pl, ml, Mp, Np, Es, Do, gl, kr, Bo, yl, xs, wl, $p, Ix, qo, Uo, Pr, Ko, Ho, Wo, bl, Lp, vl, _l, Sl, o$, c$, sn, zo, da, Vo, El, Fp, xl, u$, l$, jp, Go, Cl, Dp, Bp, qp, kl, an, Up, Jo, Zo, Pl, Tl, Kp, qx, Xn, Al, ii, Pb, d$, Il, Hr, Ol, ha, Xo, Yn, Rl, Hp, Yo, Tb, Wr, f$, p$, m$, Wp, fa, Ux, Kx, Cs, Qn, pa, gr, g$, y$, w$, Hb, Wb, zp, ma, Ml, ga, Qo, Vp, ya, Gp, Jp, Zp, Xp, Yp, ai, vt, b$, v$, _$, S$, E$, x$, zb, kc, ec, Nl, wa, $l, Ll, Qp, ks, em, tm, rm, nm, sm, im, am, om, cm, um, lm, dm, hm, fm, pm, Ps, Fl, jl, mm, gm, ym, wm, bm, vm, _m, Sm, Ab, T$, ba, va, _a, Sa, tc, rc, Dl, Qe, nc, Ea, Bl, Ts, oi, xa, yr, ql, Em, Ib, Ca, le, A$, Hx, Ua, Vb, Wx, Gb, Ag, I$, O$, R$, zx, M$, Sd, N$, $$, Vx, L$, F$, Jb, j$, Gx, D$, Jx, Zx, xm, ka, Ul, Cm, Sn, sc, Kl, ic, km, Tr, Je, Xx, B$, q$, U$, Yx, Qx, eC, K$, H$, W$, z$, Ed, Pa, Hl, Ta, tC, rC, on, es, Wl, At, ln, ac, V$, Zb, Pm, Tm, ci, Aa, oc, zl, Am, ui, Vl, Im, As, li, Om, Rm, Mm, Ia, tt, ts, Oa, cc, Ra, Gl, Jl, gt, Nt, Zl, Ma, Xl, Yl, Ql, uc, di, Ob, Nm, $m, Fe, G$, J$, Z$, nC, Lm, ed, X$, Y$, Q$, eL, tL, sC, iC, rL, nL, aC, sL, oC, hi, fi, cn, Na, $a, Is, td, La, rd, DN, Fm, nd, Xt, Fa, Yt, lc, jm, ja, dc, hc, Da, Dm, fc, Bm, sd, Rb, zr, cC, uC, qm, Um, Km, Hm, Mb, xd, Nb, id, Wm, Qt, zm, Vm, ad, pi, mi, $t, Gm, pc, iL, $b, Jm, Zm, Xm, Ym, lC, mc, Qm, Ar, dn, gi, od, Ba, yi, eg, Os, cd, tg, yc, wi, rg, ng, wc, bc, ud, vc, sg, ig, ld, ag, Lb, _F, og, Fb, SF, cg, jb, EF, _c, TF, jC, ug, Rs, dd, qa, lg, hd, fd, dg, hg, Ms, AF, IF, Db, OF, RF, Sc, fg, er, Et, un, NF, DC, BC, qC, pg, Bb, pd, $F, LF, mg, UC, md, qb, FF, gd, gg, yg, wg, bi, Ns, Ec, bg, vg, _g, xc, Cc, Sg, yd, Eg, wd, vi, _i, bd, vd, Si;
    function De(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
    }
    function We(n) {
        if (n.__esModule)
            return n;
        var e = n.default;
        if (typeof e == "function") {
            var t = function r() {
                return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
            };
            t.prototype = e.prototype
        } else
            t = {};
        return Object.defineProperty(t, "__esModule", {
            value: !0
        }),
        Object.keys(n).forEach(function(r) {
            var s = Object.getOwnPropertyDescriptor(n, r);
            Object.defineProperty(t, r, s.get ? s : {
                enumerable: !0,
                get: function() {
                    return n[r]
                }
            })
        }),
        t
    }
    var ft = {
        exports: {}
    }, Ic = ft.exports, Fg;
    function JF() {
        return Fg || (Fg = 1,
        function(n, e) {
            (function(t, r) {
                r(n)
            }
            )(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : Ic, function(t) {
                if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id))
                    throw new Error("This script should only be loaded in a browser extension.");
                if (globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)
                    t.exports = globalThis.browser;
                else {
                    const r = "The message port closed before a response was received."
                      , s = i => {
                        const a = {
                            alarms: {
                                clear: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                clearAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                get: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            bookmarks: {
                                create: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getChildren: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getRecent: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getSubTree: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getTree: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                move: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeTree: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                search: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            },
                            browserAction: {
                                disable: {
                                    minArgs: 0,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                enable: {
                                    minArgs: 0,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                getBadgeBackgroundColor: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getBadgeText: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getPopup: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getTitle: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                openPopup: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                setBadgeBackgroundColor: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setBadgeText: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setIcon: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                setPopup: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setTitle: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                }
                            },
                            browsingData: {
                                remove: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                removeCache: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeCookies: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeDownloads: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeFormData: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeHistory: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeLocalStorage: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removePasswords: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removePluginData: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                settings: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            commands: {
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            contextMenus: {
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            },
                            cookies: {
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAllCookieStores: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                set: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            devtools: {
                                inspectedWindow: {
                                    eval: {
                                        minArgs: 1,
                                        maxArgs: 2,
                                        singleCallbackArg: !1
                                    }
                                },
                                panels: {
                                    create: {
                                        minArgs: 3,
                                        maxArgs: 3,
                                        singleCallbackArg: !0
                                    },
                                    elements: {
                                        createSidebarPane: {
                                            minArgs: 1,
                                            maxArgs: 1
                                        }
                                    }
                                }
                            },
                            downloads: {
                                cancel: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                download: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                erase: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getFileIcon: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                open: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                pause: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeFile: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                resume: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                search: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                show: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                }
                            },
                            extension: {
                                isAllowedFileSchemeAccess: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                isAllowedIncognitoAccess: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            history: {
                                addUrl: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                deleteAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                deleteRange: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                deleteUrl: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getVisits: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                search: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            i18n: {
                                detectLanguage: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAcceptLanguages: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            identity: {
                                launchWebAuthFlow: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            idle: {
                                queryState: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            management: {
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getSelf: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                setEnabled: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                uninstallSelf: {
                                    minArgs: 0,
                                    maxArgs: 1
                                }
                            },
                            notifications: {
                                clear: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                create: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getPermissionLevel: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            },
                            pageAction: {
                                getPopup: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getTitle: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                hide: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setIcon: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                setPopup: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setTitle: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                show: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                }
                            },
                            permissions: {
                                contains: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                request: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            runtime: {
                                getBackgroundPage: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getPlatformInfo: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                openOptionsPage: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                requestUpdateCheck: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                sendMessage: {
                                    minArgs: 1,
                                    maxArgs: 3
                                },
                                sendNativeMessage: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                setUninstallURL: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            sessions: {
                                getDevices: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getRecentlyClosed: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                restore: {
                                    minArgs: 0,
                                    maxArgs: 1
                                }
                            },
                            storage: {
                                local: {
                                    clear: {
                                        minArgs: 0,
                                        maxArgs: 0
                                    },
                                    get: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    getBytesInUse: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    remove: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    },
                                    set: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    }
                                },
                                managed: {
                                    get: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    getBytesInUse: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    }
                                },
                                sync: {
                                    clear: {
                                        minArgs: 0,
                                        maxArgs: 0
                                    },
                                    get: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    getBytesInUse: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    remove: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    },
                                    set: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    }
                                }
                            },
                            tabs: {
                                captureVisibleTab: {
                                    minArgs: 0,
                                    maxArgs: 2
                                },
                                create: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                detectLanguage: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                discard: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                duplicate: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                executeScript: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getCurrent: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getZoom: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getZoomSettings: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                goBack: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                goForward: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                highlight: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                insertCSS: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                move: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                query: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                reload: {
                                    minArgs: 0,
                                    maxArgs: 2
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeCSS: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                sendMessage: {
                                    minArgs: 2,
                                    maxArgs: 3
                                },
                                setZoom: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                setZoomSettings: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                update: {
                                    minArgs: 1,
                                    maxArgs: 2
                                }
                            },
                            topSites: {
                                get: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            webNavigation: {
                                getAllFrames: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getFrame: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            webRequest: {
                                handlerBehaviorChanged: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            windows: {
                                create: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                get: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getCurrent: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getLastFocused: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            }
                        };
                        if (Object.keys(a).length === 0)
                            throw new Error("api-metadata.json has not been included in browser-polyfill");
                        class c extends WeakMap {
                            constructor(k, x=void 0) {
                                super(x),
                                this.createItem = k
                            }
                            get(k) {
                                return this.has(k) || this.set(k, this.createItem(k)),
                                super.get(k)
                            }
                        }
                        const u = C => C && typeof C == "object" && typeof C.then == "function"
                          , l = (C, k) => (...x) => {
                            i.runtime.lastError ? C.reject(new Error(i.runtime.lastError.message)) : k.singleCallbackArg || x.length <= 1 && k.singleCallbackArg !== !1 ? C.resolve(x[0]) : C.resolve(x)
                        }
                          , d = C => C == 1 ? "argument" : "arguments"
                          , h = (C, k) => function(N, ...R) {
                            if (R.length < k.minArgs)
                                throw new Error(`Expected at least ${k.minArgs} ${d(k.minArgs)} for ${C}(), got ${R.length}`);
                            if (R.length > k.maxArgs)
                                throw new Error(`Expected at most ${k.maxArgs} ${d(k.maxArgs)} for ${C}(), got ${R.length}`);
                            return new Promise( (F, O) => {
                                if (k.fallbackToNoCallback)
                                    try {
                                        N[C](...R, l({
                                            resolve: F,
                                            reject: O
                                        }, k))
                                    } catch (T) {
                                        console.warn(`${C} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, T),
                                        N[C](...R),
                                        k.fallbackToNoCallback = !1,
                                        k.noCallback = !0,
                                        F()
                                    }
                                else
                                    k.noCallback ? (N[C](...R),
                                    F()) : N[C](...R, l({
                                        resolve: F,
                                        reject: O
                                    }, k))
                            }
                            )
                        }
                          , f = (C, k, x) => new Proxy(k,{
                            apply(N, R, F) {
                                return x.call(R, C, ...F)
                            }
                        });
                        let p = Function.call.bind(Object.prototype.hasOwnProperty);
                        const g = (C, k={}, x={}) => {
                            let N = Object.create(null)
                              , R = {
                                has(O, T) {
                                    return T in C || T in N
                                },
                                get(O, T, L) {
                                    if (T in N)
                                        return N[T];
                                    if (!(T in C))
                                        return;
                                    let q = C[T];
                                    if (typeof q == "function")
                                        if (typeof k[T] == "function")
                                            q = f(C, C[T], k[T]);
                                        else if (p(x, T)) {
                                            let Z = h(T, x[T]);
                                            q = f(C, C[T], Z)
                                        } else
                                            q = q.bind(C);
                                    else if (typeof q == "object" && q !== null && (p(k, T) || p(x, T)))
                                        q = g(q, k[T], x[T]);
                                    else if (p(x, "*"))
                                        q = g(q, k[T], x["*"]);
                                    else
                                        return Object.defineProperty(N, T, {
                                            configurable: !0,
                                            enumerable: !0,
                                            get() {
                                                return C[T]
                                            },
                                            set(Z) {
                                                C[T] = Z
                                            }
                                        }),
                                        q;
                                    return N[T] = q,
                                    q
                                },
                                set(O, T, L, q) {
                                    return T in N ? N[T] = L : C[T] = L,
                                    !0
                                },
                                defineProperty(O, T, L) {
                                    return Reflect.defineProperty(N, T, L)
                                },
                                deleteProperty(O, T) {
                                    return Reflect.deleteProperty(N, T)
                                }
                            }
                              , F = Object.create(C);
                            return new Proxy(F,R)
                        }
                          , y = C => ({
                            addListener(k, x, ...N) {
                                k.addListener(C.get(x), ...N)
                            },
                            hasListener(k, x) {
                                return k.hasListener(C.get(x))
                            },
                            removeListener(k, x) {
                                k.removeListener(C.get(x))
                            }
                        })
                          , m = new c(C => typeof C != "function" ? C : function(x) {
                            const N = g(x, {}, {
                                getContent: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            });
                            C(N)
                        }
                        )
                          , w = new c(C => typeof C != "function" ? C : function(x, N, R) {
                            let F = !1, O, T = new Promise(j => {
                                O = function($) {
                                    F = !0,
                                    j($)
                                }
                            }
                            ), L;
                            try {
                                L = C(x, N, O)
                            } catch (j) {
                                L = Promise.reject(j)
                            }
                            const q = L !== !0 && u(L);
                            if (L !== !0 && !q && !F)
                                return !1;
                            const Z = j => {
                                j.then($ => {
                                    R($)
                                }
                                , $ => {
                                    let B;
                                    $ && ($ instanceof Error || typeof $.message == "string") ? B = $.message : B = "An unexpected error occurred",
                                    R({
                                        __mozWebExtensionPolyfillReject__: !0,
                                        message: B
                                    })
                                }
                                ).catch($ => {
                                    console.error("Failed to send onMessage rejected reply", $)
                                }
                                )
                            }
                            ;
                            return Z(q ? L : T),
                            !0
                        }
                        )
                          , E = ({reject: C, resolve: k}, x) => {
                            i.runtime.lastError ? i.runtime.lastError.message === r ? k() : C(new Error(i.runtime.lastError.message)) : x && x.__mozWebExtensionPolyfillReject__ ? C(new Error(x.message)) : k(x)
                        }
                          , v = (C, k, x, ...N) => {
                            if (N.length < k.minArgs)
                                throw new Error(`Expected at least ${k.minArgs} ${d(k.minArgs)} for ${C}(), got ${N.length}`);
                            if (N.length > k.maxArgs)
                                throw new Error(`Expected at most ${k.maxArgs} ${d(k.maxArgs)} for ${C}(), got ${N.length}`);
                            return new Promise( (R, F) => {
                                const O = E.bind(null, {
                                    resolve: R,
                                    reject: F
                                });
                                N.push(O),
                                x.sendMessage(...N)
                            }
                            )
                        }
                          , _ = {
                            devtools: {
                                network: {
                                    onRequestFinished: y(m)
                                }
                            },
                            runtime: {
                                onMessage: y(w),
                                onMessageExternal: y(w),
                                sendMessage: v.bind(null, "sendMessage", {
                                    minArgs: 1,
                                    maxArgs: 3
                                })
                            },
                            tabs: {
                                sendMessage: v.bind(null, "sendMessage", {
                                    minArgs: 2,
                                    maxArgs: 3
                                })
                            }
                        }
                          , A = {
                            clear: {
                                minArgs: 1,
                                maxArgs: 1
                            },
                            get: {
                                minArgs: 1,
                                maxArgs: 1
                            },
                            set: {
                                minArgs: 1,
                                maxArgs: 1
                            }
                        };
                        return a.privacy = {
                            network: {
                                "*": A
                            },
                            services: {
                                "*": A
                            },
                            websites: {
                                "*": A
                            }
                        },
                        g(i, _, a)
                    }
                    ;
                    t.exports = s(chrome)
                }
            })
        }(ft)),
        ft.exports
    }
    JF();
    var Ci = (n => (n.Planner = "planner",
    n.Navigator = "navigator",
    n.Validator = "validator",
    n))(Ci || {})
      , jg = (n => (n.OpenAI = "openai",
    n.Anthropic = "anthropic",
    n.Gemini = "gemini",
    n))(jg || {});
    const JC = {
        openai: ["gpt-4o", "gpt-4o-mini", "o1", "o1-mini", "o3-mini"],
        anthropic: ["claude-3-7-sonnet-latest", "claude-3-5-haiku-latest"],
        gemini: ["gemini-2.0-flash", "gemini-2.0-flash-lite", "gemini-2.0-pro-exp-02-05"]
    };
    Object.fromEntries(Object.entries(JC).flatMap( ([n,e]) => e.map(t => [t, n])));
    var Oc = (n => (n.Local = "local",
    n.Sync = "sync",
    n.Managed = "managed",
    n.Session = "session",
    n))(Oc || {})
      , ZC = (n => (n.ExtensionPagesOnly = "TRUSTED_CONTEXTS",
    n.ExtensionPagesAndContentScripts = "TRUSTED_AND_UNTRUSTED_CONTEXTS",
    n))(ZC || {})
      , Dg = (n, e, t) => new Promise( (r, s) => {
        var i = u => {
            try {
                c(t.next(u))
            } catch (l) {
                s(l)
            }
        }
          , a = u => {
            try {
                c(t.throw(u))
            } catch (l) {
                s(l)
            }
        }
          , c = u => u.done ? r(u.value) : Promise.resolve(u.value).then(i, a);
        c((t = t.apply(n, e)).next())
    }
    );
    const rs = globalThis.chrome;
    function XC(n, e) {
        return Dg(this, null, function*() {
            function t(s) {
                return typeof s == "function"
            }
            function r(s) {
                return s instanceof Promise
            }
            return t(n) ? (r(n),
            n(e)) : n
        })
    }
    let YC = !1;
    function QC(n) {
        if (rs && rs.storage[n] === void 0)
            throw new Error(`Check your storage permission in manifest.json: ${n} is not defined`)
    }
    function gv(n, e, t) {
        var r, s, i, a, c, u;
        let l = null
          , d = !1
          , h = [];
        const f = (r = t == null ? void 0 : t.storageEnum) != null ? r : Oc.Local
          , p = (s = t == null ? void 0 : t.liveUpdate) != null ? s : !1
          , g = (a = (i = t == null ? void 0 : t.serialization) == null ? void 0 : i.serialize) != null ? a : C => C
          , y = (u = (c = t == null ? void 0 : t.serialization) == null ? void 0 : c.deserialize) != null ? u : C => C;
        YC === !1 && f === Oc.Session && (t == null ? void 0 : t.sessionAccessForContentScripts) === !0 && (QC(f),
        rs == null || rs.storage[f].setAccessLevel({
            accessLevel: ZC.ExtensionPagesAndContentScripts
        }).catch(C => {
            console.warn(C),
            console.warn("Please call setAccessLevel into different context, like a background script.")
        }
        ),
        YC = !0);
        const m = () => Dg(this, null, function*() {
            var C;
            QC(f);
            const k = yield rs == null ? void 0 : rs.storage[f].get([n]);
            return k && (C = y(k[n])) != null ? C : e
        })
          , w = () => {
            h.forEach(C => C())
        }
          , E = C => Dg(this, null, function*() {
            d || (l = yield m()),
            l = yield XC(C, l),
            yield rs == null ? void 0 : rs.storage[f].set({
                [n]: g(l)
            }),
            w()
        })
          , v = C => (h = [...h, C],
        () => {
            h = h.filter(k => k !== C)
        }
        )
          , _ = () => l;
        m().then(C => {
            l = C,
            d = !0,
            w()
        }
        );
        function A(C) {
            return Dg(this, null, function*() {
                if (C[n] === void 0)
                    return;
                const k = y(C[n].newValue);
                l !== k && (l = yield XC(k, l),
                w())
            })
        }
        return p && (rs == null || rs.storage[f].onChanged.addListener(A)),
        {
            get: m,
            set: E,
            getSnapshot: _,
            subscribe: v
        }
    }
    var ZF = Object.defineProperty
      , XF = Object.defineProperties
      , YF = Object.getOwnPropertyDescriptors
      , ek = Object.getOwnPropertySymbols
      , QF = Object.prototype.hasOwnProperty
      , ej = Object.prototype.propertyIsEnumerable
      , tk = (n, e, t) => e in n ? ZF(n, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : n[e] = t
      , yv = (n, e) => {
        for (var t in e || (e = {}))
            QF.call(e, t) && tk(n, t, e[t]);
        if (ek)
            for (var t of ek(e))
                ej.call(e, t) && tk(n, t, e[t]);
        return n
    }
      , rk = (n, e) => XF(n, YF(e))
      , Rc = (n, e, t) => new Promise( (r, s) => {
        var i = u => {
            try {
                c(t.next(u))
            } catch (l) {
                s(l)
            }
        }
          , a = u => {
            try {
                c(t.throw(u))
            } catch (l) {
                s(l)
            }
        }
          , c = u => u.done ? r(u.value) : Promise.resolve(u.value).then(i, a);
        c((t = t.apply(n, e)).next())
    }
    );
    const Ls = gv("llm-api-keys", {
        providers: {}
    }, {
        storageEnum: Oc.Local,
        liveUpdate: !0
    })
      , tj = rk(yv({}, Ls), {
        setProvider(n, e) {
            return Rc(this, null, function*() {
                if (!n)
                    throw new Error("Provider name cannot be empty");
                if (!e.apiKey)
                    throw new Error("API key cannot be empty");
                const t = (yield Ls.get()) || {
                    providers: {}
                };
                yield Ls.set({
                    providers: rk(yv({}, t.providers), {
                        [n]: e
                    })
                })
            })
        },
        getProvider(n) {
            return Rc(this, null, function*() {
                return ((yield Ls.get()) || {
                    providers: {}
                }).providers[n]
            })
        },
        removeProvider(n) {
            return Rc(this, null, function*() {
                const e = (yield Ls.get()) || {
                    providers: {}
                }
                  , t = yv({}, e.providers);
                delete t[n],
                yield Ls.set({
                    providers: t
                })
            })
        },
        hasProvider(n) {
            return Rc(this, null, function*() {
                const e = (yield Ls.get()) || {
                    providers: {}
                };
                return n in e.providers
            })
        },
        getConfiguredProviders() {
            return Rc(this, null, function*() {
                console.log("Getting configured providers");
                const n = yield Ls.get();
                return console.log("Raw storage data:", n),
                !n || !n.providers ? (console.log("No data found, returning empty array"),
                []) : (console.log("Configured providers:", n.providers),
                Object.keys(n.providers))
            })
        },
        getAllProviders() {
            return Rc(this, null, function*() {
                return (yield Ls.get()).providers
            })
        }
    });
    var rj = Object.defineProperty
      , nj = Object.defineProperties
      , sj = Object.getOwnPropertyDescriptors
      , nk = Object.getOwnPropertySymbols
      , ij = Object.prototype.hasOwnProperty
      , aj = Object.prototype.propertyIsEnumerable
      , sk = (n, e, t) => e in n ? rj(n, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : n[e] = t
      , wv = (n, e) => {
        for (var t in e || (e = {}))
            ij.call(e, t) && sk(n, t, e[t]);
        if (nk)
            for (var t of nk(e))
                aj.call(e, t) && sk(n, t, e[t]);
        return n
    }
      , ik = (n, e) => nj(n, sj(e))
      , Mc = (n, e, t) => new Promise( (r, s) => {
        var i = u => {
            try {
                c(t.next(u))
            } catch (l) {
                s(l)
            }
        }
          , a = u => {
            try {
                c(t.throw(u))
            } catch (l) {
                s(l)
            }
        }
          , c = u => u.done ? r(u.value) : Promise.resolve(u.value).then(i, a);
        c((t = t.apply(n, e)).next())
    }
    );
    const Ka = gv("agent-models", {
        agents: {}
    }, {
        storageEnum: Oc.Local,
        liveUpdate: !0
    });
    function oj(n) {
        if (!n.provider || !n.modelName)
            throw new Error("Provider and model name must be specified");
        if (!JC[n.provider].includes(n.modelName))
            throw new Error(`Invalid model "${n.modelName}" for provider "${n.provider}"`)
    }
    const cj = ik(wv({}, Ka), {
        setAgentModel: (n, e) => Mc(void 0, null, function*() {
            oj(e),
            yield Ka.set(t => ({
                agents: ik(wv({}, t.agents), {
                    [n]: e
                })
            }))
        }),
        getAgentModel: n => Mc(void 0, null, function*() {
            return (yield Ka.get()).agents[n]
        }),
        resetAgentModel: n => Mc(void 0, null, function*() {
            yield Ka.set(e => {
                const t = wv({}, e.agents);
                return delete t[n],
                {
                    agents: t
                }
            }
            )
        }),
        hasAgentModel: n => Mc(void 0, null, function*() {
            const e = yield Ka.get();
            return n in e.agents
        }),
        getConfiguredAgents: () => Mc(void 0, null, function*() {
            const n = yield Ka.get();
            return Object.keys(n.agents)
        }),
        getAllAgentModels: () => Mc(void 0, null, function*() {
            return (yield Ka.get()).agents
        })
    });
    var uj = Object.defineProperty
      , lj = Object.defineProperties
      , dj = Object.getOwnPropertyDescriptors
      , ak = Object.getOwnPropertySymbols
      , hj = Object.prototype.hasOwnProperty
      , fj = Object.prototype.propertyIsEnumerable
      , ok = (n, e, t) => e in n ? uj(n, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : n[e] = t
      , bv = (n, e) => {
        for (var t in e || (e = {}))
            hj.call(e, t) && ok(n, t, e[t]);
        if (ak)
            for (var t of ak(e))
                fj.call(e, t) && ok(n, t, e[t]);
        return n
    }
      , pj = (n, e) => lj(n, dj(e))
      , vv = (n, e, t) => new Promise( (r, s) => {
        var i = u => {
            try {
                c(t.next(u))
            } catch (l) {
                s(l)
            }
        }
          , a = u => {
            try {
                c(t.throw(u))
            } catch (l) {
                s(l)
            }
        }
          , c = u => u.done ? r(u.value) : Promise.resolve(u.value).then(i, a);
        c((t = t.apply(n, e)).next())
    }
    );
    const Bg = {
        maxSteps: 100,
        maxActionsPerStep: 5,
        maxFailures: 3,
        useVision: !1,
        useVisionForPlanner: !1,
        planningInterval: 3
    }
      , Id = gv("general-settings", Bg, {
        storageEnum: Oc.Local,
        liveUpdate: !0
    })
      , mj = pj(bv({}, Id), {
        updateSettings(n) {
            return vv(this, null, function*() {
                const e = (yield Id.get()) || Bg;
                yield Id.set(bv(bv({}, e), n))
            })
        },
        getSettings() {
            return vv(this, null, function*() {
                return (yield Id.get()) || Bg
            })
        },
        resetToDefaults() {
            return vv(this, null, function*() {
                yield Id.set(Bg)
            })
        }
    })
      , ck = {
        minimumWaitPageLoadTime: .5,
        waitForNetworkIdlePageLoadTime: 1,
        maximumWaitPageLoadTime: 5,
        waitBetweenActions: 1,
        browserWindowSize: {
            width: 1280,
            height: 1100
        },
        highlightElements: !0,
        viewportExpansion: 500,
        includeDynamicAttributes: !0,
        homePageUrl: "https://www.google.com"
    };
    var _v = function(n, e) {
        return _v = Object.setPrototypeOf || {
            __proto__: []
        }instanceof Array && function(t, r) {
            t.__proto__ = r
        }
        || function(t, r) {
            for (var s in r)
                Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        ,
        _v(n, e)
    };
    function Fs(n, e) {
        if (typeof e != "function" && e !== null)
            throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
        _v(n, e);
        function t() {
            this.constructor = n
        }
        n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype,
        new t)
    }
    function gj(n, e, t, r) {
        function s(i) {
            return i instanceof t ? i : new t(function(a) {
                a(i)
            }
            )
        }
        return new (t || (t = Promise))(function(i, a) {
            function c(d) {
                try {
                    l(r.next(d))
                } catch (h) {
                    a(h)
                }
            }
            function u(d) {
                try {
                    l(r.throw(d))
                } catch (h) {
                    a(h)
                }
            }
            function l(d) {
                d.done ? i(d.value) : s(d.value).then(c, u)
            }
            l((r = r.apply(n, [])).next())
        }
        )
    }
    function uk(n, e) {
        var t = {
            label: 0,
            sent: function() {
                if (i[0] & 1)
                    throw i[1];
                return i[1]
            },
            trys: [],
            ops: []
        }, r, s, i, a;
        return a = {
            next: c(0),
            throw: c(1),
            return: c(2)
        },
        typeof Symbol == "function" && (a[Symbol.iterator] = function() {
            return this
        }
        ),
        a;
        function c(l) {
            return function(d) {
                return u([l, d])
            }
        }
        function u(l) {
            if (r)
                throw new TypeError("Generator is already executing.");
            for (; a && (a = 0,
            l[0] && (t = 0)),
            t; )
                try {
                    if (r = 1,
                    s && (i = l[0] & 2 ? s.return : l[0] ? s.throw || ((i = s.return) && i.call(s),
                    0) : s.next) && !(i = i.call(s, l[1])).done)
                        return i;
                    switch (s = 0,
                    i && (l = [l[0] & 2, i.value]),
                    l[0]) {
                    case 0:
                    case 1:
                        i = l;
                        break;
                    case 4:
                        return t.label++,
                        {
                            value: l[1],
                            done: !1
                        };
                    case 5:
                        t.label++,
                        s = l[1],
                        l = [0];
                        continue;
                    case 7:
                        l = t.ops.pop(),
                        t.trys.pop();
                        continue;
                    default:
                        if (i = t.trys,
                        !(i = i.length > 0 && i[i.length - 1]) && (l[0] === 6 || l[0] === 2)) {
                            t = 0;
                            continue
                        }
                        if (l[0] === 3 && (!i || l[1] > i[0] && l[1] < i[3])) {
                            t.label = l[1];
                            break
                        }
                        if (l[0] === 6 && t.label < i[1]) {
                            t.label = i[1],
                            i = l;
                            break
                        }
                        if (i && t.label < i[2]) {
                            t.label = i[2],
                            t.ops.push(l);
                            break
                        }
                        i[2] && t.ops.pop(),
                        t.trys.pop();
                        continue
                    }
                    l = e.call(n, t)
                } catch (d) {
                    l = [6, d],
                    s = 0
                } finally {
                    r = i = 0
                }
            if (l[0] & 5)
                throw l[1];
            return {
                value: l[0] ? l[1] : void 0,
                done: !0
            }
        }
    }
    function Nc(n) {
        var e = typeof Symbol == "function" && Symbol.iterator
          , t = e && n[e]
          , r = 0;
        if (t)
            return t.call(n);
        if (n && typeof n.length == "number")
            return {
                next: function() {
                    return n && r >= n.length && (n = void 0),
                    {
                        value: n && n[r++],
                        done: !n
                    }
                }
            };
        throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.")
    }
    function Ha(n, e) {
        var t = typeof Symbol == "function" && n[Symbol.iterator];
        if (!t)
            return n;
        var r = t.call(n), s, i = [], a;
        try {
            for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
                i.push(s.value)
        } catch (c) {
            a = {
                error: c
            }
        } finally {
            try {
                s && !s.done && (t = r.return) && t.call(r)
            } finally {
                if (a)
                    throw a.error
            }
        }
        return i
    }
    function $c(n, e, t) {
        if (arguments.length === 2)
            for (var r = 0, s = e.length, i; r < s; r++)
                (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)),
                i[r] = e[r]);
        return n.concat(i || Array.prototype.slice.call(e))
    }
    function Lc(n) {
        return this instanceof Lc ? (this.v = n,
        this) : new Lc(n)
    }
    function yj(n, e, t) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var r = t.apply(n, e || []), s, i = [];
        return s = {},
        a("next"),
        a("throw"),
        a("return"),
        s[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        s;
        function a(f) {
            r[f] && (s[f] = function(p) {
                return new Promise(function(g, y) {
                    i.push([f, p, g, y]) > 1 || c(f, p)
                }
                )
            }
            )
        }
        function c(f, p) {
            try {
                u(r[f](p))
            } catch (g) {
                h(i[0][3], g)
            }
        }
        function u(f) {
            f.value instanceof Lc ? Promise.resolve(f.value.v).then(l, d) : h(i[0][2], f)
        }
        function l(f) {
            c("next", f)
        }
        function d(f) {
            c("throw", f)
        }
        function h(f, p) {
            f(p),
            i.shift(),
            i.length && c(i[0][0], i[0][1])
        }
    }
    function wj(n) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var e = n[Symbol.asyncIterator], t;
        return e ? e.call(n) : (n = typeof Nc == "function" ? Nc(n) : n[Symbol.iterator](),
        t = {},
        r("next"),
        r("throw"),
        r("return"),
        t[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        t);
        function r(i) {
            t[i] = n[i] && function(a) {
                return new Promise(function(c, u) {
                    a = n[i](a),
                    s(c, u, a.done, a.value)
                }
                )
            }
        }
        function s(i, a, c, u) {
            Promise.resolve(u).then(function(l) {
                i({
                    value: l,
                    done: c
                })
            }, a)
        }
    }
    function ut(n) {
        return typeof n == "function"
    }
    function Sv(n) {
        var e = function(r) {
            Error.call(r),
            r.stack = new Error().stack
        }
          , t = n(e);
        return t.prototype = Object.create(Error.prototype),
        t.prototype.constructor = t,
        t
    }
    var Ev = Sv(function(n) {
        return function(t) {
            n(this),
            this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(r, s) {
                return s + 1 + ") " + r.toString()
            }).join(`
  `) : "",
            this.name = "UnsubscriptionError",
            this.errors = t
        }
    });
    function qg(n, e) {
        if (n) {
            var t = n.indexOf(e);
            0 <= t && n.splice(t, 1)
        }
    }
    var Od = function() {
        function n(e) {
            this.initialTeardown = e,
            this.closed = !1,
            this._parentage = null,
            this._finalizers = null
        }
        return n.prototype.unsubscribe = function() {
            var e, t, r, s, i;
            if (!this.closed) {
                this.closed = !0;
                var a = this._parentage;
                if (a)
                    if (this._parentage = null,
                    Array.isArray(a))
                        try {
                            for (var c = Nc(a), u = c.next(); !u.done; u = c.next()) {
                                var l = u.value;
                                l.remove(this)
                            }
                        } catch (y) {
                            e = {
                                error: y
                            }
                        } finally {
                            try {
                                u && !u.done && (t = c.return) && t.call(c)
                            } finally {
                                if (e)
                                    throw e.error
                            }
                        }
                    else
                        a.remove(this);
                var d = this.initialTeardown;
                if (ut(d))
                    try {
                        d()
                    } catch (y) {
                        i = y instanceof Ev ? y.errors : [y]
                    }
                var h = this._finalizers;
                if (h) {
                    this._finalizers = null;
                    try {
                        for (var f = Nc(h), p = f.next(); !p.done; p = f.next()) {
                            var g = p.value;
                            try {
                                hk(g)
                            } catch (y) {
                                i = i ?? [],
                                y instanceof Ev ? i = $c($c([], Ha(i)), Ha(y.errors)) : i.push(y)
                            }
                        }
                    } catch (y) {
                        r = {
                            error: y
                        }
                    } finally {
                        try {
                            p && !p.done && (s = f.return) && s.call(f)
                        } finally {
                            if (r)
                                throw r.error
                        }
                    }
                }
                if (i)
                    throw new Ev(i)
            }
        }
        ,
        n.prototype.add = function(e) {
            var t;
            if (e && e !== this)
                if (this.closed)
                    hk(e);
                else {
                    if (e instanceof n) {
                        if (e.closed || e._hasParent(this))
                            return;
                        e._addParent(this)
                    }
                    (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e)
                }
        }
        ,
        n.prototype._hasParent = function(e) {
            var t = this._parentage;
            return t === e || Array.isArray(t) && t.includes(e)
        }
        ,
        n.prototype._addParent = function(e) {
            var t = this._parentage;
            this._parentage = Array.isArray(t) ? (t.push(e),
            t) : t ? [t, e] : e
        }
        ,
        n.prototype._removeParent = function(e) {
            var t = this._parentage;
            t === e ? this._parentage = null : Array.isArray(t) && qg(t, e)
        }
        ,
        n.prototype.remove = function(e) {
            var t = this._finalizers;
            t && qg(t, e),
            e instanceof n && e._removeParent(this)
        }
        ,
        n.EMPTY = function() {
            var e = new n;
            return e.closed = !0,
            e
        }(),
        n
    }()
      , lk = Od.EMPTY;
    function dk(n) {
        return n instanceof Od || n && "closed"in n && ut(n.remove) && ut(n.add) && ut(n.unsubscribe)
    }
    function hk(n) {
        ut(n) ? n() : n.unsubscribe()
    }
    var fk = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: void 0,
        useDeprecatedSynchronousErrorHandling: !1,
        useDeprecatedNextContext: !1
    }
      , bj = {
        setTimeout: function(n, e) {
            for (var t = [], r = 2; r < arguments.length; r++)
                t[r - 2] = arguments[r];
            return setTimeout.apply(void 0, $c([n, e], Ha(t)))
        },
        clearTimeout: function(n) {
            return clearTimeout(n)
        },
        delegate: void 0
    };
    function pk(n) {
        bj.setTimeout(function() {
            throw n
        })
    }
    function Fc() {}
    function Ug(n) {
        n()
    }
    var xv = function(n) {
        Fs(e, n);
        function e(t) {
            var r = n.call(this) || this;
            return r.isStopped = !1,
            t ? (r.destination = t,
            dk(t) && t.add(r)) : r.destination = Ej,
            r
        }
        return e.create = function(t, r, s) {
            return new Kg(t,r,s)
        }
        ,
        e.prototype.next = function(t) {
            this.isStopped || this._next(t)
        }
        ,
        e.prototype.error = function(t) {
            this.isStopped || (this.isStopped = !0,
            this._error(t))
        }
        ,
        e.prototype.complete = function() {
            this.isStopped || (this.isStopped = !0,
            this._complete())
        }
        ,
        e.prototype.unsubscribe = function() {
            this.closed || (this.isStopped = !0,
            n.prototype.unsubscribe.call(this),
            this.destination = null)
        }
        ,
        e.prototype._next = function(t) {
            this.destination.next(t)
        }
        ,
        e.prototype._error = function(t) {
            try {
                this.destination.error(t)
            } finally {
                this.unsubscribe()
            }
        }
        ,
        e.prototype._complete = function() {
            try {
                this.destination.complete()
            } finally {
                this.unsubscribe()
            }
        }
        ,
        e
    }(Od)
      , vj = Function.prototype.bind;
    function Cv(n, e) {
        return vj.call(n, e)
    }
    var _j = function() {
        function n(e) {
            this.partialObserver = e
        }
        return n.prototype.next = function(e) {
            var t = this.partialObserver;
            if (t.next)
                try {
                    t.next(e)
                } catch (r) {
                    Hg(r)
                }
        }
        ,
        n.prototype.error = function(e) {
            var t = this.partialObserver;
            if (t.error)
                try {
                    t.error(e)
                } catch (r) {
                    Hg(r)
                }
            else
                Hg(e)
        }
        ,
        n.prototype.complete = function() {
            var e = this.partialObserver;
            if (e.complete)
                try {
                    e.complete()
                } catch (t) {
                    Hg(t)
                }
        }
        ,
        n
    }()
      , Kg = function(n) {
        Fs(e, n);
        function e(t, r, s) {
            var i = n.call(this) || this, a;
            if (ut(t) || !t)
                a = {
                    next: t ?? void 0,
                    error: r ?? void 0,
                    complete: s ?? void 0
                };
            else {
                var c;
                i && fk.useDeprecatedNextContext ? (c = Object.create(t),
                c.unsubscribe = function() {
                    return i.unsubscribe()
                }
                ,
                a = {
                    next: t.next && Cv(t.next, c),
                    error: t.error && Cv(t.error, c),
                    complete: t.complete && Cv(t.complete, c)
                }) : a = t
            }
            return i.destination = new _j(a),
            i
        }
        return e
    }(xv);
    function Hg(n) {
        pk(n)
    }
    function Sj(n) {
        throw n
    }
    var Ej = {
        closed: !0,
        next: Fc,
        error: Sj,
        complete: Fc
    }
      , kv = function() {
        return typeof Symbol == "function" && Symbol.observable || "@@observable"
    }();
    function ns(n) {
        return n
    }
    function xj() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        return mk(n)
    }
    function mk(n) {
        return n.length === 0 ? ns : n.length === 1 ? n[0] : function(t) {
            return n.reduce(function(r, s) {
                return s(r)
            }, t)
        }
    }
    var Lt = function() {
        function n(e) {
            e && (this._subscribe = e)
        }
        return n.prototype.lift = function(e) {
            var t = new n;
            return t.source = this,
            t.operator = e,
            t
        }
        ,
        n.prototype.subscribe = function(e, t, r) {
            var s = this
              , i = kj(e) ? e : new Kg(e,t,r);
            return Ug(function() {
                var a = s
                  , c = a.operator
                  , u = a.source;
                i.add(c ? c.call(i, u) : u ? s._subscribe(i) : s._trySubscribe(i))
            }),
            i
        }
        ,
        n.prototype._trySubscribe = function(e) {
            try {
                return this._subscribe(e)
            } catch (t) {
                e.error(t)
            }
        }
        ,
        n.prototype.forEach = function(e, t) {
            var r = this;
            return t = gk(t),
            new t(function(s, i) {
                var a = new Kg({
                    next: function(c) {
                        try {
                            e(c)
                        } catch (u) {
                            i(u),
                            a.unsubscribe()
                        }
                    },
                    error: i,
                    complete: s
                });
                r.subscribe(a)
            }
            )
        }
        ,
        n.prototype._subscribe = function(e) {
            var t;
            return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e)
        }
        ,
        n.prototype[kv] = function() {
            return this
        }
        ,
        n.prototype.pipe = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            return mk(e)(this)
        }
        ,
        n.prototype.toPromise = function(e) {
            var t = this;
            return e = gk(e),
            new e(function(r, s) {
                var i;
                t.subscribe(function(a) {
                    return i = a
                }, function(a) {
                    return s(a)
                }, function() {
                    return r(i)
                })
            }
            )
        }
        ,
        n.create = function(e) {
            return new n(e)
        }
        ,
        n
    }();
    function gk(n) {
        var e;
        return (e = n ?? fk.Promise) !== null && e !== void 0 ? e : Promise
    }
    function Cj(n) {
        return n && ut(n.next) && ut(n.error) && ut(n.complete)
    }
    function kj(n) {
        return n && n instanceof xv || Cj(n) && dk(n)
    }
    function Pj(n) {
        return ut(n == null ? void 0 : n.lift)
    }
    function nr(n) {
        return function(e) {
            if (Pj(e))
                return e.lift(function(t) {
                    try {
                        return n(t, this)
                    } catch (r) {
                        this.error(r)
                    }
                });
            throw new TypeError("Unable to lift unknown Observable type")
        }
    }
    function Ut(n, e, t, r, s) {
        return new Tj(n,e,t,r,s)
    }
    var Tj = function(n) {
        Fs(e, n);
        function e(t, r, s, i, a, c) {
            var u = n.call(this, t) || this;
            return u.onFinalize = a,
            u.shouldUnsubscribe = c,
            u._next = r ? function(l) {
                try {
                    r(l)
                } catch (d) {
                    t.error(d)
                }
            }
            : n.prototype._next,
            u._error = i ? function(l) {
                try {
                    i(l)
                } catch (d) {
                    t.error(d)
                } finally {
                    this.unsubscribe()
                }
            }
            : n.prototype._error,
            u._complete = s ? function() {
                try {
                    s()
                } catch (l) {
                    t.error(l)
                } finally {
                    this.unsubscribe()
                }
            }
            : n.prototype._complete,
            u
        }
        return e.prototype.unsubscribe = function() {
            var t;
            if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                var r = this.closed;
                n.prototype.unsubscribe.call(this),
                !r && ((t = this.onFinalize) === null || t === void 0 || t.call(this))
            }
        }
        ,
        e
    }(xv)
      , Aj = Sv(function(n) {
        return function() {
            n(this),
            this.name = "ObjectUnsubscribedError",
            this.message = "object unsubscribed"
        }
    })
      , yk = function(n) {
        Fs(e, n);
        function e() {
            var t = n.call(this) || this;
            return t.closed = !1,
            t.currentObservers = null,
            t.observers = [],
            t.isStopped = !1,
            t.hasError = !1,
            t.thrownError = null,
            t
        }
        return e.prototype.lift = function(t) {
            var r = new wk(this,this);
            return r.operator = t,
            r
        }
        ,
        e.prototype._throwIfClosed = function() {
            if (this.closed)
                throw new Aj
        }
        ,
        e.prototype.next = function(t) {
            var r = this;
            Ug(function() {
                var s, i;
                if (r._throwIfClosed(),
                !r.isStopped) {
                    r.currentObservers || (r.currentObservers = Array.from(r.observers));
                    try {
                        for (var a = Nc(r.currentObservers), c = a.next(); !c.done; c = a.next()) {
                            var u = c.value;
                            u.next(t)
                        }
                    } catch (l) {
                        s = {
                            error: l
                        }
                    } finally {
                        try {
                            c && !c.done && (i = a.return) && i.call(a)
                        } finally {
                            if (s)
                                throw s.error
                        }
                    }
                }
            })
        }
        ,
        e.prototype.error = function(t) {
            var r = this;
            Ug(function() {
                if (r._throwIfClosed(),
                !r.isStopped) {
                    r.hasError = r.isStopped = !0,
                    r.thrownError = t;
                    for (var s = r.observers; s.length; )
                        s.shift().error(t)
                }
            })
        }
        ,
        e.prototype.complete = function() {
            var t = this;
            Ug(function() {
                if (t._throwIfClosed(),
                !t.isStopped) {
                    t.isStopped = !0;
                    for (var r = t.observers; r.length; )
                        r.shift().complete()
                }
            })
        }
        ,
        e.prototype.unsubscribe = function() {
            this.isStopped = this.closed = !0,
            this.observers = this.currentObservers = null
        }
        ,
        Object.defineProperty(e.prototype, "observed", {
            get: function() {
                var t;
                return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0
            },
            enumerable: !1,
            configurable: !0
        }),
        e.prototype._trySubscribe = function(t) {
            return this._throwIfClosed(),
            n.prototype._trySubscribe.call(this, t)
        }
        ,
        e.prototype._subscribe = function(t) {
            return this._throwIfClosed(),
            this._checkFinalizedStatuses(t),
            this._innerSubscribe(t)
        }
        ,
        e.prototype._innerSubscribe = function(t) {
            var r = this
              , s = this
              , i = s.hasError
              , a = s.isStopped
              , c = s.observers;
            return i || a ? lk : (this.currentObservers = null,
            c.push(t),
            new Od(function() {
                r.currentObservers = null,
                qg(c, t)
            }
            ))
        }
        ,
        e.prototype._checkFinalizedStatuses = function(t) {
            var r = this
              , s = r.hasError
              , i = r.thrownError
              , a = r.isStopped;
            s ? t.error(i) : a && t.complete()
        }
        ,
        e.prototype.asObservable = function() {
            var t = new Lt;
            return t.source = this,
            t
        }
        ,
        e.create = function(t, r) {
            return new wk(t,r)
        }
        ,
        e
    }(Lt)
      , wk = function(n) {
        Fs(e, n);
        function e(t, r) {
            var s = n.call(this) || this;
            return s.destination = t,
            s.source = r,
            s
        }
        return e.prototype.next = function(t) {
            var r, s;
            (s = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || s === void 0 || s.call(r, t)
        }
        ,
        e.prototype.error = function(t) {
            var r, s;
            (s = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || s === void 0 || s.call(r, t)
        }
        ,
        e.prototype.complete = function() {
            var t, r;
            (r = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || r === void 0 || r.call(t)
        }
        ,
        e.prototype._subscribe = function(t) {
            var r, s;
            return (s = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(t)) !== null && s !== void 0 ? s : lk
        }
        ,
        e
    }(yk)
      , Pv = {
        now: function() {
            return (Pv.delegate || Date).now()
        },
        delegate: void 0
    }
      , Ij = function(n) {
        Fs(e, n);
        function e(t, r, s) {
            t === void 0 && (t = 1 / 0),
            r === void 0 && (r = 1 / 0),
            s === void 0 && (s = Pv);
            var i = n.call(this) || this;
            return i._bufferSize = t,
            i._windowTime = r,
            i._timestampProvider = s,
            i._buffer = [],
            i._infiniteTimeWindow = !0,
            i._infiniteTimeWindow = r === 1 / 0,
            i._bufferSize = Math.max(1, t),
            i._windowTime = Math.max(1, r),
            i
        }
        return e.prototype.next = function(t) {
            var r = this
              , s = r.isStopped
              , i = r._buffer
              , a = r._infiniteTimeWindow
              , c = r._timestampProvider
              , u = r._windowTime;
            s || (i.push(t),
            !a && i.push(c.now() + u)),
            this._trimBuffer(),
            n.prototype.next.call(this, t)
        }
        ,
        e.prototype._subscribe = function(t) {
            this._throwIfClosed(),
            this._trimBuffer();
            for (var r = this._innerSubscribe(t), s = this, i = s._infiniteTimeWindow, a = s._buffer, c = a.slice(), u = 0; u < c.length && !t.closed; u += i ? 1 : 2)
                t.next(c[u]);
            return this._checkFinalizedStatuses(t),
            r
        }
        ,
        e.prototype._trimBuffer = function() {
            var t = this
              , r = t._bufferSize
              , s = t._timestampProvider
              , i = t._buffer
              , a = t._infiniteTimeWindow
              , c = (a ? 1 : 2) * r;
            if (r < 1 / 0 && c < i.length && i.splice(0, i.length - c),
            !a) {
                for (var u = s.now(), l = 0, d = 1; d < i.length && i[d] <= u; d += 2)
                    l = d;
                l && i.splice(0, l + 1)
            }
        }
        ,
        e
    }(yk)
      , Oj = function(n) {
        Fs(e, n);
        function e(t, r) {
            return n.call(this) || this
        }
        return e.prototype.schedule = function(t, r) {
            return this
        }
        ,
        e
    }(Od)
      , bk = {
        setInterval: function(n, e) {
            for (var t = [], r = 2; r < arguments.length; r++)
                t[r - 2] = arguments[r];
            return setInterval.apply(void 0, $c([n, e], Ha(t)))
        },
        clearInterval: function(n) {
            return clearInterval(n)
        },
        delegate: void 0
    }
      , Rj = function(n) {
        Fs(e, n);
        function e(t, r) {
            var s = n.call(this, t, r) || this;
            return s.scheduler = t,
            s.work = r,
            s.pending = !1,
            s
        }
        return e.prototype.schedule = function(t, r) {
            var s;
            if (r === void 0 && (r = 0),
            this.closed)
                return this;
            this.state = t;
            var i = this.id
              , a = this.scheduler;
            return i != null && (this.id = this.recycleAsyncId(a, i, r)),
            this.pending = !0,
            this.delay = r,
            this.id = (s = this.id) !== null && s !== void 0 ? s : this.requestAsyncId(a, this.id, r),
            this
        }
        ,
        e.prototype.requestAsyncId = function(t, r, s) {
            return s === void 0 && (s = 0),
            bk.setInterval(t.flush.bind(t, this), s)
        }
        ,
        e.prototype.recycleAsyncId = function(t, r, s) {
            if (s === void 0 && (s = 0),
            s != null && this.delay === s && this.pending === !1)
                return r;
            r != null && bk.clearInterval(r)
        }
        ,
        e.prototype.execute = function(t, r) {
            if (this.closed)
                return new Error("executing a cancelled action");
            this.pending = !1;
            var s = this._execute(t, r);
            if (s)
                return s;
            this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
        }
        ,
        e.prototype._execute = function(t, r) {
            var s = !1, i;
            try {
                this.work(t)
            } catch (a) {
                s = !0,
                i = a || new Error("Scheduled action threw falsy error")
            }
            if (s)
                return this.unsubscribe(),
                i
        }
        ,
        e.prototype.unsubscribe = function() {
            if (!this.closed) {
                var t = this
                  , r = t.id
                  , s = t.scheduler
                  , i = s.actions;
                this.work = this.state = this.scheduler = null,
                this.pending = !1,
                qg(i, this),
                r != null && (this.id = this.recycleAsyncId(s, r, null)),
                this.delay = null,
                n.prototype.unsubscribe.call(this)
            }
        }
        ,
        e
    }(Oj)
      , vk = function() {
        function n(e, t) {
            t === void 0 && (t = n.now),
            this.schedulerActionCtor = e,
            this.now = t
        }
        return n.prototype.schedule = function(e, t, r) {
            return t === void 0 && (t = 0),
            new this.schedulerActionCtor(this,e).schedule(r, t)
        }
        ,
        n.now = Pv.now,
        n
    }()
      , Mj = function(n) {
        Fs(e, n);
        function e(t, r) {
            r === void 0 && (r = vk.now);
            var s = n.call(this, t, r) || this;
            return s.actions = [],
            s._active = !1,
            s
        }
        return e.prototype.flush = function(t) {
            var r = this.actions;
            if (this._active) {
                r.push(t);
                return
            }
            var s;
            this._active = !0;
            do
                if (s = t.execute(t.state, t.delay))
                    break;
            while (t = r.shift());
            if (this._active = !1,
            s) {
                for (; t = r.shift(); )
                    t.unsubscribe();
                throw s
            }
        }
        ,
        e
    }(vk)
      , Nj = new Mj(Rj)
      , $j = Nj
      , Wa = new Lt(function(n) {
        return n.complete()
    }
    );
    function Lj(n) {
        return n && ut(n.schedule)
    }
    function Tv(n) {
        return n[n.length - 1]
    }
    function Fj(n) {
        return ut(Tv(n)) ? n.pop() : void 0
    }
    function Rd(n) {
        return Lj(Tv(n)) ? n.pop() : void 0
    }
    function jj(n, e) {
        return typeof Tv(n) == "number" ? n.pop() : e
    }
    var Av = function(n) {
        return n && typeof n.length == "number" && typeof n != "function"
    };
    function _k(n) {
        return ut(n == null ? void 0 : n.then)
    }
    function Sk(n) {
        return ut(n[kv])
    }
    function Ek(n) {
        return Symbol.asyncIterator && ut(n == null ? void 0 : n[Symbol.asyncIterator])
    }
    function xk(n) {
        return new TypeError("You provided " + (n !== null && typeof n == "object" ? "an invalid object" : "'" + n + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")
    }
    function Dj() {
        return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator
    }
    var Ck = Dj();
    function kk(n) {
        return ut(n == null ? void 0 : n[Ck])
    }
    function Pk(n) {
        return yj(this, arguments, function() {
            var t, r, s, i;
            return uk(this, function(a) {
                switch (a.label) {
                case 0:
                    t = n.getReader(),
                    a.label = 1;
                case 1:
                    a.trys.push([1, , 9, 10]),
                    a.label = 2;
                case 2:
                    return [4, Lc(t.read())];
                case 3:
                    return r = a.sent(),
                    s = r.value,
                    i = r.done,
                    i ? [4, Lc(void 0)] : [3, 5];
                case 4:
                    return [2, a.sent()];
                case 5:
                    return [4, Lc(s)];
                case 6:
                    return [4, a.sent()];
                case 7:
                    return a.sent(),
                    [3, 2];
                case 8:
                    return [3, 10];
                case 9:
                    return t.releaseLock(),
                    [7];
                case 10:
                    return [2]
                }
            })
        })
    }
    function Tk(n) {
        return ut(n == null ? void 0 : n.getReader)
    }
    function wr(n) {
        if (n instanceof Lt)
            return n;
        if (n != null) {
            if (Sk(n))
                return Bj(n);
            if (Av(n))
                return qj(n);
            if (_k(n))
                return Uj(n);
            if (Ek(n))
                return Ak(n);
            if (kk(n))
                return Kj(n);
            if (Tk(n))
                return Hj(n)
        }
        throw xk(n)
    }
    function Bj(n) {
        return new Lt(function(e) {
            var t = n[kv]();
            if (ut(t.subscribe))
                return t.subscribe(e);
            throw new TypeError("Provided object does not correctly implement Symbol.observable")
        }
        )
    }
    function qj(n) {
        return new Lt(function(e) {
            for (var t = 0; t < n.length && !e.closed; t++)
                e.next(n[t]);
            e.complete()
        }
        )
    }
    function Uj(n) {
        return new Lt(function(e) {
            n.then(function(t) {
                e.closed || (e.next(t),
                e.complete())
            }, function(t) {
                return e.error(t)
            }).then(null, pk)
        }
        )
    }
    function Kj(n) {
        return new Lt(function(e) {
            var t, r;
            try {
                for (var s = Nc(n), i = s.next(); !i.done; i = s.next()) {
                    var a = i.value;
                    if (e.next(a),
                    e.closed)
                        return
                }
            } catch (c) {
                t = {
                    error: c
                }
            } finally {
                try {
                    i && !i.done && (r = s.return) && r.call(s)
                } finally {
                    if (t)
                        throw t.error
                }
            }
            e.complete()
        }
        )
    }
    function Ak(n) {
        return new Lt(function(e) {
            Wj(n, e).catch(function(t) {
                return e.error(t)
            })
        }
        )
    }
    function Hj(n) {
        return Ak(Pk(n))
    }
    function Wj(n, e) {
        var t, r, s, i;
        return gj(this, void 0, void 0, function() {
            var a, c;
            return uk(this, function(u) {
                switch (u.label) {
                case 0:
                    u.trys.push([0, 5, 6, 11]),
                    t = wj(n),
                    u.label = 1;
                case 1:
                    return [4, t.next()];
                case 2:
                    if (r = u.sent(),
                    !!r.done)
                        return [3, 4];
                    if (a = r.value,
                    e.next(a),
                    e.closed)
                        return [2];
                    u.label = 3;
                case 3:
                    return [3, 1];
                case 4:
                    return [3, 11];
                case 5:
                    return c = u.sent(),
                    s = {
                        error: c
                    },
                    [3, 11];
                case 6:
                    return u.trys.push([6, , 9, 10]),
                    r && !r.done && (i = t.return) ? [4, i.call(t)] : [3, 8];
                case 7:
                    u.sent(),
                    u.label = 8;
                case 8:
                    return [3, 10];
                case 9:
                    if (s)
                        throw s.error;
                    return [7];
                case 10:
                    return [7];
                case 11:
                    return e.complete(),
                    [2]
                }
            })
        })
    }
    function ki(n, e, t, r, s) {
        r === void 0 && (r = 0),
        s === void 0 && (s = !1);
        var i = e.schedule(function() {
            t(),
            s ? n.add(this.schedule(null, r)) : this.unsubscribe()
        }, r);
        if (n.add(i),
        !s)
            return i
    }
    function Ik(n, e) {
        return e === void 0 && (e = 0),
        nr(function(t, r) {
            t.subscribe(Ut(r, function(s) {
                return ki(r, n, function() {
                    return r.next(s)
                }, e)
            }, function() {
                return ki(r, n, function() {
                    return r.complete()
                }, e)
            }, function(s) {
                return ki(r, n, function() {
                    return r.error(s)
                }, e)
            }))
        })
    }
    function Ok(n, e) {
        return e === void 0 && (e = 0),
        nr(function(t, r) {
            r.add(n.schedule(function() {
                return t.subscribe(r)
            }, e))
        })
    }
    function zj(n, e) {
        return wr(n).pipe(Ok(e), Ik(e))
    }
    function Vj(n, e) {
        return wr(n).pipe(Ok(e), Ik(e))
    }
    function Gj(n, e) {
        return new Lt(function(t) {
            var r = 0;
            return e.schedule(function() {
                r === n.length ? t.complete() : (t.next(n[r++]),
                t.closed || this.schedule())
            })
        }
        )
    }
    function Jj(n, e) {
        return new Lt(function(t) {
            var r;
            return ki(t, e, function() {
                r = n[Ck](),
                ki(t, e, function() {
                    var s, i, a;
                    try {
                        s = r.next(),
                        i = s.value,
                        a = s.done
                    } catch (c) {
                        t.error(c);
                        return
                    }
                    a ? t.complete() : t.next(i)
                }, 0, !0)
            }),
            function() {
                return ut(r == null ? void 0 : r.return) && r.return()
            }
        }
        )
    }
    function Rk(n, e) {
        if (!n)
            throw new Error("Iterable cannot be null");
        return new Lt(function(t) {
            ki(t, e, function() {
                var r = n[Symbol.asyncIterator]();
                ki(t, e, function() {
                    r.next().then(function(s) {
                        s.done ? t.complete() : t.next(s.value)
                    })
                }, 0, !0)
            })
        }
        )
    }
    function Zj(n, e) {
        return Rk(Pk(n), e)
    }
    function Xj(n, e) {
        if (n != null) {
            if (Sk(n))
                return zj(n, e);
            if (Av(n))
                return Gj(n, e);
            if (_k(n))
                return Vj(n, e);
            if (Ek(n))
                return Rk(n, e);
            if (kk(n))
                return Jj(n, e);
            if (Tk(n))
                return Zj(n, e)
        }
        throw xk(n)
    }
    function Ze(n, e) {
        return e ? Xj(n, e) : wr(n)
    }
    function ss() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        var t = Rd(n);
        return Ze(n, t)
    }
    var Iv = Sv(function(n) {
        return function() {
            n(this),
            this.name = "EmptyError",
            this.message = "no elements in sequence"
        }
    });
    function Kt(n, e) {
        return new Promise(function(t, r) {
            var s = new Kg({
                next: function(i) {
                    t(i),
                    s.unsubscribe()
                },
                error: r,
                complete: function() {
                    r(new Iv)
                }
            });
            n.subscribe(s)
        }
        )
    }
    function Yj(n) {
        return n instanceof Date && !isNaN(n)
    }
    function Pt(n, e) {
        return nr(function(t, r) {
            var s = 0;
            t.subscribe(Ut(r, function(i) {
                r.next(n.call(e, i, s++))
            }))
        })
    }
    var Qj = Array.isArray;
    function eD(n, e) {
        return Qj(e) ? n.apply(void 0, $c([], Ha(e))) : n(e)
    }
    function Mk(n) {
        return Pt(function(e) {
            return eD(n, e)
        })
    }
    var tD = Array.isArray
      , rD = Object.getPrototypeOf
      , nD = Object.prototype
      , sD = Object.keys;
    function iD(n) {
        if (n.length === 1) {
            var e = n[0];
            if (tD(e))
                return {
                    args: e,
                    keys: null
                };
            if (aD(e)) {
                var t = sD(e);
                return {
                    args: t.map(function(r) {
                        return e[r]
                    }),
                    keys: t
                }
            }
        }
        return {
            args: n,
            keys: null
        }
    }
    function aD(n) {
        return n && typeof n == "object" && rD(n) === nD
    }
    function oD(n, e) {
        return n.reduce(function(t, r, s) {
            return t[r] = e[s],
            t
        }, {})
    }
    function Wg() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        var t = Rd(n)
          , r = Fj(n)
          , s = iD(n)
          , i = s.args
          , a = s.keys;
        if (i.length === 0)
            return Ze([], t);
        var c = new Lt(cD(i, t, a ? function(u) {
            return oD(a, u)
        }
        : ns));
        return r ? c.pipe(Mk(r)) : c
    }
    function cD(n, e, t) {
        return t === void 0 && (t = ns),
        function(r) {
            Nk(e, function() {
                for (var s = n.length, i = new Array(s), a = s, c = s, u = function(d) {
                    Nk(e, function() {
                        var h = Ze(n[d], e)
                          , f = !1;
                        h.subscribe(Ut(r, function(p) {
                            i[d] = p,
                            f || (f = !0,
                            c--),
                            c || r.next(t(i.slice()))
                        }, function() {
                            --a || r.complete()
                        }))
                    }, r)
                }, l = 0; l < s; l++)
                    u(l)
            }, r)
        }
    }
    function Nk(n, e, t) {
        n ? ki(t, n, e) : e()
    }
    function $k(n, e, t, r, s, i, a, c) {
        var u = []
          , l = 0
          , d = 0
          , h = !1
          , f = function() {
            h && !u.length && !l && e.complete()
        }
          , p = function(y) {
            return l < r ? g(y) : u.push(y)
        }
          , g = function(y) {
            i && e.next(y),
            l++;
            var m = !1;
            wr(t(y, d++)).subscribe(Ut(e, function(w) {
                s == null || s(w),
                i ? p(w) : e.next(w)
            }, function() {
                m = !0
            }, void 0, function() {
                if (m)
                    try {
                        l--;
                        for (var w = function() {
                            var E = u.shift();
                            a || g(E)
                        }; u.length && l < r; )
                            w();
                        f()
                    } catch (E) {
                        e.error(E)
                    }
            }))
        };
        return n.subscribe(Ut(e, p, function() {
            h = !0,
            f()
        })),
        function() {
            c == null || c()
        }
    }
    function Ht(n, e, t) {
        return t === void 0 && (t = 1 / 0),
        ut(e) ? Ht(function(r, s) {
            return Pt(function(i, a) {
                return e(r, i, s, a)
            })(wr(n(r, s)))
        }, t) : (typeof e == "number" && (t = e),
        nr(function(r, s) {
            return $k(r, s, n, t)
        }))
    }
    function Lk(n) {
        return n === void 0 && (n = 1 / 0),
        Ht(ns, n)
    }
    function uD() {
        return Lk(1)
    }
    function Ov() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        return uD()(Ze(n, Rd(n)))
    }
    function za(n) {
        return new Lt(function(e) {
            wr(n()).subscribe(e)
        }
        )
    }
    var lD = ["addListener", "removeListener"]
      , dD = ["addEventListener", "removeEventListener"]
      , hD = ["on", "off"];
    function Rv(n, e, t, r) {
        if (ut(t) && (r = t,
        t = void 0),
        r)
            return Rv(n, e, t).pipe(Mk(r));
        var s = Ha(mD(n) ? dD.map(function(c) {
            return function(u) {
                return n[c](e, u, t)
            }
        }) : fD(n) ? lD.map(Fk(n, e)) : pD(n) ? hD.map(Fk(n, e)) : [], 2)
          , i = s[0]
          , a = s[1];
        if (!i && Av(n))
            return Ht(function(c) {
                return Rv(c, e, t)
            })(wr(n));
        if (!i)
            throw new TypeError("Invalid event target");
        return new Lt(function(c) {
            var u = function() {
                for (var l = [], d = 0; d < arguments.length; d++)
                    l[d] = arguments[d];
                return c.next(1 < l.length ? l : l[0])
            };
            return i(u),
            function() {
                return a(u)
            }
        }
        )
    }
    function Fk(n, e) {
        return function(t) {
            return function(r) {
                return n[t](e, r)
            }
        }
    }
    function fD(n) {
        return ut(n.addListener) && ut(n.removeListener)
    }
    function pD(n) {
        return ut(n.on) && ut(n.off)
    }
    function mD(n) {
        return ut(n.addEventListener) && ut(n.removeEventListener)
    }
    function Mv(n, e, t) {
        return n === void 0 && (n = 0),
        t === void 0 && (t = $j),
        new Lt(function(r) {
            var s = Yj(n) ? +n - t.now() : n;
            s < 0 && (s = 0);
            var i = 0;
            return t.schedule(function() {
                r.closed || (r.next(i++),
                r.complete())
            }, s)
        }
        )
    }
    function Md() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        var t = Rd(n)
          , r = jj(n, 1 / 0)
          , s = n;
        return s.length ? s.length === 1 ? wr(s[0]) : Lk(r)(Ze(s, t)) : Wa
    }
    var jk = new Lt(Fc)
      , gD = Array.isArray;
    function yD(n) {
        return n.length === 1 && gD(n[0]) ? n[0] : n
    }
    function Va(n, e) {
        return nr(function(t, r) {
            var s = 0;
            t.subscribe(Ut(r, function(i) {
                return n.call(e, i, s++) && r.next(i)
            }))
        })
    }
    function Dk() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        return n = yD(n),
        n.length === 1 ? wr(n[0]) : new Lt(Bk(n))
    }
    function Bk(n) {
        return function(e) {
            for (var t = [], r = function(i) {
                t.push(wr(n[i]).subscribe(Ut(e, function(a) {
                    if (t) {
                        for (var c = 0; c < t.length; c++)
                            c !== i && t[c].unsubscribe();
                        t = null
                    }
                    e.next(a)
                })))
            }, s = 0; t && !e.closed && s < n.length; s++)
                r(s)
        }
    }
    function Nd(n) {
        return nr(function(e, t) {
            var r = null, s = !1, i;
            r = e.subscribe(Ut(t, void 0, void 0, function(a) {
                i = wr(n(a, Nd(n)(e))),
                r ? (r.unsubscribe(),
                r = null,
                i.subscribe(t)) : s = !0
            })),
            s && (r.unsubscribe(),
            r = null,
            i.subscribe(t))
        })
    }
    function qk(n) {
        return nr(function(e, t) {
            var r = !1;
            e.subscribe(Ut(t, function(s) {
                r = !0,
                t.next(s)
            }, function() {
                r || t.next(n),
                t.complete()
            }))
        })
    }
    function Nv(n) {
        return n <= 0 ? function() {
            return Wa
        }
        : nr(function(e, t) {
            var r = 0;
            e.subscribe(Ut(t, function(s) {
                ++r <= n && (t.next(s),
                n <= r && t.complete())
            }))
        })
    }
    function zg() {
        return nr(function(n, e) {
            n.subscribe(Ut(e, Fc))
        })
    }
    function wD(n) {
        return Pt(function() {
            return n
        })
    }
    function bD(n, e) {
        return Ht(function(t, r) {
            return wr(n(t, r)).pipe(Nv(1), wD(t))
        })
    }
    function Vg(n) {
        return n === void 0 && (n = vD),
        nr(function(e, t) {
            var r = !1;
            e.subscribe(Ut(t, function(s) {
                r = !0,
                t.next(s)
            }, function() {
                return r ? t.complete() : t.error(n())
            }))
        })
    }
    function vD() {
        return new Iv
    }
    function jc(n, e) {
        var t = arguments.length >= 2;
        return function(r) {
            return r.pipe(n ? Va(function(s, i) {
                return n(s, i, r)
            }) : ns, Nv(1), t ? qk(e) : Vg(function() {
                return new Iv
            }))
        }
    }
    function _D(n, e, t) {
        return t === void 0 && (t = 1 / 0),
        nr(function(r, s) {
            var i = e;
            return $k(r, s, function(a, c) {
                return n(i, a, c)
            }, t, function(a) {
                i = a
            }, !1, void 0, function() {
                return i = null
            })
        })
    }
    function sr() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        return n.length ? nr(function(t, r) {
            Bk($c([t], Ha(n)))(r)
        }) : ns
    }
    function Gg(n) {
        n === void 0 && (n = 1 / 0);
        var e;
        n && typeof n == "object" ? e = n : e = {
            count: n
        };
        var t = e.count
          , r = t === void 0 ? 1 / 0 : t
          , s = e.delay
          , i = e.resetOnSuccess
          , a = i === void 0 ? !1 : i;
        return r <= 0 ? ns : nr(function(c, u) {
            var l = 0, d, h = function() {
                var f = !1;
                d = c.subscribe(Ut(u, function(p) {
                    a && (l = 0),
                    u.next(p)
                }, void 0, function(p) {
                    if (l++ < r) {
                        var g = function() {
                            d ? (d.unsubscribe(),
                            d = null,
                            h()) : f = !0
                        };
                        if (s != null) {
                            var y = typeof s == "number" ? Mv(s) : wr(s(p, l))
                              , m = Ut(u, function() {
                                m.unsubscribe(),
                                g()
                            }, function() {
                                u.complete()
                            });
                            y.subscribe(m)
                        } else
                            g()
                    } else
                        u.error(p)
                })),
                f && (d.unsubscribe(),
                d = null,
                h())
            };
            h()
        })
    }
    function SD() {
        for (var n = [], e = 0; e < arguments.length; e++)
            n[e] = arguments[e];
        var t = Rd(n);
        return nr(function(r, s) {
            (t ? Ov(n, r, t) : Ov(n, r)).subscribe(s)
        })
    }
    function Jg(n, e) {
        return nr(function(t, r) {
            var s = null
              , i = 0
              , a = !1
              , c = function() {
                return a && !s && r.complete()
            };
            t.subscribe(Ut(r, function(u) {
                s == null || s.unsubscribe();
                var l = 0
                  , d = i++;
                wr(n(u, d)).subscribe(s = Ut(r, function(h) {
                    return r.next(e ? e(u, h, d, l++) : h)
                }, function() {
                    s = null,
                    c()
                }))
            }, function() {
                a = !0,
                c()
            }))
        })
    }
    function ED(n) {
        return nr(function(e, t) {
            wr(n).subscribe(Ut(t, function() {
                return t.complete()
            }, Fc)),
            !t.closed && e.subscribe(t)
        })
    }
    function Zg(n, e, t) {
        var r = ut(n) || e || t ? {
            next: n,
            error: e,
            complete: t
        } : n;
        return r ? nr(function(s, i) {
            var a;
            (a = r.subscribe) === null || a === void 0 || a.call(r);
            var c = !0;
            s.subscribe(Ut(i, function(u) {
                var l;
                (l = r.next) === null || l === void 0 || l.call(r, u),
                i.next(u)
            }, function() {
                var u;
                c = !1,
                (u = r.complete) === null || u === void 0 || u.call(r),
                i.complete()
            }, function(u) {
                var l;
                c = !1,
                (l = r.error) === null || l === void 0 || l.call(r, u),
                i.error(u)
            }, function() {
                var u, l;
                c && ((u = r.unsubscribe) === null || u === void 0 || u.call(r)),
                (l = r.finalize) === null || l === void 0 || l.call(r)
            }))
        }) : ns
    }
    function xD(n) {
        return {
            all: n = n || new Map,
            on: function(e, t) {
                var r = n.get(e);
                r ? r.push(t) : n.set(e, [t])
            },
            off: function(e, t) {
                var r = n.get(e);
                r && (t ? r.splice(r.indexOf(t) >>> 0, 1) : n.set(e, []))
            },
            emit: function(e, t) {
                var r = n.get(e);
                r && r.slice().map(function(s) {
                    s(t)
                }),
                (r = n.get("*")) && r.slice().map(function(s) {
                    s(e, t)
                })
            }
        }
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    Symbol.dispose ?? (Symbol.dispose = Symbol("dispose")),
    Symbol.asyncDispose ?? (Symbol.asyncDispose = Symbol("asyncDispose"));
    const Ce = Symbol.dispose
      , En = Symbol.asyncDispose;
    RN = Ce,
    ON = Symbol.toStringTag;
    const rx = class rx {
        constructor() {
            b(this, na, !1);
            b(this, Xs, []);
            J(this, RN, this.dispose);
            J(this, ON, "DisposableStack")
        }
        get disposed() {
            return o(this, na)
        }
        dispose() {
            if (!o(this, na)) {
                S(this, na, !0);
                for (const e of o(this, Xs).reverse())
                    e[Ce]()
            }
        }
        use(e) {
            return e && o(this, Xs).push(e),
            e
        }
        adopt(e, t) {
            return o(this, Xs).push({
                [Ce]() {
                    t(e)
                }
            }),
            e
        }
        defer(e) {
            o(this, Xs).push({
                [Ce]() {
                    e()
                }
            })
        }
        move() {
            if (o(this, na))
                throw new ReferenceError("a disposed stack can not use anything new");
            const e = new rx;
            return S(e, Xs, o(this, Xs)),
            S(this, na, !0),
            e
        }
    }
    ;
    na = new WeakMap,
    Xs = new WeakMap;
    let Ot = rx;
    NN = En,
    MN = Symbol.toStringTag;
    const nx = class nx {
        constructor() {
            b(this, sa, !1);
            b(this, Ys, []);
            J(this, NN, this.dispose);
            J(this, MN, "AsyncDisposableStack")
        }
        get disposed() {
            return o(this, sa)
        }
        async dispose() {
            if (!o(this, sa)) {
                S(this, sa, !0);
                for (const e of o(this, Ys).reverse())
                    await e[En]()
            }
        }
        use(e) {
            return e && o(this, Ys).push(e),
            e
        }
        adopt(e, t) {
            return o(this, Ys).push({
                [En]() {
                    return t(e)
                }
            }),
            e
        }
        defer(e) {
            o(this, Ys).push({
                [En]() {
                    return e()
                }
            })
        }
        move() {
            if (o(this, sa))
                throw new ReferenceError("a disposed stack can not use anything new");
            const e = new nx;
            return S(e, Ys, o(this, Ys)),
            S(this, sa, !0),
            e
        }
    }
    ;
    sa = new WeakMap,
    Ys = new WeakMap;
    let Xg = nx;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    let be = ($N = class {
        constructor(e=xD(new Map)) {
            b(this, Qs);
            b(this, _s, new Map);
            S(this, Qs, e)
        }
        on(e, t) {
            const r = o(this, _s).get(e);
            return r === void 0 ? o(this, _s).set(e, [t]) : r.push(t),
            o(this, Qs).on(e, t),
            this
        }
        off(e, t) {
            const r = o(this, _s).get(e) ?? [];
            if (t === void 0) {
                for (const i of r)
                    o(this, Qs).off(e, i);
                return o(this, _s).delete(e),
                this
            }
            const s = r.lastIndexOf(t);
            return s > -1 && o(this, Qs).off(e, ...r.splice(s, 1)),
            this
        }
        emit(e, t) {
            return o(this, Qs).emit(e, t),
            this.listenerCount(e) > 0
        }
        once(e, t) {
            const r = s => {
                t(s),
                this.off(e, r)
            }
            ;
            return this.on(e, r)
        }
        listenerCount(e) {
            var t;
            return ((t = o(this, _s).get(e)) == null ? void 0 : t.length) || 0
        }
        removeAllListeners(e) {
            return e !== void 0 ? this.off(e) : (this[Ce](),
            this)
        }
        [Ce]() {
            for (const [e,t] of o(this, _s))
                for (const r of t)
                    o(this, Qs).off(e, r);
            o(this, _s).clear()
        }
    }
    ,
    Qs = new WeakMap,
    _s = new WeakMap,
    $N);
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const Uk = !!(typeof process < "u" && process.version)
      , Pi = {
        value: {
            get fs() {
                throw new Error("fs is not available in this environment")
            },
            get ScreenRecorder() {
                throw new Error("ScreenRecorder is not available in this environment")
            }
        }
    }
      , Kk = "24.1.1";
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const ne = (n, e) => {
        if (!n)
            throw new Error(e)
    }
    ;
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    function $v(n, e=!1) {
        if (e) {
            const t = atob(n);
            return Uint8Array.from(t, r => r.codePointAt(0))
        }
        return new TextEncoder().encode(n)
    }
    function Hk(n) {
        return Wk(new TextEncoder().encode(n))
    }
    function Wk(n) {
        const t = [];
        for (let s = 0; s < n.length; s += 65534) {
            const i = n.subarray(s, s + 65534);
            t.push(String.fromCodePoint.apply(null, i))
        }
        const r = t.join("");
        return btoa(r)
    }
    function CD(n) {
        let e = 0;
        for (const s of n)
            e += s.length;
        const t = new Uint8Array(e);
        let r = 0;
        for (const s of n)
            t.set(s, r),
            r += s.length;
        return t
    }
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    let Lv = null;
    async function kD() {
        return Lv || (Lv = (await Promise.resolve().then( () => bz)).default),
        Lv
    }
    const Dc = n => Uk ? async (...e) => {
        (await kD())(n)(e)
    }
    : (...e) => {
        const t = globalThis.__PUPPETEER_DEBUG;
        !t || !(t === "*" || (t.endsWith("*") ? n.startsWith(t) : n === t)) || console.log(`${n}:`, ...e)
    }
    ;
    /**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Yg extends Error {
        constructor(e, t) {
            super(e, t),
            this.name = this.constructor.name
        }
        get[Symbol.toStringTag]() {
            return this.constructor.name
        }
    }
    class Qg extends Yg {
    }
    class ey extends Yg {
    }
    class Ga extends Yg {
        constructor() {
            super(...arguments);
            b(this, Qf);
            b(this, ep, "")
        }
        set code(t) {
            S(this, Qf, t)
        }
        get code() {
            return o(this, Qf)
        }
        set originalMessage(t) {
            S(this, ep, t)
        }
        get originalMessage() {
            return o(this, ep)
        }
    }
    Qf = new WeakMap,
    ep = new WeakMap;
    class Oe extends Yg {
    }
    class xn extends Ga {
    }
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const PD = {
        letter: {
            cm: {
                width: 21.59,
                height: 27.94
            },
            in: {
                width: 8.5,
                height: 11
            }
        },
        legal: {
            cm: {
                width: 21.59,
                height: 35.56
            },
            in: {
                width: 8.5,
                height: 14
            }
        },
        tabloid: {
            cm: {
                width: 27.94,
                height: 43.18
            },
            in: {
                width: 11,
                height: 17
            }
        },
        ledger: {
            cm: {
                width: 43.18,
                height: 27.94
            },
            in: {
                width: 17,
                height: 11
            }
        },
        a0: {
            cm: {
                width: 84.1,
                height: 118.9
            },
            in: {
                width: 33.1102,
                height: 46.811
            }
        },
        a1: {
            cm: {
                width: 59.4,
                height: 84.1
            },
            in: {
                width: 23.3858,
                height: 33.1102
            }
        },
        a2: {
            cm: {
                width: 42,
                height: 59.4
            },
            in: {
                width: 16.5354,
                height: 23.3858
            }
        },
        a3: {
            cm: {
                width: 29.7,
                height: 42
            },
            in: {
                width: 11.6929,
                height: 16.5354
            }
        },
        a4: {
            cm: {
                width: 21,
                height: 29.7
            },
            in: {
                width: 8.2677,
                height: 11.6929
            }
        },
        a5: {
            cm: {
                width: 14.8,
                height: 21
            },
            in: {
                width: 5.8268,
                height: 8.2677
            }
        },
        a6: {
            cm: {
                width: 10.5,
                height: 14.8
            },
            in: {
                width: 4.1339,
                height: 5.8268
            }
        }
    };
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const ge = Dc("puppeteer:error")
      , zk = Object.freeze({
        width: 800,
        height: 600
    })
      , ty = Symbol("Source URL for Puppeteer evaluation scripts")
      , bo = class bo {
        constructor() {
            b(this, yo);
            b(this, wo)
        }
        static fromCallSite(e, t) {
            const r = new bo;
            return S(r, yo, e),
            S(r, wo, t.toString()),
            r
        }
        get functionName() {
            return o(this, yo)
        }
        get siteString() {
            return o(this, wo)
        }
        toString() {
            return `pptr:${[o(this, yo), encodeURIComponent(o(this, wo))].join(";")}`
        }
    }
    ;
    yo = new WeakMap,
    wo = new WeakMap,
    J(bo, "INTERNAL_URL", "pptr:internal"),
    J(bo, "parse", e => {
        e = e.slice(5);
        const [t="",r=""] = e.split(";")
          , s = new bo;
        return S(s, yo, t),
        S(s, wo, decodeURIComponent(r)),
        s
    }
    ),
    J(bo, "isPuppeteerURL", e => e.startsWith("pptr:"));
    let Gr = bo;
    const Wt = (n, e) => {
        if (Object.prototype.hasOwnProperty.call(e, ty))
            return e;
        const t = Error.prepareStackTrace;
        Error.prepareStackTrace = (s, i) => i[2];
        const r = new Error().stack;
        return Error.prepareStackTrace = t,
        Object.assign(e, {
            [ty]: Gr.fromCallSite(n, r)
        })
    }
      , Vk = n => {
        if (Object.prototype.hasOwnProperty.call(n, ty))
            return n[ty]
    }
      , js = n => typeof n == "string" || n instanceof String
      , TD = n => typeof n == "number" || n instanceof Number
      , AD = n => typeof n == "object" && (n == null ? void 0 : n.constructor) === Object
      , ID = n => typeof n == "object" && (n == null ? void 0 : n.constructor) === RegExp
      , OD = n => typeof n == "object" && (n == null ? void 0 : n.constructor) === Date;
    function Fv(n, ...e) {
        if (js(n))
            return ne(e.length === 0, "Cannot evaluate a string with arguments"),
            n;
        function t(r) {
            return Object.is(r, void 0) ? "undefined" : JSON.stringify(r)
        }
        return `(${n})(${e.map(t).join(",")})`
    }
    async function Gk(n, e) {
        const t = []
          , r = n.getReader();
        if (e) {
            const s = await Pi.value.fs.promises.open(e, "w+");
            try {
                for (; ; ) {
                    const {done: i, value: a} = await r.read();
                    if (i)
                        break;
                    t.push(a),
                    await s.writeFile(a)
                }
            } finally {
                await s.close()
            }
        } else
            for (; ; ) {
                const {done: s, value: i} = await r.read();
                if (s)
                    break;
                t.push(i)
            }
        try {
            const s = CD(t);
            return s.length === 0 ? null : s
        } catch (s) {
            return ge(s),
            null
        }
    }
    async function Jk(n, e) {
        return new ReadableStream({
            async pull(t) {
                function r(c, u) {
                    return u ? Uint8Array.from(atob(c), d => d.codePointAt(0)) : new TextEncoder().encode(c)
                }
                const {data: s, base64Encoded: i, eof: a} = await n.send("IO.read", {
                    handle: e
                });
                t.enqueue(r(s, i ?? !1)),
                a && (await n.send("IO.close", {
                    handle: e
                }),
                t.close())
            }
        })
    }
    function RD(n) {
        let e = null;
        return new Set(["alert", "confirm", "prompt", "beforeunload"]).has(n) && (e = n),
        ne(e, `Unknown javascript dialog type: ${n}`),
        e
    }
    function Or(n, e) {
        return n === 0 ? jk : Mv(n).pipe(Pt( () => {
            throw new Qg(`Timed out after waiting ${n}ms`,{
                cause: e
            })
        }
        ))
    }
    const Zk = "__puppeteer_utility_world__" + Kk
      , ry = /^[\x20\t]*\/\/[@#] sourceURL=\s{0,10}(\S*?)\s{0,10}$/m;
    function Xk(n) {
        return `//# sourceURL=${n}`
    }
    const MD = 500;
    function Yk(n={}, e="in") {
        var a, c, u, l;
        const t = {
            scale: 1,
            displayHeaderFooter: !1,
            headerTemplate: "",
            footerTemplate: "",
            printBackground: !1,
            landscape: !1,
            pageRanges: "",
            preferCSSPageSize: !1,
            omitBackground: !1,
            outline: !1,
            tagged: !0,
            waitForFonts: !0
        };
        let r = 8.5
          , s = 11;
        if (n.format) {
            const d = PD[n.format.toLowerCase()][e];
            ne(d, "Unknown paper format: " + n.format),
            r = d.width,
            s = d.height
        } else
            r = Bc(n.width, e) ?? r,
            s = Bc(n.height, e) ?? s;
        const i = {
            top: Bc((a = n.margin) == null ? void 0 : a.top, e) || 0,
            left: Bc((c = n.margin) == null ? void 0 : c.left, e) || 0,
            bottom: Bc((u = n.margin) == null ? void 0 : u.bottom, e) || 0,
            right: Bc((l = n.margin) == null ? void 0 : l.right, e) || 0
        };
        return n.outline && (n.tagged = !0),
        {
            ...t,
            ...n,
            width: r,
            height: s,
            margin: i
        }
    }
    const jv = {
        px: 1,
        in: 96,
        cm: 37.8,
        mm: 3.78
    };
    function Bc(n, e="in") {
        if (typeof n > "u")
            return;
        let t;
        if (TD(n))
            t = n;
        else if (js(n)) {
            const r = n;
            let s = r.substring(r.length - 2).toLowerCase()
              , i = "";
            s in jv ? i = r.substring(0, r.length - 2) : (s = "px",
            i = r);
            const a = Number(i);
            ne(!isNaN(a), "Failed to parse parameter value: " + r),
            t = a * jv[s]
        } else
            throw new Error("page.pdf() Cannot handle parameter type: " + typeof n);
        return t / jv[e]
    }
    function at(n, e) {
        return new Lt(t => {
            const r = s => {
                t.next(s)
            }
            ;
            return n.on(e, r),
            () => {
                n.off(e, r)
            }
        }
        )
    }
    function Ja(n, e) {
        return n ? Rv(n, "abort").pipe(Pt( () => {
            throw n.reason instanceof Error ? (n.reason.cause = e,
            n.reason) : new Error(n.reason,{
                cause: e
            })
        }
        )) : jk
    }
    function $d(n) {
        return Ht(e => Ze(Promise.resolve(n(e))).pipe(Va(t => t), Pt( () => e)))
    }
    const Dv = new Map([["geolocation", "geolocation"], ["midi", "midi"], ["notifications", "notifications"], ["camera", "videoCapture"], ["microphone", "audioCapture"], ["background-sync", "backgroundSync"], ["ambient-light-sensor", "sensors"], ["accelerometer", "sensors"], ["gyroscope", "sensors"], ["magnetometer", "sensors"], ["accessibility-events", "accessibilityEvents"], ["clipboard-read", "clipboardReadWrite"], ["clipboard-write", "clipboardReadWrite"], ["clipboard-sanitized-write", "clipboardSanitizedWrite"], ["payment-handler", "paymentHandler"], ["persistent-storage", "durableStorage"], ["idle-detection", "idleDetection"], ["midi-sysex", "midiSysex"]]);
    let Qk = class extends be {
        constructor() {
            super()
        }
        async waitForTarget(e, t={}) {
            const {timeout: r=3e4, signal: s} = t;
            return await Kt(Md(at(this, "targetcreated"), at(this, "targetchanged"), Ze(this.targets())).pipe($d(e), sr(Ja(s), Or(r))))
        }
        async pages() {
            return (await Promise.all(this.browserContexts().map(t => t.pages()))).reduce( (t, r) => t.concat(r), [])
        }
        async cookies() {
            return await this.defaultBrowserContext().cookies()
        }
        async setCookie(...e) {
            return await this.defaultBrowserContext().setCookie(...e)
        }
        async deleteCookie(...e) {
            return await this.defaultBrowserContext().deleteCookie(...e)
        }
        isConnected() {
            return this.connected
        }
        [Ce]() {
            return this.process() ? void this.close().catch(ge) : void this.disconnect().catch(ge)
        }
        [En]() {
            return this.process() ? this.close() : this.disconnect()
        }
    }
    ;
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    let pt = (_o = class {
        constructor(e) {
            b(this, np);
            b(this, ia, !1);
            b(this, aa, !1);
            b(this, vo);
            b(this, tp);
            b(this, vb, new Promise(e => {
                S(this, tp, e)
            }
            ));
            b(this, zu);
            b(this, rp);
            b(this, Vu);
            e && e.timeout > 0 && (S(this, rp, new Qg(e.message)),
            S(this, zu, setTimeout( () => {
                this.reject(o(this, rp))
            }
            , e.timeout)))
        }
        static create(e) {
            return new _o(e)
        }
        static async race(e) {
            const t = new Set;
            try {
                const r = e.map(s => s instanceof _o ? (o(s, zu) && t.add(s),
                s.valueOrThrow()) : s);
                return await Promise.race(r)
            } finally {
                for (const r of t)
                    r.reject(new Error("Timeout cleared"))
            }
        }
        resolve(e) {
            o(this, aa) || o(this, ia) || (S(this, ia, !0),
            P(this, np, Sx).call(this, e))
        }
        reject(e) {
            o(this, aa) || o(this, ia) || (S(this, aa, !0),
            P(this, np, Sx).call(this, e))
        }
        resolved() {
            return o(this, ia)
        }
        finished() {
            return o(this, ia) || o(this, aa)
        }
        value() {
            return o(this, vo)
        }
        valueOrThrow() {
            return o(this, Vu) || S(this, Vu, (async () => {
                if (await o(this, vb),
                o(this, aa))
                    throw o(this, vo);
                return o(this, vo)
            }
            )()),
            o(this, Vu)
        }
    }
    ,
    ia = new WeakMap,
    aa = new WeakMap,
    vo = new WeakMap,
    tp = new WeakMap,
    vb = new WeakMap,
    zu = new WeakMap,
    rp = new WeakMap,
    np = new WeakSet,
    Sx = function(e) {
        clearTimeout(o(this, zu)),
        S(this, vo, e),
        o(this, tp).call(this)
    }
    ,
    Vu = new WeakMap,
    _o);
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    let Bv = (oa = class {
        constructor() {
            b(this, Gu, !1);
            b(this, ap, [])
        }
        async acquire(e) {
            if (!o(this, Gu))
                return S(this, Gu, !0),
                new oa.Guard(this);
            const t = pt.create();
            return o(this, ap).push(t.resolve.bind(t)),
            await t.valueOrThrow(),
            new oa.Guard(this,e)
        }
        release() {
            const e = o(this, ap).shift();
            if (!e) {
                S(this, Gu, !1);
                return
            }
            e()
        }
    }
    ,
    Gu = new WeakMap,
    ap = new WeakMap,
    J(oa, "Guard", (LN = class {
        constructor(t, r) {
            b(this, sp);
            b(this, ip);
            S(this, sp, t),
            S(this, ip, r)
        }
        [Ce]() {
            var t;
            return (t = o(this, ip)) == null || t.call(this),
            o(this, sp).release()
        }
    }
    ,
    sp = new WeakMap,
    ip = new WeakMap,
    LN)),
    oa);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    let eP = (FN = class extends be {
        constructor() {
            super();
            b(this, So);
            b(this, Ju, 0)
        }
        startScreenshot() {
            const t = o(this, So) || new Bv;
            return S(this, So, t),
            _d(this, Ju)._++,
            t.acquire( () => {
                _d(this, Ju)._--,
                o(this, Ju) === 0 && S(this, So, void 0)
            }
            )
        }
        waitForScreenshotOperations() {
            var t;
            return (t = o(this, So)) == null ? void 0 : t.acquire()
        }
        async waitForTarget(t, r={}) {
            const {timeout: s=3e4} = r;
            return await Kt(Md(at(this, "targetcreated"), at(this, "targetchanged"), Ze(this.targets())).pipe($d(t), sr(Or(s))))
        }
        async deleteCookie(...t) {
            return await this.setCookie(...t.map(r => ({
                ...r,
                expires: 1
            })))
        }
        get closed() {
            return !this.browser().browserContexts().includes(this)
        }
        get id() {}
        [Ce]() {
            return void this.close().catch(ge)
        }
        [En]() {
            return this.close()
        }
    }
    ,
    So = new WeakMap,
    Ju = new WeakMap,
    FN);
    var yt;
    (function(n) {
        n.Disconnected = Symbol("CDPSession.Disconnected"),
        n.Swapped = Symbol("CDPSession.Swapped"),
        n.Ready = Symbol("CDPSession.Ready"),
        n.SessionAttached = "sessionattached",
        n.SessionDetached = "sessiondetached"
    }
    )(yt || (yt = {}));
    class Ld extends be {
        constructor() {
            super()
        }
        parentSession() {}
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class tP {
        constructor(e, t, r="") {
            b(this, op);
            b(this, cp);
            b(this, up);
            J(this, "handled", !1);
            S(this, op, e),
            S(this, cp, t),
            S(this, up, r)
        }
        type() {
            return o(this, op)
        }
        message() {
            return o(this, cp)
        }
        defaultValue() {
            return o(this, up)
        }
        async accept(e) {
            ne(!this.handled, "Cannot accept dialog which is already handled!"),
            this.handled = !0,
            await this.handle({
                accept: !0,
                text: e
            })
        }
        async dismiss() {
            ne(!this.handled, "Cannot dismiss dialog which is already handled!"),
            this.handled = !0,
            await this.handle({
                accept: !1
            })
        }
    }
    op = new WeakMap,
    cp = new WeakMap,
    up = new WeakMap;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const ny = Symbol("_isElementHandle");
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    function hn(n) {
        return typeof n == "object" && n !== null && "name"in n && "message"in n
    }
    function rP(n, e, t) {
        return n.message = e,
        n.originalMessage = t ?? n.originalMessage,
        n
    }
    function nP(n) {
        let e = n.error.message;
        return n.error && typeof n.error == "object" && "data"in n.error && (e += ` ${n.error.data}`),
        e
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const sP = new Map
      , ND = n => {
        let e = sP.get(n);
        return e || (e = new Function(`return ${n}`)(),
        sP.set(n, e),
        e)
    }
    ;
    function is(n) {
        let e = n.toString();
        try {
            new Function(`(${e})`)
        } catch (t) {
            if (t.message.includes("Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script in the following Content Security Policy directive"))
                return e;
            let r = "function ";
            e.startsWith("async ") && (r = `async ${r}`,
            e = e.substring(6)),
            e = `${r}${e}`;
            try {
                new Function(`(${e})`)
            } catch {
                throw new Error("Passed function cannot be serialized!")
            }
        }
        return e
    }
    const qc = (n, e) => {
        let t = is(n);
        for (const [r,s] of Object.entries(e))
            t = t.replace(new RegExp(`PLACEHOLDER\\(\\s*(?:'${r}'|"${r}")\\s*\\)`,"g"), `(${s})`);
        return ND(t)
    }
    ;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var sy = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , qv = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    const $D = 20;
    async function *LD(n, e) {
        const t = {
            stack: [],
            error: void 0,
            hasError: !1
        };
        try {
            const s = await sy(t, await n.evaluateHandle(async (c, u) => {
                const l = [];
                for (; l.length < u; ) {
                    const d = await c.next();
                    if (d.done)
                        break;
                    l.push(d.value)
                }
                return l
            }
            , e), !1).getProperties()
              , i = s.values();
            return sy(t, new Ot, !1).defer( () => {
                for (const c of i) {
                    const u = {
                        stack: [],
                        error: void 0,
                        hasError: !1
                    };
                    try {
                        sy(u, c, !1)[Ce]()
                    } catch (l) {
                        u.error = l,
                        u.hasError = !0
                    } finally {
                        qv(u)
                    }
                }
            }
            ),
            yield*i,
            s.size === 0
        } catch (r) {
            t.error = r,
            t.hasError = !0
        } finally {
            qv(t)
        }
    }
    async function *FD(n) {
        let e = $D;
        for (; !(yield*LD(n, e)); )
            e <<= 1
    }
    async function *iP(n) {
        const e = {
            stack: [],
            error: void 0,
            hasError: !1
        };
        try {
            const t = sy(e, await n.evaluateHandle(r => async function*() {
                yield*r
            }()), !1);
            yield*FD(t)
        } catch (t) {
            e.error = t,
            e.hasError = !0
        } finally {
            qv(e)
        }
    }
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const _b = class _b {
        constructor(e) {
            b(this, lp);
            S(this, lp, e)
        }
        async get(e) {
            return await o(this, lp).call(this, e)
        }
    }
    ;
    lp = new WeakMap,
    J(_b, "create", e => new _b(e));
    let Jr = _b;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var iy = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , ay = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    class Ds {
        static get _querySelector() {
            if (this.querySelector)
                return this.querySelector;
            if (!this.querySelectorAll)
                throw new Error("Cannot create default `querySelector`.");
            return this.querySelector = qc(async (e, t, r) => {
                const i = PLACEHOLDER("querySelectorAll")(e, t, r);
                for await(const a of i)
                    return a;
                return null
            }
            , {
                querySelectorAll: is(this.querySelectorAll)
            })
        }
        static get _querySelectorAll() {
            if (this.querySelectorAll)
                return this.querySelectorAll;
            if (!this.querySelector)
                throw new Error("Cannot create default `querySelectorAll`.");
            return this.querySelectorAll = qc(async function*(e, t, r) {
                const i = await PLACEHOLDER("querySelector")(e, t, r);
                i && (yield i)
            }, {
                querySelector: is(this.querySelector)
            })
        }
        static async*queryAll(e, t) {
            const r = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const s = iy(r, await e.evaluateHandle(this._querySelectorAll, t, Jr.create(i => i.puppeteerUtil)), !1);
                yield*iP(s)
            } catch (s) {
                r.error = s,
                r.hasError = !0
            } finally {
                ay(r)
            }
        }
        static async queryOne(e, t) {
            const r = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const s = iy(r, await e.evaluateHandle(this._querySelector, t, Jr.create(i => i.puppeteerUtil)), !1);
                return ny in s ? s.move() : null
            } catch (s) {
                r.error = s,
                r.hasError = !0
            } finally {
                ay(r)
            }
        }
        static async waitFor(e, t, r) {
            const s = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                let i;
                const a = iy(s, await (async () => {
                    if (!(ny in e)) {
                        i = e;
                        return
                    }
                    return i = e.frame,
                    await i.isolatedRealm().adoptHandle(e)
                }
                )(), !1)
                  , {visible: c=!1, hidden: u=!1, timeout: l, signal: d} = r
                  , h = c || u ? "raf" : r.polling;
                try {
                    const f = {
                        stack: [],
                        error: void 0,
                        hasError: !1
                    };
                    try {
                        d == null || d.throwIfAborted();
                        const p = iy(f, await i.isolatedRealm().waitForFunction(async (g, y, m, w, E) => {
                            const _ = await g.createFunction(y)(w ?? document, m, g);
                            return g.checkVisibility(_, E)
                        }
                        , {
                            polling: h,
                            root: a,
                            timeout: l,
                            signal: d
                        }, Jr.create(g => g.puppeteerUtil), is(this._querySelector), t, a, c ? !0 : u ? !1 : void 0), !1);
                        if (d != null && d.aborted)
                            throw d.reason;
                        return ny in p ? await i.mainRealm().transferHandle(p) : null
                    } catch (p) {
                        f.error = p,
                        f.hasError = !0
                    } finally {
                        ay(f)
                    }
                } catch (f) {
                    throw !hn(f) || f.name === "AbortError" || (f.message = `Waiting for selector \`${t}\` failed: ${f.message}`),
                    f
                }
            } catch (i) {
                s.error = i,
                s.hasError = !0
            } finally {
                ay(s)
            }
        }
    }
    J(Ds, "querySelectorAll"),
    J(Ds, "querySelector");
    class Uc {
        static async*map(e, t) {
            for await(const r of e)
                yield await t(r)
        }
        static async*flatMap(e, t) {
            for await(const r of e)
                yield*t(r)
        }
        static async collect(e) {
            const t = [];
            for await(const r of e)
                t.push(r);
            return t
        }
        static async first(e) {
            for await(const t of e)
                return t
        }
    }
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const jD = n => ["name", "role"].includes(n)
      , DD = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g
      , BD = n => {
        if (n.length > 1e4)
            throw new Error(`Selector ${n} is too long`);
        const e = {}
          , t = n.replace(DD, (r, s, i, a) => (ne(jD(s), `Unknown aria attribute "${s}" in selector`),
        e[s] = a,
        ""));
        return t && !e.name && (e.name = t),
        e
    }
      , dp = class dp extends Ds {
        static async*queryAll(e, t) {
            const {name: r, role: s} = BD(t);
            yield*e.queryAXTree(r, s)
        }
    }
    ;
    J(dp, "querySelector", async (e, t, {ariaQuerySelector: r}) => await r(e, t)),
    J(dp, "queryOne", async (e, t) => await Uc.first(dp.queryAll(e, t)) ?? null);
    let Za = dp;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class oy extends Ds {
    }
    J(oy, "querySelector", (e, t, {cssQuerySelector: r}) => r(e, t)),
    J(oy, "querySelectorAll", (e, t, {cssQuerySelectorAll: r}) => r(e, t));
    const qD = '"use strict";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},J=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of B(e))!Y.call(t,n)&&n!==r&&g(t,n,{get:()=>e[n],enumerable:!(o=X(e,n))||o.enumerable});return t};var z=t=>J(g({},"__esModule",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=z(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(n=>n instanceof t?(n.#n&&r.add(n),n.valueOrThrow()):n);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#n;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#n=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#n),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#s;valueOrThrow(){return this.#s||(this.#s=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#s}};var L=new Map,F=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var x={};l(x,{ariaQuerySelector:()=>G,ariaQuerySelectorAll:()=>b});var G=(t,e)=>globalThis.__ariaQuerySelector(t,e),b=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(n,i)=>{for(let s of o(n,i))return s;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(n,i)=>{let s=o(n,i);return s?[s]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&!r&&s.matches(e)&&(r=s)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&s.matches(e)&&r.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let n=await this.#e();if(!n){window.requestAnimationFrame(o);return}e.resolve(n),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return u(this.#r,"Polling never started."),this.#r.valueOrThrow()}},S=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set(["checkbox","image","radio"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),ne=new Set(["SCRIPT","STYLE"]),f=t=>!ne.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,j=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},W=new WeakSet,se=new MutationObserver(t=>{for(let e of t)j(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:"",immediate:[]},!f(t)))return e;let r="";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",o=>{j(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??"",r+=o.nodeValue??"";continue}r&&e.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),W.has(t)||(se.observe(t,{childList:!0,characterData:!0,subtree:!0}),W.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let n;o.shadowRoot?n=m(o.shadowRoot,e):n=m(o,e);for(let i of n)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var k={};l(k,{checkVisibility:()=>le,pierce:()=>T,pierceAll:()=>O});var ie=["hidden","collapse"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),n=o&&!ie.includes(o.visibility)&&!ae(r);return e===n?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*T(t){ce(t)?yield t.shadowRoot:yield t}function*O(t){t=T(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var Q={};l(Q,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let n=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=n.iterateNext())&&(i.push(s),!(r&&i.length===r)););for(let h=0;h<i.length;h++)s=i[h],yield s,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/u,H=(r=>(r.Descendent=">>>",r.Child=">>>>",r))(H||{}),V=t=>"querySelectorAll"in t,M=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o=="string")switch(this.#o.trimStart()){case":scope":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e=="string"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let n of r.parentElement.children)if(++o,n===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*m(r,e.value);break;case"xpath":yield*q(r,e.value);break;case"aria":yield*b(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case">>>>":{this.elements=a.flatMap(this.elements,T),this.#t();break}case">>>":{this.elements=a.flatMap(this.elements,O),this.#t();break}default:this.#r=e,this.#t();break}}},D=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let n=0;for(let s=e.previousSibling;s;s=s.previousSibling)++n;let i=this.calculate(e.parentNode,[n]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[n=-1,...i]=e;return r===n?U(o,i):r<n?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new D;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,n])=>U(o,n)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let n=0;return o.some(i=>(typeof i=="string"?++n:n=0,n>1))}))throw new Error("Multiple deep combinators found in sequence.");return de(a.flatMap(r,o=>{let n=new M(t,o);return n.run(),n.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...x,...A,...R,..._,...C,...k,...Q,...E,Deferred:c,createFunction:F,createTextContent:d,IntervalPoller:S,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n';
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class UD {
        constructor() {
            b(this, Eo);
            b(this, Zu, !1);
            b(this, Xu, new Set)
        }
        append(e) {
            P(this, Eo, Ex).call(this, () => {
                o(this, Xu).add(e)
            }
            )
        }
        pop(e) {
            P(this, Eo, Ex).call(this, () => {
                o(this, Xu).delete(e)
            }
            )
        }
        inject(e, t=!1) {
            (o(this, Zu) || t) && e(P(this, Eo, JN).call(this)),
            S(this, Zu, !1)
        }
    }
    Zu = new WeakMap,
    Xu = new WeakMap,
    Eo = new WeakSet,
    Ex = function(e) {
        e(),
        S(this, Zu, !0)
    }
    ,
    JN = function() {
        return `(() => {
      const module = {};
      ${qD}
      ${[...o(this, Xu)].map(e => `(${e})(module.exports.default);`).join("")}
      return module.exports.default;
    })()`
    }
    ;
    const Fd = new UD;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class KD {
        constructor() {
            b(this, Jn, new Map)
        }
        get(e) {
            const t = o(this, Jn).get(e);
            return t ? t[1] : void 0
        }
        register(e, t) {
            var i;
            ne(!o(this, Jn).has(e), `Cannot register over existing handler: ${e}`),
            ne(/^[a-zA-Z]+$/.test(e), "Custom query handler names may only contain [a-zA-Z]"),
            ne(t.queryAll || t.queryOne, "At least one query method must be implemented.");
            const r = (i = class extends Ds {
            }
            ,
            J(i, "querySelectorAll", qc( (a, c, u) => u.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(a, c), {
                name: JSON.stringify(e)
            })),
            J(i, "querySelector", qc( (a, c, u) => u.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(a, c), {
                name: JSON.stringify(e)
            })),
            i)
              , s = qc(a => {
                a.customQuerySelectors.register(PLACEHOLDER("name"), {
                    queryAll: PLACEHOLDER("queryAll"),
                    queryOne: PLACEHOLDER("queryOne")
                })
            }
            , {
                name: JSON.stringify(e),
                queryAll: t.queryAll ? is(t.queryAll) : String(void 0),
                queryOne: t.queryOne ? is(t.queryOne) : String(void 0)
            }).toString();
            o(this, Jn).set(e, [s, r]),
            Fd.append(s)
        }
        unregister(e) {
            const t = o(this, Jn).get(e);
            if (!t)
                throw new Error(`Cannot unregister unknown handler: ${e}`);
            Fd.pop(t[0]),
            o(this, Jn).delete(e)
        }
        names() {
            return [...o(this, Jn).keys()]
        }
        clear() {
            for (const [e] of o(this, Jn))
                Fd.pop(e);
            o(this, Jn).clear()
        }
    }
    Jn = new WeakMap;
    const Uv = new KD;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Kv extends Ds {
    }
    J(Kv, "querySelector", (e, t, {pierceQuerySelector: r}) => r(e, t)),
    J(Kv, "querySelectorAll", (e, t, {pierceQuerySelectorAll: r}) => r(e, t));
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Hv extends Ds {
    }
    J(Hv, "querySelectorAll", (e, t, {pQuerySelectorAll: r}) => r(e, t)),
    J(Hv, "querySelector", (e, t, {pQuerySelector: r}) => r(e, t));
    var Kc = {
        attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
        id: /#(?<name>[-\w\P{ASCII}]+)/gu,
        class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
        comma: /\s*,\s*/g,
        combinator: /\s*[\s>+~]\s*/g,
        "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
        "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
        universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
        type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
    }
      , HD = new Set(["combinator", "comma"])
      , WD = n => {
        switch (n) {
        case "pseudo-element":
        case "pseudo-class":
            return new RegExp(Kc[n].source.replace("(?<argument>*)", "(?<argument>.*)"),"gu");
        default:
            return Kc[n]
        }
    }
    ;
    function zD(n, e) {
        let t = 0
          , r = "";
        for (; e < n.length; e++) {
            const s = n[e];
            switch (s) {
            case "(":
                ++t;
                break;
            case ")":
                --t;
                break
            }
            if (r += s,
            t === 0)
                return r
        }
        return r
    }
    function VD(n, e=Kc) {
        if (!n)
            return [];
        const t = [n];
        for (const [s,i] of Object.entries(e))
            for (let a = 0; a < t.length; a++) {
                const c = t[a];
                if (typeof c != "string")
                    continue;
                i.lastIndex = 0;
                const u = i.exec(c);
                if (!u)
                    continue;
                const l = u.index - 1
                  , d = []
                  , h = u[0]
                  , f = c.slice(0, l + 1);
                f && d.push(f),
                d.push({
                    ...u.groups,
                    type: s,
                    content: h
                });
                const p = c.slice(l + h.length + 1);
                p && d.push(p),
                t.splice(a, 1, ...d)
            }
        let r = 0;
        for (const s of t)
            switch (typeof s) {
            case "string":
                throw new Error(`Unexpected sequence ${s} found at index ${r}`);
            case "object":
                r += s.content.length,
                s.pos = [r - s.content.length, r],
                HD.has(s.type) && (s.content = s.content.trim() || " ");
                break
            }
        return t
    }
    var GD = /(['"])([^\\\n]+?)\1/g
      , JD = /\\./g;
    function ZD(n, e=Kc) {
        if (n = n.trim(),
        n === "")
            return [];
        const t = [];
        n = n.replace(JD, (i, a) => (t.push({
            value: i,
            offset: a
        }),
        "".repeat(i.length))),
        n = n.replace(GD, (i, a, c, u) => (t.push({
            value: i,
            offset: u
        }),
        `${a}${"".repeat(c.length)}${a}`));
        {
            let i = 0, a;
            for (; (a = n.indexOf("(", i)) > -1; ) {
                const c = zD(n, a);
                t.push({
                    value: c,
                    offset: a
                }),
                n = `${n.substring(0, a)}(${"".repeat(c.length - 2)})${n.substring(a + c.length)}`,
                i = a + c.length
            }
        }
        const r = VD(n, e)
          , s = new Set;
        for (const i of t.reverse())
            for (const a of r) {
                const {offset: c, value: u} = i;
                if (!(a.pos[0] <= c && c + u.length <= a.pos[1]))
                    continue;
                const {content: l} = a
                  , d = c - a.pos[0];
                a.content = l.slice(0, d) + u + l.slice(d + u.length),
                a.content !== l && s.add(a)
            }
        for (const i of s) {
            const a = WD(i.type);
            if (!a)
                throw new Error(`Unknown token type: ${i.type}`);
            a.lastIndex = 0;
            const c = a.exec(i.content);
            if (!c)
                throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);
            Object.assign(i, c.groups)
        }
        return r
    }
    function as(n) {
        if (Array.isArray(n))
            return n.map(e => e.content).join("");
        switch (n.type) {
        case "list":
            return n.list.map(as).join(",");
        case "relative":
            return n.combinator + as(n.right);
        case "complex":
            return as(n.left) + n.combinator + as(n.right);
        case "compound":
            return n.list.map(as).join("");
        default:
            return n.content
        }
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    Kc.nesting = /&/g,
    Kc.combinator = /\s*(>>>>?|[\s>+~])\s*/g;
    const XD = /\\[\s\S]/g
      , YD = n => n.length <= 1 ? n : ((n[0] === '"' || n[0] === "'") && n.endsWith(n[0]) && (n = n.slice(1, -1)),
    n.replace(XD, e => e[1]));
    function QD(n) {
        let e = !0
          , t = !1
          , r = !1;
        const s = ZD(n);
        if (s.length === 0)
            return [[], e, r, !1];
        let i = []
          , a = [i];
        const c = [a]
          , u = [];
        for (const l of s) {
            switch (l.type) {
            case "combinator":
                switch (l.content) {
                case ">>>":
                    e = !1,
                    u.length && (i.push(as(u)),
                    u.splice(0)),
                    i = [],
                    a.push(">>>"),
                    a.push(i);
                    continue;
                case ">>>>":
                    e = !1,
                    u.length && (i.push(as(u)),
                    u.splice(0)),
                    i = [],
                    a.push(">>>>"),
                    a.push(i);
                    continue
                }
                break;
            case "pseudo-element":
                if (!l.name.startsWith("-p-"))
                    break;
                e = !1,
                u.length && (i.push(as(u)),
                u.splice(0));
                const d = l.name.slice(3);
                d === "aria" && (t = !0),
                i.push({
                    name: d,
                    value: YD(l.argument ?? "")
                });
                continue;
            case "pseudo-class":
                r = !0;
                break;
            case "comma":
                u.length && (i.push(as(u)),
                u.splice(0)),
                i = [],
                a = [i],
                c.push(a);
                continue
            }
            u.push(l)
        }
        return u.length && i.push(as(u)),
        [c, e, r, t]
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class aP extends Ds {
    }
    J(aP, "querySelectorAll", (e, t, {textQuerySelectorAll: r}) => r(e, t));
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Wv extends Ds {
    }
    J(Wv, "querySelectorAll", (e, t, {xpathQuerySelectorAll: r}) => r(e, t)),
    J(Wv, "querySelector", (e, t, {xpathQuerySelectorAll: r}) => {
        for (const s of r(e, t, 1))
            return s;
        return null
    }
    );
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const eB = {
        aria: Za,
        pierce: Kv,
        xpath: Wv,
        text: aP
    }
      , tB = ["=", "/"];
    function cy(n) {
        for (const e of [Uv.names().map(t => [t, Uv.get(t)]), Object.entries(eB)])
            for (const [t,r] of e)
                for (const s of tB) {
                    const i = `${t}${s}`;
                    if (n.startsWith(i))
                        return n = n.slice(i.length),
                        {
                            updatedSelector: n,
                            polling: t === "aria" ? "raf" : "mutation",
                            QueryHandler: r
                        }
                }
        try {
            const [e,t,r,s] = QD(n);
            return t ? {
                updatedSelector: n,
                polling: r ? "raf" : "mutation",
                QueryHandler: oy
            } : {
                updatedSelector: JSON.stringify(e),
                polling: s ? "raf" : "mutation",
                QueryHandler: Hv
            }
        } catch {
            return {
                updatedSelector: n,
                polling: "mutation",
                QueryHandler: oy
            }
        }
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var rB = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , nB = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    const jd = new WeakSet;
    function sB(n, e) {
        let t = !1;
        if (n.prototype[Ce]) {
            const r = n.prototype[Ce];
            n.prototype[Ce] = function() {
                if (jd.has(this)) {
                    jd.delete(this);
                    return
                }
                return r.call(this)
            }
            ,
            t = !0
        }
        if (n.prototype[En]) {
            const r = n.prototype[En];
            n.prototype[En] = function() {
                if (jd.has(this)) {
                    jd.delete(this);
                    return
                }
                return r.call(this)
            }
            ,
            t = !0
        }
        return t && (n.prototype.move = function() {
            return jd.add(this),
            this
        }
        ),
        n
    }
    function oe(n=e => `Attempted to use disposed ${e.constructor.name}.`) {
        return (e, t) => function(...r) {
            if (this.disposed)
                throw new Error(n(this));
            return e.call(this, ...r)
        }
    }
    function Ti(n, e) {
        return function(...t) {
            if (!this.disposed)
                return n.call(this, ...t)
        }
    }
    function Cn(n, e) {
        const t = new WeakMap;
        let r = -1;
        return function(...s) {
            if (r === -1 && (r = s.length),
            r !== s.length)
                throw new Error("Memoized method was called with the wrong number of arguments");
            let i = !1
              , a = t;
            for (const c of s)
                a.has(c) || (i = !0,
                a.set(c, new WeakMap)),
                a = a.get(c);
            if (i)
                return n.call(this, ...s)
        }
    }
    function iB(n=function() {
        return this
    }
    ) {
        return (e, t) => {
            const r = new WeakMap;
            return async function(...s) {
                const i = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const a = n.call(this);
                    let c = r.get(a);
                    c || (c = new Bv,
                    r.set(a, c));
                    const u = rB(i, await c.acquire(), !0);
                    return await e.call(this, ...s)
                } catch (a) {
                    i.error = a,
                    i.hasError = !0
                } finally {
                    const a = nB(i);
                    a && await a
                }
            }
        }
    }
    const uy = new WeakMap
      , oP = function(n) {
        const e = uy.get(this) ?? new Map;
        if (e.has(n))
            return;
        const t = n !== void 0 ? (r, s) => {
            n.includes(r) && this.emit(r, s)
        }
        : (r, s) => {
            this.emit(r, s)
        }
        ;
        e.set(n, t),
        uy.set(this, e)
    };
    function ly(n) {
        return ({set: e, get: t}, r) => (r.addInitializer(function() {
            return oP.apply(this, [n])
        }),
        {
            set(s) {
                const i = uy.get(this).get(n)
                  , a = t.call(this);
                a !== void 0 && a.off("*", i),
                s !== void 0 && (s.on("*", i),
                e.call(this, s))
            },
            init(s) {
                if (s === void 0)
                    return s;
                oP.apply(this, [n]);
                const i = uy.get(this).get(n);
                return s.on("*", i),
                s
            }
        })
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var cP = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , zv = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , aB = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , oB = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    let Xa = ( () => {
        var c;
        let n = [sB], e, t = [], r, s = [], i, a;
        return c = class {
            constructor() {
                cP(this, s)
            }
            async evaluate(l, ...d) {
                return l = Wt(this.evaluate.name, l),
                await this.realm.evaluate(l, this, ...d)
            }
            async evaluateHandle(l, ...d) {
                return l = Wt(this.evaluateHandle.name, l),
                await this.realm.evaluateHandle(l, this, ...d)
            }
            async getProperty(l) {
                return await this.evaluateHandle( (d, h) => d[h], l)
            }
            async getProperties() {
                const l = await this.evaluate(f => {
                    var y;
                    const p = []
                      , g = Object.getOwnPropertyDescriptors(f);
                    for (const m in g)
                        (y = g[m]) != null && y.enumerable && p.push(m);
                    return p
                }
                )
                  , d = new Map
                  , h = await Promise.all(l.map(f => this.getProperty(f)));
                for (const [f,p] of Object.entries(l)) {
                    const g = {
                        stack: [],
                        error: void 0,
                        hasError: !1
                    };
                    try {
                        const y = aB(g, h[f], !1);
                        y && d.set(p, y.move())
                    } catch (y) {
                        g.error = y,
                        g.hasError = !0
                    } finally {
                        oB(g)
                    }
                }
                return d
            }
            [(i = [oe()],
            a = [oe()],
            Ce)]() {
                return void this.dispose().catch(ge)
            }
            [En]() {
                return this.dispose()
            }
        }
        ,
        r = c,
        ( () => {
            const l = typeof Symbol == "function" && Symbol.metadata ? Object.create(null) : void 0;
            zv(c, null, i, {
                kind: "method",
                name: "getProperty",
                static: !1,
                private: !1,
                access: {
                    has: d => "getProperty"in d,
                    get: d => d.getProperty
                },
                metadata: l
            }, null, s),
            zv(c, null, a, {
                kind: "method",
                name: "getProperties",
                static: !1,
                private: !1,
                access: {
                    has: d => "getProperties"in d,
                    get: d => d.getProperties
                },
                metadata: l
            }, null, s),
            zv(null, e = {
                value: r
            }, n, {
                kind: "class",
                name: r.name,
                metadata: l
            }, null, t),
            r = e.value,
            l && Object.defineProperty(r, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: l
            }),
            cP(r, t)
        }
        )(),
        r
    }
    )();
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var cB = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , rt = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , Dd = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , Bd = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    )
      , uB = function(n, e, t) {
        return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
        Object.defineProperty(n, "name", {
            configurable: !0,
            value: t ? "".concat(t, " ", e) : e
        })
    };
    function Xe(n, e) {
        return async function(...t) {
            if (this.realm === this.frame.isolatedRealm())
                return await n.call(this, ...t);
            let r;
            this.isolatedHandle ? r = this.isolatedHandle : this.isolatedHandle = r = await this.frame.isolatedRealm().adoptHandle(this);
            const s = await n.call(r, ...t);
            return s === r ? this : s instanceof Xa ? await this.realm.transferHandle(s) : (Array.isArray(s) && await Promise.all(s.map(async (i, a, c) => {
                i instanceof Xa && (c[a] = await this.realm.transferHandle(i))
            }
            )),
            s instanceof Map && await Promise.all([...s.entries()].map(async ([i,a]) => {
                a instanceof Xa && s.set(i, await this.realm.transferHandle(a))
            }
            )),
            s)
        }
    }
    let uP = ( () => {
        var $, xx, Cx, kx, ZN, Px, Tx, XN, YN, QN, ue;
        let n = Xa, e = [], t, r, s, i, a, c, u, l, d, h, f, p, g, y, m, w, E, v, _, A, C, k, x, N, R, F, O, T, L, q, Z, j;
        return ue = class extends n {
            constructor(I) {
                super();
                b(this, $);
                J(this, "isolatedHandle", cB(this, e));
                J(this, "handle");
                this.handle = I,
                this[ny] = !0
            }
            get id() {
                return this.handle.id
            }
            get disposed() {
                return this.handle.disposed
            }
            async getProperty(I) {
                return await this.handle.getProperty(I)
            }
            async getProperties() {
                return await this.handle.getProperties()
            }
            async evaluate(I, ...M) {
                return I = Wt(this.evaluate.name, I),
                await this.handle.evaluate(I, ...M)
            }
            async evaluateHandle(I, ...M) {
                return I = Wt(this.evaluateHandle.name, I),
                await this.handle.evaluateHandle(I, ...M)
            }
            async jsonValue() {
                return await this.handle.jsonValue()
            }
            toString() {
                return this.handle.toString()
            }
            remoteObject() {
                return this.handle.remoteObject()
            }
            async dispose() {
                var I;
                await Promise.all([this.handle.dispose(), (I = this.isolatedHandle) == null ? void 0 : I.dispose()])
            }
            asElement() {
                return this
            }
            async $(I) {
                const {updatedSelector: M, QueryHandler: U} = cy(I);
                return await U.queryOne(this, M)
            }
            async $$(I, M) {
                return (M == null ? void 0 : M.isolate) === !1 ? await P(this, $, Cx).call(this, I) : await o(this, $, xx).call(this, I)
            }
            async $eval(I, M, ...U) {
                const W = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    M = Wt(this.$eval.name, M);
                    const X = Dd(W, await this.$(I), !1);
                    if (!X)
                        throw new Error(`Error: failed to find element matching selector "${I}"`);
                    return await X.evaluate(M, ...U)
                } catch (X) {
                    W.error = X,
                    W.hasError = !0
                } finally {
                    Bd(W)
                }
            }
            async $$eval(I, M, ...U) {
                const W = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    M = Wt(this.$$eval.name, M);
                    const X = await this.$$(I)
                      , te = Dd(W, await this.evaluateHandle( (xe, ...ce) => ce, ...X), !1)
                      , [ae] = await Promise.all([te.evaluate(M, ...U), ...X.map(xe => xe.dispose())]);
                    return ae
                } catch (X) {
                    W.error = X,
                    W.hasError = !0
                } finally {
                    Bd(W)
                }
            }
            async waitForSelector(I, M={}) {
                const {updatedSelector: U, QueryHandler: W, polling: X} = cy(I);
                return await W.waitFor(this, U, {
                    polling: X,
                    ...M
                })
            }
            async isVisible() {
                return await P(this, $, kx).call(this, !0)
            }
            async isHidden() {
                return await P(this, $, kx).call(this, !1)
            }
            async toElement(I) {
                if (!await this.evaluate( (U, W) => U.nodeName === W.toUpperCase(), I))
                    throw new Error(`Element is not a(n) \`${I}\` element`);
                return this
            }
            async clickablePoint(I) {
                const M = await P(this, $, ZN).call(this);
                if (!M)
                    throw new Error("Node is either not clickable or not an Element");
                return I !== void 0 ? {
                    x: M.x + I.x,
                    y: M.y + I.y
                } : {
                    x: M.x + M.width / 2,
                    y: M.y + M.height / 2
                }
            }
            async hover() {
                await this.scrollIntoViewIfNeeded();
                const {x: I, y: M} = await this.clickablePoint();
                await this.frame.page().mouse.move(I, M)
            }
            async click(I={}) {
                await this.scrollIntoViewIfNeeded();
                const {x: M, y: U} = await this.clickablePoint(I.offset);
                await this.frame.page().mouse.click(M, U, I)
            }
            async drag(I) {
                await this.scrollIntoViewIfNeeded();
                const M = this.frame.page();
                if (M.isDragInterceptionEnabled()) {
                    const U = await this.clickablePoint();
                    return I instanceof ue && (I = await I.clickablePoint()),
                    await M.mouse.drag(U, I)
                }
                try {
                    M._isDragging || (M._isDragging = !0,
                    await this.hover(),
                    await M.mouse.down()),
                    I instanceof ue ? await I.hover() : await M.mouse.move(I.x, I.y)
                } catch (U) {
                    throw M._isDragging = !1,
                    U
                }
            }
            async dragEnter(I={
                items: [],
                dragOperationsMask: 1
            }) {
                const M = this.frame.page();
                await this.scrollIntoViewIfNeeded();
                const U = await this.clickablePoint();
                await M.mouse.dragEnter(U, I)
            }
            async dragOver(I={
                items: [],
                dragOperationsMask: 1
            }) {
                const M = this.frame.page();
                await this.scrollIntoViewIfNeeded();
                const U = await this.clickablePoint();
                await M.mouse.dragOver(U, I)
            }
            async drop(I={
                items: [],
                dragOperationsMask: 1
            }) {
                const M = this.frame.page();
                if ("items"in I) {
                    await this.scrollIntoViewIfNeeded();
                    const U = await this.clickablePoint();
                    await M.mouse.drop(U, I)
                } else
                    await I.drag(this),
                    M._isDragging = !1,
                    await M.mouse.up()
            }
            async dragAndDrop(I, M) {
                const U = this.frame.page();
                ne(U.isDragInterceptionEnabled(), "Drag Interception is not enabled!"),
                await this.scrollIntoViewIfNeeded();
                const W = await this.clickablePoint()
                  , X = await I.clickablePoint();
                await U.mouse.dragAndDrop(W, X, M)
            }
            async select(...I) {
                for (const M of I)
                    ne(js(M), 'Values must be strings. Found value "' + M + '" of type "' + typeof M + '"');
                return await this.evaluate( (M, U) => {
                    const W = new Set(U);
                    if (!(M instanceof HTMLSelectElement))
                        throw new Error("Element is not a <select> element.");
                    const X = new Set;
                    if (M.multiple)
                        for (const te of M.options)
                            te.selected = W.has(te.value),
                            te.selected && X.add(te.value);
                    else {
                        for (const te of M.options)
                            te.selected = !1;
                        for (const te of M.options)
                            if (W.has(te.value)) {
                                te.selected = !0,
                                X.add(te.value);
                                break
                            }
                    }
                    return M.dispatchEvent(new Event("input",{
                        bubbles: !0
                    })),
                    M.dispatchEvent(new Event("change",{
                        bubbles: !0
                    })),
                    [...X.values()]
                }
                , I)
            }
            async tap() {
                await this.scrollIntoViewIfNeeded();
                const {x: I, y: M} = await this.clickablePoint();
                await this.frame.page().touchscreen.tap(I, M)
            }
            async touchStart() {
                await this.scrollIntoViewIfNeeded();
                const {x: I, y: M} = await this.clickablePoint();
                return await this.frame.page().touchscreen.touchStart(I, M)
            }
            async touchMove(I) {
                await this.scrollIntoViewIfNeeded();
                const {x: M, y: U} = await this.clickablePoint();
                if (I)
                    return await I.move(M, U);
                await this.frame.page().touchscreen.touchMove(M, U)
            }
            async touchEnd() {
                await this.scrollIntoViewIfNeeded(),
                await this.frame.page().touchscreen.touchEnd()
            }
            async focus() {
                await this.evaluate(I => {
                    if (!(I instanceof HTMLElement))
                        throw new Error("Cannot focus non-HTMLElement");
                    return I.focus()
                }
                )
            }
            async type(I, M) {
                await this.focus(),
                await this.frame.page().keyboard.type(I, M)
            }
            async press(I, M) {
                await this.focus(),
                await this.frame.page().keyboard.press(I, M)
            }
            async boundingBox() {
                const I = await this.evaluate(U => {
                    if (!(U instanceof Element) || U.getClientRects().length === 0)
                        return null;
                    const W = U.getBoundingClientRect();
                    return {
                        x: W.x,
                        y: W.y,
                        width: W.width,
                        height: W.height
                    }
                }
                );
                if (!I)
                    return null;
                const M = await P(this, $, Tx).call(this);
                return M ? {
                    x: I.x + M.x,
                    y: I.y + M.y,
                    height: I.height,
                    width: I.width
                } : null
            }
            async boxModel() {
                const I = await this.evaluate(U => {
                    if (!(U instanceof Element) || U.getClientRects().length === 0)
                        return null;
                    const W = U.getBoundingClientRect()
                      , X = window.getComputedStyle(U)
                      , te = {
                        padding: {
                            left: parseInt(X.paddingLeft, 10),
                            top: parseInt(X.paddingTop, 10),
                            right: parseInt(X.paddingRight, 10),
                            bottom: parseInt(X.paddingBottom, 10)
                        },
                        margin: {
                            left: -parseInt(X.marginLeft, 10),
                            top: -parseInt(X.marginTop, 10),
                            right: -parseInt(X.marginRight, 10),
                            bottom: -parseInt(X.marginBottom, 10)
                        },
                        border: {
                            left: parseInt(X.borderLeft, 10),
                            top: parseInt(X.borderTop, 10),
                            right: parseInt(X.borderRight, 10),
                            bottom: parseInt(X.borderBottom, 10)
                        }
                    }
                      , ae = [{
                        x: W.left,
                        y: W.top
                    }, {
                        x: W.left + W.width,
                        y: W.top
                    }, {
                        x: W.left + W.width,
                        y: W.top + W.height
                    }, {
                        x: W.left,
                        y: W.top + W.height
                    }]
                      , xe = we(ae, te.border)
                      , ce = we(xe, te.padding)
                      , Pe = we(ae, te.margin);
                    return {
                        content: ce,
                        padding: xe,
                        border: ae,
                        margin: Pe,
                        width: W.width,
                        height: W.height
                    };
                    function we(H, Q) {
                        return [{
                            x: H[0].x + Q.left,
                            y: H[0].y + Q.top
                        }, {
                            x: H[1].x - Q.right,
                            y: H[1].y + Q.top
                        }, {
                            x: H[2].x - Q.right,
                            y: H[2].y - Q.bottom
                        }, {
                            x: H[3].x + Q.left,
                            y: H[3].y - Q.bottom
                        }]
                    }
                }
                );
                if (!I)
                    return null;
                const M = await P(this, $, Tx).call(this);
                if (!M)
                    return null;
                for (const U of ["content", "padding", "border", "margin"])
                    for (const W of I[U])
                        W.x += M.x,
                        W.y += M.y;
                return I
            }
            async screenshot(I={}) {
                const {scrollIntoView: M=!0, clip: U} = I
                  , W = this.frame.page();
                M && await this.scrollIntoViewIfNeeded();
                const X = await P(this, $, XN).call(this)
                  , [te,ae] = await this.evaluate( () => {
                    if (!window.visualViewport)
                        throw new Error("window.visualViewport is not supported.");
                    return [window.visualViewport.pageLeft, window.visualViewport.pageTop]
                }
                );
                return X.x += te,
                X.y += ae,
                U && (X.x += U.x,
                X.y += U.y,
                X.height = U.height,
                X.width = U.width),
                await W.screenshot({
                    ...I,
                    clip: X
                })
            }
            async assertConnectedElement() {
                const I = await this.evaluate(async M => {
                    if (!M.isConnected)
                        return "Node is detached from document";
                    if (M.nodeType !== Node.ELEMENT_NODE)
                        return "Node is not of type HTMLElement"
                }
                );
                if (I)
                    throw new Error(I)
            }
            async scrollIntoViewIfNeeded() {
                await this.isIntersectingViewport({
                    threshold: 1
                }) || await this.scrollIntoView()
            }
            async isIntersectingViewport(I={}) {
                var U;
                const M = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    await this.assertConnectedElement();
                    const W = await P(this, $, YN).call(this);
                    return await (Dd(M, W && await P(U = W, $, QN).call(U), !1) ?? this).evaluate(async (te, ae) => {
                        const xe = await new Promise(ce => {
                            const Pe = new IntersectionObserver(we => {
                                ce(we[0].intersectionRatio),
                                Pe.disconnect()
                            }
                            );
                            Pe.observe(te)
                        }
                        );
                        return ae === 1 ? xe === 1 : xe > ae
                    }
                    , I.threshold ?? 0)
                } catch (W) {
                    M.error = W,
                    M.hasError = !0
                } finally {
                    Bd(M)
                }
            }
            async scrollIntoView() {
                await this.assertConnectedElement(),
                await this.evaluate(async I => {
                    I.scrollIntoView({
                        block: "center",
                        inline: "center",
                        behavior: "instant"
                    })
                }
                )
            }
        }
        ,
        $ = new WeakSet,
        xx = function() {
            return u.value
        }
        ,
        Cx = async function(I) {
            const {updatedSelector: M, QueryHandler: U} = cy(I);
            return await Uc.collect(U.queryAll(this, M))
        }
        ,
        kx = async function(I) {
            return await this.evaluate(async (M, U, W) => !!U.checkVisibility(M, W), Jr.create(M => M.puppeteerUtil), I)
        }
        ,
        ZN = async function() {
            var X;
            const I = await this.evaluate(te => te instanceof Element ? [...te.getClientRects()].map(ae => ({
                x: ae.x,
                y: ae.y,
                width: ae.width,
                height: ae.height
            })) : null);
            if (!(I != null && I.length))
                return null;
            await P(this, $, Px).call(this, I);
            let M = this.frame, U;
            for (; U = M == null ? void 0 : M.parentFrame(); ) {
                const te = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const ae = Dd(te, await M.frameElement(), !1);
                    if (!ae)
                        throw new Error("Unsupported frame type");
                    const xe = await ae.evaluate(ce => {
                        if (ce.getClientRects().length === 0)
                            return null;
                        const Pe = ce.getBoundingClientRect()
                          , we = window.getComputedStyle(ce);
                        return {
                            left: Pe.left + parseInt(we.paddingLeft, 10) + parseInt(we.borderLeftWidth, 10),
                            top: Pe.top + parseInt(we.paddingTop, 10) + parseInt(we.borderTopWidth, 10)
                        }
                    }
                    );
                    if (!xe)
                        return null;
                    for (const ce of I)
                        ce.x += xe.left,
                        ce.y += xe.top;
                    await P(X = ae, $, Px).call(X, I),
                    M = U
                } catch (ae) {
                    te.error = ae,
                    te.hasError = !0
                } finally {
                    Bd(te)
                }
            }
            const W = I.find(te => te.width >= 1 && te.height >= 1);
            return W ? {
                x: W.x,
                y: W.y,
                height: W.height,
                width: W.width
            } : null
        }
        ,
        Px = async function(I) {
            const {documentWidth: M, documentHeight: U} = await this.frame.isolatedRealm().evaluate( () => ({
                documentWidth: document.documentElement.clientWidth,
                documentHeight: document.documentElement.clientHeight
            }));
            for (const W of I)
                lB(W, M, U)
        }
        ,
        Tx = async function() {
            const I = {
                x: 0,
                y: 0
            };
            let M = this.frame, U;
            for (; U = M == null ? void 0 : M.parentFrame(); ) {
                const W = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const X = Dd(W, await M.frameElement(), !1);
                    if (!X)
                        throw new Error("Unsupported frame type");
                    const te = await X.evaluate(ae => {
                        if (ae.getClientRects().length === 0)
                            return null;
                        const xe = ae.getBoundingClientRect()
                          , ce = window.getComputedStyle(ae);
                        return {
                            left: xe.left + parseInt(ce.paddingLeft, 10) + parseInt(ce.borderLeftWidth, 10),
                            top: xe.top + parseInt(ce.paddingTop, 10) + parseInt(ce.borderTopWidth, 10)
                        }
                    }
                    );
                    if (!te)
                        return null;
                    I.x += te.left,
                    I.y += te.top,
                    M = U
                } catch (X) {
                    W.error = X,
                    W.hasError = !0
                } finally {
                    Bd(W)
                }
            }
            return I
        }
        ,
        XN = async function() {
            const I = await this.boundingBox();
            return ne(I, "Node is either not visible or not an HTMLElement"),
            ne(I.width !== 0, "Node has 0 width."),
            ne(I.height !== 0, "Node has 0 height."),
            I
        }
        ,
        YN = async function() {
            return await this.evaluate(I => I instanceof SVGElement) ? this : null
        }
        ,
        QN = async function() {
            return await this.evaluateHandle(I => I instanceof SVGSVGElement ? I : I.ownerSVGElement)
        }
        ,
        ( () => {
            const I = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            t = [oe(), Xe],
            r = [oe(), Xe],
            s = [oe(), Xe],
            i = [oe(), Xe],
            a = [oe()],
            c = [Xe],
            l = [oe(), Xe],
            d = [oe(), Xe],
            h = [oe(), Xe],
            f = [oe(), Xe],
            p = [oe(), Xe],
            g = [oe(), Xe],
            y = [oe(), Xe],
            m = [oe(), Xe],
            w = [oe(), Xe],
            E = [oe(), Xe],
            v = [oe(), Xe],
            _ = [oe(), Xe],
            A = [oe(), Xe],
            C = [oe(), Xe],
            k = [oe(), Xe],
            x = [oe(), Xe],
            N = [oe(), Xe],
            R = [oe(), Xe],
            F = [oe(), Xe],
            O = [oe(), Xe],
            T = [oe(), Xe],
            L = [oe(), Xe],
            q = [oe(), Xe],
            Z = [oe(), Xe],
            j = [oe(), Xe],
            rt(ue, null, t, {
                kind: "method",
                name: "getProperty",
                static: !1,
                private: !1,
                access: {
                    has: M => "getProperty"in M,
                    get: M => M.getProperty
                },
                metadata: I
            }, null, e),
            rt(ue, null, r, {
                kind: "method",
                name: "getProperties",
                static: !1,
                private: !1,
                access: {
                    has: M => "getProperties"in M,
                    get: M => M.getProperties
                },
                metadata: I
            }, null, e),
            rt(ue, null, s, {
                kind: "method",
                name: "jsonValue",
                static: !1,
                private: !1,
                access: {
                    has: M => "jsonValue"in M,
                    get: M => M.jsonValue
                },
                metadata: I
            }, null, e),
            rt(ue, null, i, {
                kind: "method",
                name: "$",
                static: !1,
                private: !1,
                access: {
                    has: M => "$"in M,
                    get: M => M.$
                },
                metadata: I
            }, null, e),
            rt(ue, null, a, {
                kind: "method",
                name: "$$",
                static: !1,
                private: !1,
                access: {
                    has: M => "$$"in M,
                    get: M => M.$$
                },
                metadata: I
            }, null, e),
            rt(ue, u = {
                value: uB(async function(M) {
                    return await P(this, $, Cx).call(this, M)
                }, "#$$")
            }, c, {
                kind: "method",
                name: "#$$",
                static: !1,
                private: !0,
                access: {
                    has: M => Ir($, M),
                    get: M => o(M, $, xx)
                },
                metadata: I
            }, null, e),
            rt(ue, null, l, {
                kind: "method",
                name: "waitForSelector",
                static: !1,
                private: !1,
                access: {
                    has: M => "waitForSelector"in M,
                    get: M => M.waitForSelector
                },
                metadata: I
            }, null, e),
            rt(ue, null, d, {
                kind: "method",
                name: "isVisible",
                static: !1,
                private: !1,
                access: {
                    has: M => "isVisible"in M,
                    get: M => M.isVisible
                },
                metadata: I
            }, null, e),
            rt(ue, null, h, {
                kind: "method",
                name: "isHidden",
                static: !1,
                private: !1,
                access: {
                    has: M => "isHidden"in M,
                    get: M => M.isHidden
                },
                metadata: I
            }, null, e),
            rt(ue, null, f, {
                kind: "method",
                name: "toElement",
                static: !1,
                private: !1,
                access: {
                    has: M => "toElement"in M,
                    get: M => M.toElement
                },
                metadata: I
            }, null, e),
            rt(ue, null, p, {
                kind: "method",
                name: "clickablePoint",
                static: !1,
                private: !1,
                access: {
                    has: M => "clickablePoint"in M,
                    get: M => M.clickablePoint
                },
                metadata: I
            }, null, e),
            rt(ue, null, g, {
                kind: "method",
                name: "hover",
                static: !1,
                private: !1,
                access: {
                    has: M => "hover"in M,
                    get: M => M.hover
                },
                metadata: I
            }, null, e),
            rt(ue, null, y, {
                kind: "method",
                name: "click",
                static: !1,
                private: !1,
                access: {
                    has: M => "click"in M,
                    get: M => M.click
                },
                metadata: I
            }, null, e),
            rt(ue, null, m, {
                kind: "method",
                name: "drag",
                static: !1,
                private: !1,
                access: {
                    has: M => "drag"in M,
                    get: M => M.drag
                },
                metadata: I
            }, null, e),
            rt(ue, null, w, {
                kind: "method",
                name: "dragEnter",
                static: !1,
                private: !1,
                access: {
                    has: M => "dragEnter"in M,
                    get: M => M.dragEnter
                },
                metadata: I
            }, null, e),
            rt(ue, null, E, {
                kind: "method",
                name: "dragOver",
                static: !1,
                private: !1,
                access: {
                    has: M => "dragOver"in M,
                    get: M => M.dragOver
                },
                metadata: I
            }, null, e),
            rt(ue, null, v, {
                kind: "method",
                name: "drop",
                static: !1,
                private: !1,
                access: {
                    has: M => "drop"in M,
                    get: M => M.drop
                },
                metadata: I
            }, null, e),
            rt(ue, null, _, {
                kind: "method",
                name: "dragAndDrop",
                static: !1,
                private: !1,
                access: {
                    has: M => "dragAndDrop"in M,
                    get: M => M.dragAndDrop
                },
                metadata: I
            }, null, e),
            rt(ue, null, A, {
                kind: "method",
                name: "select",
                static: !1,
                private: !1,
                access: {
                    has: M => "select"in M,
                    get: M => M.select
                },
                metadata: I
            }, null, e),
            rt(ue, null, C, {
                kind: "method",
                name: "tap",
                static: !1,
                private: !1,
                access: {
                    has: M => "tap"in M,
                    get: M => M.tap
                },
                metadata: I
            }, null, e),
            rt(ue, null, k, {
                kind: "method",
                name: "touchStart",
                static: !1,
                private: !1,
                access: {
                    has: M => "touchStart"in M,
                    get: M => M.touchStart
                },
                metadata: I
            }, null, e),
            rt(ue, null, x, {
                kind: "method",
                name: "touchMove",
                static: !1,
                private: !1,
                access: {
                    has: M => "touchMove"in M,
                    get: M => M.touchMove
                },
                metadata: I
            }, null, e),
            rt(ue, null, N, {
                kind: "method",
                name: "touchEnd",
                static: !1,
                private: !1,
                access: {
                    has: M => "touchEnd"in M,
                    get: M => M.touchEnd
                },
                metadata: I
            }, null, e),
            rt(ue, null, R, {
                kind: "method",
                name: "focus",
                static: !1,
                private: !1,
                access: {
                    has: M => "focus"in M,
                    get: M => M.focus
                },
                metadata: I
            }, null, e),
            rt(ue, null, F, {
                kind: "method",
                name: "type",
                static: !1,
                private: !1,
                access: {
                    has: M => "type"in M,
                    get: M => M.type
                },
                metadata: I
            }, null, e),
            rt(ue, null, O, {
                kind: "method",
                name: "press",
                static: !1,
                private: !1,
                access: {
                    has: M => "press"in M,
                    get: M => M.press
                },
                metadata: I
            }, null, e),
            rt(ue, null, T, {
                kind: "method",
                name: "boundingBox",
                static: !1,
                private: !1,
                access: {
                    has: M => "boundingBox"in M,
                    get: M => M.boundingBox
                },
                metadata: I
            }, null, e),
            rt(ue, null, L, {
                kind: "method",
                name: "boxModel",
                static: !1,
                private: !1,
                access: {
                    has: M => "boxModel"in M,
                    get: M => M.boxModel
                },
                metadata: I
            }, null, e),
            rt(ue, null, q, {
                kind: "method",
                name: "screenshot",
                static: !1,
                private: !1,
                access: {
                    has: M => "screenshot"in M,
                    get: M => M.screenshot
                },
                metadata: I
            }, null, e),
            rt(ue, null, Z, {
                kind: "method",
                name: "isIntersectingViewport",
                static: !1,
                private: !1,
                access: {
                    has: M => "isIntersectingViewport"in M,
                    get: M => M.isIntersectingViewport
                },
                metadata: I
            }, null, e),
            rt(ue, null, j, {
                kind: "method",
                name: "scrollIntoView",
                static: !1,
                private: !1,
                access: {
                    has: M => "scrollIntoView"in M,
                    get: M => M.scrollIntoView
                },
                metadata: I
            }, null, e),
            I && Object.defineProperty(ue, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: I
            })
        }
        )(),
        ue
    }
    )();
    function lB(n, e, t) {
        n.width = Math.max(n.x >= 0 ? Math.min(e - n.x, n.width) : Math.min(e, n.width + n.x), 0),
        n.height = Math.max(n.y >= 0 ? Math.min(t - n.y, n.height) : Math.min(t, n.height + n.y), 0)
    }
    var dB = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }, hB = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    ), Hc;
    (function(n) {
        n.Action = "action"
    }
    )(Hc || (Hc = {}));
    class Wc extends be {
        constructor() {
            super(...arguments);
            b(this, Ss);
            J(this, "visibility", null);
            J(this, "_timeout", 3e4);
            b(this, xo, !0);
            b(this, Co, !0);
            b(this, ko, !0);
            J(this, "operators", {
                conditions: (t, r) => Ht(s => Md(...t.map(i => i(s, r))).pipe(qk(s))),
                retryAndRaceWithSignalAndTimer: (t, r) => {
                    const s = [];
                    return t && s.push(Ja(t, r)),
                    s.push(Or(this._timeout, r)),
                    xj(Gg({
                        delay: my
                    }), sr(...s))
                }
            });
            b(this, hp, (t, r) => o(this, Co) ? Ze(t.frame.waitForFunction(s => s instanceof HTMLElement ? !["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(s.nodeName) || !s.hasAttribute("disabled") : !0, {
                timeout: this._timeout,
                signal: r
            }, t)).pipe(zg()) : Wa);
            b(this, Po, t => o(this, ko) ? za( () => Ze(t.evaluate(r => new Promise(s => {
                window.requestAnimationFrame( () => {
                    const i = r.getBoundingClientRect();
                    window.requestAnimationFrame( () => {
                        const a = r.getBoundingClientRect();
                        s([{
                            x: i.x,
                            y: i.y,
                            width: i.width,
                            height: i.height
                        }, {
                            x: a.x,
                            y: a.y,
                            width: a.width,
                            height: a.height
                        }])
                    }
                    )
                }
                )
            }
            )))).pipe(jc( ([r,s]) => r.x === s.x && r.y === s.y && r.width === s.width && r.height === s.height), Gg({
                delay: my
            }), zg()) : Wa);
            b(this, To, t => o(this, xo) ? Ze(t.isIntersectingViewport({
                threshold: 0
            })).pipe(Va(r => !r), Ht( () => Ze(t.scrollIntoView())), Ht( () => za( () => Ze(t.isIntersectingViewport({
                threshold: 0
            }))).pipe(jc(ns), Gg({
                delay: my
            }), zg()))) : Wa)
        }
        static race(t) {
            return Vv.create(t)
        }
        get timeout() {
            return this._timeout
        }
        setTimeout(t) {
            const r = this._clone();
            return r._timeout = t,
            r
        }
        setVisibility(t) {
            const r = this._clone();
            return r.visibility = t,
            r
        }
        setWaitForEnabled(t) {
            const r = this._clone();
            return S(r, Co, t),
            r
        }
        setEnsureElementIsInTheViewport(t) {
            const r = this._clone();
            return S(r, xo, t),
            r
        }
        setWaitForStableBoundingBox(t) {
            const r = this._clone();
            return S(r, ko, t),
            r
        }
        copyOptions(t) {
            return this._timeout = t._timeout,
            this.visibility = t.visibility,
            S(this, Co, o(t, Co)),
            S(this, xo, o(t, xo)),
            S(this, ko, o(t, ko)),
            this
        }
        clone() {
            return this._clone()
        }
        async waitHandle(t) {
            const r = new Error("Locator.waitHandle");
            return await Kt(this._wait(t).pipe(this.operators.retryAndRaceWithSignalAndTimer(t == null ? void 0 : t.signal, r)))
        }
        async wait(t) {
            const r = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                return await dB(r, await this.waitHandle(t), !1).jsonValue()
            } catch (s) {
                r.error = s,
                r.hasError = !0
            } finally {
                hB(r)
            }
        }
        map(t) {
            return new fy(this._clone(),r => r.evaluateHandle(t))
        }
        filter(t) {
            return new hy(this._clone(),async (r, s) => (await r.frame.waitForFunction(t, {
                signal: s,
                timeout: this._timeout
            }, r),
            !0))
        }
        filterHandle(t) {
            return new hy(this._clone(),t)
        }
        mapHandle(t) {
            return new fy(this._clone(),t)
        }
        click(t) {
            return Kt(P(this, Ss, e$).call(this, t))
        }
        fill(t, r) {
            return Kt(P(this, Ss, t$).call(this, t, r))
        }
        hover(t) {
            return Kt(P(this, Ss, r$).call(this, t))
        }
        scroll(t) {
            return Kt(P(this, Ss, n$).call(this, t))
        }
    }
    xo = new WeakMap,
    Co = new WeakMap,
    ko = new WeakMap,
    hp = new WeakMap,
    Po = new WeakMap,
    To = new WeakMap,
    Ss = new WeakSet,
    e$ = function(t) {
        const r = t == null ? void 0 : t.signal
          , s = new Error("Locator.click");
        return this._wait(t).pipe(this.operators.conditions([o(this, To), o(this, Po), o(this, hp)], r), Zg( () => this.emit(Hc.Action, void 0)), Ht(i => Ze(i.click(t)).pipe(Nd(a => {
            throw i.dispose().catch(ge),
            a
        }
        ))), this.operators.retryAndRaceWithSignalAndTimer(r, s))
    }
    ,
    t$ = function(t, r) {
        const s = r == null ? void 0 : r.signal
          , i = new Error("Locator.fill");
        return this._wait(r).pipe(this.operators.conditions([o(this, To), o(this, Po), o(this, hp)], s), Zg( () => this.emit(Hc.Action, void 0)), Ht(a => Ze(a.evaluate(c => c instanceof HTMLSelectElement ? "select" : c instanceof HTMLTextAreaElement ? "typeable-input" : c instanceof HTMLInputElement ? new Set(["textarea", "text", "url", "tel", "search", "password", "number", "email"]).has(c.type) ? "typeable-input" : "other-input" : c.isContentEditable ? "contenteditable" : "unknown")).pipe(Ht(c => {
            switch (c) {
            case "select":
                return Ze(a.select(t).then(Fc));
            case "contenteditable":
            case "typeable-input":
                return Ze(a.evaluate( (u, l) => {
                    const d = u.isContentEditable ? u.innerText : u.value;
                    if (l.length <= d.length || !l.startsWith(u.value))
                        return u.isContentEditable ? u.innerText = "" : u.value = "",
                        l;
                    const h = u.isContentEditable ? u.innerText : u.value;
                    return u.isContentEditable ? (u.innerText = "",
                    u.innerText = h) : (u.value = "",
                    u.value = h),
                    l.substring(h.length)
                }
                , t)).pipe(Ht(u => Ze(a.type(u))));
            case "other-input":
                return Ze(a.focus()).pipe(Ht( () => Ze(a.evaluate( (u, l) => {
                    u.value = l,
                    u.dispatchEvent(new Event("input",{
                        bubbles: !0
                    })),
                    u.dispatchEvent(new Event("change",{
                        bubbles: !0
                    }))
                }
                , t))));
            case "unknown":
                throw new Error("Element cannot be filled out.")
            }
        }
        )).pipe(Nd(c => {
            throw a.dispose().catch(ge),
            c
        }
        ))), this.operators.retryAndRaceWithSignalAndTimer(s, i))
    }
    ,
    r$ = function(t) {
        const r = t == null ? void 0 : t.signal
          , s = new Error("Locator.hover");
        return this._wait(t).pipe(this.operators.conditions([o(this, To), o(this, Po)], r), Zg( () => this.emit(Hc.Action, void 0)), Ht(i => Ze(i.hover()).pipe(Nd(a => {
            throw i.dispose().catch(ge),
            a
        }
        ))), this.operators.retryAndRaceWithSignalAndTimer(r, s))
    }
    ,
    n$ = function(t) {
        const r = t == null ? void 0 : t.signal
          , s = new Error("Locator.scroll");
        return this._wait(t).pipe(this.operators.conditions([o(this, To), o(this, Po)], r), Zg( () => this.emit(Hc.Action, void 0)), Ht(i => Ze(i.evaluate( (a, c, u) => {
            c !== void 0 && (a.scrollTop = c),
            u !== void 0 && (a.scrollLeft = u)
        }
        , t == null ? void 0 : t.scrollTop, t == null ? void 0 : t.scrollLeft)).pipe(Nd(a => {
            throw i.dispose().catch(ge),
            a
        }
        ))), this.operators.retryAndRaceWithSignalAndTimer(r, s))
    }
    ;
    const Sb = class Sb extends Wc {
        constructor(t, r) {
            super();
            b(this, Yu);
            b(this, Qu);
            S(this, Yu, t),
            S(this, Qu, r)
        }
        static create(t, r) {
            return new Sb(t,r).setTimeout("getDefaultTimeout"in t ? t.getDefaultTimeout() : t.page().getDefaultTimeout())
        }
        _clone() {
            return new Sb(o(this, Yu),o(this, Qu))
        }
        _wait(t) {
            const r = t == null ? void 0 : t.signal;
            return za( () => Ze(o(this, Yu).waitForFunction(o(this, Qu), {
                timeout: this.timeout,
                signal: r
            }))).pipe(Vg())
        }
    }
    ;
    Yu = new WeakMap,
    Qu = new WeakMap;
    let dy = Sb;
    class lP extends Wc {
        constructor(t) {
            super();
            b(this, mr);
            S(this, mr, t),
            this.copyOptions(o(this, mr))
        }
        get delegate() {
            return o(this, mr)
        }
        setTimeout(t) {
            const r = super.setTimeout(t);
            return S(r, mr, o(this, mr).setTimeout(t)),
            r
        }
        setVisibility(t) {
            const r = super.setVisibility(t);
            return S(r, mr, o(r, mr).setVisibility(t)),
            r
        }
        setWaitForEnabled(t) {
            const r = super.setWaitForEnabled(t);
            return S(r, mr, o(this, mr).setWaitForEnabled(t)),
            r
        }
        setEnsureElementIsInTheViewport(t) {
            const r = super.setEnsureElementIsInTheViewport(t);
            return S(r, mr, o(this, mr).setEnsureElementIsInTheViewport(t)),
            r
        }
        setWaitForStableBoundingBox(t) {
            const r = super.setWaitForStableBoundingBox(t);
            return S(r, mr, o(this, mr).setWaitForStableBoundingBox(t)),
            r
        }
    }
    mr = new WeakMap;
    const sx = class sx extends lP {
        constructor(t, r) {
            super(t);
            b(this, el);
            S(this, el, r)
        }
        _clone() {
            return new sx(this.delegate.clone(),o(this, el)).copyOptions(this)
        }
        _wait(t) {
            return this.delegate._wait(t).pipe(Ht(r => Ze(Promise.resolve(o(this, el).call(this, r, t == null ? void 0 : t.signal))).pipe(Va(s => s), Pt( () => r))), Vg())
        }
    }
    ;
    el = new WeakMap;
    let hy = sx;
    const ix = class ix extends lP {
        constructor(t, r) {
            super(t);
            b(this, tl);
            S(this, tl, r)
        }
        _clone() {
            return new ix(this.delegate.clone(),o(this, tl)).copyOptions(this)
        }
        _wait(t) {
            return this.delegate._wait(t).pipe(Ht(r => Ze(Promise.resolve(o(this, tl).call(this, r, t == null ? void 0 : t.signal)))))
        }
    }
    ;
    tl = new WeakMap;
    let fy = ix;
    const xb = class xb extends Wc {
        constructor(t, r) {
            super();
            b(this, rl);
            b(this, nl);
            b(this, Eb, t => this.visibility ? ( () => {
                switch (this.visibility) {
                case "hidden":
                    return za( () => Ze(t.isHidden()));
                case "visible":
                    return za( () => Ze(t.isVisible()))
                }
            }
            )().pipe(jc(ns), Gg({
                delay: my
            }), zg()) : Wa);
            S(this, rl, t),
            S(this, nl, r)
        }
        static create(t, r) {
            return new xb(t,r).setTimeout("getDefaultTimeout"in t ? t.getDefaultTimeout() : t.page().getDefaultTimeout())
        }
        _clone() {
            return new xb(o(this, rl),o(this, nl)).copyOptions(this)
        }
        _wait(t) {
            const r = t == null ? void 0 : t.signal;
            return za( () => Ze(o(this, rl).waitForSelector(o(this, nl), {
                visible: !1,
                timeout: this._timeout,
                signal: r
            }))).pipe(Va(s => s !== null), Vg(), this.operators.conditions([o(this, Eb)], r))
        }
    }
    ;
    rl = new WeakMap,
    nl = new WeakMap,
    Eb = new WeakMap;
    let py = xb;
    function fB(n) {
        for (const e of n)
            if (!(e instanceof Wc))
                throw new Error("Unknown locator for race candidate");
        return n
    }
    const Cb = class Cb extends Wc {
        constructor(t) {
            super();
            b(this, sl);
            S(this, sl, t)
        }
        static create(t) {
            const r = fB(t);
            return new Cb(r)
        }
        _clone() {
            return new Cb(o(this, sl).map(t => t.clone())).copyOptions(this)
        }
        _wait(t) {
            return Dk(...o(this, sl).map(r => r._wait(t)))
        }
    }
    ;
    sl = new WeakMap;
    let Vv = Cb;
    const my = 100;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var pB = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }, Rt = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }, Ai = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }, Ii = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    ), ir;
    (function(n) {
        n.FrameNavigated = Symbol("Frame.FrameNavigated"),
        n.FrameSwapped = Symbol("Frame.FrameSwapped"),
        n.LifecycleEvent = Symbol("Frame.LifecycleEvent"),
        n.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument"),
        n.FrameDetached = Symbol("Frame.FrameDetached"),
        n.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation")
    }
    )(ir || (ir = {}));
    const ze = oe(n => `Attempted to use detached Frame '${n._id}'.`);
    let dP = ( () => {
        var C, k, Tg, N;
        let n = be, e = [], t, r, s, i, a, c, u, l, d, h, f, p, g, y, m, w, E, v, _, A;
        return N = class extends n {
            constructor() {
                super();
                b(this, k);
                J(this, "_id", pB(this, e));
                J(this, "_parentId");
                J(this, "_name");
                J(this, "_hasStartedLoading", !1);
                b(this, C)
            }
            clearDocumentHandle() {
                S(this, C, void 0)
            }
            async frameElement() {
                const O = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const T = this.parentFrame();
                    if (!T)
                        return null;
                    const L = Ai(O, await T.isolatedRealm().evaluateHandle( () => document.querySelectorAll("iframe,frame")), !1);
                    for await(const q of iP(L)) {
                        const Z = {
                            stack: [],
                            error: void 0,
                            hasError: !1
                        };
                        try {
                            const j = Ai(Z, q, !1)
                              , $ = await j.contentFrame();
                            if (($ == null ? void 0 : $._id) === this._id)
                                return await T.mainRealm().adoptHandle(j)
                        } catch (j) {
                            Z.error = j,
                            Z.hasError = !0
                        } finally {
                            Ii(Z)
                        }
                    }
                    return null
                } catch (T) {
                    O.error = T,
                    O.hasError = !0
                } finally {
                    Ii(O)
                }
            }
            async evaluateHandle(O, ...T) {
                return O = Wt(this.evaluateHandle.name, O),
                await this.mainRealm().evaluateHandle(O, ...T)
            }
            async evaluate(O, ...T) {
                return O = Wt(this.evaluate.name, O),
                await this.mainRealm().evaluate(O, ...T)
            }
            locator(O) {
                return typeof O == "string" ? py.create(this, O) : dy.create(this, O)
            }
            async $(O) {
                return await (await P(this, k, Tg).call(this)).$(O)
            }
            async $$(O, T) {
                return await (await P(this, k, Tg).call(this)).$$(O, T)
            }
            async $eval(O, T, ...L) {
                return T = Wt(this.$eval.name, T),
                await (await P(this, k, Tg).call(this)).$eval(O, T, ...L)
            }
            async $$eval(O, T, ...L) {
                return T = Wt(this.$$eval.name, T),
                await (await P(this, k, Tg).call(this)).$$eval(O, T, ...L)
            }
            async waitForSelector(O, T={}) {
                const {updatedSelector: L, QueryHandler: q, polling: Z} = cy(O);
                return await q.waitFor(this, L, {
                    polling: Z,
                    ...T
                })
            }
            async waitForFunction(O, T={}, ...L) {
                return await this.mainRealm().waitForFunction(O, T, ...L)
            }
            async content() {
                return await this.evaluate( () => {
                    let O = "";
                    for (const T of document.childNodes)
                        switch (T) {
                        case document.documentElement:
                            O += document.documentElement.outerHTML;
                            break;
                        default:
                            O += new XMLSerializer().serializeToString(T);
                            break
                        }
                    return O
                }
                )
            }
            async setFrameContent(O) {
                return await this.evaluate(T => {
                    document.open(),
                    document.write(T),
                    document.close()
                }
                , O)
            }
            name() {
                return this._name || ""
            }
            isDetached() {
                return this.detached
            }
            get disposed() {
                return this.detached
            }
            async addScriptTag(O) {
                let {content: T="", type: L} = O;
                const {path: q} = O;
                if (+!!O.url + +!!q + +!!T != 1)
                    throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
                return q && (T = await Pi.value.fs.promises.readFile(q, "utf8"),
                T += `//# sourceURL=${q.replace(/\n/g, "")}`),
                L = L ?? "text/javascript",
                await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({url: Z, id: j, type: $, content: B}) => await new Promise( (D, z) => {
                    const G = document.createElement("script");
                    G.type = $,
                    G.text = B,
                    G.addEventListener("error", ee => {
                        z(new Error(ee.message ?? "Could not load script"))
                    }
                    , {
                        once: !0
                    }),
                    j && (G.id = j),
                    Z ? (G.src = Z,
                    G.addEventListener("load", () => {
                        D(G)
                    }
                    , {
                        once: !0
                    }),
                    document.head.appendChild(G)) : (document.head.appendChild(G),
                    D(G))
                }
                ), {
                    ...O,
                    type: L,
                    content: T
                }))
            }
            async addStyleTag(O) {
                let {content: T=""} = O;
                const {path: L} = O;
                if (+!!O.url + +!!L + +!!T != 1)
                    throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
                return L && (T = await Pi.value.fs.promises.readFile(L, "utf8"),
                T += "/*# sourceURL=" + L.replace(/\n/g, "") + "*/",
                O.content = T),
                await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({url: q, content: Z}) => await new Promise( (j, $) => {
                    let B;
                    if (!q)
                        B = document.createElement("style"),
                        B.appendChild(document.createTextNode(Z));
                    else {
                        const D = document.createElement("link");
                        D.rel = "stylesheet",
                        D.href = q,
                        B = D
                    }
                    return B.addEventListener("load", () => {
                        j(B)
                    }
                    , {
                        once: !0
                    }),
                    B.addEventListener("error", D => {
                        $(new Error(D.message ?? "Could not load style"))
                    }
                    , {
                        once: !0
                    }),
                    document.head.appendChild(B),
                    B
                }
                ), O))
            }
            async click(O, T={}) {
                const L = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const q = Ai(L, await this.$(O), !1);
                    ne(q, `No element found for selector: ${O}`),
                    await q.click(T),
                    await q.dispose()
                } catch (q) {
                    L.error = q,
                    L.hasError = !0
                } finally {
                    Ii(L)
                }
            }
            async focus(O) {
                const T = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const L = Ai(T, await this.$(O), !1);
                    ne(L, `No element found for selector: ${O}`),
                    await L.focus()
                } catch (L) {
                    T.error = L,
                    T.hasError = !0
                } finally {
                    Ii(T)
                }
            }
            async hover(O) {
                const T = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const L = Ai(T, await this.$(O), !1);
                    ne(L, `No element found for selector: ${O}`),
                    await L.hover()
                } catch (L) {
                    T.error = L,
                    T.hasError = !0
                } finally {
                    Ii(T)
                }
            }
            async select(O, ...T) {
                const L = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const q = Ai(L, await this.$(O), !1);
                    return ne(q, `No element found for selector: ${O}`),
                    await q.select(...T)
                } catch (q) {
                    L.error = q,
                    L.hasError = !0
                } finally {
                    Ii(L)
                }
            }
            async tap(O) {
                const T = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const L = Ai(T, await this.$(O), !1);
                    ne(L, `No element found for selector: ${O}`),
                    await L.tap()
                } catch (L) {
                    T.error = L,
                    T.hasError = !0
                } finally {
                    Ii(T)
                }
            }
            async type(O, T, L) {
                const q = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const Z = Ai(q, await this.$(O), !1);
                    ne(Z, `No element found for selector: ${O}`),
                    await Z.type(T, L)
                } catch (Z) {
                    q.error = Z,
                    q.hasError = !0
                } finally {
                    Ii(q)
                }
            }
            async title() {
                return await this.isolatedRealm().evaluate( () => document.title)
            }
        }
        ,
        C = new WeakMap,
        k = new WeakSet,
        Tg = function() {
            return o(this, C) || S(this, C, this.mainRealm().evaluateHandle( () => document)),
            o(this, C)
        }
        ,
        ( () => {
            const O = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            t = [ze],
            r = [ze],
            s = [ze],
            i = [ze],
            a = [ze],
            c = [ze],
            u = [ze],
            l = [ze],
            d = [ze],
            h = [ze],
            f = [ze],
            p = [ze],
            g = [ze],
            y = [ze],
            m = [ze],
            w = [ze],
            E = [ze],
            v = [ze],
            _ = [ze],
            A = [ze],
            Rt(N, null, t, {
                kind: "method",
                name: "frameElement",
                static: !1,
                private: !1,
                access: {
                    has: T => "frameElement"in T,
                    get: T => T.frameElement
                },
                metadata: O
            }, null, e),
            Rt(N, null, r, {
                kind: "method",
                name: "evaluateHandle",
                static: !1,
                private: !1,
                access: {
                    has: T => "evaluateHandle"in T,
                    get: T => T.evaluateHandle
                },
                metadata: O
            }, null, e),
            Rt(N, null, s, {
                kind: "method",
                name: "evaluate",
                static: !1,
                private: !1,
                access: {
                    has: T => "evaluate"in T,
                    get: T => T.evaluate
                },
                metadata: O
            }, null, e),
            Rt(N, null, i, {
                kind: "method",
                name: "locator",
                static: !1,
                private: !1,
                access: {
                    has: T => "locator"in T,
                    get: T => T.locator
                },
                metadata: O
            }, null, e),
            Rt(N, null, a, {
                kind: "method",
                name: "$",
                static: !1,
                private: !1,
                access: {
                    has: T => "$"in T,
                    get: T => T.$
                },
                metadata: O
            }, null, e),
            Rt(N, null, c, {
                kind: "method",
                name: "$$",
                static: !1,
                private: !1,
                access: {
                    has: T => "$$"in T,
                    get: T => T.$$
                },
                metadata: O
            }, null, e),
            Rt(N, null, u, {
                kind: "method",
                name: "$eval",
                static: !1,
                private: !1,
                access: {
                    has: T => "$eval"in T,
                    get: T => T.$eval
                },
                metadata: O
            }, null, e),
            Rt(N, null, l, {
                kind: "method",
                name: "$$eval",
                static: !1,
                private: !1,
                access: {
                    has: T => "$$eval"in T,
                    get: T => T.$$eval
                },
                metadata: O
            }, null, e),
            Rt(N, null, d, {
                kind: "method",
                name: "waitForSelector",
                static: !1,
                private: !1,
                access: {
                    has: T => "waitForSelector"in T,
                    get: T => T.waitForSelector
                },
                metadata: O
            }, null, e),
            Rt(N, null, h, {
                kind: "method",
                name: "waitForFunction",
                static: !1,
                private: !1,
                access: {
                    has: T => "waitForFunction"in T,
                    get: T => T.waitForFunction
                },
                metadata: O
            }, null, e),
            Rt(N, null, f, {
                kind: "method",
                name: "content",
                static: !1,
                private: !1,
                access: {
                    has: T => "content"in T,
                    get: T => T.content
                },
                metadata: O
            }, null, e),
            Rt(N, null, p, {
                kind: "method",
                name: "addScriptTag",
                static: !1,
                private: !1,
                access: {
                    has: T => "addScriptTag"in T,
                    get: T => T.addScriptTag
                },
                metadata: O
            }, null, e),
            Rt(N, null, g, {
                kind: "method",
                name: "addStyleTag",
                static: !1,
                private: !1,
                access: {
                    has: T => "addStyleTag"in T,
                    get: T => T.addStyleTag
                },
                metadata: O
            }, null, e),
            Rt(N, null, y, {
                kind: "method",
                name: "click",
                static: !1,
                private: !1,
                access: {
                    has: T => "click"in T,
                    get: T => T.click
                },
                metadata: O
            }, null, e),
            Rt(N, null, m, {
                kind: "method",
                name: "focus",
                static: !1,
                private: !1,
                access: {
                    has: T => "focus"in T,
                    get: T => T.focus
                },
                metadata: O
            }, null, e),
            Rt(N, null, w, {
                kind: "method",
                name: "hover",
                static: !1,
                private: !1,
                access: {
                    has: T => "hover"in T,
                    get: T => T.hover
                },
                metadata: O
            }, null, e),
            Rt(N, null, E, {
                kind: "method",
                name: "select",
                static: !1,
                private: !1,
                access: {
                    has: T => "select"in T,
                    get: T => T.select
                },
                metadata: O
            }, null, e),
            Rt(N, null, v, {
                kind: "method",
                name: "tap",
                static: !1,
                private: !1,
                access: {
                    has: T => "tap"in T,
                    get: T => T.tap
                },
                metadata: O
            }, null, e),
            Rt(N, null, _, {
                kind: "method",
                name: "type",
                static: !1,
                private: !1,
                access: {
                    has: T => "type"in T,
                    get: T => T.type
                },
                metadata: O
            }, null, e),
            Rt(N, null, A, {
                kind: "method",
                name: "title",
                static: !1,
                private: !1,
                access: {
                    has: T => "title"in T,
                    get: T => T.title
                },
                metadata: O
            }, null, e),
            O && Object.defineProperty(N, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: O
            })
        }
        )(),
        N
    }
    )();
    class gy {
        constructor() {
            b(this, il);
            J(this, "_interceptionId");
            J(this, "_failureText", null);
            J(this, "_response", null);
            J(this, "_fromMemoryCache", !1);
            J(this, "_redirectChain", []);
            J(this, "interception", {
                enabled: !1,
                handled: !1,
                handlers: [],
                resolutionState: {
                    action: os.None
                },
                requestOverrides: {},
                response: null,
                abortReason: null
            })
        }
        continueRequestOverrides() {
            return ne(this.interception.enabled, "Request Interception is not enabled!"),
            this.interception.requestOverrides
        }
        responseForRequest() {
            return ne(this.interception.enabled, "Request Interception is not enabled!"),
            this.interception.response
        }
        abortErrorReason() {
            return ne(this.interception.enabled, "Request Interception is not enabled!"),
            this.interception.abortReason
        }
        interceptResolutionState() {
            return this.interception.enabled ? this.interception.handled ? {
                action: os.AlreadyHandled
            } : {
                ...this.interception.resolutionState
            } : {
                action: os.Disabled
            }
        }
        isInterceptResolutionHandled() {
            return this.interception.handled
        }
        enqueueInterceptAction(e) {
            this.interception.handlers.push(e)
        }
        async finalizeInterceptions() {
            await this.interception.handlers.reduce( (t, r) => t.then(r), Promise.resolve()),
            this.interception.handlers = [];
            const {action: e} = this.interceptResolutionState();
            switch (e) {
            case "abort":
                return await this._abort(this.interception.abortReason);
            case "respond":
                if (this.interception.response === null)
                    throw new Error("Response is missing for the interception");
                return await this._respond(this.interception.response);
            case "continue":
                return await this._continue(this.interception.requestOverrides)
            }
        }
        async continue(e={}, t) {
            if (P(this, il, Kb).call(this)) {
                if (ne(this.interception.enabled, "Request Interception is not enabled!"),
                ne(!this.interception.handled, "Request is already handled!"),
                t === void 0)
                    return await this._continue(e);
                if (this.interception.requestOverrides = e,
                this.interception.resolutionState.priority === void 0 || t > this.interception.resolutionState.priority) {
                    this.interception.resolutionState = {
                        action: os.Continue,
                        priority: t
                    };
                    return
                }
                if (t === this.interception.resolutionState.priority) {
                    if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond")
                        return;
                    this.interception.resolutionState.action = os.Continue
                }
            }
        }
        async respond(e, t) {
            if (P(this, il, Kb).call(this)) {
                if (ne(this.interception.enabled, "Request Interception is not enabled!"),
                ne(!this.interception.handled, "Request is already handled!"),
                t === void 0)
                    return await this._respond(e);
                if (this.interception.response = e,
                this.interception.resolutionState.priority === void 0 || t > this.interception.resolutionState.priority) {
                    this.interception.resolutionState = {
                        action: os.Respond,
                        priority: t
                    };
                    return
                }
                if (t === this.interception.resolutionState.priority) {
                    if (this.interception.resolutionState.action === "abort")
                        return;
                    this.interception.resolutionState.action = os.Respond
                }
            }
        }
        async abort(e="failed", t) {
            if (!P(this, il, Kb).call(this))
                return;
            const r = mB[e];
            if (ne(r, "Unknown error code: " + e),
            ne(this.interception.enabled, "Request Interception is not enabled!"),
            ne(!this.interception.handled, "Request is already handled!"),
            t === void 0)
                return await this._abort(r);
            if (this.interception.abortReason = r,
            this.interception.resolutionState.priority === void 0 || t >= this.interception.resolutionState.priority) {
                this.interception.resolutionState = {
                    action: os.Abort,
                    priority: t
                };
                return
            }
        }
        static getResponse(e) {
            const t = js(e) ? new TextEncoder().encode(e) : e;
            return {
                contentLength: t.byteLength,
                base64: Wk(t)
            }
        }
    }
    il = new WeakSet,
    Kb = function() {
        return !this.url().startsWith("data:") && !this._fromMemoryCache
    }
    ;
    var os;
    (function(n) {
        n.Abort = "abort",
        n.Respond = "respond",
        n.Continue = "continue",
        n.Disabled = "disabled",
        n.None = "none",
        n.AlreadyHandled = "already-handled"
    }
    )(os || (os = {}));
    function hP(n) {
        const e = [];
        for (const t in n) {
            const r = n[t];
            if (!Object.is(r, void 0)) {
                const s = Array.isArray(r) ? r : [r];
                e.push(...s.map(i => ({
                    name: t,
                    value: i + ""
                })))
            }
        }
        return e
    }
    const fP = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        103: "Early Hints",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        208: "Already Reported",
        226: "IM Used",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        306: "Switch Proxy",
        307: "Temporary Redirect",
        308: "Permanent Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        421: "Misdirected Request",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Too Early",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        510: "Not Extended",
        511: "Network Authentication Required"
    }
      , mB = {
        aborted: "Aborted",
        accessdenied: "AccessDenied",
        addressunreachable: "AddressUnreachable",
        blockedbyclient: "BlockedByClient",
        blockedbyresponse: "BlockedByResponse",
        connectionaborted: "ConnectionAborted",
        connectionclosed: "ConnectionClosed",
        connectionfailed: "ConnectionFailed",
        connectionrefused: "ConnectionRefused",
        connectionreset: "ConnectionReset",
        internetdisconnected: "InternetDisconnected",
        namenotresolved: "NameNotResolved",
        timedout: "TimedOut",
        failed: "Failed"
    };
    function yy(n) {
        if (n.originalMessage.includes("Invalid header") || n.originalMessage.includes('Expected "header"') || n.originalMessage.includes("invalid argument"))
            throw n;
        ge(n)
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class pP {
        constructor() {}
        ok() {
            const e = this.status();
            return e === 0 || e >= 200 && e <= 299
        }
        async buffer() {
            const e = await this.content();
            return Buffer.from(e)
        }
        async text() {
            const e = await this.content();
            return new TextDecoder().decode(e)
        }
        async json() {
            const e = await this.text();
            return JSON.parse(e)
        }
    }
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    function mP() {
        let n = 0;
        return () => ++n
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class gP {
        constructor() {}
    }
    const wt = Object.freeze({
        Left: "left",
        Right: "right",
        Middle: "middle",
        Back: "back",
        Forward: "forward"
    });
    class yP {
        constructor() {}
    }
    class wP {
        constructor() {
            J(this, "idGenerator", mP());
            J(this, "touches", [])
        }
        removeHandle(e) {
            const t = this.touches.indexOf(e);
            t !== -1 && this.touches.splice(t, 1)
        }
        async tap(e, t) {
            await (await this.touchStart(e, t)).end()
        }
        async touchMove(e, t) {
            const r = this.touches[0];
            if (!r)
                throw new ey("Must start a new Touch first");
            return await r.move(e, t)
        }
        async touchEnd() {
            const e = this.touches.shift();
            if (!e)
                throw new ey("Must start a new Touch first");
            await e.end()
        }
    }
    /**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const bP = 3e4;
    class Gv {
        constructor() {
            b(this, ei);
            b(this, Ao);
            S(this, ei, null),
            S(this, Ao, null)
        }
        setDefaultTimeout(e) {
            S(this, ei, e)
        }
        setDefaultNavigationTimeout(e) {
            S(this, Ao, e)
        }
        navigationTimeout() {
            return o(this, Ao) !== null ? o(this, Ao) : o(this, ei) !== null ? o(this, ei) : bP
        }
        timeout() {
            return o(this, ei) !== null ? o(this, ei) : bP
        }
    }
    ei = new WeakMap,
    Ao = new WeakMap;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var gB = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , yB = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , Jv = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , vP = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    function wB(n) {
        n.optimizeForSpeed ?? (n.optimizeForSpeed = !1),
        n.type ?? (n.type = "png"),
        n.fromSurface ?? (n.fromSurface = !0),
        n.fullPage ?? (n.fullPage = !1),
        n.omitBackground ?? (n.omitBackground = !1),
        n.encoding ?? (n.encoding = "binary"),
        n.captureBeyondViewport ?? (n.captureBeyondViewport = !0)
    }
    let _P = ( () => {
        var r, s, i, a, c, s$, l;
        let n = be, e = [], t;
        return l = class extends n {
            constructor() {
                super();
                b(this, c);
                J(this, "_isDragging", (gB(this, e),
                !1));
                J(this, "_timeoutSettings", new Gv);
                b(this, r, new WeakMap);
                b(this, s, new Ij(1));
                b(this, i, 0);
                b(this, a);
                at(this, "request").pipe(Ht(f => Ov(ss(1), Md(at(this, "requestfailed"), at(this, "requestfinished"), at(this, "response").pipe(Pt(p => p.request()))).pipe(Va(p => p.id === f.id), Nv(1), Pt( () => -1)))), _D( (f, p) => ss(f + p), 0), ED(at(this, "close")), SD(0)).subscribe(o(this, s))
            }
            on(f, p) {
                if (f !== "request")
                    return super.on(f, p);
                let g = o(this, r).get(p);
                return g === void 0 && (g = y => {
                    y.enqueueInterceptAction( () => p(y))
                }
                ,
                o(this, r).set(p, g)),
                super.on(f, g)
            }
            off(f, p) {
                return f === "request" && (p = o(this, r).get(p) || p),
                super.off(f, p)
            }
            get accessibility() {
                return this.mainFrame().accessibility
            }
            locator(f) {
                return typeof f == "string" ? py.create(this, f) : dy.create(this, f)
            }
            locatorRace(f) {
                return Wc.race(f)
            }
            async $(f) {
                return await this.mainFrame().$(f)
            }
            async $$(f, p) {
                return await this.mainFrame().$$(f, p)
            }
            async evaluateHandle(f, ...p) {
                return f = Wt(this.evaluateHandle.name, f),
                await this.mainFrame().evaluateHandle(f, ...p)
            }
            async $eval(f, p, ...g) {
                return p = Wt(this.$eval.name, p),
                await this.mainFrame().$eval(f, p, ...g)
            }
            async $$eval(f, p, ...g) {
                return p = Wt(this.$$eval.name, p),
                await this.mainFrame().$$eval(f, p, ...g)
            }
            async addScriptTag(f) {
                return await this.mainFrame().addScriptTag(f)
            }
            async addStyleTag(f) {
                return await this.mainFrame().addStyleTag(f)
            }
            url() {
                return this.mainFrame().url()
            }
            async content() {
                return await this.mainFrame().content()
            }
            async setContent(f, p) {
                await this.mainFrame().setContent(f, p)
            }
            async goto(f, p) {
                return await this.mainFrame().goto(f, p)
            }
            async waitForNavigation(f={}) {
                return await this.mainFrame().waitForNavigation(f)
            }
            waitForRequest(f, p={}) {
                const {timeout: g=this._timeoutSettings.timeout(), signal: y} = p;
                if (typeof f == "string") {
                    const w = f;
                    f = E => E.url() === w
                }
                const m = at(this, "request").pipe($d(f), sr(Or(g), Ja(y), at(this, "close").pipe(Pt( () => {
                    throw new xn("Page closed!")
                }
                ))));
                return Kt(m)
            }
            waitForResponse(f, p={}) {
                const {timeout: g=this._timeoutSettings.timeout(), signal: y} = p;
                if (typeof f == "string") {
                    const w = f;
                    f = E => E.url() === w
                }
                const m = at(this, "response").pipe($d(f), sr(Or(g), Ja(y), at(this, "close").pipe(Pt( () => {
                    throw new xn("Page closed!")
                }
                ))));
                return Kt(m)
            }
            waitForNetworkIdle(f={}) {
                return Kt(this.waitForNetworkIdle$(f))
            }
            waitForNetworkIdle$(f={}) {
                const {timeout: p=this._timeoutSettings.timeout(), idleTime: g=MD, concurrency: y=0, signal: m} = f;
                return o(this, s).pipe(Jg(w => w > y ? Wa : Mv(g)), Pt( () => {}
                ), sr(Or(p), Ja(m), at(this, "close").pipe(Pt( () => {
                    throw new xn("Page closed!")
                }
                ))))
            }
            async waitForFrame(f, p={}) {
                const {timeout: g=this.getDefaultTimeout(), signal: y} = p
                  , m = js(f) ? w => f === w.url() : f;
                return await Kt(Md(at(this, "frameattached"), at(this, "framenavigated"), Ze(this.frames())).pipe($d(m), jc(), sr(Or(g), Ja(y), at(this, "close").pipe(Pt( () => {
                    throw new xn("Page closed.")
                }
                )))))
            }
            async emulate(f) {
                await Promise.all([this.setUserAgent(f.userAgent), this.setViewport(f.viewport)])
            }
            async evaluate(f, ...p) {
                return f = Wt(this.evaluate.name, f),
                await this.mainFrame().evaluate(f, ...p)
            }
            async _maybeWriteTypedArrayToFile(f, p) {
                f && await Pi.value.fs.promises.writeFile(f, p)
            }
            async screencast(f={}) {
                const p = Pi.value.ScreenRecorder
                  , [g,y,m] = await P(this, c, s$).call(this);
                let w;
                if (f.crop) {
                    const {x: v, y: _, width: A, height: C} = EP(SP(f.crop));
                    if (v < 0 || _ < 0)
                        throw new Error("`crop.x` and `crop.y` must be greater than or equal to 0.");
                    if (A <= 0 || C <= 0)
                        throw new Error("`crop.height` and `crop.width` must be greater than or equal to 0.");
                    const k = g / m
                      , x = y / m;
                    if (v + A > k)
                        throw new Error(`\`crop.width\` cannot be larger than the viewport width (${k}).`);
                    if (_ + C > x)
                        throw new Error(`\`crop.height\` cannot be larger than the viewport height (${x}).`);
                    w = {
                        x: v * m,
                        y: _ * m,
                        width: A * m,
                        height: C * m
                    }
                }
                if (f.speed !== void 0 && f.speed <= 0)
                    throw new Error("`speed` must be greater than 0.");
                if (f.scale !== void 0 && f.scale <= 0)
                    throw new Error("`scale` must be greater than 0.");
                const E = new p(this,g,y,{
                    ...f,
                    path: f.ffmpegPath,
                    crop: w
                });
                try {
                    await this._startScreencast()
                } catch (v) {
                    throw E.stop(),
                    v
                }
                if (f.path) {
                    const {createWriteStream: v} = Pi.value.fs
                      , _ = v(f.path, "binary");
                    E.pipe(_)
                }
                return E
            }
            async _startScreencast() {
                ++_d(this, i)._,
                o(this, a) || S(this, a, this.mainFrame().client.send("Page.startScreencast", {
                    format: "png"
                }).then( () => new Promise(f => this.mainFrame().client.once("Page.screencastFrame", () => f())))),
                await o(this, a)
            }
            async _stopScreencast() {
                --_d(this, i)._,
                o(this, a) && (S(this, a, void 0),
                o(this, i) === 0 && await this.mainFrame().client.send("Page.stopScreencast"))
            }
            async screenshot(f={}) {
                const p = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const g = Jv(p, await this.browserContext().startScreenshot(), !1)
                      , y = {
                        ...f,
                        clip: f.clip ? {
                            ...f.clip
                        } : void 0
                    };
                    if (y.type === void 0 && y.path !== void 0) {
                        const v = y.path;
                        switch (v.slice(v.lastIndexOf(".") + 1).toLowerCase()) {
                        case "png":
                            y.type = "png";
                            break;
                        case "jpeg":
                        case "jpg":
                            y.type = "jpeg";
                            break;
                        case "webp":
                            y.type = "webp";
                            break
                        }
                    }
                    if (y.quality !== void 0) {
                        if (y.quality < 0 || y.quality > 100)
                            throw new Error(`Expected 'quality' (${y.quality}) to be between 0 and 100, inclusive.`);
                        if (y.type === void 0 || !["jpeg", "webp"].includes(y.type))
                            throw new Error(`${y.type ?? "png"} screenshots do not support 'quality'.`)
                    }
                    if (y.clip) {
                        if (y.clip.width <= 0)
                            throw new Error("'width' in 'clip' must be positive.");
                        if (y.clip.height <= 0)
                            throw new Error("'height' in 'clip' must be positive.")
                    }
                    wB(y);
                    const m = Jv(p, new Xg, !0);
                    if (y.clip) {
                        if (y.fullPage)
                            throw new Error("'clip' and 'fullPage' are mutually exclusive");
                        y.clip = EP(SP(y.clip))
                    } else if (y.fullPage) {
                        if (!y.captureBeyondViewport) {
                            const v = await this.mainFrame().isolatedRealm().evaluate( () => {
                                const A = document.documentElement;
                                return {
                                    width: A.scrollWidth,
                                    height: A.scrollHeight
                                }
                            }
                            )
                              , _ = this.viewport();
                            await this.setViewport({
                                ..._,
                                ...v
                            }),
                            m.defer(async () => {
                                await this.setViewport(_).catch(ge)
                            }
                            )
                        }
                    } else
                        y.captureBeyondViewport = !1;
                    const w = await this._screenshot(y);
                    if (y.encoding === "base64")
                        return w;
                    const E = $v(w, !0);
                    return await this._maybeWriteTypedArrayToFile(y.path, E),
                    E
                } catch (g) {
                    p.error = g,
                    p.hasError = !0
                } finally {
                    const g = vP(p);
                    g && await g
                }
            }
            async title() {
                return await this.mainFrame().title()
            }
            click(f, p) {
                return this.mainFrame().click(f, p)
            }
            focus(f) {
                return this.mainFrame().focus(f)
            }
            hover(f) {
                return this.mainFrame().hover(f)
            }
            select(f, ...p) {
                return this.mainFrame().select(f, ...p)
            }
            tap(f) {
                return this.mainFrame().tap(f)
            }
            type(f, p, g) {
                return this.mainFrame().type(f, p, g)
            }
            async waitForSelector(f, p={}) {
                return await this.mainFrame().waitForSelector(f, p)
            }
            waitForFunction(f, p, ...g) {
                return this.mainFrame().waitForFunction(f, p, ...g)
            }
            [(t = [iB(function() {
                return this.browser()
            })],
            Ce)]() {
                return void this.close().catch(ge)
            }
            [En]() {
                return this.close()
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakSet,
        s$ = async function() {
            const f = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const p = this.viewport()
                  , g = Jv(f, new Ot, !1);
                return p && p.deviceScaleFactor !== 0 && (await this.setViewport({
                    ...p,
                    deviceScaleFactor: 0
                }),
                g.defer( () => {
                    this.setViewport(p).catch(ge)
                }
                )),
                await this.mainFrame().isolatedRealm().evaluate( () => [window.visualViewport.width * window.devicePixelRatio, window.visualViewport.height * window.devicePixelRatio, window.devicePixelRatio])
            } catch (p) {
                f.error = p,
                f.hasError = !0
            } finally {
                vP(f)
            }
        }
        ,
        ( () => {
            const f = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            yB(l, null, t, {
                kind: "method",
                name: "screenshot",
                static: !1,
                private: !1,
                access: {
                    has: p => "screenshot"in p,
                    get: p => p.screenshot
                },
                metadata: f
            }, null, e),
            f && Object.defineProperty(l, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: f
            })
        }
        )(),
        l
    }
    )();
    function SP(n) {
        return {
            ...n,
            ...n.width < 0 ? {
                x: n.x + n.width,
                width: -n.width
            } : {
                x: n.x,
                width: n.width
            },
            ...n.height < 0 ? {
                y: n.y + n.height,
                height: -n.height
            } : {
                y: n.y,
                height: n.height
            }
        }
    }
    function EP(n) {
        const e = Math.round(n.x)
          , t = Math.round(n.y)
          , r = Math.round(n.width + n.x - e)
          , s = Math.round(n.height + n.y - t);
        return {
            ...n,
            x: e,
            y: t,
            width: r,
            height: s
        }
    }
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class bB {
        constructor(e, t, r, ...s) {
            b(this, ti);
            b(this, al);
            b(this, fp);
            b(this, ca);
            b(this, Io);
            b(this, pp);
            b(this, mp);
            b(this, Oo, pt.create());
            b(this, rn);
            b(this, Ro);
            b(this, ol, []);
            b(this, gp, () => {
                var e;
                this.terminate((e = o(this, Ro)) == null ? void 0 : e.reason)
            }
            );
            var i;
            switch (S(this, ti, e),
            S(this, al, t.polling),
            S(this, fp, t.root),
            S(this, Ro, t.signal),
            (i = o(this, Ro)) == null || i.addEventListener("abort", o(this, gp), {
                once: !0
            }),
            typeof r) {
            case "string":
                S(this, ca, `() => {return (${r});}`);
                break;
            default:
                S(this, ca, is(r));
                break
            }
            S(this, Io, s),
            o(this, ti).taskManager.add(this),
            t.timeout && (S(this, mp, new Qg(`Waiting failed: ${t.timeout}ms exceeded`)),
            S(this, pp, setTimeout( () => {
                this.terminate(o(this, mp))
            }
            , t.timeout))),
            this.rerun()
        }
        get result() {
            return o(this, Oo).valueOrThrow()
        }
        async rerun() {
            for (const t of o(this, ol))
                t.abort();
            o(this, ol).length = 0;
            const e = new AbortController;
            o(this, ol).push(e);
            try {
                switch (o(this, al)) {
                case "raf":
                    S(this, rn, await o(this, ti).evaluateHandle( ({RAFPoller: r, createFunction: s}, i, ...a) => {
                        const c = s(i);
                        return new r( () => c(...a))
                    }
                    , Jr.create(r => r.puppeteerUtil), o(this, ca), ...o(this, Io)));
                    break;
                case "mutation":
                    S(this, rn, await o(this, ti).evaluateHandle( ({MutationPoller: r, createFunction: s}, i, a, ...c) => {
                        const u = s(a);
                        return new r( () => u(...c),i || document)
                    }
                    , Jr.create(r => r.puppeteerUtil), o(this, fp), o(this, ca), ...o(this, Io)));
                    break;
                default:
                    S(this, rn, await o(this, ti).evaluateHandle( ({IntervalPoller: r, createFunction: s}, i, a, ...c) => {
                        const u = s(a);
                        return new r( () => u(...c),i)
                    }
                    , Jr.create(r => r.puppeteerUtil), o(this, al), o(this, ca), ...o(this, Io)));
                    break
                }
                await o(this, rn).evaluate(r => {
                    r.start()
                }
                );
                const t = await o(this, rn).evaluateHandle(r => r.result());
                o(this, Oo).resolve(t),
                await this.terminate()
            } catch (t) {
                if (e.signal.aborted)
                    return;
                const r = this.getBadError(t);
                r && await this.terminate(r)
            }
        }
        async terminate(e) {
            var t;
            if (o(this, ti).taskManager.delete(this),
            (t = o(this, Ro)) == null || t.removeEventListener("abort", o(this, gp)),
            clearTimeout(o(this, pp)),
            e && !o(this, Oo).finished() && o(this, Oo).reject(e),
            o(this, rn))
                try {
                    await o(this, rn).evaluate(async r => {
                        await r.stop()
                    }
                    ),
                    o(this, rn) && (await o(this, rn).dispose(),
                    S(this, rn, void 0))
                } catch {}
        }
        getBadError(e) {
            return hn(e) ? e.message.includes("Execution context is not available in detached frame") ? new Error("Waiting failed: Frame detached") : e.message.includes("Execution context was destroyed") || e.message.includes("Cannot find context with specified id") || e.message.includes("DiscardedBrowsingContextError") ? void 0 : e : new Error("WaitTask failed with an error",{
                cause: e
            })
        }
    }
    ti = new WeakMap,
    al = new WeakMap,
    fp = new WeakMap,
    ca = new WeakMap,
    Io = new WeakMap,
    pp = new WeakMap,
    mp = new WeakMap,
    Oo = new WeakMap,
    rn = new WeakMap,
    Ro = new WeakMap,
    ol = new WeakMap,
    gp = new WeakMap;
    class vB {
        constructor() {
            b(this, ua, new Set)
        }
        add(e) {
            o(this, ua).add(e)
        }
        delete(e) {
            o(this, ua).delete(e)
        }
        terminateAll(e) {
            for (const t of o(this, ua))
                t.terminate(e);
            o(this, ua).clear()
        }
        async rerunAll() {
            await Promise.all([...o(this, ua)].map(e => e.rerun()))
        }
    }
    ua = new WeakMap;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    let xP = (jN = class {
        constructor(e) {
            J(this, "timeoutSettings");
            J(this, "taskManager", new vB);
            b(this, yp, !1);
            this.timeoutSettings = e
        }
        async waitForFunction(e, t={}, ...r) {
            const {polling: s="raf", timeout: i=this.timeoutSettings.timeout(), root: a, signal: c} = t;
            if (typeof s == "number" && s < 0)
                throw new Error("Cannot poll with non-positive interval");
            return await new bB(this,{
                polling: s,
                root: a,
                timeout: i,
                signal: c
            },e,...r).result
        }
        get disposed() {
            return o(this, yp)
        }
        dispose() {
            S(this, yp, !0),
            this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."))
        }
        [Ce]() {
            this.dispose()
        }
    }
    ,
    yp = new WeakMap,
    jN);
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var ar;
    (function(n) {
        n.PAGE = "page",
        n.BACKGROUND_PAGE = "background_page",
        n.SERVICE_WORKER = "service_worker",
        n.SHARED_WORKER = "shared_worker",
        n.BROWSER = "browser",
        n.WEBVIEW = "webview",
        n.OTHER = "other",
        n.TAB = "tab"
    }
    )(ar || (ar = {}));
    class qd {
        constructor() {}
        async worker() {
            return null
        }
        async page() {
            return null
        }
    }
    /**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class CP extends be {
        constructor(t) {
            super();
            J(this, "timeoutSettings", new Gv);
            b(this, wp);
            S(this, wp, t)
        }
        url() {
            return o(this, wp)
        }
        async evaluate(t, ...r) {
            return t = Wt(this.evaluate.name, t),
            await this.mainRealm().evaluate(t, ...r)
        }
        async evaluateHandle(t, ...r) {
            return t = Wt(this.evaluateHandle.name, t),
            await this.mainRealm().evaluateHandle(t, ...r)
        }
        async close() {
            throw new Oe("WebWorker.close() is not supported")
        }
    }
    wp = new WeakMap;
    /**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var _B = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , SB = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    class kP {
        constructor(e, t="") {
            b(this, la);
            b(this, bp);
            S(this, la, e),
            S(this, bp, t)
        }
        async snapshot(e={}) {
            const {interestingOnly: t=!0, root: r=null, includeIframes: s=!1} = e
              , {nodes: i} = await o(this, la).environment.client.send("Accessibility.getFullAXTree", {
                frameId: o(this, bp)
            });
            let a;
            if (r) {
                const {node: h} = await o(this, la).environment.client.send("DOM.describeNode", {
                    objectId: r.id
                });
                a = h.backendNodeId
            }
            const c = Zv.createTree(o(this, la), i)
              , u = async h => {
                var f;
                if (((f = h.payload.role) == null ? void 0 : f.value) === "Iframe") {
                    const p = {
                        stack: [],
                        error: void 0,
                        hasError: !1
                    };
                    try {
                        if (!h.payload.backendDOMNodeId)
                            return;
                        const g = _B(p, await o(this, la).adoptBackendNode(h.payload.backendDOMNodeId), !1);
                        if (!g || !("contentFrame"in g))
                            return;
                        const y = await g.contentFrame();
                        if (!y)
                            return;
                        const m = await y.accessibility.snapshot(e);
                        h.iframeSnapshot = m ?? void 0
                    } catch (g) {
                        p.error = g,
                        p.hasError = !0
                    } finally {
                        SB(p)
                    }
                }
                for (const p of h.children)
                    await u(p)
            }
            ;
            let l = c;
            if (!c || (s && await u(c),
            a && (l = c.find(h => h.payload.backendDOMNodeId === a)),
            !l))
                return null;
            if (!t)
                return this.serializeTree(l)[0] ?? null;
            const d = new Set;
            return this.collectInterestingNodes(d, c, !1),
            d.has(l) ? this.serializeTree(l, d)[0] ?? null : null
        }
        serializeTree(e, t) {
            const r = [];
            for (const i of e.children)
                r.push(...this.serializeTree(i, t));
            if (t && !t.has(e))
                return r;
            const s = e.serialize();
            return r.length && (s.children = r),
            e.iframeSnapshot && (s.children || (s.children = []),
            s.children.push(e.iframeSnapshot)),
            [s]
        }
        collectInterestingNodes(e, t, r) {
            if ((t.isInteresting(r) || t.iframeSnapshot) && e.add(t),
            !t.isLeafNode()) {
                r = r || t.isControl();
                for (const s of t.children)
                    this.collectInterestingNodes(e, s, r)
            }
        }
    }
    la = new WeakMap,
    bp = new WeakMap;
    const ax = class ax {
        constructor(e, t) {
            b(this, ri);
            J(this, "payload");
            J(this, "children", []);
            J(this, "iframeSnapshot");
            b(this, cl, !1);
            b(this, vp, !1);
            b(this, Mo, !1);
            b(this, _p, !1);
            b(this, No);
            b(this, nn);
            b(this, Sp);
            b(this, $o);
            b(this, Ep);
            this.payload = t,
            S(this, No, this.payload.name ? this.payload.name.value : ""),
            S(this, nn, this.payload.role ? this.payload.role.value : "Unknown"),
            S(this, Sp, this.payload.ignored),
            S(this, Ep, e);
            for (const r of this.payload.properties || [])
                r.name === "editable" && (S(this, cl, r.value.value === "richtext"),
                S(this, vp, !0)),
                r.name === "focusable" && S(this, Mo, r.value.value),
                r.name === "hidden" && S(this, _p, r.value.value)
        }
        find(e) {
            if (e(this))
                return this;
            for (const t of this.children) {
                const r = t.find(e);
                if (r)
                    return r
            }
            return null
        }
        isLeafNode() {
            if (!this.children.length || P(this, ri, i$).call(this) || P(this, ri, a$).call(this))
                return !0;
            switch (o(this, nn)) {
            case "doc-cover":
            case "graphics-symbol":
            case "img":
            case "image":
            case "Meter":
            case "scrollbar":
            case "slider":
            case "separator":
            case "progressbar":
                return !0
            }
            return P(this, ri, Ax).call(this) ? !1 : !!(o(this, Mo) && o(this, No) || o(this, nn) === "heading" && o(this, No))
        }
        isControl() {
            switch (o(this, nn)) {
            case "button":
            case "checkbox":
            case "ColorWell":
            case "combobox":
            case "DisclosureTriangle":
            case "listbox":
            case "menu":
            case "menubar":
            case "menuitem":
            case "menuitemcheckbox":
            case "menuitemradio":
            case "radio":
            case "scrollbar":
            case "searchbox":
            case "slider":
            case "spinbutton":
            case "switch":
            case "tab":
            case "textbox":
            case "tree":
            case "treeitem":
                return !0;
            default:
                return !1
            }
        }
        isInteresting(e) {
            return o(this, nn) === "Ignored" || o(this, _p) || o(this, Sp) ? !1 : o(this, Mo) || o(this, cl) || this.isControl() ? !0 : e ? !1 : this.isLeafNode() && !!o(this, No)
        }
        serialize() {
            const e = new Map;
            for (const f of this.payload.properties || [])
                e.set(f.name.toLowerCase(), f.value.value);
            this.payload.name && e.set("name", this.payload.name.value),
            this.payload.value && e.set("value", this.payload.value.value),
            this.payload.description && e.set("description", this.payload.description.value);
            const t = {
                role: o(this, nn),
                elementHandle: async () => this.payload.backendDOMNodeId ? await o(this, Ep).adoptBackendNode(this.payload.backendDOMNodeId) : null
            }
              , r = ["name", "value", "description", "keyshortcuts", "roledescription", "valuetext"]
              , s = f => e.get(f);
            for (const f of r)
                e.has(f) && (t[f] = s(f));
            const i = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"]
              , a = f => e.get(f);
            for (const f of i)
                f === "focused" && o(this, nn) === "RootWebArea" || !a(f) || (t[f] = a(f));
            const c = ["checked", "pressed"];
            for (const f of c) {
                if (!e.has(f))
                    continue;
                const p = e.get(f);
                t[f] = p === "mixed" ? "mixed" : p === "true"
            }
            const u = ["level", "valuemax", "valuemin"]
              , l = f => e.get(f);
            for (const f of u)
                e.has(f) && (t[f] = l(f));
            const d = ["autocomplete", "haspopup", "invalid", "orientation"]
              , h = f => e.get(f);
            for (const f of d) {
                const p = h(f);
                !p || p === "false" || (t[f] = h(f))
            }
            return t
        }
        static createTree(e, t) {
            const r = new Map;
            for (const s of t)
                r.set(s.nodeId, new ax(e,s));
            for (const s of r.values())
                for (const i of s.payload.childIds || []) {
                    const a = r.get(i);
                    a && s.children.push(a)
                }
            return r.values().next().value ?? null
        }
    }
    ;
    cl = new WeakMap,
    vp = new WeakMap,
    Mo = new WeakMap,
    _p = new WeakMap,
    No = new WeakMap,
    nn = new WeakMap,
    Sp = new WeakMap,
    $o = new WeakMap,
    Ep = new WeakMap,
    ri = new WeakSet,
    i$ = function() {
        return o(this, cl) ? !1 : o(this, vp) ? !0 : o(this, nn) === "textbox" || o(this, nn) === "searchbox"
    }
    ,
    a$ = function() {
        const e = o(this, nn);
        return e === "LineBreak" || e === "text" || e === "InlineTextBox" || e === "StaticText"
    }
    ,
    Ax = function() {
        var e;
        if (o(this, $o) === void 0) {
            S(this, $o, !1);
            for (const t of this.children)
                if (o(t, Mo) || P(e = t, ri, Ax).call(e)) {
                    S(this, $o, !0);
                    break
                }
        }
        return o(this, $o)
    }
    ;
    let Zv = ax;
    var EB = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , xB = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    class wy {
        constructor(e, t, r) {
            b(this, ni);
            b(this, xp);
            b(this, Cp);
            S(this, ni, e),
            S(this, xp, t),
            S(this, Cp, r)
        }
        get name() {
            return o(this, ni)
        }
        get initSource() {
            return o(this, Cp)
        }
        async run(e, t, r, s) {
            const i = new Ot;
            try {
                if (!s) {
                    const a = {
                        stack: [],
                        error: void 0,
                        hasError: !1
                    };
                    try {
                        const u = await EB(a, await e.evaluateHandle( (l, d) => globalThis[l].args.get(d), o(this, ni), t), !1).getProperties();
                        for (const [l,d] of u)
                            if (l in r)
                                switch (d.remoteObject().subtype) {
                                case "node":
                                    r[+l] = d;
                                    break;
                                default:
                                    i.use(d)
                                }
                            else
                                i.use(d)
                    } catch (c) {
                        a.error = c,
                        a.hasError = !0
                    } finally {
                        xB(a)
                    }
                }
                await e.evaluate( (a, c, u) => {
                    const l = globalThis[a].callbacks;
                    l.get(c).resolve(u),
                    l.delete(c)
                }
                , o(this, ni), t, await o(this, xp).call(this, ...r));
                for (const a of r)
                    a instanceof Xa && i.use(a)
            } catch (a) {
                hn(a) ? await e.evaluate( (c, u, l, d) => {
                    const h = new Error(l);
                    h.stack = d;
                    const f = globalThis[c].callbacks;
                    f.get(u).reject(h),
                    f.delete(u)
                }
                , o(this, ni), t, a.message, a.stack).catch(ge) : await e.evaluate( (c, u, l) => {
                    const d = globalThis[c].callbacks;
                    d.get(u).reject(l),
                    d.delete(u)
                }
                , o(this, ni), t, a).catch(ge)
            }
        }
    }
    ni = new WeakMap,
    xp = new WeakMap,
    Cp = new WeakMap;
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Xv {
        constructor(e, t, r, s, i) {
            b(this, kp);
            b(this, Pp);
            b(this, Tp);
            b(this, ul);
            b(this, ll);
            S(this, kp, e),
            S(this, Pp, t),
            S(this, Tp, r),
            S(this, ul, s),
            S(this, ll, i)
        }
        type() {
            return o(this, kp)
        }
        text() {
            return o(this, Pp)
        }
        args() {
            return o(this, Tp)
        }
        location() {
            return o(this, ul)[0] ?? (o(this, ll) ? {
                url: o(this, ll).url()
            } : {})
        }
        stackTrace() {
            return o(this, ul)
        }
    }
    kp = new WeakMap,
    Pp = new WeakMap,
    Tp = new WeakMap,
    ul = new WeakMap,
    ll = new WeakMap;
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class CB {
        constructor(e, t) {
            b(this, dl);
            b(this, Ap);
            b(this, Lo, !1);
            S(this, dl, e),
            S(this, Ap, t.mode !== "selectSingle")
        }
        isMultiple() {
            return o(this, Ap)
        }
        async accept(e) {
            ne(!o(this, Lo), "Cannot accept FileChooser which is already handled!"),
            S(this, Lo, !0),
            await o(this, dl).uploadFile(...e)
        }
        async cancel() {
            ne(!o(this, Lo), "Cannot cancel FileChooser which is already handled!"),
            S(this, Lo, !0),
            await o(this, dl).evaluate(e => {
                e.dispatchEvent(new Event("cancel",{
                    bubbles: !0
                }))
            }
            )
        }
    }
    dl = new WeakMap,
    Ap = new WeakMap,
    Lo = new WeakMap;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var zt;
    (function(n) {
        n.Request = Symbol("NetworkManager.Request"),
        n.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache"),
        n.Response = Symbol("NetworkManager.Response"),
        n.RequestFailed = Symbol("NetworkManager.RequestFailed"),
        n.RequestFinished = Symbol("NetworkManager.RequestFinished")
    }
    )(zt || (zt = {}));
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Yv {
        constructor() {
            b(this, _n, new Map);
            b(this, kb, mP())
        }
        create(e, t, r) {
            const s = new kB(o(this, kb).call(this),e,t);
            o(this, _n).set(s.id, s);
            try {
                r(s.id)
            } catch (i) {
                throw s.promise.catch(ge).finally( () => {
                    o(this, _n).delete(s.id)
                }
                ),
                s.reject(i),
                i
            }
            return s.promise.finally( () => {
                o(this, _n).delete(s.id)
            }
            )
        }
        reject(e, t, r) {
            const s = o(this, _n).get(e);
            s && this._reject(s, t, r)
        }
        rejectRaw(e, t) {
            const r = o(this, _n).get(e);
            r && r.reject(t)
        }
        _reject(e, t, r) {
            let s, i;
            t instanceof Ga ? (s = t,
            s.cause = e.error,
            i = t.message) : (s = e.error,
            i = t),
            e.reject(rP(s, `Protocol error (${e.label}): ${i}`, r))
        }
        resolve(e, t) {
            const r = o(this, _n).get(e);
            r && r.resolve(t)
        }
        clear() {
            for (const e of o(this, _n).values())
                this._reject(e, new xn("Target closed"));
            o(this, _n).clear()
        }
        getPendingProtocolErrors() {
            const e = [];
            for (const t of o(this, _n).values())
                e.push(new Error(`${t.label} timed out. Trace: ${t.error.stack}`));
            return e
        }
    }
    _n = new WeakMap,
    kb = new WeakMap;
    class kB {
        constructor(e, t, r) {
            b(this, Ip);
            b(this, Op, new Ga);
            b(this, Fo, pt.create());
            b(this, hl);
            b(this, Rp);
            S(this, Ip, e),
            S(this, Rp, t),
            r && S(this, hl, setTimeout( () => {
                o(this, Fo).reject(rP(o(this, Op), `${t} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`))
            }
            , r))
        }
        resolve(e) {
            clearTimeout(o(this, hl)),
            o(this, Fo).resolve(e)
        }
        reject(e) {
            clearTimeout(o(this, hl)),
            o(this, Fo).reject(e)
        }
        get id() {
            return o(this, Ip)
        }
        get promise() {
            return o(this, Fo).valueOrThrow()
        }
        get error() {
            return o(this, Op)
        }
        get label() {
            return o(this, Rp)
        }
    }
    Ip = new WeakMap,
    Op = new WeakMap,
    Fo = new WeakMap,
    hl = new WeakMap,
    Rp = new WeakMap;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class zc extends Ld {
        constructor(t, r, s, i, a) {
            super();
            b(this, jo);
            b(this, fl);
            b(this, si, new Yv);
            b(this, Zn);
            b(this, pl);
            b(this, ml);
            b(this, Mp, !1);
            S(this, Zn, t),
            S(this, fl, r),
            S(this, jo, s),
            S(this, pl, i),
            S(this, Mp, a)
        }
        _setTarget(t) {
            S(this, ml, t)
        }
        _target() {
            return ne(o(this, ml), "Target must exist"),
            o(this, ml)
        }
        connection() {
            return o(this, Zn)
        }
        parentSession() {
            var r;
            return o(this, pl) ? ((r = o(this, Zn)) == null ? void 0 : r.session(o(this, pl))) ?? void 0 : this
        }
        send(t, r, s) {
            return o(this, Zn) ? o(this, Zn)._rawSend(o(this, si), t, r, o(this, jo), s) : Promise.reject(new xn(`Protocol error (${t}): Session closed. Most likely the ${o(this, fl)} has been closed.`))
        }
        _onMessage(t) {
            t.id ? t.error ? o(this, Mp) ? o(this, si).rejectRaw(t.id, t.error) : o(this, si).reject(t.id, nP(t), t.error.message) : o(this, si).resolve(t.id, t.result) : (ne(!t.id),
            this.emit(t.method, t.params))
        }
        async detach() {
            if (!o(this, Zn))
                throw new Error(`Session already detached. Most likely the ${o(this, fl)} has been closed.`);
            await o(this, Zn).send("Target.detachFromTarget", {
                sessionId: o(this, jo)
            })
        }
        _onClosed() {
            o(this, si).clear(),
            S(this, Zn, void 0),
            this.emit(yt.Disconnected, void 0)
        }
        id() {
            return o(this, jo)
        }
        getPendingProtocolErrors() {
            return o(this, si).getPendingProtocolErrors()
        }
    }
    jo = new WeakMap,
    fl = new WeakMap,
    si = new WeakMap,
    Zn = new WeakMap,
    pl = new WeakMap,
    ml = new WeakMap,
    Mp = new WeakMap;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const PB = Dc("puppeteer:protocol:SEND ")
      , TB = Dc("puppeteer:protocol:RECV ");
    class PP extends be {
        constructor(t, r, s=0, i, a=!1) {
            super();
            b(this, $p);
            b(this, Np);
            b(this, Es);
            b(this, Do);
            b(this, gl);
            b(this, kr, new Map);
            b(this, Bo, !1);
            b(this, yl, new Set);
            b(this, xs);
            b(this, wl, !1);
            S(this, wl, a),
            S(this, xs, new Yv),
            S(this, Np, t),
            S(this, Do, s),
            S(this, gl, i ?? 18e4),
            S(this, Es, r),
            o(this, Es).onmessage = this.onMessage.bind(this),
            o(this, Es).onclose = P(this, $p, Ix).bind(this)
        }
        static fromSession(t) {
            return t.connection()
        }
        get delay() {
            return o(this, Do)
        }
        get timeout() {
            return o(this, gl)
        }
        get _closed() {
            return o(this, Bo)
        }
        get _sessions() {
            return o(this, kr)
        }
        session(t) {
            return o(this, kr).get(t) || null
        }
        url() {
            return o(this, Np)
        }
        send(t, r, s) {
            return this._rawSend(o(this, xs), t, r, void 0, s)
        }
        _rawSend(t, r, s, i, a) {
            return o(this, Bo) ? Promise.reject(new Error("Protocol error: Connection closed.")) : t.create(r, (a == null ? void 0 : a.timeout) ?? o(this, gl), c => {
                const u = JSON.stringify({
                    method: r,
                    params: s,
                    id: c,
                    sessionId: i
                });
                PB(u),
                o(this, Es).send(u)
            }
            )
        }
        async closeBrowser() {
            await this.send("Browser.close")
        }
        async onMessage(t) {
            o(this, Do) && await new Promise(s => setTimeout(s, o(this, Do))),
            TB(t);
            const r = JSON.parse(t);
            if (r.method === "Target.attachedToTarget") {
                const s = r.params.sessionId
                  , i = new zc(this,r.params.targetInfo.type,s,r.sessionId,o(this, wl));
                o(this, kr).set(s, i),
                this.emit(yt.SessionAttached, i);
                const a = o(this, kr).get(r.sessionId);
                a && a.emit(yt.SessionAttached, i)
            } else if (r.method === "Target.detachedFromTarget") {
                const s = o(this, kr).get(r.params.sessionId);
                if (s) {
                    s._onClosed(),
                    o(this, kr).delete(r.params.sessionId),
                    this.emit(yt.SessionDetached, s);
                    const i = o(this, kr).get(r.sessionId);
                    i && i.emit(yt.SessionDetached, s)
                }
            }
            if (r.sessionId) {
                const s = o(this, kr).get(r.sessionId);
                s && s._onMessage(r)
            } else
                r.id ? r.error ? o(this, wl) ? o(this, xs).rejectRaw(r.id, r.error) : o(this, xs).reject(r.id, nP(r), r.error.message) : o(this, xs).resolve(r.id, r.result) : this.emit(r.method, r.params)
        }
        dispose() {
            P(this, $p, Ix).call(this),
            o(this, Es).close()
        }
        isAutoAttached(t) {
            return !o(this, yl).has(t)
        }
        async _createSession(t, r=!0) {
            r || o(this, yl).add(t.targetId);
            const {sessionId: s} = await this.send("Target.attachToTarget", {
                targetId: t.targetId,
                flatten: !0
            });
            o(this, yl).delete(t.targetId);
            const i = o(this, kr).get(s);
            if (!i)
                throw new Error("CDPSession creation failed.");
            return i
        }
        async createSession(t) {
            return await this._createSession(t, !1)
        }
        getPendingProtocolErrors() {
            const t = [];
            t.push(...o(this, xs).getPendingProtocolErrors());
            for (const r of o(this, kr).values())
                t.push(...r.getPendingProtocolErrors());
            return t
        }
    }
    Np = new WeakMap,
    Es = new WeakMap,
    Do = new WeakMap,
    gl = new WeakMap,
    kr = new WeakMap,
    Bo = new WeakMap,
    yl = new WeakMap,
    xs = new WeakMap,
    wl = new WeakMap,
    $p = new WeakSet,
    Ix = function() {
        if (!o(this, Bo)) {
            S(this, Bo, !0),
            o(this, Es).onmessage = void 0,
            o(this, Es).onclose = void 0,
            o(this, xs).clear();
            for (const t of o(this, kr).values())
                t._onClosed();
            o(this, kr).clear(),
            this.emit(yt.Disconnected, void 0)
        }
    }
    ;
    function Qv(n) {
        return n instanceof xn
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class TP {
        constructor(e) {
            b(this, qo);
            b(this, Uo);
            S(this, qo, new AB(e)),
            S(this, Uo, new IB(e))
        }
        updateClient(e) {
            o(this, qo).updateClient(e),
            o(this, Uo).updateClient(e)
        }
        async startJSCoverage(e={}) {
            return await o(this, qo).start(e)
        }
        async stopJSCoverage() {
            return await o(this, qo).stop()
        }
        async startCSSCoverage(e={}) {
            return await o(this, Uo).start(e)
        }
        async stopCSSCoverage() {
            return await o(this, Uo).stop()
        }
    }
    qo = new WeakMap,
    Uo = new WeakMap;
    class AB {
        constructor(e) {
            b(this, Sl);
            b(this, Pr);
            b(this, Ko, !1);
            b(this, Ho, new Map);
            b(this, Wo, new Map);
            b(this, bl);
            b(this, Lp, !1);
            b(this, vl, !1);
            b(this, _l, !1);
            S(this, Pr, e)
        }
        updateClient(e) {
            S(this, Pr, e)
        }
        async start(e={}) {
            ne(!o(this, Ko), "JSCoverage is already enabled");
            const {resetOnNavigation: t=!0, reportAnonymousScripts: r=!1, includeRawScriptCoverage: s=!1, useBlockCoverage: i=!0} = e;
            S(this, Lp, t),
            S(this, vl, r),
            S(this, _l, s),
            S(this, Ko, !0),
            o(this, Ho).clear(),
            o(this, Wo).clear(),
            S(this, bl, new Ot);
            const a = o(this, bl).use(new be(o(this, Pr)));
            a.on("Debugger.scriptParsed", P(this, Sl, c$).bind(this)),
            a.on("Runtime.executionContextsCleared", P(this, Sl, o$).bind(this)),
            await Promise.all([o(this, Pr).send("Profiler.enable"), o(this, Pr).send("Profiler.startPreciseCoverage", {
                callCount: o(this, _l),
                detailed: i
            }), o(this, Pr).send("Debugger.enable"), o(this, Pr).send("Debugger.setSkipAllPauses", {
                skip: !0
            })])
        }
        async stop() {
            var s;
            ne(o(this, Ko), "JSCoverage is not enabled"),
            S(this, Ko, !1);
            const e = await Promise.all([o(this, Pr).send("Profiler.takePreciseCoverage"), o(this, Pr).send("Profiler.stopPreciseCoverage"), o(this, Pr).send("Profiler.disable"), o(this, Pr).send("Debugger.disable")]);
            (s = o(this, bl)) == null || s.dispose();
            const t = []
              , r = e[0];
            for (const i of r.result) {
                let a = o(this, Ho).get(i.scriptId);
                !a && o(this, vl) && (a = "debugger://VM" + i.scriptId);
                const c = o(this, Wo).get(i.scriptId);
                if (c === void 0 || a === void 0)
                    continue;
                const u = [];
                for (const d of i.functions)
                    u.push(...d.ranges);
                const l = AP(u);
                o(this, _l) ? t.push({
                    url: a,
                    ranges: l,
                    text: c,
                    rawScriptCoverage: i
                }) : t.push({
                    url: a,
                    ranges: l,
                    text: c
                })
            }
            return t
        }
    }
    Pr = new WeakMap,
    Ko = new WeakMap,
    Ho = new WeakMap,
    Wo = new WeakMap,
    bl = new WeakMap,
    Lp = new WeakMap,
    vl = new WeakMap,
    _l = new WeakMap,
    Sl = new WeakSet,
    o$ = function() {
        o(this, Lp) && (o(this, Ho).clear(),
        o(this, Wo).clear())
    }
    ,
    c$ = async function(e) {
        if (!Gr.isPuppeteerURL(e.url) && !(!e.url && !o(this, vl)))
            try {
                const t = await o(this, Pr).send("Debugger.getScriptSource", {
                    scriptId: e.scriptId
                });
                o(this, Ho).set(e.scriptId, e.url),
                o(this, Wo).set(e.scriptId, t.scriptSource)
            } catch (t) {
                ge(t)
            }
    }
    ;
    class IB {
        constructor(e) {
            b(this, xl);
            b(this, sn);
            b(this, zo, !1);
            b(this, da, new Map);
            b(this, Vo, new Map);
            b(this, El);
            b(this, Fp, !1);
            S(this, sn, e)
        }
        updateClient(e) {
            S(this, sn, e)
        }
        async start(e={}) {
            ne(!o(this, zo), "CSSCoverage is already enabled");
            const {resetOnNavigation: t=!0} = e;
            S(this, Fp, t),
            S(this, zo, !0),
            o(this, da).clear(),
            o(this, Vo).clear(),
            S(this, El, new Ot);
            const r = o(this, El).use(new be(o(this, sn)));
            r.on("CSS.styleSheetAdded", P(this, xl, l$).bind(this)),
            r.on("Runtime.executionContextsCleared", P(this, xl, u$).bind(this)),
            await Promise.all([o(this, sn).send("DOM.enable"), o(this, sn).send("CSS.enable"), o(this, sn).send("CSS.startRuleUsageTracking")])
        }
        async stop() {
            var s;
            ne(o(this, zo), "CSSCoverage is not enabled"),
            S(this, zo, !1);
            const e = await o(this, sn).send("CSS.stopRuleUsageTracking");
            await Promise.all([o(this, sn).send("CSS.disable"), o(this, sn).send("DOM.disable")]),
            (s = o(this, El)) == null || s.dispose();
            const t = new Map;
            for (const i of e.ruleUsage) {
                let a = t.get(i.styleSheetId);
                a || (a = [],
                t.set(i.styleSheetId, a)),
                a.push({
                    startOffset: i.startOffset,
                    endOffset: i.endOffset,
                    count: i.used ? 1 : 0
                })
            }
            const r = [];
            for (const i of o(this, da).keys()) {
                const a = o(this, da).get(i);
                ne(typeof a < "u", `Stylesheet URL is undefined (styleSheetId=${i})`);
                const c = o(this, Vo).get(i);
                ne(typeof c < "u", `Stylesheet text is undefined (styleSheetId=${i})`);
                const u = AP(t.get(i) || []);
                r.push({
                    url: a,
                    ranges: u,
                    text: c
                })
            }
            return r
        }
    }
    sn = new WeakMap,
    zo = new WeakMap,
    da = new WeakMap,
    Vo = new WeakMap,
    El = new WeakMap,
    Fp = new WeakMap,
    xl = new WeakSet,
    u$ = function() {
        o(this, Fp) && (o(this, da).clear(),
        o(this, Vo).clear())
    }
    ,
    l$ = async function(e) {
        const t = e.header;
        if (t.sourceURL)
            try {
                const r = await o(this, sn).send("CSS.getStyleSheetText", {
                    styleSheetId: t.styleSheetId
                });
                o(this, da).set(t.styleSheetId, t.sourceURL),
                o(this, Vo).set(t.styleSheetId, r.text)
            } catch (r) {
                ge(r)
            }
    }
    ;
    function AP(n) {
        const e = [];
        for (const i of n)
            e.push({
                offset: i.startOffset,
                type: 0,
                range: i
            }),
            e.push({
                offset: i.endOffset,
                type: 1,
                range: i
            });
        e.sort( (i, a) => {
            if (i.offset !== a.offset)
                return i.offset - a.offset;
            if (i.type !== a.type)
                return a.type - i.type;
            const c = i.range.endOffset - i.range.startOffset
              , u = a.range.endOffset - a.range.startOffset;
            return i.type === 0 ? u - c : c - u
        }
        );
        const t = []
          , r = [];
        let s = 0;
        for (const i of e) {
            if (t.length && s < i.offset && t[t.length - 1] > 0) {
                const a = r[r.length - 1];
                a && a.end === s ? a.end = i.offset : r.push({
                    start: s,
                    end: i.offset
                })
            }
            s = i.offset,
            i.type === 0 ? t.push(i.range.count) : t.pop()
        }
        return r.filter(i => i.end - i.start > 0)
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class OB extends tP {
        constructor(t, r, s, i="") {
            super(r, s, i);
            b(this, jp);
            S(this, jp, t)
        }
        async handle(t) {
            await o(this, jp).send("Page.handleJavaScriptDialog", {
                accept: t.accept,
                promptText: t.text
            })
        }
    }
    jp = new WeakMap;
    var RB = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , cs = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , us = function(n, e, t) {
        return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
        Object.defineProperty(n, "name", {
            configurable: !0,
            value: t ? "".concat(t, " ", e) : e
        })
    };
    class ls {
        constructor(e, t, r) {
            b(this, Go);
            b(this, Cl);
            b(this, Dp);
            S(this, Go, e),
            S(this, Cl, t),
            S(this, Dp, r),
            o(this, Cl).registerState(this)
        }
        async setState(e) {
            S(this, Go, e),
            await this.sync()
        }
        get state() {
            return o(this, Go)
        }
        async sync() {
            await Promise.all(o(this, Cl).clients().map(e => o(this, Dp).call(this, e, o(this, Go))))
        }
    }
    Go = new WeakMap,
    Cl = new WeakMap,
    Dp = new WeakMap;
    let IP = ( () => {
        var A, C, k, x, N, R, F, O, T, L, q, Z, j, $, B, D, Ox, Rx, Mx, Nx, $x, Lx, Fx, jx, Dx, Bx, I;
        let n = [], e, t, r, s, i, a, c, u, l, d, h, f, p, g, y, m, w, E, v, _;
        return I = class {
            constructor(U) {
                b(this, D);
                b(this, A, RB(this, n));
                b(this, C, !1);
                b(this, k, !1);
                b(this, x, []);
                b(this, N, new ls({
                    active: !1
                },this,o(this, D, Ox)));
                b(this, R, new ls({
                    active: !1
                },this,o(this, D, Rx)));
                b(this, F, new ls({
                    active: !1
                },this,o(this, D, Mx)));
                b(this, O, new ls({
                    active: !1
                },this,o(this, D, Nx)));
                b(this, T, new ls({
                    active: !1
                },this,o(this, D, $x)));
                b(this, L, new ls({
                    active: !1
                },this,o(this, D, Lx)));
                b(this, q, new ls({
                    active: !1
                },this,o(this, D, Fx)));
                b(this, Z, new ls({
                    active: !1
                },this,o(this, D, jx)));
                b(this, j, new ls({
                    active: !1
                },this,o(this, D, Dx)));
                b(this, $, new ls({
                    javaScriptEnabled: !0,
                    active: !1
                },this,o(this, D, Bx)));
                b(this, B, new Set);
                S(this, A, U)
            }
            updateClient(U) {
                S(this, A, U),
                o(this, B).delete(U)
            }
            registerState(U) {
                o(this, x).push(U)
            }
            clients() {
                return [o(this, A), ...Array.from(o(this, B))]
            }
            async registerSpeculativeSession(U) {
                o(this, B).add(U),
                U.once(yt.Disconnected, () => {
                    o(this, B).delete(U)
                }
                ),
                Promise.all(o(this, x).map(W => W.sync().catch(ge)))
            }
            get javascriptEnabled() {
                return o(this, $).state.javaScriptEnabled
            }
            async emulateViewport(U) {
                const W = o(this, N).state;
                if (!U && !W.active)
                    return !1;
                await o(this, N).setState(U ? {
                    viewport: U,
                    active: !0
                } : {
                    active: !1
                });
                const X = (U == null ? void 0 : U.isMobile) || !1
                  , te = (U == null ? void 0 : U.hasTouch) || !1
                  , ae = o(this, C) !== X || o(this, k) !== te;
                return S(this, C, X),
                S(this, k, te),
                ae
            }
            async emulateIdleState(U) {
                await o(this, R).setState({
                    active: !0,
                    overrides: U
                })
            }
            async emulateTimezone(U) {
                await o(this, F).setState({
                    timezoneId: U,
                    active: !0
                })
            }
            async emulateVisionDeficiency(U) {
                ne(!U || new Set(["none", "achromatopsia", "blurredVision", "deuteranopia", "protanopia", "reducedContrast", "tritanopia"]).has(U), `Unsupported vision deficiency: ${U}`),
                await o(this, O).setState({
                    active: !0,
                    visionDeficiency: U
                })
            }
            async emulateCPUThrottling(U) {
                ne(U === null || U >= 1, "Throttling rate should be greater or equal to 1"),
                await o(this, T).setState({
                    active: !0,
                    factor: U ?? void 0
                })
            }
            async emulateMediaFeatures(U) {
                if (Array.isArray(U))
                    for (const W of U) {
                        const X = W.name;
                        ne(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(X), "Unsupported media feature: " + X)
                    }
                await o(this, L).setState({
                    active: !0,
                    mediaFeatures: U
                })
            }
            async emulateMediaType(U) {
                ne(U === "screen" || U === "print" || (U ?? void 0) === void 0, "Unsupported media type: " + U),
                await o(this, q).setState({
                    type: U,
                    active: !0
                })
            }
            async setGeolocation(U) {
                const {longitude: W, latitude: X, accuracy: te=0} = U;
                if (W < -180 || W > 180)
                    throw new Error(`Invalid longitude "${W}": precondition -180 <= LONGITUDE <= 180 failed.`);
                if (X < -90 || X > 90)
                    throw new Error(`Invalid latitude "${X}": precondition -90 <= LATITUDE <= 90 failed.`);
                if (te < 0)
                    throw new Error(`Invalid accuracy "${te}": precondition 0 <= ACCURACY failed.`);
                await o(this, Z).setState({
                    active: !0,
                    geoLocation: {
                        longitude: W,
                        latitude: X,
                        accuracy: te
                    }
                })
            }
            async resetDefaultBackgroundColor() {
                await o(this, j).setState({
                    active: !0,
                    color: void 0
                })
            }
            async setTransparentBackgroundColor() {
                await o(this, j).setState({
                    active: !0,
                    color: {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0
                    }
                })
            }
            async setJavaScriptEnabled(U) {
                await o(this, $).setState({
                    active: !0,
                    javaScriptEnabled: U
                })
            }
        }
        ,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakMap,
        x = new WeakMap,
        N = new WeakMap,
        R = new WeakMap,
        F = new WeakMap,
        O = new WeakMap,
        T = new WeakMap,
        L = new WeakMap,
        q = new WeakMap,
        Z = new WeakMap,
        j = new WeakMap,
        $ = new WeakMap,
        B = new WeakMap,
        D = new WeakSet,
        Ox = function() {
            return t.value
        }
        ,
        Rx = function() {
            return s.value
        }
        ,
        Mx = function() {
            return a.value
        }
        ,
        Nx = function() {
            return u.value
        }
        ,
        $x = function() {
            return d.value
        }
        ,
        Lx = function() {
            return f.value
        }
        ,
        Fx = function() {
            return g.value
        }
        ,
        jx = function() {
            return m.value
        }
        ,
        Dx = function() {
            return E.value
        }
        ,
        Bx = function() {
            return _.value
        }
        ,
        ( () => {
            const U = typeof Symbol == "function" && Symbol.metadata ? Object.create(null) : void 0;
            e = [Cn],
            r = [Cn],
            i = [Cn],
            c = [Cn],
            l = [Cn],
            h = [Cn],
            p = [Cn],
            y = [Cn],
            w = [Cn],
            v = [Cn],
            cs(I, t = {
                value: us(async function(W, X) {
                    if (!X.viewport) {
                        await Promise.all([W.send("Emulation.clearDeviceMetricsOverride"), W.send("Emulation.setTouchEmulationEnabled", {
                            enabled: !1
                        })]).catch(ge);
                        return
                    }
                    const {viewport: te} = X
                      , ae = te.isMobile || !1
                      , xe = te.width
                      , ce = te.height
                      , Pe = te.deviceScaleFactor ?? 1
                      , we = te.isLandscape ? {
                        angle: 90,
                        type: "landscapePrimary"
                    } : {
                        angle: 0,
                        type: "portraitPrimary"
                    }
                      , H = te.hasTouch || !1;
                    await Promise.all([W.send("Emulation.setDeviceMetricsOverride", {
                        mobile: ae,
                        width: xe,
                        height: ce,
                        deviceScaleFactor: Pe,
                        screenOrientation: we
                    }).catch(Q => {
                        if (Q.message.includes("Target does not support metrics override")) {
                            ge(Q);
                            return
                        }
                        throw Q
                    }
                    ), W.send("Emulation.setTouchEmulationEnabled", {
                        enabled: H
                    })])
                }, "#applyViewport")
            }, e, {
                kind: "method",
                name: "#applyViewport",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Ox)
                },
                metadata: U
            }, null, n),
            cs(I, s = {
                value: us(async function(W, X) {
                    X.active && (X.overrides ? await W.send("Emulation.setIdleOverride", {
                        isUserActive: X.overrides.isUserActive,
                        isScreenUnlocked: X.overrides.isScreenUnlocked
                    }) : await W.send("Emulation.clearIdleOverride"))
                }, "#emulateIdleState")
            }, r, {
                kind: "method",
                name: "#emulateIdleState",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Rx)
                },
                metadata: U
            }, null, n),
            cs(I, a = {
                value: us(async function(W, X) {
                    if (X.active)
                        try {
                            await W.send("Emulation.setTimezoneOverride", {
                                timezoneId: X.timezoneId || ""
                            })
                        } catch (te) {
                            throw hn(te) && te.message.includes("Invalid timezone") ? new Error(`Invalid timezone ID: ${X.timezoneId}`) : te
                        }
                }, "#emulateTimezone")
            }, i, {
                kind: "method",
                name: "#emulateTimezone",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Mx)
                },
                metadata: U
            }, null, n),
            cs(I, u = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setEmulatedVisionDeficiency", {
                        type: X.visionDeficiency || "none"
                    })
                }, "#emulateVisionDeficiency")
            }, c, {
                kind: "method",
                name: "#emulateVisionDeficiency",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Nx)
                },
                metadata: U
            }, null, n),
            cs(I, d = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setCPUThrottlingRate", {
                        rate: X.factor ?? 1
                    })
                }, "#emulateCpuThrottling")
            }, l, {
                kind: "method",
                name: "#emulateCpuThrottling",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, $x)
                },
                metadata: U
            }, null, n),
            cs(I, f = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setEmulatedMedia", {
                        features: X.mediaFeatures
                    })
                }, "#emulateMediaFeatures")
            }, h, {
                kind: "method",
                name: "#emulateMediaFeatures",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Lx)
                },
                metadata: U
            }, null, n),
            cs(I, g = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setEmulatedMedia", {
                        media: X.type || ""
                    })
                }, "#emulateMediaType")
            }, p, {
                kind: "method",
                name: "#emulateMediaType",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Fx)
                },
                metadata: U
            }, null, n),
            cs(I, m = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setGeolocationOverride", X.geoLocation ? {
                        longitude: X.geoLocation.longitude,
                        latitude: X.geoLocation.latitude,
                        accuracy: X.geoLocation.accuracy
                    } : void 0)
                }, "#setGeolocation")
            }, y, {
                kind: "method",
                name: "#setGeolocation",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, jx)
                },
                metadata: U
            }, null, n),
            cs(I, E = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setDefaultBackgroundColorOverride", {
                        color: X.color
                    })
                }, "#setDefaultBackgroundColor")
            }, w, {
                kind: "method",
                name: "#setDefaultBackgroundColor",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Dx)
                },
                metadata: U
            }, null, n),
            cs(I, _ = {
                value: us(async function(W, X) {
                    X.active && await W.send("Emulation.setScriptExecutionDisabled", {
                        value: !X.javaScriptEnabled
                    })
                }, "#setJavaScriptEnabled")
            }, v, {
                kind: "method",
                name: "#setJavaScriptEnabled",
                static: !1,
                private: !0,
                access: {
                    has: W => Ir(D, W),
                    get: W => o(W, D, Bx)
                },
                metadata: U
            }, null, n),
            U && Object.defineProperty(I, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: U
            })
        }
        )(),
        I
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class MB {
        constructor(e, t, r) {
            b(this, Bp);
            b(this, qp);
            b(this, kl, new WeakMap);
            S(this, Bp, t),
            S(this, qp, r),
            o(this, kl).set(e, t)
        }
        get id() {
            return o(this, Bp)
        }
        get source() {
            return o(this, qp)
        }
        getIdForFrame(e) {
            return o(this, kl).get(e)
        }
        setIdForFrame(e, t) {
            o(this, kl).set(e, t)
        }
    }
    Bp = new WeakMap,
    qp = new WeakMap,
    kl = new WeakMap;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class NB {
        constructor(e, t) {
            J(this, "id");
            J(this, "name");
            this.id = e,
            this.name = t
        }
    }
    class $B {
        constructor(e, t, r) {
            b(this, Kp);
            b(this, an);
            b(this, Up);
            b(this, Jo);
            b(this, Zo, !1);
            b(this, Pl, P(this, Kp, qx).bind(this));
            b(this, Tl, new Set);
            J(this, "devices", []);
            S(this, an, e),
            S(this, Up, t),
            S(this, Jo, r.id),
            o(this, an).on("DeviceAccess.deviceRequestPrompted", o(this, Pl)),
            o(this, an).on("Target.detachedFromTarget", () => {
                S(this, an, null)
            }
            ),
            P(this, Kp, qx).call(this, r)
        }
        async waitForDevice(e, t={}) {
            for (const a of this.devices)
                if (e(a))
                    return a;
            const {timeout: r=o(this, Up).timeout()} = t
              , s = pt.create({
                message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${r}ms exceeded`,
                timeout: r
            });
            t.signal && t.signal.addEventListener("abort", () => {
                var a;
                s.reject((a = t.signal) == null ? void 0 : a.reason)
            }
            , {
                once: !0
            });
            const i = {
                filter: e,
                promise: s
            };
            o(this, Tl).add(i);
            try {
                return await s.valueOrThrow()
            } finally {
                o(this, Tl).delete(i)
            }
        }
        async select(e) {
            return ne(o(this, an) !== null, "Cannot select device through detached session!"),
            ne(this.devices.includes(e), "Cannot select unknown device!"),
            ne(!o(this, Zo), "Cannot select DeviceRequestPrompt which is already handled!"),
            o(this, an).off("DeviceAccess.deviceRequestPrompted", o(this, Pl)),
            S(this, Zo, !0),
            await o(this, an).send("DeviceAccess.selectPrompt", {
                id: o(this, Jo),
                deviceId: e.id
            })
        }
        async cancel() {
            return ne(o(this, an) !== null, "Cannot cancel prompt through detached session!"),
            ne(!o(this, Zo), "Cannot cancel DeviceRequestPrompt which is already handled!"),
            o(this, an).off("DeviceAccess.deviceRequestPrompted", o(this, Pl)),
            S(this, Zo, !0),
            await o(this, an).send("DeviceAccess.cancelPrompt", {
                id: o(this, Jo)
            })
        }
    }
    an = new WeakMap,
    Up = new WeakMap,
    Jo = new WeakMap,
    Zo = new WeakMap,
    Pl = new WeakMap,
    Tl = new WeakMap,
    Kp = new WeakSet,
    qx = function(e) {
        if (e.id === o(this, Jo))
            for (const t of e.devices) {
                if (this.devices.some(s => s.id === t.id))
                    continue;
                const r = new NB(t.id,t.name);
                this.devices.push(r);
                for (const s of o(this, Tl))
                    s.filter(r) && s.promise.resolve(r)
            }
    }
    ;
    class LB {
        constructor(e, t) {
            b(this, Pb);
            b(this, Xn);
            b(this, Al);
            b(this, ii, new Set);
            S(this, Xn, e),
            S(this, Al, t),
            o(this, Xn).on("DeviceAccess.deviceRequestPrompted", r => {
                P(this, Pb, d$).call(this, r)
            }
            ),
            o(this, Xn).on("Target.detachedFromTarget", () => {
                S(this, Xn, null)
            }
            )
        }
        async waitForDevicePrompt(e={}) {
            ne(o(this, Xn) !== null, "Cannot wait for device prompt through detached session!");
            const t = o(this, ii).size === 0;
            let r;
            t && (r = o(this, Xn).send("DeviceAccess.enable"));
            const {timeout: s=o(this, Al).timeout()} = e
              , i = pt.create({
                message: `Waiting for \`DeviceRequestPrompt\` failed: ${s}ms exceeded`,
                timeout: s
            });
            e.signal && e.signal.addEventListener("abort", () => {
                var a;
                i.reject((a = e.signal) == null ? void 0 : a.reason)
            }
            , {
                once: !0
            }),
            o(this, ii).add(i);
            try {
                const [a] = await Promise.all([i.valueOrThrow(), r]);
                return a
            } finally {
                o(this, ii).delete(i)
            }
        }
    }
    Xn = new WeakMap,
    Al = new WeakMap,
    ii = new WeakMap,
    Pb = new WeakSet,
    d$ = function(e) {
        if (!o(this, ii).size)
            return;
        ne(o(this, Xn) !== null);
        const t = new $B(o(this, Xn),o(this, Al),e);
        for (const r of o(this, ii))
            r.resolve(t);
        o(this, ii).clear()
    }
    ;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    function OP(n) {
        let e, t;
        if (!n.exception)
            e = "Error",
            t = n.text;
        else {
            if ((n.exception.type !== "object" || n.exception.subtype !== "error") && !n.exception.objectId)
                return Ya(n.exception);
            {
                const c = RP(n);
                e = c.name,
                t = c.message
            }
        }
        const r = t.split(`
`).length
          , s = new Error(t);
        s.name = e;
        const i = s.stack.split(`
`)
          , a = i.splice(0, r);
        if (i.shift(),
        n.stackTrace && i.length < Error.stackTraceLimit)
            for (const c of n.stackTrace.callFrames.reverse()) {
                if (Gr.isPuppeteerURL(c.url) && c.url !== Gr.INTERNAL_URL) {
                    const u = Gr.parse(c.url);
                    i.unshift(`    at ${c.functionName || u.functionName} (${u.functionName} at ${u.siteString}, <anonymous>:${c.lineNumber}:${c.columnNumber})`)
                } else
                    i.push(`    at ${c.functionName || "<anonymous>"} (${c.url}:${c.lineNumber}:${c.columnNumber})`);
                if (i.length >= Error.stackTraceLimit)
                    break
            }
        return s.stack = [...a, ...i].join(`
`),
        s
    }
    const RP = n => {
        var i, a, c, u;
        let e = "", t;
        const r = ((a = (i = n.exception) == null ? void 0 : i.description) == null ? void 0 : a.split(`
    at `)) ?? []
          , s = Math.min(((c = n.stackTrace) == null ? void 0 : c.callFrames.length) ?? 0, r.length - 1);
        return r.splice(-s, s),
        (u = n.exception) != null && u.className && (e = n.exception.className),
        t = r.join(`
`),
        e && t.startsWith(`${e}: `) && (t = t.slice(e.length + 2)),
        {
            message: t,
            name: e
        }
    }
    ;
    function FB(n) {
        let e, t;
        if (!n.exception)
            e = "Error",
            t = n.text;
        else {
            if ((n.exception.type !== "object" || n.exception.subtype !== "error") && !n.exception.objectId)
                return Ya(n.exception);
            {
                const c = RP(n);
                e = c.name,
                t = c.message
            }
        }
        const r = new Error(t);
        r.name = e;
        const s = r.message.split(`
`).length
          , i = r.stack.split(`
`).splice(0, s)
          , a = [];
        if (n.stackTrace) {
            for (const c of n.stackTrace.callFrames)
                if (a.push(`    at ${c.functionName || "<anonymous>"} (${c.url}:${c.lineNumber + 1}:${c.columnNumber + 1})`),
                a.length >= Error.stackTraceLimit)
                    break
        }
        return r.stack = [...i, ...a].join(`
`),
        r
    }
    function Ya(n) {
        if (ne(!n.objectId, "Cannot extract value when objectId is given"),
        n.unserializableValue) {
            if (n.type === "bigint")
                return BigInt(n.unserializableValue.replace("n", ""));
            switch (n.unserializableValue) {
            case "-0":
                return -0;
            case "NaN":
                return NaN;
            case "Infinity":
                return 1 / 0;
            case "-Infinity":
                return -1 / 0;
            default:
                throw new Error("Unsupported unserializable value: " + n.unserializableValue)
            }
        }
        return n.value
    }
    function MP(n, e, t) {
        globalThis[e] || Object.assign(globalThis, {
            [e](...r) {
                const s = globalThis[e];
                s.args ?? (s.args = new Map),
                s.callbacks ?? (s.callbacks = new Map);
                const i = (s.lastSeq ?? 0) + 1;
                return s.lastSeq = i,
                s.args.set(i, r),
                globalThis[t + e](JSON.stringify({
                    type: n,
                    name: e,
                    seq: i,
                    args: r,
                    isTrivial: !r.some(a => a instanceof Node)
                })),
                new Promise( (a, c) => {
                    s.callbacks.set(i, {
                        resolve(u) {
                            s.args.delete(i),
                            a(u)
                        },
                        reject(u) {
                            s.args.delete(i),
                            c(u)
                        }
                    })
                }
                )
            }
        })
    }
    const Vc = "puppeteer_";
    function jB(n, e) {
        return Fv(MP, n, e, Vc)
    }
    /**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class by extends Xa {
        constructor(t, r) {
            super();
            b(this, Il, !1);
            b(this, Hr);
            b(this, Ol);
            S(this, Ol, t),
            S(this, Hr, r)
        }
        get disposed() {
            return o(this, Il)
        }
        get realm() {
            return o(this, Ol)
        }
        get client() {
            return this.realm.environment.client
        }
        async jsonValue() {
            if (!o(this, Hr).objectId)
                return Ya(o(this, Hr));
            const t = await this.evaluate(r => r);
            if (t === void 0)
                throw new Error("Could not serialize referenced object");
            return t
        }
        asElement() {
            return null
        }
        async dispose() {
            o(this, Il) || (S(this, Il, !0),
            await NP(this.client, o(this, Hr)))
        }
        toString() {
            return o(this, Hr).objectId ? "JSHandle@" + (o(this, Hr).subtype || o(this, Hr).type) : "JSHandle:" + Ya(o(this, Hr))
        }
        get id() {
            return o(this, Hr).objectId
        }
        remoteObject() {
            return o(this, Hr)
        }
        async getProperties() {
            const t = await this.client.send("Runtime.getProperties", {
                objectId: o(this, Hr).objectId,
                ownProperties: !0
            })
              , r = new Map;
            for (const s of t.result)
                !s.enumerable || !s.value || r.set(s.name, o(this, Ol).createCdpHandle(s.value));
            return r
        }
    }
    Il = new WeakMap,
    Hr = new WeakMap,
    Ol = new WeakMap;
    async function NP(n, e) {
        e.objectId && await n.send("Runtime.releaseObject", {
            objectId: e.objectId
        }).catch(t => {
            ge(t)
        }
        )
    }
    /**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var DB = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , vy = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    const BB = new Set(["StaticText", "InlineTextBox"]);
    let $P = ( () => {
        var a, c, h$, l;
        let n = uP, e = [], t, r, s, i;
        return l = class extends n {
            constructor(f, p) {
                super(new by(f,p));
                b(this, c);
                b(this, a, DB(this, e))
            }
            get realm() {
                return this.handle.realm
            }
            get client() {
                return this.handle.client
            }
            remoteObject() {
                return this.handle.remoteObject()
            }
            get frame() {
                return this.realm.environment
            }
            async contentFrame() {
                const f = await this.client.send("DOM.describeNode", {
                    objectId: this.id
                });
                return typeof f.node.frameId != "string" ? null : o(this, c, h$).frame(f.node.frameId)
            }
            async scrollIntoView() {
                await this.assertConnectedElement();
                try {
                    await this.client.send("DOM.scrollIntoViewIfNeeded", {
                        objectId: this.id
                    })
                } catch (f) {
                    ge(f),
                    await super.scrollIntoView()
                }
            }
            async uploadFile(...f) {
                const p = await this.evaluate(m => m.multiple);
                ne(f.length <= 1 || p, "Multiple file uploads only work with <input type=file multiple>");
                const g = Pi.value.path;
                if (g && (f = f.map(m => g.win32.isAbsolute(m) || g.posix.isAbsolute(m) ? m : g.resolve(m))),
                f.length === 0) {
                    await this.evaluate(m => {
                        m.files = new DataTransfer().files,
                        m.dispatchEvent(new Event("input",{
                            bubbles: !0,
                            composed: !0
                        })),
                        m.dispatchEvent(new Event("change",{
                            bubbles: !0
                        }))
                    }
                    );
                    return
                }
                const {node: {backendNodeId: y}} = await this.client.send("DOM.describeNode", {
                    objectId: this.id
                });
                await this.client.send("DOM.setFileInputFiles", {
                    objectId: this.id,
                    files: f,
                    backendNodeId: y
                })
            }
            async autofill(f) {
                const g = (await this.client.send("DOM.describeNode", {
                    objectId: this.handle.id
                })).node.backendNodeId
                  , y = this.frame._id;
                await this.client.send("Autofill.trigger", {
                    fieldId: g,
                    frameId: y,
                    card: f.creditCard
                })
            }
            async*queryAXTree(f, p) {
                const {nodes: g} = await this.client.send("Accessibility.queryAXTree", {
                    objectId: this.id,
                    accessibleName: f,
                    role: p
                })
                  , y = g.filter(m => !(m.ignored || !m.role || BB.has(m.role.value)));
                return yield*Uc.map(y, m => this.realm.adoptBackendNode(m.backendDOMNodeId))
            }
            async backendNodeId() {
                if (o(this, a))
                    return o(this, a);
                const {node: f} = await this.client.send("DOM.describeNode", {
                    objectId: this.handle.id
                });
                return S(this, a, f.backendNodeId),
                o(this, a)
            }
        }
        ,
        a = new WeakMap,
        c = new WeakSet,
        h$ = function() {
            return this.frame._frameManager
        }
        ,
        ( () => {
            const f = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            t = [oe()],
            r = [oe(), Xe],
            s = [oe(), Xe],
            i = [oe()],
            vy(l, null, t, {
                kind: "method",
                name: "contentFrame",
                static: !1,
                private: !1,
                access: {
                    has: p => "contentFrame"in p,
                    get: p => p.contentFrame
                },
                metadata: f
            }, null, e),
            vy(l, null, r, {
                kind: "method",
                name: "scrollIntoView",
                static: !1,
                private: !1,
                access: {
                    has: p => "scrollIntoView"in p,
                    get: p => p.scrollIntoView
                },
                metadata: f
            }, null, e),
            vy(l, null, s, {
                kind: "method",
                name: "uploadFile",
                static: !1,
                private: !1,
                access: {
                    has: p => "uploadFile"in p,
                    get: p => p.uploadFile
                },
                metadata: f
            }, null, e),
            vy(l, null, i, {
                kind: "method",
                name: "autofill",
                static: !1,
                private: !1,
                access: {
                    has: p => "autofill"in p,
                    get: p => p.autofill
                },
                metadata: f
            }, null, e),
            f && Object.defineProperty(l, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: f
            })
        }
        )(),
        l
    }
    )();
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var qB = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , UB = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    const KB = new wy("__ariaQuerySelector",Za.queryOne,"")
      , HB = new wy("__ariaQuerySelectorAll",async (n, e) => {
        const t = Za.queryAll(n, e);
        return await n.realm.evaluateHandle( (...r) => r, ...await Uc.collect(t))
    }
    ,"");
    class LP extends be {
        constructor(t, r, s) {
            super();
            b(this, Wr);
            b(this, ha);
            b(this, Xo);
            b(this, Yn);
            b(this, Rl);
            b(this, Hp, new Ot);
            b(this, Yo, new Map);
            b(this, Tb, new Bv);
            b(this, Wp, !1);
            b(this, fa);
            S(this, ha, t),
            S(this, Xo, s),
            S(this, Yn, r.id),
            r.name && S(this, Rl, r.name);
            const i = o(this, Hp).use(new be(o(this, ha)));
            i.on("Runtime.bindingCalled", P(this, Wr, p$).bind(this)),
            i.on("Runtime.executionContextDestroyed", async a => {
                a.executionContextId === o(this, Yn) && this[Ce]()
            }
            ),
            i.on("Runtime.executionContextsCleared", async () => {
                this[Ce]()
            }
            ),
            i.on("Runtime.consoleAPICalled", P(this, Wr, m$).bind(this)),
            i.on(yt.Disconnected, () => {
                this[Ce]()
            }
            )
        }
        get id() {
            return o(this, Yn)
        }
        get puppeteerUtil() {
            let t = Promise.resolve();
            return o(this, Wp) || (t = Promise.all([P(this, Wr, Ux).call(this, KB), P(this, Wr, Ux).call(this, HB)]),
            S(this, Wp, !0)),
            Fd.inject(r => {
                o(this, fa) && o(this, fa).then(s => {
                    s.dispose()
                }
                ),
                S(this, fa, t.then( () => this.evaluateHandle(r)))
            }
            , !o(this, fa)),
            o(this, fa)
        }
        async evaluate(t, ...r) {
            return await P(this, Wr, Kx).call(this, !0, t, ...r)
        }
        async evaluateHandle(t, ...r) {
            return await P(this, Wr, Kx).call(this, !1, t, ...r)
        }
        [Ce]() {
            o(this, Hp).dispose(),
            this.emit("disposed", void 0)
        }
    }
    ha = new WeakMap,
    Xo = new WeakMap,
    Yn = new WeakMap,
    Rl = new WeakMap,
    Hp = new WeakMap,
    Yo = new WeakMap,
    Tb = new WeakMap,
    Wr = new WeakSet,
    f$ = async function(t) {
        const r = {
            stack: [],
            error: void 0,
            hasError: !1
        };
        try {
            if (o(this, Yo).has(t.name))
                return;
            const s = qB(r, await o(this, Tb).acquire(), !1);
            try {
                await o(this, ha).send("Runtime.addBinding", o(this, Rl) ? {
                    name: Vc + t.name,
                    executionContextName: o(this, Rl)
                } : {
                    name: Vc + t.name,
                    executionContextId: o(this, Yn)
                }),
                await this.evaluate(MP, "internal", t.name, Vc),
                o(this, Yo).set(t.name, t)
            } catch (i) {
                if (i instanceof Error && (i.message.includes("Execution context was destroyed") || i.message.includes("Cannot find context with specified id")))
                    return;
                ge(i)
            }
        } catch (s) {
            r.error = s,
            r.hasError = !0
        } finally {
            UB(r)
        }
    }
    ,
    p$ = async function(t) {
        if (t.executionContextId !== o(this, Yn))
            return;
        let r;
        try {
            r = JSON.parse(t.payload)
        } catch {
            return
        }
        const {type: s, name: i, seq: a, args: c, isTrivial: u} = r;
        if (s !== "internal") {
            this.emit("bindingcalled", t);
            return
        }
        if (!o(this, Yo).has(i)) {
            this.emit("bindingcalled", t);
            return
        }
        try {
            const l = o(this, Yo).get(i);
            await (l == null ? void 0 : l.run(this, a, c, u))
        } catch (l) {
            ge(l)
        }
    }
    ,
    m$ = function(t) {
        t.executionContextId === o(this, Yn) && this.emit("consoleapicalled", t)
    }
    ,
    Wp = new WeakMap,
    fa = new WeakMap,
    Ux = async function(t) {
        try {
            await P(this, Wr, f$).call(this, t)
        } catch (r) {
            ge(r)
        }
    }
    ,
    Kx = async function(t, r, ...s) {
        var p;
        const i = Xk(((p = Vk(r)) == null ? void 0 : p.toString()) ?? Gr.INTERNAL_URL);
        if (js(r)) {
            const g = o(this, Yn)
              , y = r
              , m = ry.test(y) ? y : `${y}
${i}
`
              , {exceptionDetails: w, result: E} = await o(this, ha).send("Runtime.evaluate", {
                expression: m,
                contextId: g,
                returnByValue: t,
                awaitPromise: !0,
                userGesture: !0
            }).catch(FP);
            if (w)
                throw OP(w);
            return t ? Ya(E) : o(this, Xo).createCdpHandle(E)
        }
        const a = is(r)
          , c = ry.test(a) ? a : `${a}
${i}
`;
        let u;
        try {
            u = o(this, ha).send("Runtime.callFunctionOn", {
                functionDeclaration: c,
                executionContextId: o(this, Yn),
                arguments: s.some(g => g instanceof Jr) ? await Promise.all(s.map(g => h(this, g))) : s.map(g => f(this, g)),
                returnByValue: t,
                awaitPromise: !0,
                userGesture: !0
            })
        } catch (g) {
            throw g instanceof TypeError && g.message.startsWith("Converting circular structure to JSON") && (g.message += " Recursive objects are not allowed."),
            g
        }
        const {exceptionDetails: l, result: d} = await u.catch(FP);
        if (l)
            throw OP(l);
        return t ? Ya(d) : o(this, Xo).createCdpHandle(d);
        async function h(g, y) {
            return y instanceof Jr && (y = await y.get(g)),
            f(g, y)
        }
        function f(g, y) {
            if (typeof y == "bigint")
                return {
                    unserializableValue: `${y.toString()}n`
                };
            if (Object.is(y, -0))
                return {
                    unserializableValue: "-0"
                };
            if (Object.is(y, 1 / 0))
                return {
                    unserializableValue: "Infinity"
                };
            if (Object.is(y, -1 / 0))
                return {
                    unserializableValue: "-Infinity"
                };
            if (Object.is(y, NaN))
                return {
                    unserializableValue: "NaN"
                };
            const m = y && (y instanceof by || y instanceof $P) ? y : null;
            if (m) {
                if (m.realm !== o(g, Xo))
                    throw new Error("JSHandles can be evaluated only in the context they were created!");
                if (m.disposed)
                    throw new Error("JSHandle is disposed!");
                return m.remoteObject().unserializableValue ? {
                    unserializableValue: m.remoteObject().unserializableValue
                } : m.remoteObject().objectId ? {
                    objectId: m.remoteObject().objectId
                } : {
                    value: m.remoteObject().value
                }
            }
            return {
                value: y
            }
        }
    }
    ;
    const FP = n => {
        if (n.message.includes("Object reference chain is too long"))
            return {
                result: {
                    type: "undefined"
                }
            };
        if (n.message.includes("Object couldn't be returned by value"))
            return {
                result: {
                    type: "undefined"
                }
            };
        throw n.message.endsWith("Cannot find context with specified id") || n.message.endsWith("Inspected target navigated or closed") ? new Error("Execution context was destroyed, most likely because of a navigation.") : n
    }
    ;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var Vt;
    (function(n) {
        n.FrameAttached = Symbol("FrameManager.FrameAttached"),
        n.FrameNavigated = Symbol("FrameManager.FrameNavigated"),
        n.FrameDetached = Symbol("FrameManager.FrameDetached"),
        n.FrameSwapped = Symbol("FrameManager.FrameSwapped"),
        n.LifecycleEvent = Symbol("FrameManager.LifecycleEvent"),
        n.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument"),
        n.ConsoleApiCalled = Symbol("FrameManager.ConsoleApiCalled"),
        n.BindingCalled = Symbol("FrameManager.BindingCalled")
    }
    )(Vt || (Vt = {}));
    /**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class e_ extends xP {
        constructor(t, r) {
            super(r);
            b(this, gr);
            b(this, Cs);
            b(this, Qn, new be);
            b(this, pa);
            S(this, pa, t)
        }
        get environment() {
            return o(this, pa)
        }
        get client() {
            return o(this, pa).client
        }
        get emitter() {
            return o(this, Qn)
        }
        setContext(t) {
            var r;
            (r = o(this, Cs)) == null || r[Ce](),
            t.once("disposed", P(this, gr, g$).bind(this)),
            t.on("consoleapicalled", P(this, gr, y$).bind(this)),
            t.on("bindingcalled", P(this, gr, w$).bind(this)),
            S(this, Cs, t),
            o(this, Qn).emit("context", t),
            this.taskManager.rerunAll()
        }
        hasContext() {
            return !!o(this, Cs)
        }
        get context() {
            return o(this, Cs)
        }
        async evaluateHandle(t, ...r) {
            t = Wt(this.evaluateHandle.name, t);
            let s = P(this, gr, Hb).call(this);
            return s || (s = await P(this, gr, Wb).call(this)),
            await s.evaluateHandle(t, ...r)
        }
        async evaluate(t, ...r) {
            t = Wt(this.evaluate.name, t);
            let s = P(this, gr, Hb).call(this);
            return s || (s = await P(this, gr, Wb).call(this)),
            await s.evaluate(t, ...r)
        }
        async adoptBackendNode(t) {
            let r = P(this, gr, Hb).call(this);
            r || (r = await P(this, gr, Wb).call(this));
            const {object: s} = await this.client.send("DOM.resolveNode", {
                backendNodeId: t,
                executionContextId: r.id
            });
            return this.createCdpHandle(s)
        }
        async adoptHandle(t) {
            if (t.realm === this)
                return await t.evaluateHandle(s => s);
            const r = await this.client.send("DOM.describeNode", {
                objectId: t.id
            });
            return await this.adoptBackendNode(r.node.backendNodeId)
        }
        async transferHandle(t) {
            if (t.realm === this || t.remoteObject().objectId === void 0)
                return t;
            const r = await this.client.send("DOM.describeNode", {
                objectId: t.remoteObject().objectId
            })
              , s = await this.adoptBackendNode(r.node.backendNodeId);
            return await t.dispose(),
            s
        }
        createCdpHandle(t) {
            return t.subtype === "node" ? new $P(this,t) : new by(this,t)
        }
        [Ce]() {
            var t;
            (t = o(this, Cs)) == null || t[Ce](),
            o(this, Qn).emit("disposed", void 0),
            super[Ce](),
            o(this, Qn).removeAllListeners()
        }
    }
    Cs = new WeakMap,
    Qn = new WeakMap,
    pa = new WeakMap,
    gr = new WeakSet,
    g$ = function() {
        S(this, Cs, void 0),
        "clearDocumentHandle"in o(this, pa) && o(this, pa).clearDocumentHandle()
    }
    ,
    y$ = function(t) {
        o(this, Qn).emit("consoleapicalled", t)
    }
    ,
    w$ = function(t) {
        o(this, Qn).emit("bindingcalled", t)
    }
    ,
    Hb = function() {
        if (this.disposed)
            throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
        return o(this, Cs)
    }
    ,
    Wb = async function() {
        const t = new Error("Execution context was destroyed");
        return await Kt(at(o(this, Qn), "context").pipe(sr(at(o(this, Qn), "disposed").pipe(Pt( () => {
            throw t
        }
        )), Or(this.timeoutSettings.timeout()))))
    }
    ;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const ds = Symbol("mainWorld")
      , _y = Symbol("puppeteerWorld");
    /**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const WB = new Map([["load", "load"], ["domcontentloaded", "DOMContentLoaded"], ["networkidle0", "networkIdle"], ["networkidle2", "networkAlmostIdle"]]);
    class t_ {
        constructor(e, t, r, s, i) {
            b(this, vt);
            b(this, zp);
            b(this, ma);
            b(this, Ml);
            b(this, ga, null);
            b(this, Qo, new Ot);
            b(this, Vp);
            b(this, ya);
            b(this, Gp, pt.create());
            b(this, Jp, pt.create());
            b(this, Zp, pt.create());
            b(this, Xp);
            b(this, Yp);
            b(this, ai);
            Array.isArray(r) ? r = r.slice() : typeof r == "string" && (r = [r]),
            S(this, Vp, t._loaderId),
            S(this, zp, r.map(l => {
                const d = WB.get(l);
                return ne(d, "Unknown value for options.waitUntil: " + l),
                d
            }
            )),
            i == null || i.addEventListener("abort", () => {
                o(this, ya).reject(i.reason)
            }
            ),
            S(this, ma, t),
            S(this, Ml, s),
            o(this, Qo).use(new be(t._frameManager)).on(Vt.LifecycleEvent, P(this, vt, kc).bind(this));
            const c = o(this, Qo).use(new be(t));
            c.on(ir.FrameNavigatedWithinDocument, P(this, vt, E$).bind(this)),
            c.on(ir.FrameNavigated, P(this, vt, x$).bind(this)),
            c.on(ir.FrameSwapped, P(this, vt, zb).bind(this)),
            c.on(ir.FrameSwappedByActivation, P(this, vt, zb).bind(this)),
            c.on(ir.FrameDetached, P(this, vt, S$).bind(this));
            const u = o(this, Qo).use(new be(e));
            u.on(zt.Request, P(this, vt, b$).bind(this)),
            u.on(zt.Response, P(this, vt, _$).bind(this)),
            u.on(zt.RequestFailed, P(this, vt, v$).bind(this)),
            S(this, ya, pt.create({
                timeout: o(this, Ml),
                message: `Navigation timeout of ${o(this, Ml)} ms exceeded`
            })),
            P(this, vt, kc).call(this)
        }
        async navigationResponse() {
            var e;
            return await ((e = o(this, ai)) == null ? void 0 : e.valueOrThrow()),
            o(this, ga) ? o(this, ga).response() : null
        }
        sameDocumentNavigationPromise() {
            return o(this, Gp).valueOrThrow()
        }
        newDocumentNavigationPromise() {
            return o(this, Zp).valueOrThrow()
        }
        lifecyclePromise() {
            return o(this, Jp).valueOrThrow()
        }
        terminationPromise() {
            return o(this, ya).valueOrThrow()
        }
        dispose() {
            o(this, Qo).dispose(),
            o(this, ya).resolve(new Error("LifecycleWatcher disposed"))
        }
    }
    zp = new WeakMap,
    ma = new WeakMap,
    Ml = new WeakMap,
    ga = new WeakMap,
    Qo = new WeakMap,
    Vp = new WeakMap,
    ya = new WeakMap,
    Gp = new WeakMap,
    Jp = new WeakMap,
    Zp = new WeakMap,
    Xp = new WeakMap,
    Yp = new WeakMap,
    ai = new WeakMap,
    vt = new WeakSet,
    b$ = function(e) {
        var t, r;
        e.frame() !== o(this, ma) || !e.isNavigationRequest() || (S(this, ga, e),
        (t = o(this, ai)) == null || t.resolve(),
        S(this, ai, pt.create()),
        e.response() !== null && ((r = o(this, ai)) == null || r.resolve()))
    }
    ,
    v$ = function(e) {
        var t, r;
        ((t = o(this, ga)) == null ? void 0 : t.id) === e.id && ((r = o(this, ai)) == null || r.resolve())
    }
    ,
    _$ = function(e) {
        var t, r;
        ((t = o(this, ga)) == null ? void 0 : t.id) === e.request().id && ((r = o(this, ai)) == null || r.resolve())
    }
    ,
    S$ = function(e) {
        if (o(this, ma) === e) {
            o(this, ya).resolve(new Error("Navigating frame was detached"));
            return
        }
        P(this, vt, kc).call(this)
    }
    ,
    E$ = function() {
        S(this, Xp, !0),
        P(this, vt, kc).call(this)
    }
    ,
    x$ = function(e) {
        if (e === "BackForwardCacheRestore")
            return P(this, vt, zb).call(this);
        P(this, vt, kc).call(this)
    }
    ,
    zb = function() {
        S(this, Yp, !0),
        P(this, vt, kc).call(this)
    }
    ,
    kc = function() {
        if (!e(o(this, ma), o(this, zp)))
            return;
        o(this, Jp).resolve(),
        o(this, Xp) && o(this, Gp).resolve(void 0),
        (o(this, Yp) || o(this, ma)._loaderId !== o(this, Vp)) && o(this, Zp).resolve(void 0);
        function e(t, r) {
            for (const s of r)
                if (!t._lifecycleEvents.has(s))
                    return !1;
            for (const s of t.childFrames())
                if (s._hasStartedLoading && !e(s, r))
                    return !1;
            return !0
        }
    }
    ;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var zB = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , Qa = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let jP = ( () => {
        var l, d, h, f, C$, k$, P$, m;
        let n = dP, e = [], t, r, s, i, a, c, u;
        return m = class extends n {
            constructor(v, _, A, C) {
                super();
                b(this, f);
                b(this, l, (zB(this, e),
                ""));
                b(this, d, !1);
                b(this, h);
                J(this, "_frameManager");
                J(this, "_loaderId", "");
                J(this, "_lifecycleEvents", new Set);
                J(this, "_id");
                J(this, "_parentId");
                J(this, "accessibility");
                J(this, "worlds");
                this._frameManager = v,
                S(this, l, ""),
                this._id = _,
                this._parentId = A,
                S(this, d, !1),
                S(this, h, C),
                this._loaderId = "",
                this.worlds = {
                    [ds]: new e_(this,this._frameManager.timeoutSettings),
                    [_y]: new e_(this,this._frameManager.timeoutSettings)
                },
                this.accessibility = new kP(this.worlds[ds],_),
                this.on(ir.FrameSwappedByActivation, () => {
                    this._onLoadingStarted(),
                    this._onLoadingStopped()
                }
                ),
                this.worlds[ds].emitter.on("consoleapicalled", P(this, f, C$).bind(this)),
                this.worlds[ds].emitter.on("bindingcalled", P(this, f, k$).bind(this))
            }
            _client() {
                return o(this, h)
            }
            updateId(v) {
                this._id = v
            }
            updateClient(v) {
                S(this, h, v)
            }
            page() {
                return this._frameManager.page()
            }
            async goto(v, _={}) {
                const {referer: A=this._frameManager.networkManager.extraHTTPHeaders().referer, referrerPolicy: C=this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil: k=["load"], timeout: x=this._frameManager.timeoutSettings.navigationTimeout()} = _;
                let N = !1;
                const R = new t_(this._frameManager.networkManager,this,k,x);
                let F = await pt.race([O(o(this, h), v, A, C, this._id), R.terminationPromise()]);
                F || (F = await pt.race([R.terminationPromise(), N ? R.newDocumentNavigationPromise() : R.sameDocumentNavigationPromise()]));
                try {
                    if (F)
                        throw F;
                    return await R.navigationResponse()
                } finally {
                    R.dispose()
                }
                async function O(T, L, q, Z, j) {
                    try {
                        const $ = await T.send("Page.navigate", {
                            url: L,
                            referrer: q,
                            frameId: j,
                            referrerPolicy: Z
                        });
                        return N = !!$.loaderId,
                        $.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE" ? null : $.errorText ? new Error(`${$.errorText} at ${L}`) : null
                    } catch ($) {
                        if (hn($))
                            return $;
                        throw $
                    }
                }
            }
            async waitForNavigation(v={}) {
                const {waitUntil: _=["load"], timeout: A=this._frameManager.timeoutSettings.navigationTimeout(), signal: C} = v
                  , k = new t_(this._frameManager.networkManager,this,_,A,C)
                  , x = await pt.race([k.terminationPromise(), ...v.ignoreSameDocumentNavigation ? [] : [k.sameDocumentNavigationPromise()], k.newDocumentNavigationPromise()]);
                try {
                    if (x)
                        throw x;
                    const N = await pt.race([k.terminationPromise(), k.navigationResponse()]);
                    if (N instanceof Error)
                        throw x;
                    return N || null
                } finally {
                    k.dispose()
                }
            }
            get client() {
                return o(this, h)
            }
            mainRealm() {
                return this.worlds[ds]
            }
            isolatedRealm() {
                return this.worlds[_y]
            }
            async setContent(v, _={}) {
                const {waitUntil: A=["load"], timeout: C=this._frameManager.timeoutSettings.navigationTimeout()} = _;
                await this.setFrameContent(v);
                const k = new t_(this._frameManager.networkManager,this,A,C)
                  , x = await pt.race([k.terminationPromise(), k.lifecyclePromise()]);
                if (k.dispose(),
                x)
                    throw x
            }
            url() {
                return o(this, l)
            }
            parentFrame() {
                return this._frameManager._frameTree.parentFrame(this._id) || null
            }
            childFrames() {
                return this._frameManager._frameTree.childFrames(this._id)
            }
            async addPreloadScript(v) {
                const _ = this.parentFrame();
                if (_ && o(this, h) === _.client || v.getIdForFrame(this))
                    return;
                const {identifier: A} = await o(this, h).send("Page.addScriptToEvaluateOnNewDocument", {
                    source: v.source
                });
                v.setIdForFrame(this, A)
            }
            async addExposedFunctionBinding(v) {
                this !== this._frameManager.mainFrame() && !this._hasStartedLoading || await Promise.all([o(this, h).send("Runtime.addBinding", {
                    name: Vc + v.name
                }), this.evaluate(v.initSource).catch(ge)])
            }
            async removeExposedFunctionBinding(v) {
                this !== this._frameManager.mainFrame() && !this._hasStartedLoading || await Promise.all([o(this, h).send("Runtime.removeBinding", {
                    name: Vc + v.name
                }), this.evaluate(_ => {
                    globalThis[_] = void 0
                }
                , v.name).catch(ge)])
            }
            async waitForDevicePrompt(v={}) {
                return await P(this, f, P$).call(this).waitForDevicePrompt(v)
            }
            _navigated(v) {
                this._name = v.name,
                S(this, l, `${v.url}${v.urlFragment || ""}`)
            }
            _navigatedWithinDocument(v) {
                S(this, l, v)
            }
            _onLifecycleEvent(v, _) {
                _ === "init" && (this._loaderId = v,
                this._lifecycleEvents.clear()),
                this._lifecycleEvents.add(_)
            }
            _onLoadingStopped() {
                this._lifecycleEvents.add("DOMContentLoaded"),
                this._lifecycleEvents.add("load")
            }
            _onLoadingStarted() {
                this._hasStartedLoading = !0
            }
            get detached() {
                return o(this, d)
            }
            [(t = [ze],
            r = [ze],
            s = [ze],
            i = [ze],
            a = [ze],
            c = [ze],
            u = [ze],
            Ce)]() {
                o(this, d) || (S(this, d, !0),
                this.worlds[ds][Ce](),
                this.worlds[_y][Ce]())
            }
            exposeFunction() {
                throw new Oe
            }
            async frameElement() {
                const v = this.parentFrame();
                if (!v)
                    return null;
                const {backendNodeId: _} = await v.client.send("DOM.getFrameOwner", {
                    frameId: this._id
                });
                return await v.mainRealm().adoptBackendNode(_)
            }
        }
        ,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakSet,
        C$ = function(v) {
            this._frameManager.emit(Vt.ConsoleApiCalled, [this.worlds[ds], v])
        }
        ,
        k$ = function(v) {
            this._frameManager.emit(Vt.BindingCalled, [this.worlds[ds], v])
        }
        ,
        P$ = function() {
            return this._frameManager._deviceRequestPromptManager(o(this, h))
        }
        ,
        ( () => {
            const v = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            Qa(m, null, t, {
                kind: "method",
                name: "goto",
                static: !1,
                private: !1,
                access: {
                    has: _ => "goto"in _,
                    get: _ => _.goto
                },
                metadata: v
            }, null, e),
            Qa(m, null, r, {
                kind: "method",
                name: "waitForNavigation",
                static: !1,
                private: !1,
                access: {
                    has: _ => "waitForNavigation"in _,
                    get: _ => _.waitForNavigation
                },
                metadata: v
            }, null, e),
            Qa(m, null, s, {
                kind: "method",
                name: "setContent",
                static: !1,
                private: !1,
                access: {
                    has: _ => "setContent"in _,
                    get: _ => _.setContent
                },
                metadata: v
            }, null, e),
            Qa(m, null, i, {
                kind: "method",
                name: "addPreloadScript",
                static: !1,
                private: !1,
                access: {
                    has: _ => "addPreloadScript"in _,
                    get: _ => _.addPreloadScript
                },
                metadata: v
            }, null, e),
            Qa(m, null, a, {
                kind: "method",
                name: "addExposedFunctionBinding",
                static: !1,
                private: !1,
                access: {
                    has: _ => "addExposedFunctionBinding"in _,
                    get: _ => _.addExposedFunctionBinding
                },
                metadata: v
            }, null, e),
            Qa(m, null, c, {
                kind: "method",
                name: "removeExposedFunctionBinding",
                static: !1,
                private: !1,
                access: {
                    has: _ => "removeExposedFunctionBinding"in _,
                    get: _ => _.removeExposedFunctionBinding
                },
                metadata: v
            }, null, e),
            Qa(m, null, u, {
                kind: "method",
                name: "waitForDevicePrompt",
                static: !1,
                private: !1,
                access: {
                    has: _ => "waitForDevicePrompt"in _,
                    get: _ => _.waitForDevicePrompt
                },
                metadata: v
            }, null, e),
            v && Object.defineProperty(m, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: v
            })
        }
        )(),
        m
    }
    )();
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class VB {
        constructor() {
            b(this, ec, new Map);
            b(this, Nl, new Map);
            b(this, wa, new Map);
            b(this, $l);
            b(this, Ll, !1);
            b(this, Qp, new Map)
        }
        getMainFrame() {
            return o(this, $l)
        }
        getById(e) {
            return o(this, ec).get(e)
        }
        waitForFrame(e) {
            const t = this.getById(e);
            if (t)
                return Promise.resolve(t);
            const r = pt.create();
            return (o(this, Qp).get(e) || new Set).add(r),
            r.valueOrThrow()
        }
        frames() {
            return Array.from(o(this, ec).values())
        }
        addFrame(e) {
            var t;
            o(this, ec).set(e._id, e),
            e._parentId ? (o(this, Nl).set(e._id, e._parentId),
            o(this, wa).has(e._parentId) || o(this, wa).set(e._parentId, new Set),
            o(this, wa).get(e._parentId).add(e._id)) : (!o(this, $l) || o(this, Ll)) && (S(this, $l, e),
            S(this, Ll, !1)),
            (t = o(this, Qp).get(e._id)) == null || t.forEach(r => r.resolve(e))
        }
        removeFrame(e) {
            var t;
            o(this, ec).delete(e._id),
            o(this, Nl).delete(e._id),
            e._parentId ? (t = o(this, wa).get(e._parentId)) == null || t.delete(e._id) : S(this, Ll, !0)
        }
        childFrames(e) {
            const t = o(this, wa).get(e);
            return t ? Array.from(t).map(r => this.getById(r)).filter(r => r !== void 0) : []
        }
        parentFrame(e) {
            const t = o(this, Nl).get(e);
            return t ? this.getById(t) : void 0
        }
    }
    ec = new WeakMap,
    Nl = new WeakMap,
    wa = new WeakMap,
    $l = new WeakMap,
    Ll = new WeakMap,
    Qp = new WeakMap;
    class r_ extends gy {
        constructor(t, r, s, i, a, c) {
            super();
            J(this, "id");
            b(this, ks);
            b(this, em);
            b(this, tm);
            b(this, rm);
            b(this, nm);
            b(this, sm, !1);
            b(this, im);
            b(this, am, {});
            b(this, om);
            b(this, cm);
            S(this, ks, t),
            this.id = a.requestId,
            S(this, em, a.requestId === a.loaderId && a.type === "Document"),
            this._interceptionId = s,
            S(this, tm, a.request.url + (a.request.urlFragment ?? "")),
            S(this, rm, (a.type || "other").toLowerCase()),
            S(this, nm, a.request.method),
            S(this, im, a.request.postData),
            S(this, sm, a.request.hasPostData ?? !1),
            S(this, om, r),
            this._redirectChain = c,
            S(this, cm, a.initiator),
            this.interception.enabled = i;
            for (const [u,l] of Object.entries(a.request.headers))
                o(this, am)[u.toLowerCase()] = l
        }
        get client() {
            return o(this, ks)
        }
        set client(t) {
            S(this, ks, t)
        }
        url() {
            return o(this, tm)
        }
        resourceType() {
            return o(this, rm)
        }
        method() {
            return o(this, nm)
        }
        postData() {
            return o(this, im)
        }
        hasPostData() {
            return o(this, sm)
        }
        async fetchPostData() {
            try {
                return (await o(this, ks).send("Network.getRequestPostData", {
                    requestId: this.id
                })).postData
            } catch (t) {
                ge(t);
                return
            }
        }
        headers() {
            return o(this, am)
        }
        response() {
            return this._response
        }
        frame() {
            return o(this, om)
        }
        isNavigationRequest() {
            return o(this, em)
        }
        initiator() {
            return o(this, cm)
        }
        redirectChain() {
            return this._redirectChain.slice()
        }
        failure() {
            return this._failureText ? {
                errorText: this._failureText
            } : null
        }
        async _continue(t={}) {
            const {url: r, method: s, postData: i, headers: a} = t;
            this.interception.handled = !0;
            const c = i ? Hk(i) : void 0;
            if (this._interceptionId === void 0)
                throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
            await o(this, ks).send("Fetch.continueRequest", {
                requestId: this._interceptionId,
                url: r,
                method: s,
                postData: c,
                headers: a ? hP(a) : void 0
            }).catch(u => (this.interception.handled = !1,
            yy(u)))
        }
        async _respond(t) {
            this.interception.handled = !0;
            let r;
            t.body && (r = gy.getResponse(t.body));
            const s = {};
            if (t.headers)
                for (const a of Object.keys(t.headers)) {
                    const c = t.headers[a];
                    s[a.toLowerCase()] = Array.isArray(c) ? c.map(u => String(u)) : String(c)
                }
            t.contentType && (s["content-type"] = t.contentType),
            r != null && r.contentLength && !("content-length"in s) && (s["content-length"] = String(r.contentLength));
            const i = t.status || 200;
            if (this._interceptionId === void 0)
                throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
            await o(this, ks).send("Fetch.fulfillRequest", {
                requestId: this._interceptionId,
                responseCode: i,
                responsePhrase: fP[i],
                responseHeaders: hP(s),
                body: r == null ? void 0 : r.base64
            }).catch(a => (this.interception.handled = !1,
            yy(a)))
        }
        async _abort(t) {
            if (this.interception.handled = !0,
            this._interceptionId === void 0)
                throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
            await o(this, ks).send("Fetch.failRequest", {
                requestId: this._interceptionId,
                errorReason: t || "Failed"
            }).catch(yy)
        }
    }
    ks = new WeakMap,
    em = new WeakMap,
    tm = new WeakMap,
    rm = new WeakMap,
    nm = new WeakMap,
    sm = new WeakMap,
    im = new WeakMap,
    am = new WeakMap,
    om = new WeakMap,
    cm = new WeakMap;
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class DP {
        constructor(e) {
            b(this, um);
            b(this, lm);
            b(this, dm);
            b(this, hm);
            b(this, fm);
            b(this, pm);
            S(this, um, e.subjectName),
            S(this, lm, e.issuer),
            S(this, dm, e.validFrom),
            S(this, hm, e.validTo),
            S(this, fm, e.protocol),
            S(this, pm, e.sanList)
        }
        issuer() {
            return o(this, lm)
        }
        validFrom() {
            return o(this, dm)
        }
        validTo() {
            return o(this, hm)
        }
        protocol() {
            return o(this, fm)
        }
        subjectName() {
            return o(this, um)
        }
        subjectAlternativeNames() {
            return o(this, pm)
        }
    }
    um = new WeakMap,
    lm = new WeakMap,
    dm = new WeakMap,
    hm = new WeakMap,
    fm = new WeakMap,
    pm = new WeakMap;
    class BP extends pP {
        constructor(t, r, s) {
            super();
            b(this, Ab);
            b(this, Ps);
            b(this, Fl, null);
            b(this, jl, pt.create());
            b(this, mm);
            b(this, gm);
            b(this, ym);
            b(this, wm);
            b(this, bm);
            b(this, vm, {});
            b(this, _m);
            b(this, Sm);
            S(this, Ps, t),
            S(this, mm, {
                ip: r.remoteIPAddress,
                port: r.remotePort
            }),
            S(this, ym, P(this, Ab, T$).call(this, s) || r.statusText),
            S(this, wm, !!r.fromDiskCache),
            S(this, bm, !!r.fromServiceWorker),
            S(this, gm, s ? s.statusCode : r.status);
            const i = s ? s.headers : r.headers;
            for (const [a,c] of Object.entries(i))
                o(this, vm)[a.toLowerCase()] = c;
            S(this, _m, r.securityDetails ? new DP(r.securityDetails) : null),
            S(this, Sm, r.timing || null)
        }
        _resolveBody(t) {
            return t ? o(this, jl).reject(t) : o(this, jl).resolve()
        }
        remoteAddress() {
            return o(this, mm)
        }
        url() {
            return o(this, Ps).url()
        }
        status() {
            return o(this, gm)
        }
        statusText() {
            return o(this, ym)
        }
        headers() {
            return o(this, vm)
        }
        securityDetails() {
            return o(this, _m)
        }
        timing() {
            return o(this, Sm)
        }
        content() {
            return o(this, Fl) || S(this, Fl, o(this, jl).valueOrThrow().then(async () => {
                try {
                    const t = await o(this, Ps).client.send("Network.getResponseBody", {
                        requestId: o(this, Ps).id
                    });
                    return $v(t.body, t.base64Encoded)
                } catch (t) {
                    throw t instanceof Ga && t.originalMessage === "No resource with given identifier found" ? new Ga("Could not load body for this request. This might happen if the request is a preflight request.") : t
                }
            }
            )),
            o(this, Fl)
        }
        request() {
            return o(this, Ps)
        }
        fromCache() {
            return o(this, wm) || o(this, Ps)._fromMemoryCache
        }
        fromServiceWorker() {
            return o(this, bm)
        }
        frame() {
            return o(this, Ps).frame()
        }
    }
    Ps = new WeakMap,
    Fl = new WeakMap,
    jl = new WeakMap,
    mm = new WeakMap,
    gm = new WeakMap,
    ym = new WeakMap,
    wm = new WeakMap,
    bm = new WeakMap,
    vm = new WeakMap,
    _m = new WeakMap,
    Sm = new WeakMap,
    Ab = new WeakSet,
    T$ = function(t) {
        if (!t || !t.headersText)
            return;
        const r = t.headersText.split("\r", 1)[0];
        if (!r || r.length > 1e3)
            return;
        const s = r.match(/[^ ]* [^ ]* (.*)/);
        if (!s)
            return;
        const i = s[1];
        if (i)
            return i
    }
    ;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class GB {
        constructor() {
            b(this, ba, new Map);
            b(this, va, new Map);
            b(this, _a, new Map);
            b(this, Sa, new Map);
            b(this, tc, new Map);
            b(this, rc, new Map)
        }
        forget(e) {
            o(this, ba).delete(e),
            o(this, va).delete(e),
            o(this, rc).delete(e),
            o(this, tc).delete(e),
            o(this, Sa).delete(e)
        }
        responseExtraInfo(e) {
            return o(this, Sa).has(e) || o(this, Sa).set(e, []),
            o(this, Sa).get(e)
        }
        queuedRedirectInfo(e) {
            return o(this, tc).has(e) || o(this, tc).set(e, []),
            o(this, tc).get(e)
        }
        queueRedirectInfo(e, t) {
            this.queuedRedirectInfo(e).push(t)
        }
        takeQueuedRedirectInfo(e) {
            return this.queuedRedirectInfo(e).shift()
        }
        inFlightRequestsCount() {
            let e = 0;
            for (const t of o(this, _a).values())
                t.response() || e++;
            return e
        }
        storeRequestWillBeSent(e, t) {
            o(this, ba).set(e, t)
        }
        getRequestWillBeSent(e) {
            return o(this, ba).get(e)
        }
        forgetRequestWillBeSent(e) {
            o(this, ba).delete(e)
        }
        getRequestPaused(e) {
            return o(this, va).get(e)
        }
        forgetRequestPaused(e) {
            o(this, va).delete(e)
        }
        storeRequestPaused(e, t) {
            o(this, va).set(e, t)
        }
        getRequest(e) {
            return o(this, _a).get(e)
        }
        storeRequest(e, t) {
            o(this, _a).set(e, t)
        }
        forgetRequest(e) {
            o(this, _a).delete(e)
        }
        getQueuedEventGroup(e) {
            return o(this, rc).get(e)
        }
        queueEventGroup(e, t) {
            o(this, rc).set(e, t)
        }
        forgetQueuedEventGroup(e) {
            o(this, rc).delete(e)
        }
        printState() {
            function e(t, r) {
                return r instanceof Map ? {
                    dataType: "Map",
                    value: Array.from(r.entries())
                } : r instanceof r_ ? {
                    dataType: "CdpHTTPRequest",
                    value: `${r.id}: ${r.url()}`
                } : r
            }
            console.log("httpRequestsMap", JSON.stringify(o(this, _a), e, 2)),
            console.log("requestWillBeSentMap", JSON.stringify(o(this, ba), e, 2)),
            console.log("requestWillBeSentMap", JSON.stringify(o(this, Sa), e, 2)),
            console.log("requestWillBeSentMap", JSON.stringify(o(this, va), e, 2))
        }
    }
    ba = new WeakMap,
    va = new WeakMap,
    _a = new WeakMap,
    Sa = new WeakMap,
    tc = new WeakMap,
    rc = new WeakMap;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class JB extends be {
        constructor(t) {
            super();
            b(this, le);
            b(this, Dl);
            b(this, Qe, new GB);
            b(this, nc);
            b(this, Ea, null);
            b(this, Bl, new Set);
            b(this, Ts, !1);
            b(this, oi, !1);
            b(this, xa);
            b(this, yr);
            b(this, ql);
            b(this, Em);
            b(this, Ib, [["Fetch.requestPaused", P(this, le, R$)], ["Fetch.authRequired", P(this, le, O$)], ["Network.requestWillBeSent", P(this, le, I$)], ["Network.requestServedFromCache", P(this, le, N$)], ["Network.responseReceived", P(this, le, L$)], ["Network.loadingFinished", P(this, le, j$)], ["Network.loadingFailed", P(this, le, D$)], ["Network.responseReceivedExtraInfo", P(this, le, F$)], [yt.Disconnected, P(this, le, A$)]]);
            b(this, Ca, new Map);
            S(this, Dl, t)
        }
        async addClient(t) {
            if (o(this, Ca).has(t))
                return;
            const r = new Ot;
            o(this, Ca).set(t, r);
            const s = r.use(new be(t));
            for (const [i,a] of o(this, Ib))
                s.on(i, c => a.bind(this)(t, c));
            await Promise.all([t.send("Network.enable"), P(this, le, Hx).call(this, t), P(this, le, Vb).call(this, t), P(this, le, Ag).call(this, t), P(this, le, Gb).call(this, t), P(this, le, Wx).call(this, t)])
        }
        async authenticate(t) {
            S(this, Ea, t);
            const r = o(this, Ts) || !!o(this, Ea);
            r !== o(this, oi) && (S(this, oi, r),
            await P(this, le, Ua).call(this, P(this, le, Gb).bind(this)))
        }
        async setExtraHTTPHeaders(t) {
            const r = {};
            for (const [s,i] of Object.entries(t))
                ne(js(i), `Expected value of header "${s}" to be String, but "${typeof i}" is found.`),
                r[s.toLowerCase()] = i;
            S(this, nc, r),
            await P(this, le, Ua).call(this, P(this, le, Hx).bind(this))
        }
        extraHTTPHeaders() {
            return Object.assign({}, o(this, nc))
        }
        inFlightRequestsCount() {
            return o(this, Qe).inFlightRequestsCount()
        }
        async setOfflineMode(t) {
            o(this, yr) || S(this, yr, {
                offline: !1,
                upload: -1,
                download: -1,
                latency: 0
            }),
            o(this, yr).offline = t,
            await P(this, le, Ua).call(this, P(this, le, Vb).bind(this))
        }
        async emulateNetworkConditions(t) {
            o(this, yr) || S(this, yr, {
                offline: !1,
                upload: -1,
                download: -1,
                latency: 0
            }),
            o(this, yr).upload = t ? t.upload : -1,
            o(this, yr).download = t ? t.download : -1,
            o(this, yr).latency = t ? t.latency : 0,
            await P(this, le, Ua).call(this, P(this, le, Vb).bind(this))
        }
        async setUserAgent(t, r) {
            S(this, ql, t),
            S(this, Em, r),
            await P(this, le, Ua).call(this, P(this, le, Wx).bind(this))
        }
        async setCacheEnabled(t) {
            S(this, xa, !t),
            await P(this, le, Ua).call(this, P(this, le, Ag).bind(this))
        }
        async setRequestInterception(t) {
            S(this, Ts, t);
            const r = o(this, Ts) || !!o(this, Ea);
            r !== o(this, oi) && (S(this, oi, r),
            await P(this, le, Ua).call(this, P(this, le, Gb).bind(this)))
        }
    }
    Dl = new WeakMap,
    Qe = new WeakMap,
    nc = new WeakMap,
    Ea = new WeakMap,
    Bl = new WeakMap,
    Ts = new WeakMap,
    oi = new WeakMap,
    xa = new WeakMap,
    yr = new WeakMap,
    ql = new WeakMap,
    Em = new WeakMap,
    Ib = new WeakMap,
    Ca = new WeakMap,
    le = new WeakSet,
    A$ = async function(t) {
        var r;
        (r = o(this, Ca).get(t)) == null || r.dispose(),
        o(this, Ca).delete(t)
    }
    ,
    Hx = async function(t) {
        o(this, nc) !== void 0 && await t.send("Network.setExtraHTTPHeaders", {
            headers: o(this, nc)
        })
    }
    ,
    Ua = async function(t) {
        await Promise.all(Array.from(o(this, Ca).keys()).map(r => t(r)))
    }
    ,
    Vb = async function(t) {
        o(this, yr) !== void 0 && await t.send("Network.emulateNetworkConditions", {
            offline: o(this, yr).offline,
            latency: o(this, yr).latency,
            uploadThroughput: o(this, yr).upload,
            downloadThroughput: o(this, yr).download
        })
    }
    ,
    Wx = async function(t) {
        o(this, ql) !== void 0 && await t.send("Network.setUserAgentOverride", {
            userAgent: o(this, ql),
            userAgentMetadata: o(this, Em)
        })
    }
    ,
    Gb = async function(t) {
        o(this, xa) === void 0 && S(this, xa, !1),
        o(this, oi) ? await Promise.all([P(this, le, Ag).call(this, t), t.send("Fetch.enable", {
            handleAuthRequests: !0,
            patterns: [{
                urlPattern: "*"
            }]
        })]) : await Promise.all([P(this, le, Ag).call(this, t), t.send("Fetch.disable")])
    }
    ,
    Ag = async function(t) {
        o(this, xa) !== void 0 && await t.send("Network.setCacheDisabled", {
            cacheDisabled: o(this, xa)
        })
    }
    ,
    I$ = function(t, r) {
        if (o(this, Ts) && !r.request.url.startsWith("data:")) {
            const {requestId: s} = r;
            o(this, Qe).storeRequestWillBeSent(s, r);
            const i = o(this, Qe).getRequestPaused(s);
            if (i) {
                const {requestId: a} = i;
                P(this, le, zx).call(this, r, i),
                P(this, le, Sd).call(this, t, r, a),
                o(this, Qe).forgetRequestPaused(s)
            }
            return
        }
        P(this, le, Sd).call(this, t, r, void 0)
    }
    ,
    O$ = function(t, r) {
        let s = "Default";
        o(this, Bl).has(r.requestId) ? s = "CancelAuth" : o(this, Ea) && (s = "ProvideCredentials",
        o(this, Bl).add(r.requestId));
        const {username: i, password: a} = o(this, Ea) || {
            username: void 0,
            password: void 0
        };
        t.send("Fetch.continueWithAuth", {
            requestId: r.requestId,
            authChallengeResponse: {
                response: s,
                username: i,
                password: a
            }
        }).catch(ge)
    }
    ,
    R$ = function(t, r) {
        !o(this, Ts) && o(this, oi) && t.send("Fetch.continueRequest", {
            requestId: r.requestId
        }).catch(ge);
        const {networkId: s, requestId: i} = r;
        if (!s) {
            P(this, le, M$).call(this, t, r);
            return
        }
        const a = ( () => {
            const c = o(this, Qe).getRequestWillBeSent(s);
            if (c && (c.request.url !== r.request.url || c.request.method !== r.request.method)) {
                o(this, Qe).forgetRequestWillBeSent(s);
                return
            }
            return c
        }
        )();
        a ? (P(this, le, zx).call(this, a, r),
        P(this, le, Sd).call(this, t, a, i)) : o(this, Qe).storeRequestPaused(s, r)
    }
    ,
    zx = function(t, r) {
        t.request.headers = {
            ...t.request.headers,
            ...r.request.headers
        }
    }
    ,
    M$ = function(t, r) {
        const s = r.frameId ? o(this, Dl).frame(r.frameId) : null
          , i = new r_(t,s,r.requestId,o(this, Ts),r,[]);
        this.emit(zt.Request, i),
        i.finalizeInterceptions()
    }
    ,
    Sd = function(t, r, s, i=!1) {
        let a = [];
        if (r.redirectResponse) {
            let l = null;
            if (r.redirectHasExtraInfo && (l = o(this, Qe).responseExtraInfo(r.requestId).shift(),
            !l)) {
                o(this, Qe).queueRedirectInfo(r.requestId, {
                    event: r,
                    fetchRequestId: s
                });
                return
            }
            const d = o(this, Qe).getRequest(r.requestId);
            d && (P(this, le, $$).call(this, t, d, r.redirectResponse, l),
            a = d._redirectChain)
        }
        const c = r.frameId ? o(this, Dl).frame(r.frameId) : null
          , u = new r_(t,c,s,o(this, Ts),r,a);
        u._fromMemoryCache = i,
        o(this, Qe).storeRequest(r.requestId, u),
        this.emit(zt.Request, u),
        u.finalizeInterceptions()
    }
    ,
    N$ = function(t, r) {
        const s = o(this, Qe).getRequestWillBeSent(r.requestId);
        let i = o(this, Qe).getRequest(r.requestId);
        if (i && (i._fromMemoryCache = !0),
        !i && s && (P(this, le, Sd).call(this, t, s, void 0, !0),
        i = o(this, Qe).getRequest(r.requestId)),
        !i) {
            ge(new Error(`Request ${r.requestId} was served from cache but we could not find the corresponding request object`));
            return
        }
        this.emit(zt.RequestServedFromCache, i)
    }
    ,
    $$ = function(t, r, s, i) {
        const a = new BP(r,s,i);
        r._response = a,
        r._redirectChain.push(r),
        a._resolveBody(new Error("Response body is unavailable for redirect responses")),
        P(this, le, Jb).call(this, r, !1),
        this.emit(zt.Response, a),
        this.emit(zt.RequestFinished, r)
    }
    ,
    Vx = function(t, r, s) {
        const i = o(this, Qe).getRequest(r.requestId);
        if (!i)
            return;
        o(this, Qe).responseExtraInfo(r.requestId).length && ge(new Error("Unexpected extraInfo events for request " + r.requestId)),
        r.response.fromDiskCache && (s = null);
        const c = new BP(i,r.response,s);
        i._response = c,
        this.emit(zt.Response, c)
    }
    ,
    L$ = function(t, r) {
        const s = o(this, Qe).getRequest(r.requestId);
        let i = null;
        if (s && !s._fromMemoryCache && r.hasExtraInfo && (i = o(this, Qe).responseExtraInfo(r.requestId).shift(),
        !i)) {
            o(this, Qe).queueEventGroup(r.requestId, {
                responseReceivedEvent: r
            });
            return
        }
        P(this, le, Vx).call(this, t, r, i)
    }
    ,
    F$ = function(t, r) {
        const s = o(this, Qe).takeQueuedRedirectInfo(r.requestId);
        if (s) {
            o(this, Qe).responseExtraInfo(r.requestId).push(r),
            P(this, le, Sd).call(this, t, s.event, s.fetchRequestId);
            return
        }
        const i = o(this, Qe).getQueuedEventGroup(r.requestId);
        if (i) {
            o(this, Qe).forgetQueuedEventGroup(r.requestId),
            P(this, le, Vx).call(this, t, i.responseReceivedEvent, r),
            i.loadingFinishedEvent && P(this, le, Gx).call(this, t, i.loadingFinishedEvent),
            i.loadingFailedEvent && P(this, le, Jx).call(this, t, i.loadingFailedEvent);
            return
        }
        o(this, Qe).responseExtraInfo(r.requestId).push(r)
    }
    ,
    Jb = function(t, r) {
        const s = t.id
          , i = t._interceptionId;
        o(this, Qe).forgetRequest(s),
        i !== void 0 && o(this, Bl).delete(i),
        r && o(this, Qe).forget(s)
    }
    ,
    j$ = function(t, r) {
        const s = o(this, Qe).getQueuedEventGroup(r.requestId);
        s ? s.loadingFinishedEvent = r : P(this, le, Gx).call(this, t, r)
    }
    ,
    Gx = function(t, r) {
        var i;
        const s = o(this, Qe).getRequest(r.requestId);
        s && (P(this, le, Zx).call(this, t, s),
        s.response() && ((i = s.response()) == null || i._resolveBody()),
        P(this, le, Jb).call(this, s, !0),
        this.emit(zt.RequestFinished, s))
    }
    ,
    D$ = function(t, r) {
        const s = o(this, Qe).getQueuedEventGroup(r.requestId);
        s ? s.loadingFailedEvent = r : P(this, le, Jx).call(this, t, r)
    }
    ,
    Jx = function(t, r) {
        const s = o(this, Qe).getRequest(r.requestId);
        if (!s)
            return;
        P(this, le, Zx).call(this, t, s),
        s._failureText = r.errorText;
        const i = s.response();
        i && i._resolveBody(),
        P(this, le, Jb).call(this, s, !0),
        this.emit(zt.RequestFailed, s)
    }
    ,
    Zx = function(t, r) {
        t !== r.client && r.isNavigationRequest() && (r.client = t)
    }
    ;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const ZB = 100;
    class XB extends be {
        constructor(t, r, s) {
            super();
            b(this, Je);
            b(this, xm);
            b(this, ka);
            b(this, Ul);
            b(this, Cm, new Set);
            b(this, Sn);
            b(this, sc, new Map);
            b(this, Kl, new Set);
            J(this, "_frameTree", new VB);
            b(this, ic, new Set);
            b(this, km, new WeakMap);
            b(this, Tr);
            S(this, Sn, t),
            S(this, xm, r),
            S(this, ka, new JB(this)),
            S(this, Ul, s),
            this.setupEventListeners(o(this, Sn)),
            t.once(yt.Disconnected, () => {
                P(this, Je, Xx).call(this).catch(ge)
            }
            )
        }
        get timeoutSettings() {
            return o(this, Ul)
        }
        get networkManager() {
            return o(this, ka)
        }
        get client() {
            return o(this, Sn)
        }
        async swapFrameTree(t) {
            S(this, Sn, t),
            ne(o(this, Sn)instanceof zc, "CDPSession is not an instance of CDPSessionImpl.");
            const r = this._frameTree.getMainFrame();
            r && (o(this, ic).add(o(this, Sn)._target()._targetId),
            this._frameTree.removeFrame(r),
            r.updateId(o(this, Sn)._target()._targetId),
            this._frameTree.addFrame(r),
            r.updateClient(t)),
            this.setupEventListeners(t),
            t.once(yt.Disconnected, () => {
                P(this, Je, Xx).call(this).catch(ge)
            }
            ),
            await this.initialize(t, r),
            await o(this, ka).addClient(t),
            r && r.emit(ir.FrameSwappedByActivation, void 0)
        }
        async registerSpeculativeSession(t) {
            await o(this, ka).addClient(t)
        }
        setupEventListeners(t) {
            t.on("Page.frameAttached", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, Qx).call(this, t, r.frameId, r.parentFrameId)
            }
            ),
            t.on("Page.frameNavigated", async r => {
                var s;
                o(this, ic).add(r.frame.id),
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, eC).call(this, r.frame, r.type)
            }
            ),
            t.on("Page.navigatedWithinDocument", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, H$).call(this, r.frameId, r.url)
            }
            ),
            t.on("Page.frameDetached", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, W$).call(this, r.frameId, r.reason)
            }
            ),
            t.on("Page.frameStartedLoading", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, q$).call(this, r.frameId)
            }
            ),
            t.on("Page.frameStoppedLoading", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, U$).call(this, r.frameId)
            }
            ),
            t.on("Runtime.executionContextCreated", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, z$).call(this, r.context, t)
            }
            ),
            t.on("Page.lifecycleEvent", async r => {
                var s;
                await ((s = o(this, Tr)) == null ? void 0 : s.valueOrThrow()),
                P(this, Je, B$).call(this, r)
            }
            )
        }
        async initialize(t, r) {
            var s, i;
            try {
                (s = o(this, Tr)) == null || s.resolve(),
                S(this, Tr, pt.create()),
                await Promise.all([o(this, ka).addClient(t), t.send("Page.enable"), t.send("Page.getFrameTree").then( ({frameTree: a}) => {
                    var c;
                    P(this, Je, Yx).call(this, t, a),
                    (c = o(this, Tr)) == null || c.resolve()
                }
                ), t.send("Page.setLifecycleEventsEnabled", {
                    enabled: !0
                }), t.send("Runtime.enable").then( () => P(this, Je, K$).call(this, t, Zk)), ...(r ? Array.from(o(this, sc).values()) : []).map(a => r == null ? void 0 : r.addPreloadScript(a)), ...(r ? Array.from(o(this, Kl).values()) : []).map(a => r == null ? void 0 : r.addExposedFunctionBinding(a))])
            } catch (a) {
                if ((i = o(this, Tr)) == null || i.resolve(),
                hn(a) && Qv(a))
                    return;
                throw a
            }
        }
        page() {
            return o(this, xm)
        }
        mainFrame() {
            const t = this._frameTree.getMainFrame();
            return ne(t, "Requesting main frame too early!"),
            t
        }
        frames() {
            return Array.from(this._frameTree.frames())
        }
        frame(t) {
            return this._frameTree.getById(t) || null
        }
        async addExposedFunctionBinding(t) {
            o(this, Kl).add(t),
            await Promise.all(this.frames().map(async r => await r.addExposedFunctionBinding(t)))
        }
        async removeExposedFunctionBinding(t) {
            o(this, Kl).delete(t),
            await Promise.all(this.frames().map(async r => await r.removeExposedFunctionBinding(t)))
        }
        async evaluateOnNewDocument(t) {
            const {identifier: r} = await this.mainFrame()._client().send("Page.addScriptToEvaluateOnNewDocument", {
                source: t
            })
              , s = new MB(this.mainFrame(),r,t);
            return o(this, sc).set(r, s),
            await Promise.all(this.frames().map(async i => await i.addPreloadScript(s))),
            {
                identifier: r
            }
        }
        async removeScriptToEvaluateOnNewDocument(t) {
            const r = o(this, sc).get(t);
            if (!r)
                throw new Error(`Script to evaluate on new document with id ${t} not found`);
            o(this, sc).delete(t),
            await Promise.all(this.frames().map(s => {
                const i = r.getIdForFrame(s);
                if (i)
                    return s._client().send("Page.removeScriptToEvaluateOnNewDocument", {
                        identifier: i
                    }).catch(ge)
            }
            ))
        }
        onAttachedToTarget(t) {
            if (t._getTargetInfo().type !== "iframe")
                return;
            const r = this.frame(t._getTargetInfo().targetId);
            r && r.updateClient(t._session()),
            this.setupEventListeners(t._session()),
            this.initialize(t._session(), r)
        }
        _deviceRequestPromptManager(t) {
            let r = o(this, km).get(t);
            return r === void 0 && (r = new LB(t,o(this, Ul)),
            o(this, km).set(t, r)),
            r
        }
    }
    xm = new WeakMap,
    ka = new WeakMap,
    Ul = new WeakMap,
    Cm = new WeakMap,
    Sn = new WeakMap,
    sc = new WeakMap,
    Kl = new WeakMap,
    ic = new WeakMap,
    km = new WeakMap,
    Tr = new WeakMap,
    Je = new WeakSet,
    Xx = async function() {
        const t = this._frameTree.getMainFrame();
        if (!t)
            return;
        for (const s of t.childFrames())
            P(this, Je, Ed).call(this, s);
        const r = pt.create({
            timeout: ZB,
            message: "Frame was not swapped"
        });
        t.once(ir.FrameSwappedByActivation, () => {
            r.resolve()
        }
        );
        try {
            await r.valueOrThrow()
        } catch {
            P(this, Je, Ed).call(this, t)
        }
    }
    ,
    B$ = function(t) {
        const r = this.frame(t.frameId);
        r && (r._onLifecycleEvent(t.loaderId, t.name),
        this.emit(Vt.LifecycleEvent, r),
        r.emit(ir.LifecycleEvent, void 0))
    }
    ,
    q$ = function(t) {
        const r = this.frame(t);
        r && r._onLoadingStarted()
    }
    ,
    U$ = function(t) {
        const r = this.frame(t);
        r && (r._onLoadingStopped(),
        this.emit(Vt.LifecycleEvent, r),
        r.emit(ir.LifecycleEvent, void 0))
    }
    ,
    Yx = function(t, r) {
        if (r.frame.parentId && P(this, Je, Qx).call(this, t, r.frame.id, r.frame.parentId),
        o(this, ic).has(r.frame.id) ? o(this, ic).delete(r.frame.id) : P(this, Je, eC).call(this, r.frame, "Navigation"),
        !!r.childFrames)
            for (const s of r.childFrames)
                P(this, Je, Yx).call(this, t, s)
    }
    ,
    Qx = function(t, r, s) {
        let i = this.frame(r);
        if (i) {
            const a = this.frame(s);
            t && a && i.client !== (a == null ? void 0 : a.client) && i.updateClient(t);
            return
        }
        i = new jP(this,r,s,t),
        this._frameTree.addFrame(i),
        this.emit(Vt.FrameAttached, i)
    }
    ,
    eC = async function(t, r) {
        const s = t.id
          , i = !t.parentId;
        let a = this._frameTree.getById(s);
        if (a)
            for (const c of a.childFrames())
                P(this, Je, Ed).call(this, c);
        i && (a ? (this._frameTree.removeFrame(a),
        a._id = s) : a = new jP(this,s,void 0,o(this, Sn)),
        this._frameTree.addFrame(a)),
        a = await this._frameTree.waitForFrame(s),
        a._navigated(t),
        this.emit(Vt.FrameNavigated, a),
        a.emit(ir.FrameNavigated, r)
    }
    ,
    K$ = async function(t, r) {
        const s = `${t.id()}:${r}`;
        o(this, Cm).has(s) || (await t.send("Page.addScriptToEvaluateOnNewDocument", {
            source: `//# sourceURL=${Gr.INTERNAL_URL}`,
            worldName: r
        }),
        await Promise.all(this.frames().filter(i => i.client === t).map(i => t.send("Page.createIsolatedWorld", {
            frameId: i._id,
            worldName: r,
            grantUniveralAccess: !0
        }).catch(ge))),
        o(this, Cm).add(s))
    }
    ,
    H$ = function(t, r) {
        const s = this.frame(t);
        s && (s._navigatedWithinDocument(r),
        this.emit(Vt.FrameNavigatedWithinDocument, s),
        s.emit(ir.FrameNavigatedWithinDocument, void 0),
        this.emit(Vt.FrameNavigated, s),
        s.emit(ir.FrameNavigated, "Navigation"))
    }
    ,
    W$ = function(t, r) {
        const s = this.frame(t);
        if (s)
            switch (r) {
            case "remove":
                P(this, Je, Ed).call(this, s);
                break;
            case "swap":
                this.emit(Vt.FrameSwapped, s),
                s.emit(ir.FrameSwapped, void 0);
                break
            }
    }
    ,
    z$ = function(t, r) {
        const s = t.auxData
          , i = s && s.frameId
          , a = typeof i == "string" ? this.frame(i) : void 0;
        let c;
        if (a) {
            if (a.client !== r)
                return;
            t.auxData && t.auxData.isDefault ? c = a.worlds[ds] : t.name === Zk && (c = a.worlds[_y])
        }
        if (!c)
            return;
        const u = new LP((a == null ? void 0 : a.client) || o(this, Sn),t,c);
        c.setContext(u)
    }
    ,
    Ed = function(t) {
        for (const r of t.childFrames())
            P(this, Je, Ed).call(this, r);
        t[Ce](),
        this._frameTree.removeFrame(t),
        this.emit(Vt.FrameDetached, t),
        t.emit(ir.FrameDetached, t)
    }
    ;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const qP = {
        0: {
            keyCode: 48,
            key: "0",
            code: "Digit0"
        },
        1: {
            keyCode: 49,
            key: "1",
            code: "Digit1"
        },
        2: {
            keyCode: 50,
            key: "2",
            code: "Digit2"
        },
        3: {
            keyCode: 51,
            key: "3",
            code: "Digit3"
        },
        4: {
            keyCode: 52,
            key: "4",
            code: "Digit4"
        },
        5: {
            keyCode: 53,
            key: "5",
            code: "Digit5"
        },
        6: {
            keyCode: 54,
            key: "6",
            code: "Digit6"
        },
        7: {
            keyCode: 55,
            key: "7",
            code: "Digit7"
        },
        8: {
            keyCode: 56,
            key: "8",
            code: "Digit8"
        },
        9: {
            keyCode: 57,
            key: "9",
            code: "Digit9"
        },
        Power: {
            key: "Power",
            code: "Power"
        },
        Eject: {
            key: "Eject",
            code: "Eject"
        },
        Abort: {
            keyCode: 3,
            code: "Abort",
            key: "Cancel"
        },
        Help: {
            keyCode: 6,
            code: "Help",
            key: "Help"
        },
        Backspace: {
            keyCode: 8,
            code: "Backspace",
            key: "Backspace"
        },
        Tab: {
            keyCode: 9,
            code: "Tab",
            key: "Tab"
        },
        Numpad5: {
            keyCode: 12,
            shiftKeyCode: 101,
            key: "Clear",
            code: "Numpad5",
            shiftKey: "5",
            location: 3
        },
        NumpadEnter: {
            keyCode: 13,
            code: "NumpadEnter",
            key: "Enter",
            text: "\r",
            location: 3
        },
        Enter: {
            keyCode: 13,
            code: "Enter",
            key: "Enter",
            text: "\r"
        },
        "\r": {
            keyCode: 13,
            code: "Enter",
            key: "Enter",
            text: "\r"
        },
        "\n": {
            keyCode: 13,
            code: "Enter",
            key: "Enter",
            text: "\r"
        },
        ShiftLeft: {
            keyCode: 16,
            code: "ShiftLeft",
            key: "Shift",
            location: 1
        },
        ShiftRight: {
            keyCode: 16,
            code: "ShiftRight",
            key: "Shift",
            location: 2
        },
        ControlLeft: {
            keyCode: 17,
            code: "ControlLeft",
            key: "Control",
            location: 1
        },
        ControlRight: {
            keyCode: 17,
            code: "ControlRight",
            key: "Control",
            location: 2
        },
        AltLeft: {
            keyCode: 18,
            code: "AltLeft",
            key: "Alt",
            location: 1
        },
        AltRight: {
            keyCode: 18,
            code: "AltRight",
            key: "Alt",
            location: 2
        },
        Pause: {
            keyCode: 19,
            code: "Pause",
            key: "Pause"
        },
        CapsLock: {
            keyCode: 20,
            code: "CapsLock",
            key: "CapsLock"
        },
        Escape: {
            keyCode: 27,
            code: "Escape",
            key: "Escape"
        },
        Convert: {
            keyCode: 28,
            code: "Convert",
            key: "Convert"
        },
        NonConvert: {
            keyCode: 29,
            code: "NonConvert",
            key: "NonConvert"
        },
        Space: {
            keyCode: 32,
            code: "Space",
            key: " "
        },
        Numpad9: {
            keyCode: 33,
            shiftKeyCode: 105,
            key: "PageUp",
            code: "Numpad9",
            shiftKey: "9",
            location: 3
        },
        PageUp: {
            keyCode: 33,
            code: "PageUp",
            key: "PageUp"
        },
        Numpad3: {
            keyCode: 34,
            shiftKeyCode: 99,
            key: "PageDown",
            code: "Numpad3",
            shiftKey: "3",
            location: 3
        },
        PageDown: {
            keyCode: 34,
            code: "PageDown",
            key: "PageDown"
        },
        End: {
            keyCode: 35,
            code: "End",
            key: "End"
        },
        Numpad1: {
            keyCode: 35,
            shiftKeyCode: 97,
            key: "End",
            code: "Numpad1",
            shiftKey: "1",
            location: 3
        },
        Home: {
            keyCode: 36,
            code: "Home",
            key: "Home"
        },
        Numpad7: {
            keyCode: 36,
            shiftKeyCode: 103,
            key: "Home",
            code: "Numpad7",
            shiftKey: "7",
            location: 3
        },
        ArrowLeft: {
            keyCode: 37,
            code: "ArrowLeft",
            key: "ArrowLeft"
        },
        Numpad4: {
            keyCode: 37,
            shiftKeyCode: 100,
            key: "ArrowLeft",
            code: "Numpad4",
            shiftKey: "4",
            location: 3
        },
        Numpad8: {
            keyCode: 38,
            shiftKeyCode: 104,
            key: "ArrowUp",
            code: "Numpad8",
            shiftKey: "8",
            location: 3
        },
        ArrowUp: {
            keyCode: 38,
            code: "ArrowUp",
            key: "ArrowUp"
        },
        ArrowRight: {
            keyCode: 39,
            code: "ArrowRight",
            key: "ArrowRight"
        },
        Numpad6: {
            keyCode: 39,
            shiftKeyCode: 102,
            key: "ArrowRight",
            code: "Numpad6",
            shiftKey: "6",
            location: 3
        },
        Numpad2: {
            keyCode: 40,
            shiftKeyCode: 98,
            key: "ArrowDown",
            code: "Numpad2",
            shiftKey: "2",
            location: 3
        },
        ArrowDown: {
            keyCode: 40,
            code: "ArrowDown",
            key: "ArrowDown"
        },
        Select: {
            keyCode: 41,
            code: "Select",
            key: "Select"
        },
        Open: {
            keyCode: 43,
            code: "Open",
            key: "Execute"
        },
        PrintScreen: {
            keyCode: 44,
            code: "PrintScreen",
            key: "PrintScreen"
        },
        Insert: {
            keyCode: 45,
            code: "Insert",
            key: "Insert"
        },
        Numpad0: {
            keyCode: 45,
            shiftKeyCode: 96,
            key: "Insert",
            code: "Numpad0",
            shiftKey: "0",
            location: 3
        },
        Delete: {
            keyCode: 46,
            code: "Delete",
            key: "Delete"
        },
        NumpadDecimal: {
            keyCode: 46,
            shiftKeyCode: 110,
            code: "NumpadDecimal",
            key: "\0",
            shiftKey: ".",
            location: 3
        },
        Digit0: {
            keyCode: 48,
            code: "Digit0",
            shiftKey: ")",
            key: "0"
        },
        Digit1: {
            keyCode: 49,
            code: "Digit1",
            shiftKey: "!",
            key: "1"
        },
        Digit2: {
            keyCode: 50,
            code: "Digit2",
            shiftKey: "@",
            key: "2"
        },
        Digit3: {
            keyCode: 51,
            code: "Digit3",
            shiftKey: "#",
            key: "3"
        },
        Digit4: {
            keyCode: 52,
            code: "Digit4",
            shiftKey: "$",
            key: "4"
        },
        Digit5: {
            keyCode: 53,
            code: "Digit5",
            shiftKey: "%",
            key: "5"
        },
        Digit6: {
            keyCode: 54,
            code: "Digit6",
            shiftKey: "^",
            key: "6"
        },
        Digit7: {
            keyCode: 55,
            code: "Digit7",
            shiftKey: "&",
            key: "7"
        },
        Digit8: {
            keyCode: 56,
            code: "Digit8",
            shiftKey: "*",
            key: "8"
        },
        Digit9: {
            keyCode: 57,
            code: "Digit9",
            shiftKey: "(",
            key: "9"
        },
        KeyA: {
            keyCode: 65,
            code: "KeyA",
            shiftKey: "A",
            key: "a"
        },
        KeyB: {
            keyCode: 66,
            code: "KeyB",
            shiftKey: "B",
            key: "b"
        },
        KeyC: {
            keyCode: 67,
            code: "KeyC",
            shiftKey: "C",
            key: "c"
        },
        KeyD: {
            keyCode: 68,
            code: "KeyD",
            shiftKey: "D",
            key: "d"
        },
        KeyE: {
            keyCode: 69,
            code: "KeyE",
            shiftKey: "E",
            key: "e"
        },
        KeyF: {
            keyCode: 70,
            code: "KeyF",
            shiftKey: "F",
            key: "f"
        },
        KeyG: {
            keyCode: 71,
            code: "KeyG",
            shiftKey: "G",
            key: "g"
        },
        KeyH: {
            keyCode: 72,
            code: "KeyH",
            shiftKey: "H",
            key: "h"
        },
        KeyI: {
            keyCode: 73,
            code: "KeyI",
            shiftKey: "I",
            key: "i"
        },
        KeyJ: {
            keyCode: 74,
            code: "KeyJ",
            shiftKey: "J",
            key: "j"
        },
        KeyK: {
            keyCode: 75,
            code: "KeyK",
            shiftKey: "K",
            key: "k"
        },
        KeyL: {
            keyCode: 76,
            code: "KeyL",
            shiftKey: "L",
            key: "l"
        },
        KeyM: {
            keyCode: 77,
            code: "KeyM",
            shiftKey: "M",
            key: "m"
        },
        KeyN: {
            keyCode: 78,
            code: "KeyN",
            shiftKey: "N",
            key: "n"
        },
        KeyO: {
            keyCode: 79,
            code: "KeyO",
            shiftKey: "O",
            key: "o"
        },
        KeyP: {
            keyCode: 80,
            code: "KeyP",
            shiftKey: "P",
            key: "p"
        },
        KeyQ: {
            keyCode: 81,
            code: "KeyQ",
            shiftKey: "Q",
            key: "q"
        },
        KeyR: {
            keyCode: 82,
            code: "KeyR",
            shiftKey: "R",
            key: "r"
        },
        KeyS: {
            keyCode: 83,
            code: "KeyS",
            shiftKey: "S",
            key: "s"
        },
        KeyT: {
            keyCode: 84,
            code: "KeyT",
            shiftKey: "T",
            key: "t"
        },
        KeyU: {
            keyCode: 85,
            code: "KeyU",
            shiftKey: "U",
            key: "u"
        },
        KeyV: {
            keyCode: 86,
            code: "KeyV",
            shiftKey: "V",
            key: "v"
        },
        KeyW: {
            keyCode: 87,
            code: "KeyW",
            shiftKey: "W",
            key: "w"
        },
        KeyX: {
            keyCode: 88,
            code: "KeyX",
            shiftKey: "X",
            key: "x"
        },
        KeyY: {
            keyCode: 89,
            code: "KeyY",
            shiftKey: "Y",
            key: "y"
        },
        KeyZ: {
            keyCode: 90,
            code: "KeyZ",
            shiftKey: "Z",
            key: "z"
        },
        MetaLeft: {
            keyCode: 91,
            code: "MetaLeft",
            key: "Meta",
            location: 1
        },
        MetaRight: {
            keyCode: 92,
            code: "MetaRight",
            key: "Meta",
            location: 2
        },
        ContextMenu: {
            keyCode: 93,
            code: "ContextMenu",
            key: "ContextMenu"
        },
        NumpadMultiply: {
            keyCode: 106,
            code: "NumpadMultiply",
            key: "*",
            location: 3
        },
        NumpadAdd: {
            keyCode: 107,
            code: "NumpadAdd",
            key: "+",
            location: 3
        },
        NumpadSubtract: {
            keyCode: 109,
            code: "NumpadSubtract",
            key: "-",
            location: 3
        },
        NumpadDivide: {
            keyCode: 111,
            code: "NumpadDivide",
            key: "/",
            location: 3
        },
        F1: {
            keyCode: 112,
            code: "F1",
            key: "F1"
        },
        F2: {
            keyCode: 113,
            code: "F2",
            key: "F2"
        },
        F3: {
            keyCode: 114,
            code: "F3",
            key: "F3"
        },
        F4: {
            keyCode: 115,
            code: "F4",
            key: "F4"
        },
        F5: {
            keyCode: 116,
            code: "F5",
            key: "F5"
        },
        F6: {
            keyCode: 117,
            code: "F6",
            key: "F6"
        },
        F7: {
            keyCode: 118,
            code: "F7",
            key: "F7"
        },
        F8: {
            keyCode: 119,
            code: "F8",
            key: "F8"
        },
        F9: {
            keyCode: 120,
            code: "F9",
            key: "F9"
        },
        F10: {
            keyCode: 121,
            code: "F10",
            key: "F10"
        },
        F11: {
            keyCode: 122,
            code: "F11",
            key: "F11"
        },
        F12: {
            keyCode: 123,
            code: "F12",
            key: "F12"
        },
        F13: {
            keyCode: 124,
            code: "F13",
            key: "F13"
        },
        F14: {
            keyCode: 125,
            code: "F14",
            key: "F14"
        },
        F15: {
            keyCode: 126,
            code: "F15",
            key: "F15"
        },
        F16: {
            keyCode: 127,
            code: "F16",
            key: "F16"
        },
        F17: {
            keyCode: 128,
            code: "F17",
            key: "F17"
        },
        F18: {
            keyCode: 129,
            code: "F18",
            key: "F18"
        },
        F19: {
            keyCode: 130,
            code: "F19",
            key: "F19"
        },
        F20: {
            keyCode: 131,
            code: "F20",
            key: "F20"
        },
        F21: {
            keyCode: 132,
            code: "F21",
            key: "F21"
        },
        F22: {
            keyCode: 133,
            code: "F22",
            key: "F22"
        },
        F23: {
            keyCode: 134,
            code: "F23",
            key: "F23"
        },
        F24: {
            keyCode: 135,
            code: "F24",
            key: "F24"
        },
        NumLock: {
            keyCode: 144,
            code: "NumLock",
            key: "NumLock"
        },
        ScrollLock: {
            keyCode: 145,
            code: "ScrollLock",
            key: "ScrollLock"
        },
        AudioVolumeMute: {
            keyCode: 173,
            code: "AudioVolumeMute",
            key: "AudioVolumeMute"
        },
        AudioVolumeDown: {
            keyCode: 174,
            code: "AudioVolumeDown",
            key: "AudioVolumeDown"
        },
        AudioVolumeUp: {
            keyCode: 175,
            code: "AudioVolumeUp",
            key: "AudioVolumeUp"
        },
        MediaTrackNext: {
            keyCode: 176,
            code: "MediaTrackNext",
            key: "MediaTrackNext"
        },
        MediaTrackPrevious: {
            keyCode: 177,
            code: "MediaTrackPrevious",
            key: "MediaTrackPrevious"
        },
        MediaStop: {
            keyCode: 178,
            code: "MediaStop",
            key: "MediaStop"
        },
        MediaPlayPause: {
            keyCode: 179,
            code: "MediaPlayPause",
            key: "MediaPlayPause"
        },
        Semicolon: {
            keyCode: 186,
            code: "Semicolon",
            shiftKey: ":",
            key: ";"
        },
        Equal: {
            keyCode: 187,
            code: "Equal",
            shiftKey: "+",
            key: "="
        },
        NumpadEqual: {
            keyCode: 187,
            code: "NumpadEqual",
            key: "=",
            location: 3
        },
        Comma: {
            keyCode: 188,
            code: "Comma",
            shiftKey: "<",
            key: ","
        },
        Minus: {
            keyCode: 189,
            code: "Minus",
            shiftKey: "_",
            key: "-"
        },
        Period: {
            keyCode: 190,
            code: "Period",
            shiftKey: ">",
            key: "."
        },
        Slash: {
            keyCode: 191,
            code: "Slash",
            shiftKey: "?",
            key: "/"
        },
        Backquote: {
            keyCode: 192,
            code: "Backquote",
            shiftKey: "~",
            key: "`"
        },
        BracketLeft: {
            keyCode: 219,
            code: "BracketLeft",
            shiftKey: "{",
            key: "["
        },
        Backslash: {
            keyCode: 220,
            code: "Backslash",
            shiftKey: "|",
            key: "\\"
        },
        BracketRight: {
            keyCode: 221,
            code: "BracketRight",
            shiftKey: "}",
            key: "]"
        },
        Quote: {
            keyCode: 222,
            code: "Quote",
            shiftKey: '"',
            key: "'"
        },
        AltGraph: {
            keyCode: 225,
            code: "AltGraph",
            key: "AltGraph"
        },
        Props: {
            keyCode: 247,
            code: "Props",
            key: "CrSel"
        },
        Cancel: {
            keyCode: 3,
            key: "Cancel",
            code: "Abort"
        },
        Clear: {
            keyCode: 12,
            key: "Clear",
            code: "Numpad5",
            location: 3
        },
        Shift: {
            keyCode: 16,
            key: "Shift",
            code: "ShiftLeft",
            location: 1
        },
        Control: {
            keyCode: 17,
            key: "Control",
            code: "ControlLeft",
            location: 1
        },
        Alt: {
            keyCode: 18,
            key: "Alt",
            code: "AltLeft",
            location: 1
        },
        Accept: {
            keyCode: 30,
            key: "Accept"
        },
        ModeChange: {
            keyCode: 31,
            key: "ModeChange"
        },
        " ": {
            keyCode: 32,
            key: " ",
            code: "Space"
        },
        Print: {
            keyCode: 42,
            key: "Print"
        },
        Execute: {
            keyCode: 43,
            key: "Execute",
            code: "Open"
        },
        "\0": {
            keyCode: 46,
            key: "\0",
            code: "NumpadDecimal",
            location: 3
        },
        a: {
            keyCode: 65,
            key: "a",
            code: "KeyA"
        },
        b: {
            keyCode: 66,
            key: "b",
            code: "KeyB"
        },
        c: {
            keyCode: 67,
            key: "c",
            code: "KeyC"
        },
        d: {
            keyCode: 68,
            key: "d",
            code: "KeyD"
        },
        e: {
            keyCode: 69,
            key: "e",
            code: "KeyE"
        },
        f: {
            keyCode: 70,
            key: "f",
            code: "KeyF"
        },
        g: {
            keyCode: 71,
            key: "g",
            code: "KeyG"
        },
        h: {
            keyCode: 72,
            key: "h",
            code: "KeyH"
        },
        i: {
            keyCode: 73,
            key: "i",
            code: "KeyI"
        },
        j: {
            keyCode: 74,
            key: "j",
            code: "KeyJ"
        },
        k: {
            keyCode: 75,
            key: "k",
            code: "KeyK"
        },
        l: {
            keyCode: 76,
            key: "l",
            code: "KeyL"
        },
        m: {
            keyCode: 77,
            key: "m",
            code: "KeyM"
        },
        n: {
            keyCode: 78,
            key: "n",
            code: "KeyN"
        },
        o: {
            keyCode: 79,
            key: "o",
            code: "KeyO"
        },
        p: {
            keyCode: 80,
            key: "p",
            code: "KeyP"
        },
        q: {
            keyCode: 81,
            key: "q",
            code: "KeyQ"
        },
        r: {
            keyCode: 82,
            key: "r",
            code: "KeyR"
        },
        s: {
            keyCode: 83,
            key: "s",
            code: "KeyS"
        },
        t: {
            keyCode: 84,
            key: "t",
            code: "KeyT"
        },
        u: {
            keyCode: 85,
            key: "u",
            code: "KeyU"
        },
        v: {
            keyCode: 86,
            key: "v",
            code: "KeyV"
        },
        w: {
            keyCode: 87,
            key: "w",
            code: "KeyW"
        },
        x: {
            keyCode: 88,
            key: "x",
            code: "KeyX"
        },
        y: {
            keyCode: 89,
            key: "y",
            code: "KeyY"
        },
        z: {
            keyCode: 90,
            key: "z",
            code: "KeyZ"
        },
        Meta: {
            keyCode: 91,
            key: "Meta",
            code: "MetaLeft",
            location: 1
        },
        "*": {
            keyCode: 106,
            key: "*",
            code: "NumpadMultiply",
            location: 3
        },
        "+": {
            keyCode: 107,
            key: "+",
            code: "NumpadAdd",
            location: 3
        },
        "-": {
            keyCode: 109,
            key: "-",
            code: "NumpadSubtract",
            location: 3
        },
        "/": {
            keyCode: 111,
            key: "/",
            code: "NumpadDivide",
            location: 3
        },
        ";": {
            keyCode: 186,
            key: ";",
            code: "Semicolon"
        },
        "=": {
            keyCode: 187,
            key: "=",
            code: "Equal"
        },
        ",": {
            keyCode: 188,
            key: ",",
            code: "Comma"
        },
        ".": {
            keyCode: 190,
            key: ".",
            code: "Period"
        },
        "`": {
            keyCode: 192,
            key: "`",
            code: "Backquote"
        },
        "[": {
            keyCode: 219,
            key: "[",
            code: "BracketLeft"
        },
        "\\": {
            keyCode: 220,
            key: "\\",
            code: "Backslash"
        },
        "]": {
            keyCode: 221,
            key: "]",
            code: "BracketRight"
        },
        "'": {
            keyCode: 222,
            key: "'",
            code: "Quote"
        },
        Attn: {
            keyCode: 246,
            key: "Attn"
        },
        CrSel: {
            keyCode: 247,
            key: "CrSel",
            code: "Props"
        },
        ExSel: {
            keyCode: 248,
            key: "ExSel"
        },
        EraseEof: {
            keyCode: 249,
            key: "EraseEof"
        },
        Play: {
            keyCode: 250,
            key: "Play"
        },
        ZoomOut: {
            keyCode: 251,
            key: "ZoomOut"
        },
        ")": {
            keyCode: 48,
            key: ")",
            code: "Digit0"
        },
        "!": {
            keyCode: 49,
            key: "!",
            code: "Digit1"
        },
        "@": {
            keyCode: 50,
            key: "@",
            code: "Digit2"
        },
        "#": {
            keyCode: 51,
            key: "#",
            code: "Digit3"
        },
        $: {
            keyCode: 52,
            key: "$",
            code: "Digit4"
        },
        "%": {
            keyCode: 53,
            key: "%",
            code: "Digit5"
        },
        "^": {
            keyCode: 54,
            key: "^",
            code: "Digit6"
        },
        "&": {
            keyCode: 55,
            key: "&",
            code: "Digit7"
        },
        "(": {
            keyCode: 57,
            key: "(",
            code: "Digit9"
        },
        A: {
            keyCode: 65,
            key: "A",
            code: "KeyA"
        },
        B: {
            keyCode: 66,
            key: "B",
            code: "KeyB"
        },
        C: {
            keyCode: 67,
            key: "C",
            code: "KeyC"
        },
        D: {
            keyCode: 68,
            key: "D",
            code: "KeyD"
        },
        E: {
            keyCode: 69,
            key: "E",
            code: "KeyE"
        },
        F: {
            keyCode: 70,
            key: "F",
            code: "KeyF"
        },
        G: {
            keyCode: 71,
            key: "G",
            code: "KeyG"
        },
        H: {
            keyCode: 72,
            key: "H",
            code: "KeyH"
        },
        I: {
            keyCode: 73,
            key: "I",
            code: "KeyI"
        },
        J: {
            keyCode: 74,
            key: "J",
            code: "KeyJ"
        },
        K: {
            keyCode: 75,
            key: "K",
            code: "KeyK"
        },
        L: {
            keyCode: 76,
            key: "L",
            code: "KeyL"
        },
        M: {
            keyCode: 77,
            key: "M",
            code: "KeyM"
        },
        N: {
            keyCode: 78,
            key: "N",
            code: "KeyN"
        },
        O: {
            keyCode: 79,
            key: "O",
            code: "KeyO"
        },
        P: {
            keyCode: 80,
            key: "P",
            code: "KeyP"
        },
        Q: {
            keyCode: 81,
            key: "Q",
            code: "KeyQ"
        },
        R: {
            keyCode: 82,
            key: "R",
            code: "KeyR"
        },
        S: {
            keyCode: 83,
            key: "S",
            code: "KeyS"
        },
        T: {
            keyCode: 84,
            key: "T",
            code: "KeyT"
        },
        U: {
            keyCode: 85,
            key: "U",
            code: "KeyU"
        },
        V: {
            keyCode: 86,
            key: "V",
            code: "KeyV"
        },
        W: {
            keyCode: 87,
            key: "W",
            code: "KeyW"
        },
        X: {
            keyCode: 88,
            key: "X",
            code: "KeyX"
        },
        Y: {
            keyCode: 89,
            key: "Y",
            code: "KeyY"
        },
        Z: {
            keyCode: 90,
            key: "Z",
            code: "KeyZ"
        },
        ":": {
            keyCode: 186,
            key: ":",
            code: "Semicolon"
        },
        "<": {
            keyCode: 188,
            key: "<",
            code: "Comma"
        },
        _: {
            keyCode: 189,
            key: "_",
            code: "Minus"
        },
        ">": {
            keyCode: 190,
            key: ">",
            code: "Period"
        },
        "?": {
            keyCode: 191,
            key: "?",
            code: "Slash"
        },
        "~": {
            keyCode: 192,
            key: "~",
            code: "Backquote"
        },
        "{": {
            keyCode: 219,
            key: "{",
            code: "BracketLeft"
        },
        "|": {
            keyCode: 220,
            key: "|",
            code: "Backslash"
        },
        "}": {
            keyCode: 221,
            key: "}",
            code: "BracketRight"
        },
        '"': {
            keyCode: 222,
            key: '"',
            code: "Quote"
        },
        SoftLeft: {
            key: "SoftLeft",
            code: "SoftLeft",
            location: 4
        },
        SoftRight: {
            key: "SoftRight",
            code: "SoftRight",
            location: 4
        },
        Camera: {
            keyCode: 44,
            key: "Camera",
            code: "Camera",
            location: 4
        },
        Call: {
            key: "Call",
            code: "Call",
            location: 4
        },
        EndCall: {
            keyCode: 95,
            key: "EndCall",
            code: "EndCall",
            location: 4
        },
        VolumeDown: {
            keyCode: 182,
            key: "VolumeDown",
            code: "VolumeDown",
            location: 4
        },
        VolumeUp: {
            keyCode: 183,
            key: "VolumeUp",
            code: "VolumeUp",
            location: 4
        }
    };
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class YB extends gP {
        constructor(t) {
            super();
            b(this, Ta);
            b(this, Pa);
            b(this, Hl, new Set);
            J(this, "_modifiers", 0);
            S(this, Pa, t)
        }
        updateClient(t) {
            S(this, Pa, t)
        }
        async down(t, r={
            text: void 0,
            commands: []
        }) {
            const s = P(this, Ta, rC).call(this, t)
              , i = o(this, Hl).has(s.code);
            o(this, Hl).add(s.code),
            this._modifiers |= P(this, Ta, tC).call(this, s.key);
            const a = r.text === void 0 ? s.text : r.text;
            await o(this, Pa).send("Input.dispatchKeyEvent", {
                type: a ? "keyDown" : "rawKeyDown",
                modifiers: this._modifiers,
                windowsVirtualKeyCode: s.keyCode,
                code: s.code,
                key: s.key,
                text: a,
                unmodifiedText: a,
                autoRepeat: i,
                location: s.location,
                isKeypad: s.location === 3,
                commands: r.commands
            })
        }
        async up(t) {
            const r = P(this, Ta, rC).call(this, t);
            this._modifiers &= ~P(this, Ta, tC).call(this, r.key),
            o(this, Hl).delete(r.code),
            await o(this, Pa).send("Input.dispatchKeyEvent", {
                type: "keyUp",
                modifiers: this._modifiers,
                key: r.key,
                windowsVirtualKeyCode: r.keyCode,
                code: r.code,
                location: r.location
            })
        }
        async sendCharacter(t) {
            await o(this, Pa).send("Input.insertText", {
                text: t
            })
        }
        charIsKey(t) {
            return !!qP[t]
        }
        async type(t, r={}) {
            const s = r.delay || void 0;
            for (const i of t)
                this.charIsKey(i) ? await this.press(i, {
                    delay: s
                }) : (s && await new Promise(a => setTimeout(a, s)),
                await this.sendCharacter(i))
        }
        async press(t, r={}) {
            const {delay: s=null} = r;
            await this.down(t, r),
            s && await new Promise(i => setTimeout(i, r.delay)),
            await this.up(t)
        }
    }
    Pa = new WeakMap,
    Hl = new WeakMap,
    Ta = new WeakSet,
    tC = function(t) {
        return t === "Alt" ? 1 : t === "Control" ? 2 : t === "Meta" ? 4 : t === "Shift" ? 8 : 0
    }
    ,
    rC = function(t) {
        const r = this._modifiers & 8
          , s = {
            key: "",
            keyCode: 0,
            code: "",
            text: "",
            location: 0
        }
          , i = qP[t];
        return ne(i, `Unknown key: "${t}"`),
        i.key && (s.key = i.key),
        r && i.shiftKey && (s.key = i.shiftKey),
        i.keyCode && (s.keyCode = i.keyCode),
        r && i.shiftKeyCode && (s.keyCode = i.shiftKeyCode),
        i.code && (s.code = i.code),
        i.location && (s.location = i.location),
        s.key.length === 1 && (s.text = s.key),
        i.text && (s.text = i.text),
        r && i.shiftText && (s.text = i.shiftText),
        this._modifiers & -9 && (s.text = ""),
        s
    }
    ;
    const UP = n => {
        switch (n) {
        case wt.Left:
            return 1;
        case wt.Right:
            return 2;
        case wt.Middle:
            return 4;
        case wt.Back:
            return 8;
        case wt.Forward:
            return 16
        }
    }
      , QB = n => n & 1 ? wt.Left : n & 2 ? wt.Right : n & 4 ? wt.Middle : n & 8 ? wt.Back : n & 16 ? wt.Forward : "none";
    class eq extends yP {
        constructor(t, r) {
            super();
            b(this, At);
            b(this, on);
            b(this, es);
            b(this, Wl, {
                position: {
                    x: 0,
                    y: 0
                },
                buttons: 0
            });
            b(this, ac, []);
            S(this, on, t),
            S(this, es, r)
        }
        updateClient(t) {
            S(this, on, t)
        }
        async reset() {
            const t = [];
            for (const [r,s] of [[1, wt.Left], [4, wt.Middle], [2, wt.Right], [16, wt.Forward], [8, wt.Back]])
                o(this, At, ln).buttons & r && t.push(this.up({
                    button: s
                }));
            (o(this, At, ln).position.x !== 0 || o(this, At, ln).position.y !== 0) && t.push(this.move(0, 0)),
            await Promise.all(t)
        }
        async move(t, r, s={}) {
            const {steps: i=1} = s
              , a = o(this, At, ln).position
              , c = {
                x: t,
                y: r
            };
            for (let u = 1; u <= i; u++)
                await P(this, At, Zb).call(this, l => {
                    l({
                        position: {
                            x: a.x + (c.x - a.x) * (u / i),
                            y: a.y + (c.y - a.y) * (u / i)
                        }
                    });
                    const {buttons: d, position: h} = o(this, At, ln);
                    return o(this, on).send("Input.dispatchMouseEvent", {
                        type: "mouseMoved",
                        modifiers: o(this, es)._modifiers,
                        buttons: d,
                        button: QB(d),
                        ...h
                    })
                }
                )
        }
        async down(t={}) {
            const {button: r=wt.Left, clickCount: s=1} = t
              , i = UP(r);
            if (!i)
                throw new Error(`Unsupported mouse button: ${r}`);
            if (o(this, At, ln).buttons & i)
                throw new Error(`'${r}' is already pressed.`);
            await P(this, At, Zb).call(this, a => {
                a({
                    buttons: o(this, At, ln).buttons | i
                });
                const {buttons: c, position: u} = o(this, At, ln);
                return o(this, on).send("Input.dispatchMouseEvent", {
                    type: "mousePressed",
                    modifiers: o(this, es)._modifiers,
                    clickCount: s,
                    buttons: c,
                    button: r,
                    ...u
                })
            }
            )
        }
        async up(t={}) {
            const {button: r=wt.Left, clickCount: s=1} = t
              , i = UP(r);
            if (!i)
                throw new Error(`Unsupported mouse button: ${r}`);
            if (!(o(this, At, ln).buttons & i))
                throw new Error(`'${r}' is not pressed.`);
            await P(this, At, Zb).call(this, a => {
                a({
                    buttons: o(this, At, ln).buttons & ~i
                });
                const {buttons: c, position: u} = o(this, At, ln);
                return o(this, on).send("Input.dispatchMouseEvent", {
                    type: "mouseReleased",
                    modifiers: o(this, es)._modifiers,
                    clickCount: s,
                    buttons: c,
                    button: r,
                    ...u
                })
            }
            )
        }
        async click(t, r, s={}) {
            const {delay: i, count: a=1, clickCount: c=a} = s;
            if (a < 1)
                throw new Error("Click must occur a positive number of times.");
            const u = [this.move(t, r)];
            if (c === a)
                for (let l = 1; l < a; ++l)
                    u.push(this.down({
                        ...s,
                        clickCount: l
                    }), this.up({
                        ...s,
                        clickCount: l
                    }));
            u.push(this.down({
                ...s,
                clickCount: c
            })),
            typeof i == "number" && (await Promise.all(u),
            u.length = 0,
            await new Promise(l => {
                setTimeout(l, i)
            }
            )),
            u.push(this.up({
                ...s,
                clickCount: c
            })),
            await Promise.all(u)
        }
        async wheel(t={}) {
            const {deltaX: r=0, deltaY: s=0} = t
              , {position: i, buttons: a} = o(this, At, ln);
            await o(this, on).send("Input.dispatchMouseEvent", {
                type: "mouseWheel",
                pointerType: "mouse",
                modifiers: o(this, es)._modifiers,
                deltaY: s,
                deltaX: r,
                buttons: a,
                ...i
            })
        }
        async drag(t, r) {
            const s = new Promise(i => {
                o(this, on).once("Input.dragIntercepted", a => i(a.data))
            }
            );
            return await this.move(t.x, t.y),
            await this.down(),
            await this.move(r.x, r.y),
            await s
        }
        async dragEnter(t, r) {
            await o(this, on).send("Input.dispatchDragEvent", {
                type: "dragEnter",
                x: t.x,
                y: t.y,
                modifiers: o(this, es)._modifiers,
                data: r
            })
        }
        async dragOver(t, r) {
            await o(this, on).send("Input.dispatchDragEvent", {
                type: "dragOver",
                x: t.x,
                y: t.y,
                modifiers: o(this, es)._modifiers,
                data: r
            })
        }
        async drop(t, r) {
            await o(this, on).send("Input.dispatchDragEvent", {
                type: "drop",
                x: t.x,
                y: t.y,
                modifiers: o(this, es)._modifiers,
                data: r
            })
        }
        async dragAndDrop(t, r, s={}) {
            const {delay: i=null} = s
              , a = await this.drag(t, r);
            await this.dragEnter(r, a),
            await this.dragOver(r, a),
            i && await new Promise(c => setTimeout(c, i)),
            await this.drop(r, a),
            await this.up()
        }
    }
    on = new WeakMap,
    es = new WeakMap,
    Wl = new WeakMap,
    At = new WeakSet,
    ln = function() {
        return Object.assign({
            ...o(this, Wl)
        }, ...o(this, ac))
    }
    ,
    ac = new WeakMap,
    V$ = function() {
        const t = {};
        o(this, ac).push(t);
        const r = () => {
            o(this, ac).splice(o(this, ac).indexOf(t), 1)
        }
        ;
        return {
            update: s => {
                Object.assign(t, s)
            }
            ,
            commit: () => {
                S(this, Wl, {
                    ...o(this, Wl),
                    ...t
                }),
                r()
            }
            ,
            rollback: r
        }
    }
    ,
    Zb = async function(t) {
        const {update: r, commit: s, rollback: i} = P(this, At, V$).call(this);
        try {
            await t(r),
            s()
        } catch (a) {
            throw i(),
            a
        }
    }
    ;
    class tq {
        constructor(e, t, r, s) {
            b(this, Pm, !1);
            b(this, Tm);
            b(this, ci);
            b(this, Aa);
            b(this, oc);
            S(this, Aa, e),
            S(this, Tm, t),
            S(this, oc, r),
            S(this, ci, s)
        }
        updateClient(e) {
            S(this, Aa, e)
        }
        async start() {
            if (o(this, Pm))
                throw new ey("Touch has already started");
            await o(this, Aa).send("Input.dispatchTouchEvent", {
                type: "touchStart",
                touchPoints: [o(this, ci)],
                modifiers: o(this, oc)._modifiers
            }),
            S(this, Pm, !0)
        }
        move(e, t) {
            return o(this, ci).x = Math.round(e),
            o(this, ci).y = Math.round(t),
            o(this, Aa).send("Input.dispatchTouchEvent", {
                type: "touchMove",
                touchPoints: [o(this, ci)],
                modifiers: o(this, oc)._modifiers
            })
        }
        async end() {
            await o(this, Aa).send("Input.dispatchTouchEvent", {
                type: "touchEnd",
                touchPoints: [o(this, ci)],
                modifiers: o(this, oc)._modifiers
            }),
            o(this, Tm).removeHandle(this)
        }
    }
    Pm = new WeakMap,
    Tm = new WeakMap,
    ci = new WeakMap,
    Aa = new WeakMap,
    oc = new WeakMap;
    class rq extends wP {
        constructor(t, r) {
            super();
            b(this, zl);
            b(this, Am);
            S(this, zl, t),
            S(this, Am, r)
        }
        updateClient(t) {
            S(this, zl, t),
            this.touches.forEach(r => {
                r.updateClient(t)
            }
            )
        }
        async touchStart(t, r) {
            const s = this.idGenerator()
              , i = {
                x: Math.round(t),
                y: Math.round(r),
                radiusX: .5,
                radiusY: .5,
                force: .5,
                id: s
            }
              , a = new tq(o(this, zl),this,o(this, Am),i);
            return await a.start(),
            this.touches.push(a),
            a
        }
    }
    zl = new WeakMap,
    Am = new WeakMap;
    class KP {
        constructor(e) {
            b(this, ui);
            b(this, Vl, !1);
            b(this, Im);
            S(this, ui, e)
        }
        updateClient(e) {
            S(this, ui, e)
        }
        async start(e={}) {
            ne(!o(this, Vl), "Cannot start recording trace while already recording trace.");
            const t = ["-*", "devtools.timeline", "v8.execute", "disabled-by-default-devtools.timeline", "disabled-by-default-devtools.timeline.frame", "toplevel", "blink.console", "blink.user_timing", "latencyInfo", "disabled-by-default-devtools.timeline.stack", "disabled-by-default-v8.cpu_profiler"]
              , {path: r, screenshots: s=!1, categories: i=t} = e;
            s && i.push("disabled-by-default-devtools.screenshot");
            const a = i.filter(u => u.startsWith("-")).map(u => u.slice(1))
              , c = i.filter(u => !u.startsWith("-"));
            S(this, Im, r),
            S(this, Vl, !0),
            await o(this, ui).send("Tracing.start", {
                transferMode: "ReturnAsStream",
                traceConfig: {
                    excludedCategories: a,
                    includedCategories: c
                }
            })
        }
        async stop() {
            const e = pt.create();
            return o(this, ui).once("Tracing.tracingComplete", async t => {
                try {
                    ne(t.stream, 'Missing "stream"');
                    const r = await Jk(o(this, ui), t.stream)
                      , s = await Gk(r, o(this, Im));
                    e.resolve(s ?? void 0)
                } catch (r) {
                    hn(r) ? e.reject(r) : e.reject(new Error(`Unknown error: ${r}`))
                }
            }
            ),
            await o(this, ui).send("Tracing.end"),
            S(this, Vl, !1),
            await e.valueOrThrow()
        }
    }
    ui = new WeakMap,
    Vl = new WeakMap,
    Im = new WeakMap;
    class HP extends CP {
        constructor(t, r, s, i, a, c) {
            super(r);
            b(this, As);
            b(this, li);
            b(this, Om);
            b(this, Rm);
            S(this, Om, s),
            S(this, li, t),
            S(this, Rm, i),
            S(this, As, new e_(this,new Gv)),
            o(this, li).once("Runtime.executionContextCreated", async u => {
                o(this, As).setContext(new LP(t,u.context,o(this, As)))
            }
            ),
            o(this, As).emitter.on("consoleapicalled", async u => {
                try {
                    return a(u.type, u.args.map(l => new by(o(this, As),l)), u.stackTrace)
                } catch (l) {
                    ge(l)
                }
            }
            ),
            o(this, li).on("Runtime.exceptionThrown", c),
            o(this, li).once(yt.Disconnected, () => {
                o(this, As).dispose()
            }
            ),
            o(this, li).send("Runtime.enable").catch(ge)
        }
        mainRealm() {
            return o(this, As)
        }
        get client() {
            return o(this, li)
        }
        async close() {
            var t, r;
            switch (o(this, Rm)) {
            case ar.SERVICE_WORKER:
            case ar.SHARED_WORKER:
                {
                    await ((t = this.client.connection()) == null ? void 0 : t.send("Target.closeTarget", {
                        targetId: o(this, Om)
                    })),
                    await ((r = this.client.connection()) == null ? void 0 : r.send("Target.detachFromTarget", {
                        sessionId: this.client.id()
                    }));
                    break
                }
            default:
                await this.evaluate( () => {
                    self.close()
                }
                )
            }
        }
    }
    As = new WeakMap,
    li = new WeakMap,
    Om = new WeakMap,
    Rm = new WeakMap;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var n_ = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , s_ = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    function i_(n) {
        switch (n) {
        case "warning":
            return "warn";
        default:
            return n
        }
    }
    const ox = class ox extends _P {
        constructor(t, r) {
            super();
            b(this, Fe);
            b(this, Mm, !1);
            b(this, Ia);
            b(this, tt);
            b(this, ts);
            b(this, Oa);
            b(this, cc);
            b(this, Ra);
            b(this, Gl);
            b(this, Jl);
            b(this, gt);
            b(this, Nt);
            b(this, Zl);
            b(this, Ma, new Map);
            b(this, Xl, new Map);
            b(this, Yl);
            b(this, Ql);
            b(this, uc, new Map);
            b(this, di, new Set);
            b(this, Ob, pt.create());
            b(this, Nm, !1);
            b(this, $m, !1);
            b(this, Lm, t => {
                var i;
                const r = (i = t._session()) == null ? void 0 : i.id()
                  , s = o(this, uc).get(r);
                s && (o(this, uc).delete(r),
                this.emit("workerdestroyed", s))
            }
            );
            b(this, ed, t => {
                if (ne(t instanceof zc),
                o(this, gt).onAttachedToTarget(t._target()),
                t._target()._getTargetInfo().type === "worker") {
                    const r = new HP(t,t._target().url(),t._target()._targetId,t._target().type(),P(this, Fe, aC).bind(this),P(this, Fe, iC).bind(this));
                    o(this, uc).set(t.id(), r),
                    this.emit("workercreated", r)
                }
                t.on(yt.Ready, o(this, ed))
            }
            );
            S(this, tt, t),
            S(this, Oa, t.parentSession()),
            ne(o(this, Oa), "Tab target session is not defined."),
            S(this, cc, o(this, Oa)._target()),
            ne(o(this, cc), "Tab target is not defined."),
            S(this, ts, r),
            S(this, Ia, r._targetManager()),
            S(this, Ra, new YB(t)),
            S(this, Gl, new eq(t,o(this, Ra))),
            S(this, Jl, new rq(t,o(this, Ra))),
            S(this, gt, new XB(t,this,this._timeoutSettings)),
            S(this, Nt, new IP(t)),
            S(this, Zl, new KP(t)),
            S(this, Yl, new TP(t)),
            S(this, Ql, null);
            const s = new be(o(this, gt));
            s.on(Vt.FrameAttached, a => {
                this.emit("frameattached", a)
            }
            ),
            s.on(Vt.FrameDetached, a => {
                this.emit("framedetached", a)
            }
            ),
            s.on(Vt.FrameNavigated, a => {
                this.emit("framenavigated", a)
            }
            ),
            s.on(Vt.ConsoleApiCalled, ([a,c]) => {
                P(this, Fe, rL).call(this, a, c)
            }
            ),
            s.on(Vt.BindingCalled, ([a,c]) => {
                P(this, Fe, nL).call(this, a, c)
            }
            );
            const i = new be(o(this, gt).networkManager);
            i.on(zt.Request, a => {
                this.emit("request", a)
            }
            ),
            i.on(zt.RequestServedFromCache, a => {
                this.emit("requestservedfromcache", a)
            }
            ),
            i.on(zt.Response, a => {
                this.emit("response", a)
            }
            ),
            i.on(zt.RequestFailed, a => {
                this.emit("requestfailed", a)
            }
            ),
            i.on(zt.RequestFinished, a => {
                this.emit("requestfinished", a)
            }
            ),
            o(this, Oa).on(yt.Swapped, P(this, Fe, J$).bind(this)),
            o(this, Oa).on(yt.Ready, P(this, Fe, Z$).bind(this)),
            o(this, Ia).on("targetGone", o(this, Lm)),
            o(this, cc)._isClosedDeferred.valueOrThrow().then( () => {
                o(this, Ia).off("targetGone", o(this, Lm)),
                this.emit("close", void 0),
                S(this, Mm, !0)
            }
            ).catch(ge),
            P(this, Fe, nC).call(this),
            P(this, Fe, G$).call(this)
        }
        static async _create(t, r, s) {
            var a;
            const i = new ox(t,r);
            if (await P(a = i, Fe, X$).call(a),
            s)
                try {
                    await i.setViewport(s)
                } catch (c) {
                    if (hn(c) && Qv(c))
                        ge(c);
                    else
                        throw c
                }
            return i
        }
        _client() {
            return o(this, tt)
        }
        isServiceWorkerBypassed() {
            return o(this, Nm)
        }
        isDragInterceptionEnabled() {
            return o(this, $m)
        }
        isJavaScriptEnabled() {
            return o(this, Nt).javascriptEnabled
        }
        async waitForFileChooser(t={}) {
            const r = o(this, di).size === 0
              , {timeout: s=this._timeoutSettings.timeout()} = t
              , i = pt.create({
                message: `Waiting for \`FileChooser\` failed: ${s}ms exceeded`,
                timeout: s
            });
            t.signal && t.signal.addEventListener("abort", () => {
                var c;
                i.reject((c = t.signal) == null ? void 0 : c.reason)
            }
            , {
                once: !0
            }),
            o(this, di).add(i);
            let a;
            r && (a = o(this, tt).send("Page.setInterceptFileChooserDialog", {
                enabled: !0
            }));
            try {
                const [c] = await Promise.all([i.valueOrThrow(), a]);
                return c
            } catch (c) {
                throw o(this, di).delete(i),
                c
            }
        }
        async setGeolocation(t) {
            return await o(this, Nt).setGeolocation(t)
        }
        target() {
            return o(this, ts)
        }
        browser() {
            return o(this, ts).browser()
        }
        browserContext() {
            return o(this, ts).browserContext()
        }
        mainFrame() {
            return o(this, gt).mainFrame()
        }
        get keyboard() {
            return o(this, Ra)
        }
        get touchscreen() {
            return o(this, Jl)
        }
        get coverage() {
            return o(this, Yl)
        }
        get tracing() {
            return o(this, Zl)
        }
        frames() {
            return o(this, gt).frames()
        }
        workers() {
            return Array.from(o(this, uc).values())
        }
        async setRequestInterception(t) {
            return await o(this, gt).networkManager.setRequestInterception(t)
        }
        async setBypassServiceWorker(t) {
            return S(this, Nm, t),
            await o(this, tt).send("Network.setBypassServiceWorker", {
                bypass: t
            })
        }
        async setDragInterception(t) {
            return S(this, $m, t),
            await o(this, tt).send("Input.setInterceptDrags", {
                enabled: t
            })
        }
        async setOfflineMode(t) {
            return await o(this, gt).networkManager.setOfflineMode(t)
        }
        async emulateNetworkConditions(t) {
            return await o(this, gt).networkManager.emulateNetworkConditions(t)
        }
        setDefaultNavigationTimeout(t) {
            this._timeoutSettings.setDefaultNavigationTimeout(t)
        }
        setDefaultTimeout(t) {
            this._timeoutSettings.setDefaultTimeout(t)
        }
        getDefaultTimeout() {
            return this._timeoutSettings.timeout()
        }
        getDefaultNavigationTimeout() {
            return this._timeoutSettings.navigationTimeout()
        }
        async queryObjects(t) {
            ne(!t.disposed, "Prototype JSHandle is disposed!"),
            ne(t.id, "Prototype JSHandle must not be referencing primitive value");
            const r = await this.mainFrame().client.send("Runtime.queryObjects", {
                prototypeObjectId: t.id
            });
            return this.mainFrame().mainRealm().createCdpHandle(r.objects)
        }
        async cookies(...t) {
            const r = (await o(this, tt).send("Network.getCookies", {
                urls: t.length ? t : [this.url()]
            })).cookies
              , s = ["sourcePort"]
              , i = a => {
                for (const c of s)
                    delete a[c];
                return a
            }
            ;
            return r.map(i).map(a => ({
                ...a,
                partitionKey: a.partitionKey ? a.partitionKey.topLevelSite : void 0
            }))
        }
        async deleteCookie(...t) {
            const r = this.url();
            for (const s of t) {
                const i = {
                    ...s,
                    partitionKey: a_(s.partitionKey)
                };
                if (!s.url && r.startsWith("http") && (i.url = r),
                await o(this, tt).send("Network.deleteCookies", i),
                r.startsWith("http") && !i.partitionKey) {
                    const a = new URL(r);
                    await o(this, tt).send("Network.deleteCookies", {
                        ...i,
                        partitionKey: {
                            topLevelSite: a.origin.replace(`:${a.port}`, ""),
                            hasCrossSiteAncestor: !1
                        }
                    })
                }
            }
        }
        async setCookie(...t) {
            const r = this.url()
              , s = r.startsWith("http")
              , i = t.map(a => {
                const c = Object.assign({}, a);
                return !c.url && s && (c.url = r),
                ne(c.url !== "about:blank", `Blank page can not have cookie "${c.name}"`),
                ne(!String.prototype.startsWith.call(c.url || "", "data:"), `Data URL page can not have cookie "${c.name}"`),
                c
            }
            );
            await this.deleteCookie(...i),
            i.length && await o(this, tt).send("Network.setCookies", {
                cookies: i.map(a => ({
                    ...a,
                    partitionKey: a_(a.partitionKey)
                }))
            })
        }
        async exposeFunction(t, r) {
            if (o(this, Ma).has(t))
                throw new Error(`Failed to add page binding with name ${t}: window['${t}'] already exists!`);
            const s = jB("exposedFun", t);
            let i;
            switch (typeof r) {
            case "function":
                i = new wy(t,r,s);
                break;
            default:
                i = new wy(t,r.default,s);
                break
            }
            o(this, Ma).set(t, i);
            const [{identifier: a}] = await Promise.all([o(this, gt).evaluateOnNewDocument(s), o(this, gt).addExposedFunctionBinding(i)]);
            o(this, Xl).set(t, a)
        }
        async removeExposedFunction(t) {
            const r = o(this, Xl).get(t);
            if (!r)
                throw new Error(`Function with name "${t}" does not exist`);
            const s = o(this, Ma).get(t);
            o(this, Xl).delete(t),
            o(this, Ma).delete(t),
            await Promise.all([o(this, gt).removeScriptToEvaluateOnNewDocument(r), o(this, gt).removeExposedFunctionBinding(s)])
        }
        async authenticate(t) {
            return await o(this, gt).networkManager.authenticate(t)
        }
        async setExtraHTTPHeaders(t) {
            return await o(this, gt).networkManager.setExtraHTTPHeaders(t)
        }
        async setUserAgent(t, r) {
            return await o(this, gt).networkManager.setUserAgent(t, r)
        }
        async metrics() {
            const t = await o(this, tt).send("Performance.getMetrics");
            return P(this, Fe, sC).call(this, t.metrics)
        }
        async reload(t) {
            const [r] = await Promise.all([this.waitForNavigation({
                ...t,
                ignoreSameDocumentNavigation: !0
            }), o(this, tt).send("Page.reload")]);
            return r
        }
        async createCDPSession() {
            return await this.target().createCDPSession()
        }
        async goBack(t={}) {
            return await P(this, Fe, oC).call(this, -1, t)
        }
        async goForward(t={}) {
            return await P(this, Fe, oC).call(this, 1, t)
        }
        async bringToFront() {
            await o(this, tt).send("Page.bringToFront")
        }
        async setJavaScriptEnabled(t) {
            return await o(this, Nt).setJavaScriptEnabled(t)
        }
        async setBypassCSP(t) {
            await o(this, tt).send("Page.setBypassCSP", {
                enabled: t
            })
        }
        async emulateMediaType(t) {
            return await o(this, Nt).emulateMediaType(t)
        }
        async emulateCPUThrottling(t) {
            return await o(this, Nt).emulateCPUThrottling(t)
        }
        async emulateMediaFeatures(t) {
            return await o(this, Nt).emulateMediaFeatures(t)
        }
        async emulateTimezone(t) {
            return await o(this, Nt).emulateTimezone(t)
        }
        async emulateIdleState(t) {
            return await o(this, Nt).emulateIdleState(t)
        }
        async emulateVisionDeficiency(t) {
            return await o(this, Nt).emulateVisionDeficiency(t)
        }
        async setViewport(t) {
            const r = await o(this, Nt).emulateViewport(t);
            S(this, Ql, t),
            r && await this.reload()
        }
        viewport() {
            return o(this, Ql)
        }
        async evaluateOnNewDocument(t, ...r) {
            const s = Fv(t, ...r);
            return await o(this, gt).evaluateOnNewDocument(s)
        }
        async removeScriptToEvaluateOnNewDocument(t) {
            return await o(this, gt).removeScriptToEvaluateOnNewDocument(t)
        }
        async setCacheEnabled(t=!0) {
            await o(this, gt).networkManager.setCacheEnabled(t)
        }
        async _screenshot(t) {
            const r = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const {fromSurface: s, omitBackground: i, optimizeForSpeed: a, quality: c, clip: u, type: l, captureBeyondViewport: d} = t
                  , h = n_(r, new Xg, !0);
                i && (l === "png" || l === "webp") && (await o(this, Nt).setTransparentBackgroundColor(),
                h.defer(async () => {
                    await o(this, Nt).resetDefaultBackgroundColor().catch(ge)
                }
                ));
                let f = u;
                if (f && !d) {
                    const g = await this.mainFrame().isolatedRealm().evaluate( () => {
                        const {height: y, pageLeft: m, pageTop: w, width: E} = window.visualViewport;
                        return {
                            x: m,
                            y: w,
                            height: y,
                            width: E
                        }
                    }
                    );
                    f = sq(f, g)
                }
                const {data: p} = await o(this, tt).send("Page.captureScreenshot", {
                    format: l,
                    optimizeForSpeed: a,
                    fromSurface: s,
                    ...c !== void 0 ? {
                        quality: Math.round(c)
                    } : {},
                    ...f ? {
                        clip: {
                            ...f,
                            scale: f.scale ?? 1
                        }
                    } : {},
                    captureBeyondViewport: d
                });
                return p
            } catch (s) {
                r.error = s,
                r.hasError = !0
            } finally {
                const s = s_(r);
                s && await s
            }
        }
        async createPDFStream(t={}) {
            const {timeout: r=this._timeoutSettings.timeout()} = t
              , {landscape: s, displayHeaderFooter: i, headerTemplate: a, footerTemplate: c, printBackground: u, scale: l, width: d, height: h, margin: f, pageRanges: p, preferCSSPageSize: g, omitBackground: y, tagged: m, outline: w, waitForFonts: E} = Yk(t);
            y && await o(this, Nt).setTransparentBackgroundColor(),
            E && await Kt(Ze(this.mainFrame().isolatedRealm().evaluate( () => document.fonts.ready)).pipe(sr(Or(r))));
            const v = o(this, tt).send("Page.printToPDF", {
                transferMode: "ReturnAsStream",
                landscape: s,
                displayHeaderFooter: i,
                headerTemplate: a,
                footerTemplate: c,
                printBackground: u,
                scale: l,
                paperWidth: d,
                paperHeight: h,
                marginTop: f.top,
                marginBottom: f.bottom,
                marginLeft: f.left,
                marginRight: f.right,
                pageRanges: p,
                preferCSSPageSize: g,
                generateTaggedPDF: m,
                generateDocumentOutline: w
            })
              , _ = await Kt(Ze(v).pipe(sr(Or(r))));
            return y && await o(this, Nt).resetDefaultBackgroundColor(),
            ne(_.stream, "`stream` is missing from `Page.printToPDF"),
            await Jk(o(this, tt), _.stream)
        }
        async pdf(t={}) {
            const {path: r=void 0} = t
              , s = await this.createPDFStream(t)
              , i = await Gk(s, r);
            return ne(i, "Could not create typed array"),
            i
        }
        async close(t={
            runBeforeUnload: void 0
        }) {
            const r = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const s = n_(r, await this.browserContext().waitForScreenshotOperations(), !1)
                  , i = o(this, tt).connection();
                ne(i, "Protocol error: Connection closed. Most likely the page has been closed."),
                !!t.runBeforeUnload ? await o(this, tt).send("Page.close") : (await i.send("Target.closeTarget", {
                    targetId: o(this, ts)._targetId
                }),
                await o(this, cc)._isClosedDeferred.valueOrThrow())
            } catch (s) {
                r.error = s,
                r.hasError = !0
            } finally {
                s_(r)
            }
        }
        isClosed() {
            return o(this, Mm)
        }
        get mouse() {
            return o(this, Gl)
        }
        async waitForDevicePrompt(t={}) {
            return await this.mainFrame().waitForDevicePrompt(t)
        }
    }
    ;
    Mm = new WeakMap,
    Ia = new WeakMap,
    tt = new WeakMap,
    ts = new WeakMap,
    Oa = new WeakMap,
    cc = new WeakMap,
    Ra = new WeakMap,
    Gl = new WeakMap,
    Jl = new WeakMap,
    gt = new WeakMap,
    Nt = new WeakMap,
    Zl = new WeakMap,
    Ma = new WeakMap,
    Xl = new WeakMap,
    Yl = new WeakMap,
    Ql = new WeakMap,
    uc = new WeakMap,
    di = new WeakMap,
    Ob = new WeakMap,
    Nm = new WeakMap,
    $m = new WeakMap,
    Fe = new WeakSet,
    G$ = function() {
        const t = [];
        for (const s of o(this, Ia).getChildTargets(o(this, ts)))
            t.push(s);
        let r = 0;
        for (; r < t.length; ) {
            const s = t[r];
            r++;
            const i = s._session();
            i && o(this, ed).call(this, i);
            for (const a of o(this, Ia).getChildTargets(s))
                t.push(a)
        }
    }
    ,
    J$ = async function(t) {
        S(this, tt, t),
        ne(o(this, tt)instanceof zc, "CDPSession is not instance of CDPSessionImpl"),
        S(this, ts, o(this, tt)._target()),
        ne(o(this, ts), "Missing target on swap"),
        o(this, Ra).updateClient(t),
        o(this, Gl).updateClient(t),
        o(this, Jl).updateClient(t),
        o(this, Nt).updateClient(t),
        o(this, Zl).updateClient(t),
        o(this, Yl).updateClient(t),
        await o(this, gt).swapFrameTree(t),
        P(this, Fe, nC).call(this)
    }
    ,
    Z$ = async function(t) {
        ne(t instanceof zc),
        t._target()._subtype() === "prerender" && (o(this, gt).registerSpeculativeSession(t).catch(ge),
        o(this, Nt).registerSpeculativeSession(t).catch(ge))
    }
    ,
    nC = function() {
        const t = new be(o(this, tt));
        t.on(yt.Ready, o(this, ed)),
        t.on(yt.Disconnected, () => {
            o(this, Ob).reject(new xn("Target closed"))
        }
        ),
        t.on("Page.domContentEventFired", () => {
            this.emit("domcontentloaded", void 0)
        }
        ),
        t.on("Page.loadEventFired", () => {
            this.emit("load", void 0)
        }
        ),
        t.on("Page.javascriptDialogOpening", P(this, Fe, sL).bind(this)),
        t.on("Runtime.exceptionThrown", P(this, Fe, iC).bind(this)),
        t.on("Inspector.targetCrashed", P(this, Fe, Q$).bind(this)),
        t.on("Performance.metrics", P(this, Fe, tL).bind(this)),
        t.on("Log.entryAdded", P(this, Fe, eL).bind(this)),
        t.on("Page.fileChooserOpened", P(this, Fe, Y$).bind(this))
    }
    ,
    Lm = new WeakMap,
    ed = new WeakMap,
    X$ = async function() {
        try {
            await Promise.all([o(this, gt).initialize(o(this, tt)), o(this, tt).send("Performance.enable"), o(this, tt).send("Log.enable")])
        } catch (t) {
            if (hn(t) && Qv(t))
                ge(t);
            else
                throw t
        }
    }
    ,
    Y$ = async function(t) {
        const r = {
            stack: [],
            error: void 0,
            hasError: !1
        };
        try {
            if (!o(this, di).size)
                return;
            const s = o(this, gt).frame(t.frameId);
            ne(s, "This should never happen.");
            const i = n_(r, await s.worlds[ds].adoptBackendNode(t.backendNodeId), !1)
              , a = new CB(i.move(),t);
            for (const c of o(this, di))
                c.resolve(a);
            o(this, di).clear()
        } catch (s) {
            r.error = s,
            r.hasError = !0
        } finally {
            s_(r)
        }
    }
    ,
    Q$ = function() {
        this.emit("error", new Error("Page crashed!"))
    }
    ,
    eL = function(t) {
        const {level: r, text: s, args: i, source: a, url: c, lineNumber: u} = t.entry;
        i && i.map(l => {
            NP(o(this, tt), l)
        }
        ),
        a !== "worker" && this.emit("console", new Xv(i_(r),s,[],[{
            url: c,
            lineNumber: u
        }]))
    }
    ,
    tL = function(t) {
        this.emit("metrics", {
            title: t.title,
            metrics: P(this, Fe, sC).call(this, t.metrics)
        })
    }
    ,
    sC = function(t) {
        const r = {};
        for (const s of t || [])
            nq.has(s.name) && (r[s.name] = s.value);
        return r
    }
    ,
    iC = function(t) {
        this.emit("pageerror", FB(t.exceptionDetails))
    }
    ,
    rL = function(t, r) {
        const s = r.args.map(i => t.createCdpHandle(i));
        P(this, Fe, aC).call(this, i_(r.type), s, r.stackTrace)
    }
    ,
    nL = async function(t, r) {
        let s;
        try {
            s = JSON.parse(r.payload)
        } catch {
            return
        }
        const {type: i, name: a, seq: c, args: u, isTrivial: l} = s;
        if (i !== "exposedFun")
            return;
        const d = t.context;
        if (!d)
            return;
        const h = o(this, Ma).get(a);
        await (h == null ? void 0 : h.run(d, c, u, l))
    }
    ,
    aC = function(t, r, s) {
        if (!this.listenerCount("console")) {
            r.forEach(u => u.dispose());
            return
        }
        const i = [];
        for (const u of r) {
            const l = u.remoteObject();
            l.objectId ? i.push(u.toString()) : i.push(Ya(l))
        }
        const a = [];
        if (s)
            for (const u of s.callFrames)
                a.push({
                    url: u.url,
                    lineNumber: u.lineNumber,
                    columnNumber: u.columnNumber
                });
        const c = new Xv(i_(t),i.join(" "),r,a);
        this.emit("console", c)
    }
    ,
    sL = function(t) {
        const r = RD(t.type)
          , s = new OB(o(this, tt),r,t.message,t.defaultPrompt);
        this.emit("dialog", s)
    }
    ,
    oC = async function(t, r) {
        const s = await o(this, tt).send("Page.getNavigationHistory")
          , i = s.entries[s.currentIndex + t];
        return i ? (await Promise.all([this.waitForNavigation(r), o(this, tt).send("Page.navigateToHistoryEntry", {
            entryId: i.id
        })]))[0] : null
    }
    ;
    let Ud = ox;
    const nq = new Set(["Timestamp", "Documents", "Frames", "JSEventListeners", "Nodes", "LayoutCount", "RecalcStyleCount", "LayoutDuration", "RecalcStyleDuration", "ScriptDuration", "TaskDuration", "JSHeapUsedSize", "JSHeapTotalSize"]);
    function sq(n, e) {
        const t = Math.max(n.x, e.x)
          , r = Math.max(n.y, e.y);
        return {
            x: t,
            y: r,
            width: Math.max(Math.min(n.x + n.width, e.x + e.width) - t, 0),
            height: Math.max(Math.min(n.y + n.height, e.y + e.height) - r, 0)
        }
    }
    function a_(n) {
        if (n !== void 0)
            return typeof n == "string" ? {
                topLevelSite: n,
                hasCrossSiteAncestor: !1
            } : {
                topLevelSite: n.sourceOrigin,
                hasCrossSiteAncestor: n.hasCrossSiteAncestor ?? !1
            }
    }
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var iq = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , aq = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    class o_ extends eP {
        constructor(t, r, s) {
            super();
            b(this, hi);
            b(this, fi);
            b(this, cn);
            S(this, hi, t),
            S(this, fi, r),
            S(this, cn, s)
        }
        get id() {
            return o(this, cn)
        }
        targets() {
            return o(this, fi).targets().filter(t => t.browserContext() === this)
        }
        async pages() {
            return (await Promise.all(this.targets().filter(r => {
                var s;
                return r.type() === "page" || r.type() === "other" && ((s = o(this, fi)._getIsPageTargetCallback()) == null ? void 0 : s(r))
            }
            ).map(r => r.page()))).filter(r => !!r)
        }
        async overridePermissions(t, r) {
            const s = r.map(i => {
                const a = Dv.get(i);
                if (!a)
                    throw new Error("Unknown permission: " + i);
                return a
            }
            );
            await o(this, hi).send("Browser.grantPermissions", {
                origin: t,
                browserContextId: o(this, cn) || void 0,
                permissions: s
            })
        }
        async clearPermissionOverrides() {
            await o(this, hi).send("Browser.resetPermissions", {
                browserContextId: o(this, cn) || void 0
            })
        }
        async newPage() {
            const t = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const r = iq(t, await this.waitForScreenshotOperations(), !1);
                return await o(this, fi)._createPageInContext(o(this, cn))
            } catch (r) {
                t.error = r,
                t.hasError = !0
            } finally {
                aq(t)
            }
        }
        browser() {
            return o(this, fi)
        }
        async close() {
            ne(o(this, cn), "Default BrowserContext cannot be closed!"),
            await o(this, fi)._disposeContext(o(this, cn))
        }
        async cookies() {
            const {cookies: t} = await o(this, hi).send("Storage.getCookies", {
                browserContextId: o(this, cn)
            });
            return t.map(r => ({
                ...r,
                partitionKey: r.partitionKey ? {
                    sourceOrigin: r.partitionKey.topLevelSite,
                    hasCrossSiteAncestor: r.partitionKey.hasCrossSiteAncestor
                } : void 0
            }))
        }
        async setCookie(...t) {
            return await o(this, hi).send("Storage.setCookies", {
                browserContextId: o(this, cn),
                cookies: t.map(r => ({
                    ...r,
                    partitionKey: a_(r.partitionKey)
                }))
            })
        }
        async setDownloadBehavior(t) {
            await o(this, hi).send("Browser.setDownloadBehavior", {
                behavior: t.policy,
                downloadPath: t.downloadPath,
                browserContextId: o(this, cn)
            })
        }
    }
    hi = new WeakMap,
    fi = new WeakMap,
    cn = new WeakMap;
    /**
 * @license
 * Copyright 2019 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var fn;
    (function(n) {
        n.SUCCESS = "success",
        n.ABORTED = "aborted"
    }
    )(fn || (fn = {}));
    let Sy = (DN = class extends qd {
        constructor(t, r, s, i, a) {
            super();
            b(this, Na);
            b(this, $a);
            b(this, Is);
            b(this, td);
            b(this, La);
            b(this, rd, new Set);
            J(this, "_initializedDeferred", pt.create());
            J(this, "_isClosedDeferred", pt.create());
            J(this, "_targetId");
            S(this, $a, r),
            S(this, td, i),
            S(this, Is, t),
            S(this, Na, s),
            this._targetId = t.targetId,
            S(this, La, a),
            o(this, $a) && o(this, $a)instanceof zc && o(this, $a)._setTarget(this)
        }
        async asPage() {
            const t = this._session();
            return t ? await Ud._create(t, this, null) : await this.createCDPSession().then(r => Ud._create(r, this, null))
        }
        _subtype() {
            return o(this, Is).subtype
        }
        _session() {
            return o(this, $a)
        }
        _addChildTarget(t) {
            o(this, rd).add(t)
        }
        _removeChildTarget(t) {
            o(this, rd).delete(t)
        }
        _childTargets() {
            return o(this, rd)
        }
        _sessionFactory() {
            if (!o(this, La))
                throw new Error("sessionFactory is not initialized");
            return o(this, La)
        }
        createCDPSession() {
            if (!o(this, La))
                throw new Error("sessionFactory is not initialized");
            return o(this, La).call(this, !1).then(t => (t._setTarget(this),
            t))
        }
        url() {
            return o(this, Is).url
        }
        type() {
            switch (o(this, Is).type) {
            case "page":
                return ar.PAGE;
            case "background_page":
                return ar.BACKGROUND_PAGE;
            case "service_worker":
                return ar.SERVICE_WORKER;
            case "shared_worker":
                return ar.SHARED_WORKER;
            case "browser":
                return ar.BROWSER;
            case "webview":
                return ar.WEBVIEW;
            case "tab":
                return ar.TAB;
            default:
                return ar.OTHER
            }
        }
        _targetManager() {
            if (!o(this, td))
                throw new Error("targetManager is not initialized");
            return o(this, td)
        }
        _getTargetInfo() {
            return o(this, Is)
        }
        browser() {
            if (!o(this, Na))
                throw new Error("browserContext is not initialized");
            return o(this, Na).browser()
        }
        browserContext() {
            if (!o(this, Na))
                throw new Error("browserContext is not initialized");
            return o(this, Na)
        }
        opener() {
            const {openerId: t} = o(this, Is);
            if (t)
                return this.browser().targets().find(r => r._targetId === t)
        }
        _targetInfoChanged(t) {
            S(this, Is, t),
            this._checkIfInitialized()
        }
        _initialize() {
            this._initializedDeferred.resolve(fn.SUCCESS)
        }
        _isTargetExposed() {
            return this.type() !== ar.TAB && !this._subtype()
        }
        _checkIfInitialized() {
            this._initializedDeferred.resolved() || this._initializedDeferred.resolve(fn.SUCCESS)
        }
    }
    ,
    Na = new WeakMap,
    $a = new WeakMap,
    Is = new WeakMap,
    td = new WeakMap,
    La = new WeakMap,
    rd = new WeakMap,
    DN);
    const cx = class cx extends Sy {
        constructor(t, r, s, i, a, c) {
            super(t, r, s, i, a);
            b(this, Fm);
            J(this, "pagePromise");
            S(this, Fm, c ?? void 0)
        }
        _initialize() {
            this._initializedDeferred.valueOrThrow().then(async t => {
                if (t === fn.ABORTED)
                    return;
                const r = this.opener();
                if (!(r instanceof cx))
                    return;
                if (!r || !r.pagePromise || this.type() !== "page")
                    return !0;
                const s = await r.pagePromise;
                if (!s.listenerCount("popup"))
                    return !0;
                const i = await this.page();
                return s.emit("popup", i),
                !0
            }
            ).catch(ge),
            this._checkIfInitialized()
        }
        async page() {
            if (!this.pagePromise) {
                const t = this._session();
                this.pagePromise = (t ? Promise.resolve(t) : this._sessionFactory()(!1)).then(r => Ud._create(r, this, o(this, Fm) ?? null))
            }
            return await this.pagePromise ?? null
        }
        _checkIfInitialized() {
            this._initializedDeferred.resolved() || this._getTargetInfo().url !== "" && this._initializedDeferred.resolve(fn.SUCCESS)
        }
    }
    ;
    Fm = new WeakMap;
    let Ey = cx;
    class oq extends Ey {
    }
    class cq extends Sy {
        constructor() {
            super(...arguments);
            b(this, nd)
        }
        async worker() {
            if (!o(this, nd)) {
                const t = this._session();
                S(this, nd, (t ? Promise.resolve(t) : this._sessionFactory()(!1)).then(r => new HP(r,this._getTargetInfo().url,this._targetId,this.type(), () => {}
                , () => {}
                )))
            }
            return await o(this, nd)
        }
    }
    nd = new WeakMap;
    class uq extends Sy {
    }
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    function lq(n, e) {
        return !!n._subtype() && !e.subtype
    }
    class dq extends be {
        constructor(t, r, s, i=!0) {
            super();
            b(this, zr);
            b(this, Xt);
            b(this, Fa, new Map);
            b(this, Yt, new Map);
            b(this, lc, new Map);
            b(this, jm, new Set);
            b(this, ja);
            b(this, dc);
            b(this, hc, new WeakMap);
            b(this, Da, new WeakMap);
            b(this, Dm, pt.create());
            b(this, fc, new Set);
            b(this, Bm, !0);
            b(this, sd, [{}]);
            b(this, Rb, () => {
                if (o(this, Bm))
                    for (const [t,r] of o(this, Fa).entries()) {
                        const s = new Sy(r,void 0,void 0,this,void 0)
                          , i = r.type === "page" || r.type === "iframe"
                          , a = r.url.startsWith("chrome-extension://");
                        (!o(this, ja) || o(this, ja).call(this, s)) && i && !a && o(this, fc).add(t)
                    }
            }
            );
            b(this, qm, t => {
                P(this, zr, uC).call(this, t)
            }
            );
            b(this, Um, async t => {
                if (o(this, Fa).set(t.targetInfo.targetId, t.targetInfo),
                this.emit("targetDiscovered", t.targetInfo),
                t.targetInfo.type === "browser" && t.targetInfo.attached) {
                    if (o(this, Yt).has(t.targetInfo.targetId))
                        return;
                    const r = o(this, dc).call(this, t.targetInfo, void 0);
                    r._initialize(),
                    o(this, Yt).set(t.targetInfo.targetId, r)
                }
            }
            );
            b(this, Km, t => {
                const r = o(this, Fa).get(t.targetId);
                if (o(this, Fa).delete(t.targetId),
                P(this, zr, xd).call(this, t.targetId),
                (r == null ? void 0 : r.type) === "service_worker" && o(this, Yt).has(t.targetId)) {
                    const s = o(this, Yt).get(t.targetId);
                    s && (this.emit("targetGone", s),
                    o(this, Yt).delete(t.targetId))
                }
            }
            );
            b(this, Hm, t => {
                var a;
                if (o(this, Fa).set(t.targetInfo.targetId, t.targetInfo),
                o(this, jm).has(t.targetInfo.targetId) || !o(this, Yt).has(t.targetInfo.targetId) || !t.targetInfo.attached)
                    return;
                const r = o(this, Yt).get(t.targetInfo.targetId);
                if (!r)
                    return;
                const s = r.url()
                  , i = r._initializedDeferred.value() === fn.SUCCESS;
                if (lq(r, t.targetInfo)) {
                    const c = r == null ? void 0 : r._session();
                    ne(c, "Target that is being activated is missing a CDPSession."),
                    (a = c.parentSession()) == null || a.emit(yt.Swapped, c)
                }
                r._targetInfoChanged(t.targetInfo),
                i && s !== r.url() && this.emit("targetChanged", {
                    target: r,
                    wasInitialized: i,
                    previousURL: s
                })
            }
            );
            b(this, Mb, async (t, r) => {
                const s = r.targetInfo
                  , i = o(this, Xt).session(r.sessionId);
                if (!i)
                    throw new Error(`Session ${r.sessionId} was not created.`);
                const a = async () => {
                    await i.send("Runtime.runIfWaitingForDebugger").catch(ge),
                    await t.send("Target.detachFromTarget", {
                        sessionId: i.id()
                    }).catch(ge)
                }
                ;
                if (!o(this, Xt).isAutoAttached(s.targetId))
                    return;
                if (s.type === "service_worker") {
                    if (P(this, zr, xd).call(this, s.targetId),
                    await a(),
                    o(this, Yt).has(s.targetId))
                        return;
                    const d = o(this, dc).call(this, s);
                    d._initialize(),
                    o(this, Yt).set(s.targetId, d),
                    this.emit("targetAvailable", d);
                    return
                }
                const c = o(this, Yt).has(s.targetId)
                  , u = c ? o(this, Yt).get(s.targetId) : o(this, dc).call(this, s, i, t instanceof Ld ? t : void 0);
                if (o(this, ja) && !o(this, ja).call(this, u)) {
                    o(this, jm).add(s.targetId),
                    P(this, zr, xd).call(this, s.targetId),
                    await a();
                    return
                }
                P(this, zr, cC).call(this, i),
                c ? (i._setTarget(u),
                o(this, lc).set(i.id(), o(this, Yt).get(s.targetId))) : (u._initialize(),
                o(this, Yt).set(s.targetId, u),
                o(this, lc).set(i.id(), u));
                const l = t instanceof Ld ? t._target() : null;
                l == null || l._addChildTarget(u),
                t.emit(yt.Ready, i),
                o(this, fc).delete(u._targetId),
                c || this.emit("targetAvailable", u),
                P(this, zr, xd).call(this),
                await Promise.all([i.send("Target.setAutoAttach", {
                    waitForDebuggerOnStart: !0,
                    flatten: !0,
                    autoAttach: !0,
                    filter: o(this, sd)
                }), i.send("Runtime.runIfWaitingForDebugger")]).catch(ge)
            }
            );
            b(this, Nb, (t, r) => {
                const s = o(this, lc).get(r.sessionId);
                o(this, lc).delete(r.sessionId),
                s && (t instanceof Ld && t._target()._removeChildTarget(s),
                o(this, Yt).delete(s._targetId),
                this.emit("targetGone", s))
            }
            );
            S(this, Xt, t),
            S(this, ja, s),
            S(this, dc, r),
            S(this, Bm, i),
            o(this, Xt).on("Target.targetCreated", o(this, Um)),
            o(this, Xt).on("Target.targetDestroyed", o(this, Km)),
            o(this, Xt).on("Target.targetInfoChanged", o(this, Hm)),
            o(this, Xt).on(yt.SessionDetached, o(this, qm)),
            P(this, zr, cC).call(this, o(this, Xt))
        }
        async initialize() {
            await o(this, Xt).send("Target.setDiscoverTargets", {
                discover: !0,
                filter: o(this, sd)
            }),
            o(this, Rb).call(this),
            await o(this, Xt).send("Target.setAutoAttach", {
                waitForDebuggerOnStart: !0,
                flatten: !0,
                autoAttach: !0,
                filter: [{
                    type: "page",
                    exclude: !0
                }, ...o(this, sd)]
            }),
            P(this, zr, xd).call(this),
            await o(this, Dm).valueOrThrow()
        }
        getChildTargets(t) {
            return t._childTargets()
        }
        dispose() {
            o(this, Xt).off("Target.targetCreated", o(this, Um)),
            o(this, Xt).off("Target.targetDestroyed", o(this, Km)),
            o(this, Xt).off("Target.targetInfoChanged", o(this, Hm)),
            o(this, Xt).off(yt.SessionDetached, o(this, qm)),
            P(this, zr, uC).call(this, o(this, Xt))
        }
        getAvailableTargets() {
            return o(this, Yt)
        }
    }
    Xt = new WeakMap,
    Fa = new WeakMap,
    Yt = new WeakMap,
    lc = new WeakMap,
    jm = new WeakMap,
    ja = new WeakMap,
    dc = new WeakMap,
    hc = new WeakMap,
    Da = new WeakMap,
    Dm = new WeakMap,
    fc = new WeakMap,
    Bm = new WeakMap,
    sd = new WeakMap,
    Rb = new WeakMap,
    zr = new WeakSet,
    cC = function(t) {
        const r = i => {
            o(this, Mb).call(this, t, i)
        }
        ;
        ne(!o(this, hc).has(t)),
        o(this, hc).set(t, r),
        t.on("Target.attachedToTarget", r);
        const s = i => o(this, Nb).call(this, t, i);
        ne(!o(this, Da).has(t)),
        o(this, Da).set(t, s),
        t.on("Target.detachedFromTarget", s)
    }
    ,
    uC = function(t) {
        const r = o(this, hc).get(t);
        r && (t.off("Target.attachedToTarget", r),
        o(this, hc).delete(t)),
        o(this, Da).has(t) && (t.off("Target.detachedFromTarget", o(this, Da).get(t)),
        o(this, Da).delete(t))
    }
    ,
    qm = new WeakMap,
    Um = new WeakMap,
    Km = new WeakMap,
    Hm = new WeakMap,
    Mb = new WeakMap,
    xd = function(t) {
        t !== void 0 && o(this, fc).delete(t),
        o(this, fc).size === 0 && o(this, Dm).resolve()
    }
    ,
    Nb = new WeakMap;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const ux = class ux extends Qk {
        constructor(t, r, s, i, a, c, u, l=!0) {
            super();
            b(this, pc);
            J(this, "protocol", "cdp");
            b(this, id);
            b(this, Wm);
            b(this, Qt);
            b(this, zm);
            b(this, Vm);
            b(this, ad);
            b(this, pi);
            b(this, mi, new Map);
            b(this, $t);
            b(this, Gm, () => {
                this.emit("disconnected", void 0)
            }
            );
            b(this, $b, (t, r) => {
                var u;
                const {browserContextId: s} = t
                  , i = s && o(this, mi).has(s) ? o(this, mi).get(s) : o(this, pi);
                if (!i)
                    throw new Error("Missing browser context");
                const a = l => o(this, Qt)._createSession(t, l)
                  , c = new uq(t,r,i,o(this, $t),a);
                return (u = t.url) != null && u.startsWith("devtools://") ? new oq(t,r,i,o(this, $t),a,o(this, id) ?? null) : o(this, ad).call(this, c) ? new Ey(t,r,i,o(this, $t),a,o(this, id) ?? null) : t.type === "service_worker" || t.type === "shared_worker" ? new cq(t,r,i,o(this, $t),a) : c
            }
            );
            b(this, Jm, async t => {
                t._isTargetExposed() && await t._initializedDeferred.valueOrThrow() === fn.SUCCESS && (this.emit("targetcreated", t),
                t.browserContext().emit("targetcreated", t))
            }
            );
            b(this, Zm, async t => {
                t._initializedDeferred.resolve(fn.ABORTED),
                t._isClosedDeferred.resolve(),
                t._isTargetExposed() && await t._initializedDeferred.valueOrThrow() === fn.SUCCESS && (this.emit("targetdestroyed", t),
                t.browserContext().emit("targetdestroyed", t))
            }
            );
            b(this, Xm, ({target: t}) => {
                this.emit("targetchanged", t),
                t.browserContext().emit("targetchanged", t)
            }
            );
            b(this, Ym, t => {
                this.emit("targetdiscovered", t)
            }
            );
            S(this, id, s),
            S(this, Wm, i),
            S(this, Qt, t),
            S(this, zm, a || ( () => {}
            )),
            S(this, Vm, c || ( () => !0)),
            P(this, pc, iL).call(this, u),
            S(this, $t, new dq(t,o(this, $b),o(this, Vm),l)),
            S(this, pi, new o_(o(this, Qt),this));
            for (const d of r)
                o(this, mi).set(d, new o_(o(this, Qt),this,d))
        }
        static async _create(t, r, s, i, a, c, u, l, d, h=!0) {
            const f = new ux(t,r,i,c,u,l,d,h);
            return s && await t.send("Security.setIgnoreCertificateErrors", {
                ignore: !0
            }),
            await f._attach(a),
            f
        }
        async _attach(t) {
            o(this, Qt).on(yt.Disconnected, o(this, Gm)),
            t && await o(this, pi).setDownloadBehavior(t),
            o(this, $t).on("targetAvailable", o(this, Jm)),
            o(this, $t).on("targetGone", o(this, Zm)),
            o(this, $t).on("targetChanged", o(this, Xm)),
            o(this, $t).on("targetDiscovered", o(this, Ym)),
            await o(this, $t).initialize()
        }
        _detach() {
            o(this, Qt).off(yt.Disconnected, o(this, Gm)),
            o(this, $t).off("targetAvailable", o(this, Jm)),
            o(this, $t).off("targetGone", o(this, Zm)),
            o(this, $t).off("targetChanged", o(this, Xm)),
            o(this, $t).off("targetDiscovered", o(this, Ym))
        }
        process() {
            return o(this, Wm) ?? null
        }
        _targetManager() {
            return o(this, $t)
        }
        _getIsPageTargetCallback() {
            return o(this, ad)
        }
        async createBrowserContext(t={}) {
            const {proxyServer: r, proxyBypassList: s, downloadBehavior: i} = t
              , {browserContextId: a} = await o(this, Qt).send("Target.createBrowserContext", {
                proxyServer: r,
                proxyBypassList: s && s.join(",")
            })
              , c = new o_(o(this, Qt),this,a);
            return i && await c.setDownloadBehavior(i),
            o(this, mi).set(a, c),
            c
        }
        browserContexts() {
            return [o(this, pi), ...Array.from(o(this, mi).values())]
        }
        defaultBrowserContext() {
            return o(this, pi)
        }
        async _disposeContext(t) {
            t && (await o(this, Qt).send("Target.disposeBrowserContext", {
                browserContextId: t
            }),
            o(this, mi).delete(t))
        }
        wsEndpoint() {
            return o(this, Qt).url()
        }
        async newPage() {
            return await o(this, pi).newPage()
        }
        async _createPageInContext(t) {
            const {targetId: r} = await o(this, Qt).send("Target.createTarget", {
                url: "about:blank",
                browserContextId: t || void 0
            })
              , s = await this.waitForTarget(c => c._targetId === r);
            if (!s)
                throw new Error(`Missing target for page (id = ${r})`);
            if (!(await s._initializedDeferred.valueOrThrow() === fn.SUCCESS))
                throw new Error(`Failed to create target for page (id = ${r})`);
            const a = await s.page();
            if (!a)
                throw new Error(`Failed to create a page for context (id = ${t})`);
            return a
        }
        targets() {
            return Array.from(o(this, $t).getAvailableTargets().values()).filter(t => t._isTargetExposed() && t._initializedDeferred.value() === fn.SUCCESS)
        }
        target() {
            const t = this.targets().find(r => r.type() === "browser");
            if (!t)
                throw new Error("Browser target is not found");
            return t
        }
        async version() {
            return (await P(this, pc, lC).call(this)).product
        }
        async userAgent() {
            return (await P(this, pc, lC).call(this)).userAgent
        }
        async close() {
            await o(this, zm).call(null),
            await this.disconnect()
        }
        disconnect() {
            return o(this, $t).dispose(),
            o(this, Qt).dispose(),
            this._detach(),
            Promise.resolve()
        }
        get connected() {
            return !o(this, Qt)._closed
        }
        get debugInfo() {
            return {
                pendingProtocolErrors: o(this, Qt).getPendingProtocolErrors()
            }
        }
    }
    ;
    id = new WeakMap,
    Wm = new WeakMap,
    Qt = new WeakMap,
    zm = new WeakMap,
    Vm = new WeakMap,
    ad = new WeakMap,
    pi = new WeakMap,
    mi = new WeakMap,
    $t = new WeakMap,
    Gm = new WeakMap,
    pc = new WeakSet,
    iL = function(t) {
        S(this, ad, t || (r => r.type() === "page" || r.type() === "background_page" || r.type() === "webview"))
    }
    ,
    $b = new WeakMap,
    Jm = new WeakMap,
    Zm = new WeakMap,
    Xm = new WeakMap,
    Ym = new WeakMap,
    lC = function() {
        return o(this, Qt).send("Browser.getVersion")
    }
    ;
    let c_ = ux;
    /**
 * @license
 * Copyright 2020 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    async function hq(n, e, t) {
        const {acceptInsecureCerts: r=!1, defaultViewport: s=zk, downloadBehavior: i, targetFilter: a, _isPageTarget: c, slowMo: u=0, protocolTimeout: l} = t
          , d = new PP(e,n,u,l)
          , {browserContextIds: h} = await d.send("Target.getBrowserContexts");
        return await c_._create(d, h, r, s, i, void 0, () => d.send("Browser.close").catch(ge), a, c)
    }
    const WP = {
        targetId: "tabTargetId",
        type: "tab",
        title: "tab",
        url: "about:blank",
        attached: !1,
        canAccessOpener: !1
    }
      , zP = {
        targetId: "pageTargetId",
        type: "page",
        title: "page",
        url: "about:blank",
        attached: !1,
        canAccessOpener: !1
    }
      , lx = class lx {
        constructor(e) {
            b(this, Ar);
            J(this, "onmessage");
            J(this, "onclose");
            b(this, mc);
            b(this, Qm, (e, t, r) => {
                e.tabId === o(this, mc) && P(this, Ar, dn).call(this, {
                    sessionId: e.sessionId ?? "pageTargetSessionId",
                    method: t,
                    params: r
                })
            }
            );
            S(this, mc, e),
            chrome.debugger.onEvent.addListener(o(this, Qm))
        }
        static async connectTab(e) {
            return await chrome.debugger.attach({
                tabId: e
            }, "1.3"),
            new lx(e)
        }
        send(e) {
            const t = JSON.parse(e);
            switch (t.method) {
            case "Browser.getVersion":
                {
                    P(this, Ar, dn).call(this, {
                        id: t.id,
                        sessionId: t.sessionId,
                        method: t.method,
                        result: {
                            protocolVersion: "1.3",
                            product: "chrome",
                            revision: "unknown",
                            userAgent: "chrome",
                            jsVersion: "unknown"
                        }
                    });
                    return
                }
            case "Target.getBrowserContexts":
                {
                    P(this, Ar, dn).call(this, {
                        id: t.id,
                        sessionId: t.sessionId,
                        method: t.method,
                        result: {
                            browserContextIds: []
                        }
                    });
                    return
                }
            case "Target.setDiscoverTargets":
                {
                    P(this, Ar, dn).call(this, {
                        method: "Target.targetCreated",
                        params: {
                            targetInfo: WP
                        }
                    }),
                    P(this, Ar, dn).call(this, {
                        method: "Target.targetCreated",
                        params: {
                            targetInfo: zP
                        }
                    }),
                    P(this, Ar, dn).call(this, {
                        id: t.id,
                        sessionId: t.sessionId,
                        method: t.method,
                        result: {}
                    });
                    return
                }
            case "Target.setAutoAttach":
                if (t.sessionId === "tabTargetSessionId") {
                    P(this, Ar, dn).call(this, {
                        method: "Target.attachedToTarget",
                        params: {
                            targetInfo: zP,
                            sessionId: "pageTargetSessionId"
                        }
                    }),
                    P(this, Ar, dn).call(this, {
                        id: t.id,
                        sessionId: t.sessionId,
                        method: t.method,
                        result: {}
                    });
                    return
                } else if (!t.sessionId) {
                    P(this, Ar, dn).call(this, {
                        method: "Target.attachedToTarget",
                        params: {
                            targetInfo: WP,
                            sessionId: "tabTargetSessionId"
                        }
                    }),
                    P(this, Ar, dn).call(this, {
                        id: t.id,
                        sessionId: t.sessionId,
                        method: t.method,
                        result: {}
                    });
                    return
                }
            }
            t.sessionId === "pageTargetSessionId" && delete t.sessionId,
            chrome.debugger.sendCommand({
                tabId: o(this, mc),
                sessionId: t.sessionId
            }, t.method, t.params).then(r => {
                P(this, Ar, dn).call(this, {
                    id: t.id,
                    sessionId: t.sessionId ?? "pageTargetSessionId",
                    method: t.method,
                    result: r
                })
            }
            ).catch(r => {
                P(this, Ar, dn).call(this, {
                    id: t.id,
                    sessionId: t.sessionId ?? "pageTargetSessionId",
                    method: t.method,
                    error: {
                        code: r == null ? void 0 : r.code,
                        data: r == null ? void 0 : r.data,
                        message: (r == null ? void 0 : r.message) ?? "CDP error had no message"
                    }
                })
            }
            )
        }
        close() {
            chrome.debugger.onEvent.removeListener(o(this, Qm)),
            chrome.debugger.detach({
                tabId: o(this, mc)
            })
        }
    }
    ;
    mc = new WeakMap,
    Qm = new WeakMap,
    Ar = new WeakSet,
    dn = function(e) {
        var t;
        (t = this.onmessage) == null || t.call(this, JSON.stringify(e))
    }
    ;
    let u_ = lx;
    const dx = class dx {
        constructor(e) {
            b(this, gi);
            J(this, "onmessage");
            J(this, "onclose");
            S(this, gi, e),
            o(this, gi).addEventListener("message", t => {
                this.onmessage && this.onmessage.call(null, t.data)
            }
            ),
            o(this, gi).addEventListener("close", () => {
                this.onclose && this.onclose.call(null)
            }
            ),
            o(this, gi).addEventListener("error", () => {}
            )
        }
        static create(e) {
            return new Promise( (t, r) => {
                const s = new WebSocket(e);
                s.addEventListener("open", () => t(new dx(s))),
                s.addEventListener("error", r)
            }
            )
        }
        send(e) {
            o(this, gi).send(e)
        }
        close() {
            o(this, gi).close()
        }
    }
    ;
    gi = new WeakMap;
    let l_ = dx;
    const fq = Object.freeze(Object.defineProperty({
        __proto__: null,
        BrowserWebSocketTransport: l_
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const pq = [{
        name: "Blackberry PlayBook",
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        viewport: {
            width: 600,
            height: 1024,
            deviceScaleFactor: 1,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Blackberry PlayBook landscape",
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        viewport: {
            width: 1024,
            height: 600,
            deviceScaleFactor: 1,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "BlackBerry Z30",
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "BlackBerry Z30 landscape",
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy Note 3",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy Note 3 landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy Note II",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy Note II landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy S III",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy S III landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy S5",
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy S5 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy S8",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        viewport: {
            width: 360,
            height: 740,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy S8 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
        viewport: {
            width: 740,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy S9+",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        viewport: {
            width: 320,
            height: 658,
            deviceScaleFactor: 4.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy S9+ landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
        viewport: {
            width: 658,
            height: 320,
            deviceScaleFactor: 4.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Galaxy Tab S4",
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
        viewport: {
            width: 712,
            height: 1138,
            deviceScaleFactor: 2.25,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Galaxy Tab S4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
        viewport: {
            width: 1138,
            height: 712,
            deviceScaleFactor: 2.25,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPad",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPad landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPad (gen 6)",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPad (gen 6) landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPad (gen 7)",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 810,
            height: 1080,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPad (gen 7) landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 1080,
            height: 810,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPad Mini",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
            width: 768,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPad Mini landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
            width: 1024,
            height: 768,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPad Pro",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
            width: 1024,
            height: 1366,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPad Pro landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        viewport: {
            width: 1366,
            height: 1024,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPad Pro 11",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 834,
            height: 1194,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPad Pro 11 landscape",
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 1194,
            height: 834,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 4",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        viewport: {
            width: 320,
            height: 480,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 4 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        viewport: {
            width: 480,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 5",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 5 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 6",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 6 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 6 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 6 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 7",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 7 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 7 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 7 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 8",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 375,
            height: 667,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 8 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 667,
            height: 375,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 8 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 414,
            height: 736,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 8 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 736,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone SE",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
            width: 320,
            height: 568,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone SE landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        viewport: {
            width: 568,
            height: 320,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone X",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone X landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone XR",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone XR landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 11",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 414,
            height: 828,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 11 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 828,
            height: 414,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 11 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 11 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 11 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 414,
            height: 896,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 11 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 896,
            height: 414,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 12",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 12 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 12 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 12 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 12 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 428,
            height: 926,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 12 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 926,
            height: 428,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 12 Mini",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 12 Mini landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 13",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 13 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 13 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 390,
            height: 844,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 13 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 844,
            height: 390,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 13 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 428,
            height: 926,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 13 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 926,
            height: 428,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 13 Mini",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 375,
            height: 812,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 13 Mini landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 812,
            height: 375,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 14",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 390,
            height: 663,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 14 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 750,
            height: 340,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 14 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 428,
            height: 745,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 14 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 832,
            height: 378,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 14 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 393,
            height: 659,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 14 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 734,
            height: 343,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 14 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 430,
            height: 739,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 14 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 814,
            height: 380,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 15",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 393,
            height: 659,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 15 landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 734,
            height: 343,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 15 Plus",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 430,
            height: 739,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 15 Plus landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 814,
            height: 380,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 15 Pro",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 393,
            height: 659,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 15 Pro landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 734,
            height: 343,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "iPhone 15 Pro Max",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 430,
            height: 739,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "iPhone 15 Pro Max landscape",
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
        viewport: {
            width: 814,
            height: 380,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "JioPhone 2",
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        viewport: {
            width: 240,
            height: 320,
            deviceScaleFactor: 1,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "JioPhone 2 landscape",
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        viewport: {
            width: 320,
            height: 240,
            deviceScaleFactor: 1,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Kindle Fire HDX",
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Kindle Fire HDX landscape",
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "LG Optimus L70",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 1.25,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "LG Optimus L70 landscape",
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 1.25,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Microsoft Lumia 550",
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Microsoft Lumia 950",
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 4,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Microsoft Lumia 950 landscape",
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 4,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 10",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
            width: 800,
            height: 1280,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 10 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
            width: 1280,
            height: 800,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 4",
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 384,
            height: 640,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 640,
            height: 384,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 5",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 5 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 5X",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 2.625,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 5X landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 2.625,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 6",
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 6 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 6P",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 412,
            height: 732,
            deviceScaleFactor: 3.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 6P landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 732,
            height: 412,
            deviceScaleFactor: 3.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nexus 7",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
            width: 600,
            height: 960,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nexus 7 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        viewport: {
            width: 960,
            height: 600,
            deviceScaleFactor: 2,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nokia Lumia 520",
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
            width: 320,
            height: 533,
            deviceScaleFactor: 1.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nokia Lumia 520 landscape",
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
            width: 533,
            height: 320,
            deviceScaleFactor: 1.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Nokia N9",
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
            width: 480,
            height: 854,
            deviceScaleFactor: 1,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Nokia N9 landscape",
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
            width: 854,
            height: 480,
            deviceScaleFactor: 1,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Pixel 2",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 411,
            height: 731,
            deviceScaleFactor: 2.625,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Pixel 2 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 731,
            height: 411,
            deviceScaleFactor: 2.625,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Pixel 2 XL",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 411,
            height: 823,
            deviceScaleFactor: 3.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Pixel 2 XL landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        viewport: {
            width: 823,
            height: 411,
            deviceScaleFactor: 3.5,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Pixel 3",
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
        viewport: {
            width: 393,
            height: 786,
            deviceScaleFactor: 2.75,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Pixel 3 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
        viewport: {
            width: 786,
            height: 393,
            deviceScaleFactor: 2.75,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Pixel 4",
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
        viewport: {
            width: 353,
            height: 745,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Pixel 4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
        viewport: {
            width: 745,
            height: 353,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Pixel 4a (5G)",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
            width: 353,
            height: 745,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Pixel 4a (5G) landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
            width: 745,
            height: 353,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Pixel 5",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
            width: 393,
            height: 851,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Pixel 5 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
            width: 851,
            height: 393,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }, {
        name: "Moto G4",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
            width: 360,
            height: 640,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !1
        }
    }, {
        name: "Moto G4 landscape",
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
        viewport: {
            width: 640,
            height: 360,
            deviceScaleFactor: 3,
            isMobile: !0,
            hasTouch: !0,
            isLandscape: !0
        }
    }]
      , VP = {};
    for (const n of pq)
        VP[n.name] = n;
    Object.freeze(VP);
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    async function mq(n, e, t) {
        const {acceptInsecureCerts: r=!1, defaultViewport: s=zk} = t
          , {bidiConnection: i, cdpConnection: a, closeCallback: c} = await gq(n, e, t);
        return await (await Promise.resolve().then( () => AN)).BidiBrowser.create({
            connection: i,
            cdpConnection: a,
            closeCallback: c,
            process: void 0,
            defaultViewport: s,
            acceptInsecureCerts: r,
            capabilities: t.capabilities
        })
    }
    async function gq(n, e, t) {
        const r = await Promise.resolve().then( () => AN)
          , {slowMo: s=0, protocolTimeout: i} = t
          , a = new r.BidiConnection(e,n,s,i);
        try {
            const d = await a.send("session.status", {});
            if ("type"in d && d.type === "success")
                return {
                    bidiConnection: a,
                    closeCallback: async () => {
                        await a.send("browser.close", {}).catch(ge)
                    }
                }
        } catch (d) {
            if (!(d instanceof Ga))
                throw d
        }
        a.unbind();
        const c = new PP(e,n,s,i,!0);
        if ((await c.send("Browser.getVersion")).product.toLowerCase().includes("firefox"))
            throw new Oe("Firefox is not supported in BiDi over CDP mode.");
        const l = await r.connectBidiOverCdp(c);
        return {
            cdpConnection: c,
            bidiConnection: l,
            closeCallback: async () => {
                await c.send("Browser.close").catch(ge)
            }
        }
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const GP = async () => Uk ? (await Promise.resolve().then( () => _9)).NodeWebSocketTransport : (await Promise.resolve().then( () => fq)).BrowserWebSocketTransport;
    async function yq(n) {
        const {connectionTransport: e, endpointUrl: t} = await wq(n);
        return n.protocol === "webDriverBiDi" ? await mq(e, t, n) : await hq(e, t, n)
    }
    async function wq(n) {
        const {browserWSEndpoint: e, browserURL: t, transport: r, headers: s={}} = n;
        if (ne(+!!e + +!!t + +!!r == 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect"),
        r)
            return {
                connectionTransport: r,
                endpointUrl: ""
            };
        if (e)
            return {
                connectionTransport: await (await GP()).create(e, s),
                endpointUrl: e
            };
        if (t) {
            const i = await bq(t);
            return {
                connectionTransport: await (await GP()).create(i),
                endpointUrl: i
            }
        }
        throw new Error("Invalid connection options")
    }
    async function bq(n) {
        const e = new URL("/json/version",n);
        try {
            const t = await globalThis.fetch(e.toString(), {
                method: "GET"
            });
            if (!t.ok)
                throw new Error(`HTTP ${t.statusText}`);
            return (await t.json()).webSocketDebuggerUrl
        } catch (t) {
            throw hn(t) && (t.message = `Failed to fetch browser webSocket URL from ${e}: ` + t.message),
            t
        }
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class JP {
        constructor(e) {
            J(this, "_isPuppeteerCore");
            J(this, "_changedBrowsers", !1);
            this._isPuppeteerCore = e.isPuppeteerCore,
            this.connect = this.connect.bind(this)
        }
        static registerCustomQueryHandler(e, t) {
            return this.customQueryHandlers.register(e, t)
        }
        static unregisterCustomQueryHandler(e) {
            return this.customQueryHandlers.unregister(e)
        }
        static customQueryHandlerNames() {
            return this.customQueryHandlers.names()
        }
        static clearCustomQueryHandlers() {
            return this.customQueryHandlers.clear()
        }
        connect(e) {
            return yq(e)
        }
    }
    J(JP, "customQueryHandlers", Uv);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const vq = new JP({
        isPuppeteerCore: !0
    })
      , {connect: _q} = vq
      , kn = n => {
        const e = `[${n}]`;
        return {
            debug: (...t) => {}
            ,
            info: (...t) => console.info(e, ...t),
            warning: (...t) => console.warn(e, ...t),
            error: (...t) => console.error(e, ...t),
            group: t => console.group(`${e} ${t}`),
            groupEnd: () => console.groupEnd()
        }
    }
    ;
    class ZP {
        constructor(e, t) {
            this.isVisible = e,
            this.parent = t
        }
    }
    class d_ extends ZP {
        constructor(e, t, r) {
            super(t, r),
            this.type = "TEXT_NODE",
            this.text = e
        }
        hasParentWithHighlightIndex() {
            let e = this.parent;
            for (; e != null; ) {
                if (e.highlightIndex !== void 0)
                    return !0;
                e = e.parent
            }
            return !1
        }
    }
    class hs extends ZP {
        constructor(e) {
            super(e.isVisible, e.parent),
            this.tagName = e.tagName,
            this.xpath = e.xpath,
            this.attributes = e.attributes,
            this.children = e.children,
            this.isInteractive = e.isInteractive ?? !1,
            this.isTopElement = e.isTopElement ?? !1,
            this.shadowRoot = e.shadowRoot ?? !1,
            this.highlightIndex = e.highlightIndex,
            this.viewportCoordinates = e.viewportCoordinates,
            this.pageCoordinates = e.pageCoordinates,
            this.viewportInfo = e.viewportInfo
        }
        getAllTextTillNextClickableElement(e=-1) {
            const t = []
              , r = (s, i) => {
                if (!(e !== -1 && i > e) && !(s instanceof hs && s !== this && s.highlightIndex !== void 0)) {
                    if (s instanceof d_)
                        t.push(s.text);
                    else if (s instanceof hs)
                        for (const a of s.children)
                            r(a, i + 1)
                }
            }
            ;
            return r(this, 0),
            t.join(`
`).trim()
        }
        clickableElementsToString(e=[]) {
            const t = []
              , r = (s, i) => {
                if (s instanceof hs) {
                    if (s.highlightIndex !== void 0) {
                        let a = "";
                        e.length && (a = ` ${e.map(c => s.attributes[c] ? `${c}="${s.attributes[c]}"` : "").filter(Boolean).join(" ")}`),
                        t.push(`[${s.highlightIndex}]<${s.tagName}${a}>${s.getAllTextTillNextClickableElement()}</${s.tagName}>`)
                    }
                    for (const a of s.children)
                        r(a)
                } else
                    s instanceof d_ && (s.hasParentWithHighlightIndex() || t.push(`[]${s.text}`))
            }
            ;
            return r(this),
            t.join(`
`)
        }
        getFileUploadElement(e=!0) {
            if (this.tagName === "input" && this.attributes.type === "file")
                return this;
            for (const t of this.children)
                if (t instanceof hs) {
                    const r = t.getFileUploadElement(!1);
                    if (r)
                        return r
                }
            if (e && this.parent) {
                for (const t of this.parent.children)
                    if (t !== this && t instanceof hs) {
                        const r = t.getFileUploadElement(!1);
                        if (r)
                            return r
                    }
            }
            return null
        }
        getAdvancedCssSelector() {
            return this.enhancedCssSelectorForElement()
        }
        convertSimpleXPathToCssSelector(e) {
            if (!e)
                return "";
            const r = e.replace(/^\//, "").split("/")
              , s = [];
            for (const a of r)
                if (a)
                    if (a.includes("[")) {
                        const c = a.indexOf("[");
                        let u = a.substring(0, c);
                        const d = a.substring(c).split("]").slice(0, -1).map(h => h.replace("[", ""));
                        for (const h of d)
                            if (/^\d+$/.test(h))
                                try {
                                    const f = Number.parseInt(h, 10) - 1;
                                    u += `:nth-of-type(${f + 1})`
                                } catch {}
                            else
                                h === "last()" ? u += ":last-of-type" : h.includes("position()") && h.includes(">1") && (u += ":nth-of-type(n+2)");
                        s.push(u)
                    } else
                        s.push(a);
            return s.join(" > ")
        }
        enhancedCssSelectorForElement(e=!0) {
            try {
                if (!this.xpath)
                    return "";
                let t = this.convertSimpleXPathToCssSelector(this.xpath);
                if (this.attributes.class && e) {
                    const s = /^[a-zA-Z_][a-zA-Z0-9_-]*$/
                      , i = this.attributes.class.split(/\s+/);
                    for (const a of i)
                        a.trim() && s.test(a) && (t += `.${a}`)
                }
                const r = new Set(["id", "name", "type", "value", "placeholder", "aria-label", "aria-labelledby", "aria-describedby", "role", "for", "autocomplete", "required", "readonly", "alt", "title", "src", "href", "target"]);
                e && (r.add("data-id"),
                r.add("data-qa"),
                r.add("data-cy"),
                r.add("data-testid"));
                for (const [s,i] of Object.entries(this.attributes)) {
                    if (s === "class" || !s.trim() || !r.has(s))
                        continue;
                    const a = s.replace(":", "\\:");
                    if (i === "")
                        t += `[${a}]`;
                    else if (/["'<>`\n\r\t]/.test(i)) {
                        const u = i.replace(/\s+/g, " ").trim().replace(/"/g, '\\"');
                        t += `[${a}*="${u}"]`
                    } else
                        t += `[${a}="${i}"]`
                }
                return t
            } catch {
                return `${this.tagName || "*"}[highlight-index='${this.highlightIndex}']`
            }
        }
    }
    const XP = kn("DOMService");
    async function Sq(n) {
        var r;
        const t = (r = (await chrome.scripting.executeScript({
            target: {
                tabId: n
            },
            func: () => {
                const s = window.scrollY
                  , i = window.innerHeight
                  , a = document.documentElement.scrollHeight;
                return {
                    pixels_above: s,
                    pixels_below: a - (s + i)
                }
            }
        }))[0]) == null ? void 0 : r.result;
        if (!t)
            throw new Error("Failed to get scroll information");
        return [t.pixels_above, t.pixels_below]
    }
    async function Eq(n, e) {
        var s;
        const r = (s = (await chrome.scripting.executeScript({
            target: {
                tabId: n
            },
            func: i => window.turn2Markdown(i),
            args: [e || ""]
        }))[0]) == null ? void 0 : s.result;
        if (!r)
            throw new Error("Failed to get markdown content");
        return r
    }
    async function xq(n) {
        var r;
        const t = (r = (await chrome.scripting.executeScript({
            target: {
                tabId: n
            },
            func: () => window.parserReadability()
        }))[0]) == null ? void 0 : r.result;
        if (!t)
            throw new Error("Failed to get readability content");
        return t
    }
    async function Cq(n, e=!0, t=-1, r=0) {
        try {
            const s = await Pq(n, e, t, r)
              , i = kq(s);
            return {
                elementTree: s,
                selectorMap: i
            }
        } catch (s) {
            return XP.error("Failed to build DOM tree:", s),
            null
        }
    }
    function kq(n) {
        const e = new Map;
        function t(r) {
            r instanceof hs && (r.highlightIndex != null && e.set(r.highlightIndex, r),
            r.children.forEach(t))
        }
        return t(n),
        e
    }
    async function Pq(n, e=!0, t=-1, r=0) {
        const i = (await chrome.scripting.executeScript({
            target: {
                tabId: n
            },
            func: a => window.buildDomTree(a),
            args: [{
                doHighlightElements: e,
                focusHighlightIndex: t,
                viewportExpansion: r
            }]
        }))[0].result;
        if (i !== null) {
            const a = YP(i);
            if (a !== null && a instanceof hs)
                return a
        }
        throw new Error("Failed to build DOM tree: Invalid or empty tree structure")
    }
    function YP(n, e=null) {
        if (!n)
            return null;
        if ("type"in n)
            return new d_(n.text,n.isVisible,e);
        const t = n.tagName
          , r = n.viewportCoordinates
          , s = n.pageCoordinates
          , i = n.viewportInfo
          , a = new hs({
            tagName: t,
            xpath: n.xpath,
            attributes: n.attributes ?? {},
            children: [],
            isVisible: n.isVisible ?? !1,
            isInteractive: n.isInteractive ?? !1,
            isTopElement: n.isTopElement ?? !1,
            highlightIndex: n.highlightIndex,
            viewportCoordinates: r ?? void 0,
            pageCoordinates: s ?? void 0,
            viewportInfo: i ?? void 0,
            shadowRoot: n.shadowRoot ?? !1,
            parent: e
        })
          , c = [];
        for (const u of n.children || [])
            if (u !== null) {
                const l = YP(u, a);
                l !== null && c.push(l)
            }
        return a.children = c,
        a
    }
    async function Tq(n) {
        try {
            await chrome.scripting.executeScript({
                target: {
                    tabId: n
                },
                func: () => {
                    const e = document.getElementById("playwright-highlight-container");
                    e && e.remove();
                    const t = document.querySelectorAll('[browser-user-highlight-id^="playwright-highlight-"]');
                    for (const r of Array.from(t))
                        r.removeAttribute("browser-user-highlight-id")
                }
            })
        } catch (e) {
            XP.error("Failed to remove highlights:", e)
        }
    }
    const Be = kn("Page");
    function xy(n, e, t) {
        return {
            elementTree: new hs({
                tagName: "root",
                isVisible: !0,
                parent: null,
                xpath: "",
                attributes: {},
                children: []
            }),
            selectorMap: new Map,
            tabId: n || 0,
            url: e || "",
            title: t || "",
            screenshot: null,
            pixelsAbove: 0,
            pixelsBelow: 0
        }
    }
    let Aq = class {
        constructor(e, t, r, s={}) {
            this._browser = null,
            this._puppeteerPage = null,
            this._validWebPage = !1,
            this._tabId = e,
            this._config = {
                ...ck,
                ...s
            },
            this._state = xy(e, t, r),
            this._validWebPage = e && t && t.startsWith("http") || !1
        }
        get tabId() {
            return this._tabId
        }
        get validWebPage() {
            return this._validWebPage
        }
        get attached() {
            return this._validWebPage && this._puppeteerPage !== null
        }
        async attachPuppeteer() {
            if (!this._validWebPage)
                return !1;
            if (this._puppeteerPage)
                return !0;
            Be.info("attaching puppeteer", this._tabId);
            const e = await _q({
                transport: await u_.connectTab(this._tabId),
                defaultViewport: null,
                protocol: "cdp"
            });
            this._browser = e;
            const [t] = await e.pages();
            return this._puppeteerPage = t,
            await this._addAntiDetectionScripts(),
            !0
        }
        async _addAntiDetectionScripts() {
            this._puppeteerPage && await this._puppeteerPage.evaluateOnNewDocument(`
      // Webdriver property
      Object.defineProperty(navigator, 'webdriver', {
        get: () => undefined
      });

      // Languages
      // Object.defineProperty(navigator, 'languages', {
      //   get: () => ['en-US']
      // });

      // Plugins
      // Object.defineProperty(navigator, 'plugins', {
      //   get: () => [1, 2, 3, 4, 5]
      // });

      // Chrome runtime
      window.chrome = { runtime: {} };

      // Permissions
      const originalQuery = window.navigator.permissions.query;
      window.navigator.permissions.query = (parameters) => (
        parameters.name === 'notifications' ?
          Promise.resolve({ state: Notification.permission }) :
          originalQuery(parameters)
      );

      // Shadow DOM
      (function () {
        const originalAttachShadow = Element.prototype.attachShadow;
        Element.prototype.attachShadow = function attachShadow(options) {
          return originalAttachShadow.call(this, { ...options, mode: "open" });
        };
      })();
    `)
        }
        async detachPuppeteer() {
            this._browser && (await this._browser.disconnect(),
            this._browser = null,
            this._puppeteerPage = null,
            this._state = xy(this._tabId))
        }
        async removeHighlight() {
            this._config.highlightElements && this._validWebPage && await Tq(this._tabId)
        }
        async getClickableElements(e) {
            return this._validWebPage ? Cq(this._tabId, this._config.highlightElements, e, this._config.viewportExpansion) : null
        }
        async getScrollInfo() {
            return this._validWebPage ? Sq(this._tabId) : [0, 0]
        }
        async getContent() {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer page is not connected");
            return await this._puppeteerPage.content()
        }
        async getMarkdownContent(e) {
            return this._validWebPage ? Eq(this._tabId, e) : ""
        }
        async getReadabilityContent() {
            return this._validWebPage ? xq(this._tabId) : ""
        }
        async getState() {
            return this._validWebPage ? (await this.waitForPageAndFramesLoad(),
            await this._updateState()) : xy(this._tabId)
        }
        async _updateState(e=!0, t=-1) {
            var r, s, i;
            try {
                await this._puppeteerPage.evaluate("1")
            } catch (a) {
                if (Be.warning("Current page is no longer accessible:", a),
                this._browser) {
                    const c = await this._browser.pages();
                    if (c.length > 0)
                        this._puppeteerPage = c[0];
                    else
                        throw new Error("Browser closed: no valid pages available")
                }
            }
            try {
                await this.removeHighlight();
                const a = await this.getClickableElements(t);
                if (!a)
                    return Be.warning("Failed to get clickable elements"),
                    this._state;
                "selectorMap"in a ? Be.debug("content.selectorMap:", a.selectorMap.size) : Be.debug("content.selectorMap: not found"),
                "elementTree"in a ? Be.debug("content.elementTree:", (r = a.elementTree) == null ? void 0 : r.tagName) : Be.debug("content.elementTree: not found");
                const c = e ? await this.takeScreenshot() : null
                  , [u,l] = await this.getScrollInfo();
                return this._state.elementTree = a.elementTree,
                this._state.selectorMap = a.selectorMap,
                this._state.url = ((s = this._puppeteerPage) == null ? void 0 : s.url()) || "",
                this._state.title = await ((i = this._puppeteerPage) == null ? void 0 : i.title()) || "",
                this._state.screenshot = c,
                this._state.pixelsAbove = u,
                this._state.pixelsBelow = l,
                this._state
            } catch (a) {
                return Be.error("Failed to update state:", a),
                this._state
            }
        }
        async takeScreenshot(e=!1) {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer page is not connected");
            try {
                await this._puppeteerPage.evaluate( () => {
                    const r = "puppeteer-disable-animations";
                    if (!document.getElementById(r)) {
                        const s = document.createElement("style");
                        s.id = r,
                        s.textContent = `
            *, *::before, *::after {
              animation: none !important;
              transition: none !important;
            }
          `,
                        document.head.appendChild(s)
                    }
                }
                );
                const t = await this._puppeteerPage.screenshot({
                    fullPage: e,
                    encoding: "base64",
                    type: "jpeg",
                    quality: 80
                });
                return await this._puppeteerPage.evaluate( () => {
                    const r = document.getElementById("puppeteer-disable-animations");
                    r && r.remove()
                }
                ),
                t
            } catch (t) {
                throw Be.error("Failed to take screenshot:", t),
                t
            }
        }
        url() {
            return this._puppeteerPage ? this._puppeteerPage.url() : this._state.url
        }
        async title() {
            return this._puppeteerPage ? await this._puppeteerPage.title() : this._state.title
        }
        async navigateTo(e) {
            if (this._puppeteerPage) {
                Be.info("navigateTo", e);
                try {
                    await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.goto(e)]),
                    Be.info("navigateTo complete")
                } catch (t) {
                    if (t instanceof Error && t.message.includes("timeout"))
                        Be.warning("Navigation timeout, but page might still be usable:", t);
                    else
                        throw Be.error("Navigation failed:", t),
                        t
                }
            }
        }
        async refreshPage() {
            if (this._puppeteerPage)
                try {
                    await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.reload()]),
                    Be.info("Page refresh complete")
                } catch (e) {
                    if (e instanceof Error && e.message.includes("timeout"))
                        Be.warning("Refresh timeout, but page might still be usable:", e);
                    else
                        throw Be.error("Page refresh failed:", e),
                        e
                }
        }
        async goBack() {
            if (this._puppeteerPage)
                try {
                    await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.goBack()]),
                    Be.info("Navigation back completed")
                } catch (e) {
                    if (e instanceof Error && e.message.includes("timeout"))
                        Be.warning("Back navigation timeout, but page might still be usable:", e);
                    else
                        throw Be.error("Could not navigate back:", e),
                        e
                }
        }
        async goForward() {
            if (this._puppeteerPage)
                try {
                    await Promise.all([this.waitForPageAndFramesLoad(), this._puppeteerPage.goForward()]),
                    Be.info("Navigation forward completed")
                } catch (e) {
                    if (e instanceof Error && e.message.includes("timeout"))
                        Be.warning("Forward navigation timeout, but page might still be usable:", e);
                    else
                        throw Be.error("Could not navigate forward:", e),
                        e
                }
        }
        async scrollDown(e) {
            var t, r;
            this._puppeteerPage && (e ? await ((t = this._puppeteerPage) == null ? void 0 : t.evaluate(`window.scrollBy(0, ${e});`)) : await ((r = this._puppeteerPage) == null ? void 0 : r.evaluate("window.scrollBy(0, window.innerHeight);")))
        }
        async scrollUp(e) {
            var t, r;
            this._puppeteerPage && (e ? await ((t = this._puppeteerPage) == null ? void 0 : t.evaluate(`window.scrollBy(0, -${e});`)) : await ((r = this._puppeteerPage) == null ? void 0 : r.evaluate("window.scrollBy(0, -window.innerHeight);")))
        }
        async sendKeys(e) {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer page is not connected");
            const t = e.split("+")
              , r = t.slice(0, -1)
              , s = t[t.length - 1];
            try {
                for (const i of r)
                    await this._puppeteerPage.keyboard.down(this._convertKey(i));
                await Promise.all([this._puppeteerPage.keyboard.press(this._convertKey(s)), this.waitForPageAndFramesLoad()]),
                Be.info("sendKeys complete", e)
            } catch (i) {
                throw Be.error("Failed to send keys:", i),
                new Error(`Failed to send keys: ${iinstanceof Error ? i.message : String(i)}`)
            } finally {
                for (const i of [...r].reverse())
                    try {
                        await this._puppeteerPage.keyboard.up(this._convertKey(i))
                    } catch (a) {
                        Be.error("Failed to release modifier:", i, a)
                    }
            }
        }
        _convertKey(e) {
            const t = e.trim().toLowerCase()
              , s = {
                a: "KeyA",
                b: "KeyB",
                c: "KeyC",
                d: "KeyD",
                e: "KeyE",
                f: "KeyF",
                g: "KeyG",
                h: "KeyH",
                i: "KeyI",
                j: "KeyJ",
                k: "KeyK",
                l: "KeyL",
                m: "KeyM",
                n: "KeyN",
                o: "KeyO",
                p: "KeyP",
                q: "KeyQ",
                r: "KeyR",
                s: "KeyS",
                t: "KeyT",
                u: "KeyU",
                v: "KeyV",
                w: "KeyW",
                x: "KeyX",
                y: "KeyY",
                z: "KeyZ",
                0: "Digit0",
                1: "Digit1",
                2: "Digit2",
                3: "Digit3",
                4: "Digit4",
                5: "Digit5",
                6: "Digit6",
                7: "Digit7",
                8: "Digit8",
                9: "Digit9",
                control: "Control",
                shift: "Shift",
                alt: "Alt",
                meta: "Meta",
                enter: "Enter",
                backspace: "Backspace",
                delete: "Delete",
                arrowleft: "ArrowLeft",
                arrowright: "ArrowRight",
                arrowup: "ArrowUp",
                arrowdown: "ArrowDown",
                escape: "Escape",
                tab: "Tab",
                space: "Space"
            }[t] || e;
            return Be.info("convertedKey", s),
            s
        }
        async scrollToText(e) {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer is not connected");
            try {
                const t = [`::-p-text(${e})`, `::-p-xpath(//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${e.toLowerCase()}')])`];
                for (const r of t)
                    try {
                        const s = await this._puppeteerPage.$(r);
                        if (s && await s.evaluate(a => {
                            const c = window.getComputedStyle(a);
                            return c.display !== "none" && c.visibility !== "hidden" && c.opacity !== "0"
                        }
                        ))
                            return await this._scrollIntoViewIfNeeded(s),
                            await new Promise(a => setTimeout(a, 500)),
                            !0
                    } catch (s) {
                        Be.debug(`Locator attempt failed: ${s}`)
                    }
                return !1
            } catch (t) {
                throw new Error(t instanceof Error ? t.message : String(t))
            }
        }
        async getDropdownOptions(e) {
            const t = this.getSelectorMap()
              , r = t == null ? void 0 : t.get(e);
            if (!r || !this._puppeteerPage)
                throw new Error("Element not found or puppeteer is not connected");
            try {
                const s = await this.locateElement(r);
                if (!s)
                    throw new Error("Dropdown element not found");
                const i = await s.evaluate(a => {
                    if (!(a instanceof HTMLSelectElement))
                        throw new Error("Element is not a select element");
                    return Array.from(a.options).map(c => ({
                        index: c.index,
                        text: c.text,
                        value: c.value
                    }))
                }
                );
                if (!i.length)
                    throw new Error("No options found in dropdown");
                return i
            } catch (s) {
                throw new Error(`Failed to get dropdown options: ${sinstanceof Error ? s.message : String(s)}`)
            }
        }
        async selectDropdownOption(e, t) {
            var i;
            const r = this.getSelectorMap()
              , s = r == null ? void 0 : r.get(e);
            if (!s || !this._puppeteerPage)
                throw new Error("Element not found or puppeteer is not connected");
            if (Be.debug(`Element attributes: ${JSON.stringify(s.attributes)}`),
            Be.debug(`Element tag: ${s.tagName}`),
            ((i = s.tagName) == null ? void 0 : i.toLowerCase()) !== "select") {
                const a = `Cannot select option: Element with index ${e} is a ${s.tagName}, not a SELECT`;
                throw Be.error(a),
                new Error(a)
            }
            try {
                const a = await this.locateElement(s);
                if (!a)
                    throw new Error(`Dropdown element with index ${e} not found`);
                const c = await a.evaluate( (u, l, d) => {
                    if (!(u instanceof HTMLSelectElement))
                        return {
                            found: !1,
                            message: `Element with index ${d} is not a SELECT`
                        };
                    const h = Array.from(u.options)
                      , f = h.find(g => g.text.trim() === l);
                    if (!f) {
                        const g = h.map(y => y.text.trim()).join('", "');
                        return {
                            found: !1,
                            message: `Option "${l}" not found in dropdown element with index ${d}. Available options: "${g}"`
                        }
                    }
                    const p = u.value;
                    return u.value = f.value,
                    p !== f.value && (u.dispatchEvent(new Event("change",{
                        bubbles: !0
                    })),
                    u.dispatchEvent(new Event("input",{
                        bubbles: !0
                    }))),
                    {
                        found: !0,
                        message: `Selected option "${l}" with value "${f.value}"`
                    }
                }
                , t, e);
                return Be.debug("Selection result:", c),
                c.message
            } catch (a) {
                const c = `${ainstanceof Error ? a.message : String(a)}`;
                throw Be.error(c),
                new Error(c)
            }
        }
        async locateElement(e) {
            if (!this._puppeteerPage)
                return Be.warning("Puppeteer is not connected"),
                null;
            let t = this._puppeteerPage;
            const r = [];
            let s = e;
            for (; s.parent; )
                r.push(s.parent),
                s = s.parent;
            const i = r.reverse().filter(c => c.tagName === "iframe");
            for (const c of i) {
                const u = c.enhancedCssSelectorForElement(this._config.includeDynamicAttributes)
                  , l = await t.$(u);
                if (!l)
                    return Be.warning(`Could not find iframe with selector: ${u}`),
                    null;
                const d = await l.contentFrame();
                if (!d)
                    return Be.warning(`Could not access frame content for selector: ${u}`),
                    null;
                t = d
            }
            const a = e.enhancedCssSelectorForElement(this._config.includeDynamicAttributes);
            try {
                const c = await t.$(a);
                if (c)
                    return await this._scrollIntoViewIfNeeded(c),
                    c
            } catch (c) {
                Be.error("Failed to locate element:", c)
            }
            return null
        }
        async inputTextElementNode(e, t, r) {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer is not connected");
            try {
                t.highlightIndex !== void 0 && await this._updateState(e, t.highlightIndex);
                const s = await this.locateElement(t);
                if (!s)
                    throw new Error(`Element: ${t} not found`);
                await this._scrollIntoViewIfNeeded(s),
                await s.evaluate(i => {
                    (i instanceof HTMLInputElement || i instanceof HTMLTextAreaElement) && (i.value = "",
                    i.dispatchEvent(new Event("input",{
                        bubbles: !0
                    })),
                    i.dispatchEvent(new Event("change",{
                        bubbles: !0
                    })))
                }
                ),
                await s.type(r)
            } catch (s) {
                throw new Error(`Failed to input text into element: ${t}. Error: ${sinstanceof Error ? s.message : String(s)}`)
            }
        }
        async _scrollIntoViewIfNeeded(e, t=2500) {
            const r = Date.now();
            for (; !await e.evaluate(i => {
                const a = i.getBoundingClientRect();
                if (a.width === 0 || a.height === 0)
                    return !1;
                const c = window.getComputedStyle(i);
                return c.visibility === "hidden" || c.display === "none" || c.opacity === "0" ? !1 : a.top >= 0 && a.left >= 0 && a.bottom <= (window.innerHeight || document.documentElement.clientHeight) && a.right <= (window.innerWidth || document.documentElement.clientWidth) ? !0 : (i.scrollIntoView({
                    behavior: "auto",
                    block: "center",
                    inline: "center"
                }),
                !1)
            }
            ); ) {
                if (Date.now() - r > t)
                    throw new Error("Timed out while trying to scroll element into view");
                await new Promise(i => setTimeout(i, 100))
            }
        }
        async clickElementNode(e, t) {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer is not connected");
            try {
                t.highlightIndex !== void 0 && await this._updateState(e, t.highlightIndex);
                const r = await this.locateElement(t);
                if (!r)
                    throw new Error(`Element: ${t} not found`);
                await this._scrollIntoViewIfNeeded(r);
                try {
                    await Promise.race([r.click(), new Promise( (s, i) => setTimeout( () => i(new Error("Click timeout")), 2e3))])
                } catch (s) {
                    Be.info("Failed to click element, trying again", s);
                    try {
                        await r.evaluate(i => i.click())
                    } catch (i) {
                        throw new Error(`Failed to click element: ${iinstanceof Error ? i.message : String(i)}`)
                    }
                }
            } catch (r) {
                throw new Error(`Failed to click element: ${t}. Error: ${rinstanceof Error ? r.message : String(r)}`)
            }
        }
        getSelectorMap() {
            return this._state.selectorMap
        }
        async getElementByIndex(e) {
            const r = this.getSelectorMap().get(e);
            return r ? await this.locateElement(r) : null
        }
        getDomElementByIndex(e) {
            return this.getSelectorMap().get(e) || null
        }
        isFileUploader(e, t=3, r=0) {
            var s;
            if (r > t)
                return !1;
            if (e.tagName === "input") {
                const i = e.attributes;
                if (((s = i.type) == null ? void 0 : s.toLowerCase()) === "file" || i.accept)
                    return !0
            }
            if (e.children && r < t) {
                for (const i of e.children)
                    if ("tagName"in i && this.isFileUploader(i, t, r + 1))
                        return !0
            }
            return !1
        }
        async waitForPageLoadState(e) {
            var r;
            const t = e || 8e3;
            await ((r = this._puppeteerPage) == null ? void 0 : r.waitForNavigation({
                timeout: t
            }))
        }
        async _waitForStableNetwork() {
            if (!this._puppeteerPage)
                throw new Error("Puppeteer page is not connected");
            const e = new Set(["document", "stylesheet", "image", "font", "script", "iframe"])
              , t = new Set(["text/html", "text/css", "application/javascript", "image/", "font/", "application/json"])
              , r = new Set(["analytics", "tracking", "telemetry", "beacon", "metrics", "doubleclick", "adsystem", "adserver", "advertising", "facebook.com/plugins", "platform.twitter", "linkedin.com/embed", "livechat", "zendesk", "intercom", "crisp.chat", "hotjar", "push-notifications", "onesignal", "pushwoosh", "heartbeat", "ping", "alive", "webrtc", "rtmp://", "wss://", "cloudfront.net", "fastly.net"])
              , s = new Set;
            let i = Date.now();
            const a = u => {
                const l = u.resourceType();
                if (!e.has(l) || ["websocket", "media", "eventsource", "manifest", "other"].includes(l))
                    return;
                const d = u.url().toLowerCase();
                if (Array.from(r).some(f => d.includes(f)) || d.startsWith("data:") || d.startsWith("blob:"))
                    return;
                const h = u.headers();
                h.purpose === "prefetch" || h["sec-fetch-dest"] === "video" || h["sec-fetch-dest"] === "audio" || (s.add(u),
                i = Date.now())
            }
              , c = u => {
                var f;
                const l = u.request();
                if (!s.has(l))
                    return;
                const d = ((f = u.headers()["content-type"]) == null ? void 0 : f.toLowerCase()) || "";
                if (["streaming", "video", "audio", "webm", "mp4", "event-stream", "websocket", "protobuf"].some(p => d.includes(p))) {
                    s.delete(l);
                    return
                }
                if (!Array.from(t).some(p => d.includes(p))) {
                    s.delete(l);
                    return
                }
                const h = u.headers()["content-length"];
                if (h && Number.parseInt(h) > 5 * 1024 * 1024) {
                    s.delete(l);
                    return
                }
                s.delete(l),
                i = Date.now()
            }
            ;
            this._puppeteerPage.on("request", a),
            this._puppeteerPage.on("response", c);
            try {
                const u = Date.now();
                for (; ; ) {
                    await new Promise(f => setTimeout(f, 100));
                    const l = Date.now()
                      , d = (l - i) / 1e3;
                    if (s.size === 0 && d >= this._config.waitForNetworkIdlePageLoadTime)
                        break;
                    if ((l - u) / 1e3 > this._config.maximumWaitPageLoadTime) {
                        console.debug(`Network timeout after ${this._config.maximumWaitPageLoadTime}s with ${s.size} pending requests:`, Array.from(s).map(f => f.url()));
                        break
                    }
                }
            } finally {
                this._puppeteerPage.off("request", a),
                this._puppeteerPage.off("response", c)
            }
            console.debug(`Network stabilized for ${this._config.waitForNetworkIdlePageLoadTime} seconds`)
        }
        async waitForPageAndFramesLoad(e) {
            const t = Date.now();
            try {
                await this._waitForStableNetwork()
            } catch {
                console.warn("Page load failed, continuing...")
            }
            const r = (Date.now() - t) / 1e3
              , s = e || this._config.minimumWaitPageLoadTime
              , i = Math.max(s - r, 0);
            console.debug(`--Page loaded in ${r.toFixed(2)} seconds, waiting for additional ${i.toFixed(2)} seconds`),
            i > 0 && await new Promise(a => setTimeout(a, i * 1e3))
        }
    }
    ;
    const Gc = kn("BrowserContext");
    class Iq {
        constructor(e) {
            this._currentTabId = null,
            this._attachedPages = new Map,
            this._config = {
                ...ck,
                ...e
            }
        }
        getConfig() {
            return this._config
        }
        updateCurrentTabId(e) {
            this._currentTabId = e
        }
        async _getOrCreatePage(e, t=!1) {
            if (!e.id)
                throw new Error("Tab ID is not available");
            const r = this._attachedPages.get(e.id);
            if (r) {
                if (Gc.info("getOrCreatePage", e.id, "already attached"),
                !t)
                    return r;
                await r.detachPuppeteer(),
                this._attachedPages.delete(e.id)
            }
            return Gc.info("getOrCreatePage", e.id, "creating new page"),
            new Aq(e.id,e.url || "",e.title || "",this._config)
        }
        async cleanup() {
            const e = await this.getCurrentPage();
            e == null || e.removeHighlight();
            for (const t of this._attachedPages.values())
                await t.detachPuppeteer();
            this._attachedPages.clear(),
            this._currentTabId = null
        }
        async attachPage(e) {
            return this._attachedPages.has(e.tabId) ? (Gc.info("attachPage", e.tabId, "already attached"),
            !0) : await e.attachPuppeteer() ? (Gc.info("attachPage", e.tabId, "attached"),
            this._attachedPages.set(e.tabId, e),
            !0) : !1
        }
        async detachPage(e) {
            const t = this._attachedPages.get(e);
            t && (await t.detachPuppeteer(),
            this._attachedPages.delete(e))
        }
        async getCurrentPage() {
            if (!this._currentTabId) {
                let t;
                const [r] = await chrome.tabs.query({
                    active: !0,
                    currentWindow: !0
                });
                if (r != null && r.id)
                    t = r;
                else {
                    const i = await chrome.tabs.create({
                        url: this._config.homePageUrl
                    });
                    if (!i.id)
                        throw new Error("No tab ID available");
                    t = i
                }
                Gc.info("active tab", t.id, t.url, t.title);
                const s = await this._getOrCreatePage(t);
                return await this.attachPage(s),
                this._currentTabId = t.id || null,
                s
            }
            const e = this._attachedPages.get(this._currentTabId);
            if (!e) {
                const t = await chrome.tabs.get(this._currentTabId)
                  , r = await this._getOrCreatePage(t);
                return await this.attachPage(r),
                r
            }
            return e
        }
        async getAllTabIds() {
            const e = await chrome.tabs.query({
                currentWindow: !0
            });
            return new Set(e.map(t => t.id).filter(t => t !== void 0))
        }
        async waitForTabEvents(e, t={}) {
            const {waitForUpdate: r=!0, waitForActivation: s=!0, timeoutMs: i=5e3} = t
              , a = [];
            if (r) {
                const u = new Promise(l => {
                    let d = !1
                      , h = !1
                      , f = !1;
                    const p = (g, y) => {
                        g === e && (y.url && (d = !0),
                        y.title && (h = !0),
                        y.status === "complete" && (f = !0),
                        d && h && f && (chrome.tabs.onUpdated.removeListener(p),
                        l()))
                    }
                    ;
                    chrome.tabs.onUpdated.addListener(p),
                    chrome.tabs.get(e).then(g => {
                        g.url && (d = !0),
                        g.title && (h = !0),
                        g.status === "complete" && (f = !0),
                        d && h && f && (chrome.tabs.onUpdated.removeListener(p),
                        l())
                    }
                    )
                }
                );
                a.push(u)
            }
            if (s) {
                const u = new Promise(l => {
                    const d = h => {
                        h.tabId === e && (chrome.tabs.onActivated.removeListener(d),
                        l())
                    }
                    ;
                    chrome.tabs.onActivated.addListener(d),
                    chrome.tabs.get(e).then(h => {
                        h.active && (chrome.tabs.onActivated.removeListener(d),
                        l())
                    }
                    )
                }
                );
                a.push(u)
            }
            const c = new Promise( (u, l) => setTimeout( () => l(new Error(`Tab operation timed out after ${i} ms`)), i));
            await Promise.race([Promise.all(a), c])
        }
        async switchTab(e) {
            Gc.info("switchTab", e),
            await chrome.tabs.update(e, {
                active: !0
            }),
            await this.waitForTabEvents(e, {
                waitForUpdate: !1
            });
            const t = await this._getOrCreatePage(await chrome.tabs.get(e));
            return await this.attachPage(t),
            this._currentTabId = e,
            t
        }
        async navigateTo(e) {
            const t = await this.getCurrentPage();
            if (!t) {
                await this.openTab(e);
                return
            }
            if (t.attached) {
                await t.navigateTo(e);
                return
            }
            const r = t.tabId;
            await chrome.tabs.update(r, {
                url: e,
                active: !0
            }),
            await this.waitForTabEvents(r);
            const s = await this._getOrCreatePage(await chrome.tabs.get(r), !0);
            await this.attachPage(s),
            this._currentTabId = r
        }
        async openTab(e) {
            const t = await chrome.tabs.create({
                url: e,
                active: !0
            });
            if (!t.id)
                throw new Error("No tab ID available");
            await this.waitForTabEvents(t.id);
            const r = await chrome.tabs.get(t.id)
              , s = await this._getOrCreatePage(r);
            return await this.attachPage(s),
            this._currentTabId = t.id,
            s
        }
        async closeTab(e) {
            await this.detachPage(e),
            await chrome.tabs.remove(e),
            this._currentTabId === e && (this._currentTabId = null)
        }
        removeAttachedPage(e) {
            this._attachedPages.delete(e),
            this._currentTabId === e && (this._currentTabId = null)
        }
        async getTabInfos() {
            const e = await chrome.tabs.query({})
              , t = [];
            for (const r of e)
                r.id && r.url && r.title && t.push({
                    id: r.id,
                    url: r.url,
                    title: r.title
                });
            return t
        }
        async getState() {
            const e = await this.getCurrentPage()
              , t = e ? await e.getState() : xy()
              , r = await this.getTabInfos();
            return {
                ...t,
                tabs: r
            }
        }
        async removeHighlight() {
            const e = await this.getCurrentPage();
            e && await e.removeHighlight()
        }
    }
    var Ve;
    (function(n) {
        n.assertEqual = s => s;
        function e(s) {}
        n.assertIs = e;
        function t(s) {
            throw new Error
        }
        n.assertNever = t,
        n.arrayToEnum = s => {
            const i = {};
            for (const a of s)
                i[a] = a;
            return i
        }
        ,
        n.getValidEnumValues = s => {
            const i = n.objectKeys(s).filter(c => typeof s[s[c]] != "number")
              , a = {};
            for (const c of i)
                a[c] = s[c];
            return n.objectValues(a)
        }
        ,
        n.objectValues = s => n.objectKeys(s).map(function(i) {
            return s[i]
        }),
        n.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
            const i = [];
            for (const a in s)
                Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
            return i
        }
        ,
        n.find = (s, i) => {
            for (const a of s)
                if (i(a))
                    return a
        }
        ,
        n.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
        function r(s, i=" | ") {
            return s.map(a => typeof a == "string" ? `'${a}'` : a).join(i)
        }
        n.joinValues = r,
        n.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i
    }
    )(Ve || (Ve = {}));
    var h_;
    (function(n) {
        n.mergeShapes = (e, t) => ({
            ...e,
            ...t
        })
    }
    )(h_ || (h_ = {}));
    const he = Ve.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
      , Bs = n => {
        switch (typeof n) {
        case "undefined":
            return he.undefined;
        case "string":
            return he.string;
        case "number":
            return isNaN(n) ? he.nan : he.number;
        case "boolean":
            return he.boolean;
        case "function":
            return he.function;
        case "bigint":
            return he.bigint;
        case "symbol":
            return he.symbol;
        case "object":
            return Array.isArray(n) ? he.array : n === null ? he.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? he.promise : typeof Map < "u" && n instanceof Map ? he.map : typeof Set < "u" && n instanceof Set ? he.set : typeof Date < "u" && n instanceof Date ? he.date : he.object;
        default:
            return he.unknown
        }
    }
      , re = Ve.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
      , Oq = n => JSON.stringify(n, null, 2).replace(/"([^"]+)":/g, "$1:");
    class Zr extends Error {
        get errors() {
            return this.issues
        }
        constructor(e) {
            super(),
            this.issues = [],
            this.addIssue = r => {
                this.issues = [...this.issues, r]
            }
            ,
            this.addIssues = (r=[]) => {
                this.issues = [...this.issues, ...r]
            }
            ;
            const t = new.target.prototype;
            Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t,
            this.name = "ZodError",
            this.issues = e
        }
        format(e) {
            const t = e || function(i) {
                return i.message
            }
              , r = {
                _errors: []
            }
              , s = i => {
                for (const a of i.issues)
                    if (a.code === "invalid_union")
                        a.unionErrors.map(s);
                    else if (a.code === "invalid_return_type")
                        s(a.returnTypeError);
                    else if (a.code === "invalid_arguments")
                        s(a.argumentsError);
                    else if (a.path.length === 0)
                        r._errors.push(t(a));
                    else {
                        let c = r
                          , u = 0;
                        for (; u < a.path.length; ) {
                            const l = a.path[u];
                            u === a.path.length - 1 ? (c[l] = c[l] || {
                                _errors: []
                            },
                            c[l]._errors.push(t(a))) : c[l] = c[l] || {
                                _errors: []
                            },
                            c = c[l],
                            u++
                        }
                    }
            }
            ;
            return s(this),
            r
        }
        static assert(e) {
            if (!(e instanceof Zr))
                throw new Error(`Not a ZodError: ${e}`)
        }
        toString() {
            return this.message
        }
        get message() {
            return JSON.stringify(this.issues, Ve.jsonStringifyReplacer, 2)
        }
        get isEmpty() {
            return this.issues.length === 0
        }
        flatten(e=t => t.message) {
            const t = {}
              , r = [];
            for (const s of this.issues)
                s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [],
                t[s.path[0]].push(e(s))) : r.push(e(s));
            return {
                formErrors: r,
                fieldErrors: t
            }
        }
        get formErrors() {
            return this.flatten()
        }
    }
    Zr.create = n => new Zr(n);
    const Jc = (n, e) => {
        let t;
        switch (n.code) {
        case re.invalid_type:
            n.received === he.undefined ? t = "Required" : t = `Expected ${n.expected}, received ${n.received}`;
            break;
        case re.invalid_literal:
            t = `Invalid literal value, expected ${JSON.stringify(n.expected, Ve.jsonStringifyReplacer)}`;
            break;
        case re.unrecognized_keys:
            t = `Unrecognized key(s) in object: ${Ve.joinValues(n.keys, ", ")}`;
            break;
        case re.invalid_union:
            t = "Invalid input";
            break;
        case re.invalid_union_discriminator:
            t = `Invalid discriminator value. Expected ${Ve.joinValues(n.options)}`;
            break;
        case re.invalid_enum_value:
            t = `Invalid enum value. Expected ${Ve.joinValues(n.options)}, received '${n.received}'`;
            break;
        case re.invalid_arguments:
            t = "Invalid function arguments";
            break;
        case re.invalid_return_type:
            t = "Invalid function return type";
            break;
        case re.invalid_date:
            t = "Invalid date";
            break;
        case re.invalid_string:
            typeof n.validation == "object" ? "includes"in n.validation ? (t = `Invalid input: must include "${n.validation.includes}"`,
            typeof n.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith"in n.validation ? t = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith"in n.validation ? t = `Invalid input: must end with "${n.validation.endsWith}"` : Ve.assertNever(n.validation) : n.validation !== "regex" ? t = `Invalid ${n.validation}` : t = "Invalid";
            break;
        case re.too_small:
            n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : t = "Invalid input";
            break;
        case re.too_big:
            n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? t = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : t = "Invalid input";
            break;
        case re.custom:
            t = "Invalid input";
            break;
        case re.invalid_intersection_types:
            t = "Intersection results could not be merged";
            break;
        case re.not_multiple_of:
            t = `Number must be a multiple of ${n.multipleOf}`;
            break;
        case re.not_finite:
            t = "Number must be finite";
            break;
        default:
            t = e.defaultError,
            Ve.assertNever(n)
        }
        return {
            message: t
        }
    }
    ;
    let QP = Jc;
    function Rq(n) {
        QP = n
    }
    function Cy() {
        return QP
    }
    const ky = n => {
        const {data: e, path: t, errorMaps: r, issueData: s} = n
          , i = [...t, ...s.path || []]
          , a = {
            ...s,
            path: i
        };
        if (s.message !== void 0)
            return {
                ...s,
                path: i,
                message: s.message
            };
        let c = "";
        const u = r.filter(l => !!l).slice().reverse();
        for (const l of u)
            c = l(a, {
                data: e,
                defaultError: c
            }).message;
        return {
            ...s,
            path: i,
            message: c
        }
    }
      , Mq = [];
    function de(n, e) {
        const t = Cy()
          , r = ky({
            issueData: e,
            data: n.data,
            path: n.path,
            errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, t, t === Jc ? void 0 : Jc].filter(s => !!s)
        });
        n.common.issues.push(r)
    }
    class lr {
        constructor() {
            this.value = "valid"
        }
        dirty() {
            this.value === "valid" && (this.value = "dirty")
        }
        abort() {
            this.value !== "aborted" && (this.value = "aborted")
        }
        static mergeArray(e, t) {
            const r = [];
            for (const s of t) {
                if (s.status === "aborted")
                    return Ae;
                s.status === "dirty" && e.dirty(),
                r.push(s.value)
            }
            return {
                status: e.value,
                value: r
            }
        }
        static async mergeObjectAsync(e, t) {
            const r = [];
            for (const s of t) {
                const i = await s.key
                  , a = await s.value;
                r.push({
                    key: i,
                    value: a
                })
            }
            return lr.mergeObjectSync(e, r)
        }
        static mergeObjectSync(e, t) {
            const r = {};
            for (const s of t) {
                const {key: i, value: a} = s;
                if (i.status === "aborted" || a.status === "aborted")
                    return Ae;
                i.status === "dirty" && e.dirty(),
                a.status === "dirty" && e.dirty(),
                i.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) && (r[i.value] = a.value)
            }
            return {
                status: e.value,
                value: r
            }
        }
    }
    const Ae = Object.freeze({
        status: "aborted"
    })
      , Zc = n => ({
        status: "dirty",
        value: n
    })
      , br = n => ({
        status: "valid",
        value: n
    })
      , f_ = n => n.status === "aborted"
      , p_ = n => n.status === "dirty"
      , eo = n => n.status === "valid"
      , Kd = n => typeof Promise < "u" && n instanceof Promise;
    function Py(n, e, t, r) {
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return e.get(n)
    }
    function eT(n, e, t, r, s) {
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return e.set(n, t),
        t
    }
    typeof SuppressedError == "function" && SuppressedError;
    var ve;
    (function(n) {
        n.errToObj = e => typeof e == "string" ? {
            message: e
        } : e || {},
        n.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
    }
    )(ve || (ve = {}));
    var Hd, Wd;
    class fs {
        constructor(e, t, r, s) {
            this._cachedPath = [],
            this.parent = e,
            this.data = t,
            this._path = r,
            this._key = s
        }
        get path() {
            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
        }
    }
    const tT = (n, e) => {
        if (eo(e))
            return {
                success: !0,
                data: e.value
            };
        if (!n.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error)
                    return this._error;
                const t = new Zr(n.common.issues);
                return this._error = t,
                this._error
            }
        }
    }
    ;
    function Re(n) {
        if (!n)
            return {};
        const {errorMap: e, invalid_type_error: t, required_error: r, description: s} = n;
        if (e && (t || r))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return e ? {
            errorMap: e,
            description: s
        } : {
            errorMap: (a, c) => {
                var u, l;
                const {message: d} = n;
                return a.code === "invalid_enum_value" ? {
                    message: d ?? c.defaultError
                } : typeof c.data > "u" ? {
                    message: (u = d ?? r) !== null && u !== void 0 ? u : c.defaultError
                } : a.code !== "invalid_type" ? {
                    message: c.defaultError
                } : {
                    message: (l = d ?? t) !== null && l !== void 0 ? l : c.defaultError
                }
            }
            ,
            description: s
        }
    }
    class $e {
        get description() {
            return this._def.description
        }
        _getType(e) {
            return Bs(e.data)
        }
        _getOrReturnCtx(e, t) {
            return t || {
                common: e.parent.common,
                data: e.data,
                parsedType: Bs(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
        _processInputParams(e) {
            return {
                status: new lr,
                ctx: {
                    common: e.parent.common,
                    data: e.data,
                    parsedType: Bs(e.data),
                    schemaErrorMap: this._def.errorMap,
                    path: e.path,
                    parent: e.parent
                }
            }
        }
        _parseSync(e) {
            const t = this._parse(e);
            if (Kd(t))
                throw new Error("Synchronous parse encountered promise.");
            return t
        }
        _parseAsync(e) {
            const t = this._parse(e);
            return Promise.resolve(t)
        }
        parse(e, t) {
            const r = this.safeParse(e, t);
            if (r.success)
                return r.data;
            throw r.error
        }
        safeParse(e, t) {
            var r;
            const s = {
                common: {
                    issues: [],
                    async: (r = t == null ? void 0 : t.async) !== null && r !== void 0 ? r : !1,
                    contextualErrorMap: t == null ? void 0 : t.errorMap
                },
                path: (t == null ? void 0 : t.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: Bs(e)
            }
              , i = this._parseSync({
                data: e,
                path: s.path,
                parent: s
            });
            return tT(s, i)
        }
        "~validate"(e) {
            var t, r;
            const s = {
                common: {
                    issues: [],
                    async: !!this["~standard"].async
                },
                path: [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: Bs(e)
            };
            if (!this["~standard"].async)
                try {
                    const i = this._parseSync({
                        data: e,
                        path: [],
                        parent: s
                    });
                    return eo(i) ? {
                        value: i.value
                    } : {
                        issues: s.common.issues
                    }
                } catch (i) {
                    !((r = (t = i == null ? void 0 : i.message) === null || t === void 0 ? void 0 : t.toLowerCase()) === null || r === void 0) && r.includes("encountered") && (this["~standard"].async = !0),
                    s.common = {
                        issues: [],
                        async: !0
                    }
                }
            return this._parseAsync({
                data: e,
                path: [],
                parent: s
            }).then(i => eo(i) ? {
                value: i.value
            } : {
                issues: s.common.issues
            })
        }
        async parseAsync(e, t) {
            const r = await this.safeParseAsync(e, t);
            if (r.success)
                return r.data;
            throw r.error
        }
        async safeParseAsync(e, t) {
            const r = {
                common: {
                    issues: [],
                    contextualErrorMap: t == null ? void 0 : t.errorMap,
                    async: !0
                },
                path: (t == null ? void 0 : t.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: Bs(e)
            }
              , s = this._parse({
                data: e,
                path: r.path,
                parent: r
            })
              , i = await (Kd(s) ? s : Promise.resolve(s));
            return tT(r, i)
        }
        refine(e, t) {
            const r = s => typeof t == "string" || typeof t > "u" ? {
                message: t
            } : typeof t == "function" ? t(s) : t;
            return this._refinement( (s, i) => {
                const a = e(s)
                  , c = () => i.addIssue({
                    code: re.custom,
                    ...r(s)
                });
                return typeof Promise < "u" && a instanceof Promise ? a.then(u => u ? !0 : (c(),
                !1)) : a ? !0 : (c(),
                !1)
            }
            )
        }
        refinement(e, t) {
            return this._refinement( (r, s) => e(r) ? !0 : (s.addIssue(typeof t == "function" ? t(r, s) : t),
            !1))
        }
        _refinement(e) {
            return new An({
                schema: this,
                typeName: Y.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement: e
                }
            })
        }
        superRefine(e) {
            return this._refinement(e)
        }
        constructor(e) {
            this.spa = this.safeParseAsync,
            this._def = e,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this),
            this["~standard"] = {
                version: 1,
                vendor: "zod",
                validate: t => this["~validate"](t)
            }
        }
        optional() {
            return In.create(this, this._def)
        }
        nullable() {
            return Ni.create(this, this._def)
        }
        nullish() {
            return this.nullable().optional()
        }
        array() {
            return Tn.create(this)
        }
        promise() {
            return eu.create(this, this._def)
        }
        or(e) {
            return Jd.create([this, e], this._def)
        }
        and(e) {
            return Zd.create(this, e, this._def)
        }
        transform(e) {
            return new An({
                ...Re(this._def),
                schema: this,
                typeName: Y.ZodEffects,
                effect: {
                    type: "transform",
                    transform: e
                }
            })
        }
        default(e) {
            const t = typeof e == "function" ? e : () => e;
            return new th({
                ...Re(this._def),
                innerType: this,
                defaultValue: t,
                typeName: Y.ZodDefault
            })
        }
        brand() {
            return new y_({
                typeName: Y.ZodBranded,
                type: this,
                ...Re(this._def)
            })
        }
        catch(e) {
            const t = typeof e == "function" ? e : () => e;
            return new rh({
                ...Re(this._def),
                innerType: this,
                catchValue: t,
                typeName: Y.ZodCatch
            })
        }
        describe(e) {
            const t = this.constructor;
            return new t({
                ...this._def,
                description: e
            })
        }
        pipe(e) {
            return nh.create(this, e)
        }
        readonly() {
            return sh.create(this)
        }
        isOptional() {
            return this.safeParse(void 0).success
        }
        isNullable() {
            return this.safeParse(null).success
        }
    }
    const Nq = /^c[^\s-]{8,}$/i
      , $q = /^[0-9a-z]+$/
      , Lq = /^[0-9A-HJKMNP-TV-Z]{26}$/i
      , Fq = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , jq = /^[a-z0-9_-]{21}$/i
      , Dq = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
      , Bq = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
      , qq = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , Uq = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let m_;
    const Kq = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
      , Hq = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
      , Wq = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
      , zq = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
      , Vq = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      , Gq = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
      , rT = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
      , Jq = new RegExp(`^${rT}$`);
    function nT(n) {
        let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
        return n.precision ? e = `${e}\\.\\d{${n.precision}}` : n.precision == null && (e = `${e}(\\.\\d+)?`),
        e
    }
    function Zq(n) {
        return new RegExp(`^${nT(n)}$`)
    }
    function sT(n) {
        let e = `${rT}T${nT(n)}`;
        const t = [];
        return t.push(n.local ? "Z?" : "Z"),
        n.offset && t.push("([+-]\\d{2}:?\\d{2})"),
        e = `${e}(${t.join("|")})`,
        new RegExp(`^${e}$`)
    }
    function Xq(n, e) {
        return !!((e === "v4" || !e) && Kq.test(n) || (e === "v6" || !e) && Wq.test(n))
    }
    function Yq(n, e) {
        if (!Dq.test(n))
            return !1;
        try {
            const [t] = n.split(".")
              , r = t.replace(/-/g, "+").replace(/_/g, "/").padEnd(t.length + (4 - t.length % 4) % 4, "=")
              , s = JSON.parse(atob(r));
            return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e)
        } catch {
            return !1
        }
    }
    function Qq(n, e) {
        return !!((e === "v4" || !e) && Hq.test(n) || (e === "v6" || !e) && zq.test(n))
    }
    class Pn extends $e {
        _parse(e) {
            if (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== he.string) {
                const i = this._getOrReturnCtx(e);
                return de(i, {
                    code: re.invalid_type,
                    expected: he.string,
                    received: i.parsedType
                }),
                Ae
            }
            const r = new lr;
            let s;
            for (const i of this._def.checks)
                if (i.kind === "min")
                    e.data.length < i.value && (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.too_small,
                        minimum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "max")
                    e.data.length > i.value && (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.too_big,
                        maximum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "length") {
                    const a = e.data.length > i.value
                      , c = e.data.length < i.value;
                    (a || c) && (s = this._getOrReturnCtx(e, s),
                    a ? de(s, {
                        code: re.too_big,
                        maximum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: i.message
                    }) : c && de(s, {
                        code: re.too_small,
                        minimum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: i.message
                    }),
                    r.dirty())
                } else if (i.kind === "email")
                    qq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "email",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "emoji")
                    m_ || (m_ = new RegExp(Uq,"u")),
                    m_.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "emoji",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "uuid")
                    Fq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "uuid",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "nanoid")
                    jq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "nanoid",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "cuid")
                    Nq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "cuid",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "cuid2")
                    $q.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "cuid2",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "ulid")
                    Lq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "ulid",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty());
                else if (i.kind === "url")
                    try {
                        new URL(e.data)
                    } catch {
                        s = this._getOrReturnCtx(e, s),
                        de(s, {
                            validation: "url",
                            code: re.invalid_string,
                            message: i.message
                        }),
                        r.dirty()
                    }
                else
                    i.kind === "regex" ? (i.regex.lastIndex = 0,
                    i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "regex",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.invalid_string,
                        validation: {
                            includes: i.value,
                            position: i.position
                        },
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.invalid_string,
                        validation: {
                            startsWith: i.value
                        },
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.invalid_string,
                        validation: {
                            endsWith: i.value
                        },
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "datetime" ? sT(i).test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.invalid_string,
                        validation: "datetime",
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "date" ? Jq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.invalid_string,
                        validation: "date",
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "time" ? Zq(i).test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        code: re.invalid_string,
                        validation: "time",
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "duration" ? Bq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "duration",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "ip" ? Xq(e.data, i.version) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "ip",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "jwt" ? Yq(e.data, i.alg) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "jwt",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "cidr" ? Qq(e.data, i.version) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "cidr",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "base64" ? Vq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "base64",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty()) : i.kind === "base64url" ? Gq.test(e.data) || (s = this._getOrReturnCtx(e, s),
                    de(s, {
                        validation: "base64url",
                        code: re.invalid_string,
                        message: i.message
                    }),
                    r.dirty()) : Ve.assertNever(i);
            return {
                status: r.value,
                value: e.data
            }
        }
        _regex(e, t, r) {
            return this.refinement(s => e.test(s), {
                validation: t,
                code: re.invalid_string,
                ...ve.errToObj(r)
            })
        }
        _addCheck(e) {
            return new Pn({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        email(e) {
            return this._addCheck({
                kind: "email",
                ...ve.errToObj(e)
            })
        }
        url(e) {
            return this._addCheck({
                kind: "url",
                ...ve.errToObj(e)
            })
        }
        emoji(e) {
            return this._addCheck({
                kind: "emoji",
                ...ve.errToObj(e)
            })
        }
        uuid(e) {
            return this._addCheck({
                kind: "uuid",
                ...ve.errToObj(e)
            })
        }
        nanoid(e) {
            return this._addCheck({
                kind: "nanoid",
                ...ve.errToObj(e)
            })
        }
        cuid(e) {
            return this._addCheck({
                kind: "cuid",
                ...ve.errToObj(e)
            })
        }
        cuid2(e) {
            return this._addCheck({
                kind: "cuid2",
                ...ve.errToObj(e)
            })
        }
        ulid(e) {
            return this._addCheck({
                kind: "ulid",
                ...ve.errToObj(e)
            })
        }
        base64(e) {
            return this._addCheck({
                kind: "base64",
                ...ve.errToObj(e)
            })
        }
        base64url(e) {
            return this._addCheck({
                kind: "base64url",
                ...ve.errToObj(e)
            })
        }
        jwt(e) {
            return this._addCheck({
                kind: "jwt",
                ...ve.errToObj(e)
            })
        }
        ip(e) {
            return this._addCheck({
                kind: "ip",
                ...ve.errToObj(e)
            })
        }
        cidr(e) {
            return this._addCheck({
                kind: "cidr",
                ...ve.errToObj(e)
            })
        }
        datetime(e) {
            var t, r;
            return typeof e == "string" ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                local: !1,
                message: e
            }) : this._addCheck({
                kind: "datetime",
                precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
                offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
                local: (r = e == null ? void 0 : e.local) !== null && r !== void 0 ? r : !1,
                ...ve.errToObj(e == null ? void 0 : e.message)
            })
        }
        date(e) {
            return this._addCheck({
                kind: "date",
                message: e
            })
        }
        time(e) {
            return typeof e == "string" ? this._addCheck({
                kind: "time",
                precision: null,
                message: e
            }) : this._addCheck({
                kind: "time",
                precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
                ...ve.errToObj(e == null ? void 0 : e.message)
            })
        }
        duration(e) {
            return this._addCheck({
                kind: "duration",
                ...ve.errToObj(e)
            })
        }
        regex(e, t) {
            return this._addCheck({
                kind: "regex",
                regex: e,
                ...ve.errToObj(t)
            })
        }
        includes(e, t) {
            return this._addCheck({
                kind: "includes",
                value: e,
                position: t == null ? void 0 : t.position,
                ...ve.errToObj(t == null ? void 0 : t.message)
            })
        }
        startsWith(e, t) {
            return this._addCheck({
                kind: "startsWith",
                value: e,
                ...ve.errToObj(t)
            })
        }
        endsWith(e, t) {
            return this._addCheck({
                kind: "endsWith",
                value: e,
                ...ve.errToObj(t)
            })
        }
        min(e, t) {
            return this._addCheck({
                kind: "min",
                value: e,
                ...ve.errToObj(t)
            })
        }
        max(e, t) {
            return this._addCheck({
                kind: "max",
                value: e,
                ...ve.errToObj(t)
            })
        }
        length(e, t) {
            return this._addCheck({
                kind: "length",
                value: e,
                ...ve.errToObj(t)
            })
        }
        nonempty(e) {
            return this.min(1, ve.errToObj(e))
        }
        trim() {
            return new Pn({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "trim"
                }]
            })
        }
        toLowerCase() {
            return new Pn({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toLowerCase"
                }]
            })
        }
        toUpperCase() {
            return new Pn({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toUpperCase"
                }]
            })
        }
        get isDatetime() {
            return !!this._def.checks.find(e => e.kind === "datetime")
        }
        get isDate() {
            return !!this._def.checks.find(e => e.kind === "date")
        }
        get isTime() {
            return !!this._def.checks.find(e => e.kind === "time")
        }
        get isDuration() {
            return !!this._def.checks.find(e => e.kind === "duration")
        }
        get isEmail() {
            return !!this._def.checks.find(e => e.kind === "email")
        }
        get isURL() {
            return !!this._def.checks.find(e => e.kind === "url")
        }
        get isEmoji() {
            return !!this._def.checks.find(e => e.kind === "emoji")
        }
        get isUUID() {
            return !!this._def.checks.find(e => e.kind === "uuid")
        }
        get isNANOID() {
            return !!this._def.checks.find(e => e.kind === "nanoid")
        }
        get isCUID() {
            return !!this._def.checks.find(e => e.kind === "cuid")
        }
        get isCUID2() {
            return !!this._def.checks.find(e => e.kind === "cuid2")
        }
        get isULID() {
            return !!this._def.checks.find(e => e.kind === "ulid")
        }
        get isIP() {
            return !!this._def.checks.find(e => e.kind === "ip")
        }
        get isCIDR() {
            return !!this._def.checks.find(e => e.kind === "cidr")
        }
        get isBase64() {
            return !!this._def.checks.find(e => e.kind === "base64")
        }
        get isBase64url() {
            return !!this._def.checks.find(e => e.kind === "base64url")
        }
        get minLength() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "min" && (e === null || t.value > e) && (e = t.value);
            return e
        }
        get maxLength() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "max" && (e === null || t.value < e) && (e = t.value);
            return e
        }
    }
    Pn.create = n => {
        var e;
        return new Pn({
            checks: [],
            typeName: Y.ZodString,
            coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1,
            ...Re(n)
        })
    }
    ;
    function eU(n, e) {
        const t = (n.toString().split(".")[1] || "").length
          , r = (e.toString().split(".")[1] || "").length
          , s = t > r ? t : r
          , i = parseInt(n.toFixed(s).replace(".", ""))
          , a = parseInt(e.toFixed(s).replace(".", ""));
        return i % a / Math.pow(10, s)
    }
    class Oi extends $e {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
        }
        _parse(e) {
            if (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== he.number) {
                const i = this._getOrReturnCtx(e);
                return de(i, {
                    code: re.invalid_type,
                    expected: he.number,
                    received: i.parsedType
                }),
                Ae
            }
            let r;
            const s = new lr;
            for (const i of this._def.checks)
                i.kind === "int" ? Ve.isInteger(e.data) || (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: i.message
                }),
                s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.too_small,
                    minimum: i.value,
                    type: "number",
                    inclusive: i.inclusive,
                    exact: !1,
                    message: i.message
                }),
                s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.too_big,
                    maximum: i.value,
                    type: "number",
                    inclusive: i.inclusive,
                    exact: !1,
                    message: i.message
                }),
                s.dirty()) : i.kind === "multipleOf" ? eU(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.not_multiple_of,
                    multipleOf: i.value,
                    message: i.message
                }),
                s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.not_finite,
                    message: i.message
                }),
                s.dirty()) : Ve.assertNever(i);
            return {
                status: s.value,
                value: e.data
            }
        }
        gte(e, t) {
            return this.setLimit("min", e, !0, ve.toString(t))
        }
        gt(e, t) {
            return this.setLimit("min", e, !1, ve.toString(t))
        }
        lte(e, t) {
            return this.setLimit("max", e, !0, ve.toString(t))
        }
        lt(e, t) {
            return this.setLimit("max", e, !1, ve.toString(t))
        }
        setLimit(e, t, r, s) {
            return new Oi({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: t,
                    inclusive: r,
                    message: ve.toString(s)
                }]
            })
        }
        _addCheck(e) {
            return new Oi({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        int(e) {
            return this._addCheck({
                kind: "int",
                message: ve.toString(e)
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: ve.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: ve.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: ve.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: ve.toString(e)
            })
        }
        multipleOf(e, t) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: ve.toString(t)
            })
        }
        finite(e) {
            return this._addCheck({
                kind: "finite",
                message: ve.toString(e)
            })
        }
        safe(e) {
            return this._addCheck({
                kind: "min",
                inclusive: !0,
                value: Number.MIN_SAFE_INTEGER,
                message: ve.toString(e)
            })._addCheck({
                kind: "max",
                inclusive: !0,
                value: Number.MAX_SAFE_INTEGER,
                message: ve.toString(e)
            })
        }
        get minValue() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "min" && (e === null || t.value > e) && (e = t.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "max" && (e === null || t.value < e) && (e = t.value);
            return e
        }
        get isInt() {
            return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && Ve.isInteger(e.value))
        }
        get isFinite() {
            let e = null
              , t = null;
            for (const r of this._def.checks) {
                if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
                    return !0;
                r.kind === "min" ? (t === null || r.value > t) && (t = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value)
            }
            return Number.isFinite(t) && Number.isFinite(e)
        }
    }
    Oi.create = n => new Oi({
        checks: [],
        typeName: Y.ZodNumber,
        coerce: (n == null ? void 0 : n.coerce) || !1,
        ...Re(n)
    });
    class Ri extends $e {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte
        }
        _parse(e) {
            if (this._def.coerce)
                try {
                    e.data = BigInt(e.data)
                } catch {
                    return this._getInvalidInput(e)
                }
            if (this._getType(e) !== he.bigint)
                return this._getInvalidInput(e);
            let r;
            const s = new lr;
            for (const i of this._def.checks)
                i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.too_small,
                    type: "bigint",
                    minimum: i.value,
                    inclusive: i.inclusive,
                    message: i.message
                }),
                s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.too_big,
                    type: "bigint",
                    maximum: i.value,
                    inclusive: i.inclusive,
                    message: i.message
                }),
                s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r),
                de(r, {
                    code: re.not_multiple_of,
                    multipleOf: i.value,
                    message: i.message
                }),
                s.dirty()) : Ve.assertNever(i);
            return {
                status: s.value,
                value: e.data
            }
        }
        _getInvalidInput(e) {
            const t = this._getOrReturnCtx(e);
            return de(t, {
                code: re.invalid_type,
                expected: he.bigint,
                received: t.parsedType
            }),
            Ae
        }
        gte(e, t) {
            return this.setLimit("min", e, !0, ve.toString(t))
        }
        gt(e, t) {
            return this.setLimit("min", e, !1, ve.toString(t))
        }
        lte(e, t) {
            return this.setLimit("max", e, !0, ve.toString(t))
        }
        lt(e, t) {
            return this.setLimit("max", e, !1, ve.toString(t))
        }
        setLimit(e, t, r, s) {
            return new Ri({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: t,
                    inclusive: r,
                    message: ve.toString(s)
                }]
            })
        }
        _addCheck(e) {
            return new Ri({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !1,
                message: ve.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !1,
                message: ve.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !0,
                message: ve.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !0,
                message: ve.toString(e)
            })
        }
        multipleOf(e, t) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: ve.toString(t)
            })
        }
        get minValue() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "min" && (e === null || t.value > e) && (e = t.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "max" && (e === null || t.value < e) && (e = t.value);
            return e
        }
    }
    Ri.create = n => {
        var e;
        return new Ri({
            checks: [],
            typeName: Y.ZodBigInt,
            coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1,
            ...Re(n)
        })
    }
    ;
    class zd extends $e {
        _parse(e) {
            if (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== he.boolean) {
                const r = this._getOrReturnCtx(e);
                return de(r, {
                    code: re.invalid_type,
                    expected: he.boolean,
                    received: r.parsedType
                }),
                Ae
            }
            return br(e.data)
        }
    }
    zd.create = n => new zd({
        typeName: Y.ZodBoolean,
        coerce: (n == null ? void 0 : n.coerce) || !1,
        ...Re(n)
    });
    class to extends $e {
        _parse(e) {
            if (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== he.date) {
                const i = this._getOrReturnCtx(e);
                return de(i, {
                    code: re.invalid_type,
                    expected: he.date,
                    received: i.parsedType
                }),
                Ae
            }
            if (isNaN(e.data.getTime())) {
                const i = this._getOrReturnCtx(e);
                return de(i, {
                    code: re.invalid_date
                }),
                Ae
            }
            const r = new lr;
            let s;
            for (const i of this._def.checks)
                i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s),
                de(s, {
                    code: re.too_small,
                    message: i.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: i.value,
                    type: "date"
                }),
                r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s),
                de(s, {
                    code: re.too_big,
                    message: i.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: i.value,
                    type: "date"
                }),
                r.dirty()) : Ve.assertNever(i);
            return {
                status: r.value,
                value: new Date(e.data.getTime())
            }
        }
        _addCheck(e) {
            return new to({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        min(e, t) {
            return this._addCheck({
                kind: "min",
                value: e.getTime(),
                message: ve.toString(t)
            })
        }
        max(e, t) {
            return this._addCheck({
                kind: "max",
                value: e.getTime(),
                message: ve.toString(t)
            })
        }
        get minDate() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "min" && (e === null || t.value > e) && (e = t.value);
            return e != null ? new Date(e) : null
        }
        get maxDate() {
            let e = null;
            for (const t of this._def.checks)
                t.kind === "max" && (e === null || t.value < e) && (e = t.value);
            return e != null ? new Date(e) : null
        }
    }
    to.create = n => new to({
        checks: [],
        coerce: (n == null ? void 0 : n.coerce) || !1,
        typeName: Y.ZodDate,
        ...Re(n)
    });
    class Ty extends $e {
        _parse(e) {
            if (this._getType(e) !== he.symbol) {
                const r = this._getOrReturnCtx(e);
                return de(r, {
                    code: re.invalid_type,
                    expected: he.symbol,
                    received: r.parsedType
                }),
                Ae
            }
            return br(e.data)
        }
    }
    Ty.create = n => new Ty({
        typeName: Y.ZodSymbol,
        ...Re(n)
    });
    class Vd extends $e {
        _parse(e) {
            if (this._getType(e) !== he.undefined) {
                const r = this._getOrReturnCtx(e);
                return de(r, {
                    code: re.invalid_type,
                    expected: he.undefined,
                    received: r.parsedType
                }),
                Ae
            }
            return br(e.data)
        }
    }
    Vd.create = n => new Vd({
        typeName: Y.ZodUndefined,
        ...Re(n)
    });
    class Gd extends $e {
        _parse(e) {
            if (this._getType(e) !== he.null) {
                const r = this._getOrReturnCtx(e);
                return de(r, {
                    code: re.invalid_type,
                    expected: he.null,
                    received: r.parsedType
                }),
                Ae
            }
            return br(e.data)
        }
    }
    Gd.create = n => new Gd({
        typeName: Y.ZodNull,
        ...Re(n)
    });
    class Xc extends $e {
        constructor() {
            super(...arguments),
            this._any = !0
        }
        _parse(e) {
            return br(e.data)
        }
    }
    Xc.create = n => new Xc({
        typeName: Y.ZodAny,
        ...Re(n)
    });
    class ro extends $e {
        constructor() {
            super(...arguments),
            this._unknown = !0
        }
        _parse(e) {
            return br(e.data)
        }
    }
    ro.create = n => new ro({
        typeName: Y.ZodUnknown,
        ...Re(n)
    });
    class qs extends $e {
        _parse(e) {
            const t = this._getOrReturnCtx(e);
            return de(t, {
                code: re.invalid_type,
                expected: he.never,
                received: t.parsedType
            }),
            Ae
        }
    }
    qs.create = n => new qs({
        typeName: Y.ZodNever,
        ...Re(n)
    });
    class Ay extends $e {
        _parse(e) {
            if (this._getType(e) !== he.undefined) {
                const r = this._getOrReturnCtx(e);
                return de(r, {
                    code: re.invalid_type,
                    expected: he.void,
                    received: r.parsedType
                }),
                Ae
            }
            return br(e.data)
        }
    }
    Ay.create = n => new Ay({
        typeName: Y.ZodVoid,
        ...Re(n)
    });
    class Tn extends $e {
        _parse(e) {
            const {ctx: t, status: r} = this._processInputParams(e)
              , s = this._def;
            if (t.parsedType !== he.array)
                return de(t, {
                    code: re.invalid_type,
                    expected: he.array,
                    received: t.parsedType
                }),
                Ae;
            if (s.exactLength !== null) {
                const a = t.data.length > s.exactLength.value
                  , c = t.data.length < s.exactLength.value;
                (a || c) && (de(t, {
                    code: a ? re.too_big : re.too_small,
                    minimum: c ? s.exactLength.value : void 0,
                    maximum: a ? s.exactLength.value : void 0,
                    type: "array",
                    inclusive: !0,
                    exact: !0,
                    message: s.exactLength.message
                }),
                r.dirty())
            }
            if (s.minLength !== null && t.data.length < s.minLength.value && (de(t, {
                code: re.too_small,
                minimum: s.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: s.minLength.message
            }),
            r.dirty()),
            s.maxLength !== null && t.data.length > s.maxLength.value && (de(t, {
                code: re.too_big,
                maximum: s.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: s.maxLength.message
            }),
            r.dirty()),
            t.common.async)
                return Promise.all([...t.data].map( (a, c) => s.type._parseAsync(new fs(t,a,t.path,c)))).then(a => lr.mergeArray(r, a));
            const i = [...t.data].map( (a, c) => s.type._parseSync(new fs(t,a,t.path,c)));
            return lr.mergeArray(r, i)
        }
        get element() {
            return this._def.type
        }
        min(e, t) {
            return new Tn({
                ...this._def,
                minLength: {
                    value: e,
                    message: ve.toString(t)
                }
            })
        }
        max(e, t) {
            return new Tn({
                ...this._def,
                maxLength: {
                    value: e,
                    message: ve.toString(t)
                }
            })
        }
        length(e, t) {
            return new Tn({
                ...this._def,
                exactLength: {
                    value: e,
                    message: ve.toString(t)
                }
            })
        }
        nonempty(e) {
            return this.min(1, e)
        }
    }
    Tn.create = (n, e) => new Tn({
        type: n,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: Y.ZodArray,
        ...Re(e)
    });
    function Yc(n) {
        if (n instanceof xt) {
            const e = {};
            for (const t in n.shape) {
                const r = n.shape[t];
                e[t] = In.create(Yc(r))
            }
            return new xt({
                ...n._def,
                shape: () => e
            })
        } else
            return n instanceof Tn ? new Tn({
                ...n._def,
                type: Yc(n.element)
            }) : n instanceof In ? In.create(Yc(n.unwrap())) : n instanceof Ni ? Ni.create(Yc(n.unwrap())) : n instanceof ps ? ps.create(n.items.map(e => Yc(e))) : n
    }
    class xt extends $e {
        constructor() {
            super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const e = this._def.shape()
              , t = Ve.objectKeys(e);
            return this._cached = {
                shape: e,
                keys: t
            }
        }
        _parse(e) {
            if (this._getType(e) !== he.object) {
                const l = this._getOrReturnCtx(e);
                return de(l, {
                    code: re.invalid_type,
                    expected: he.object,
                    received: l.parsedType
                }),
                Ae
            }
            const {status: r, ctx: s} = this._processInputParams(e)
              , {shape: i, keys: a} = this._getCached()
              , c = [];
            if (!(this._def.catchall instanceof qs && this._def.unknownKeys === "strip"))
                for (const l in s.data)
                    a.includes(l) || c.push(l);
            const u = [];
            for (const l of a) {
                const d = i[l]
                  , h = s.data[l];
                u.push({
                    key: {
                        status: "valid",
                        value: l
                    },
                    value: d._parse(new fs(s,h,s.path,l)),
                    alwaysSet: l in s.data
                })
            }
            if (this._def.catchall instanceof qs) {
                const l = this._def.unknownKeys;
                if (l === "passthrough")
                    for (const d of c)
                        u.push({
                            key: {
                                status: "valid",
                                value: d
                            },
                            value: {
                                status: "valid",
                                value: s.data[d]
                            }
                        });
                else if (l === "strict")
                    c.length > 0 && (de(s, {
                        code: re.unrecognized_keys,
                        keys: c
                    }),
                    r.dirty());
                else if (l !== "strip")
                    throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                const l = this._def.catchall;
                for (const d of c) {
                    const h = s.data[d];
                    u.push({
                        key: {
                            status: "valid",
                            value: d
                        },
                        value: l._parse(new fs(s,h,s.path,d)),
                        alwaysSet: d in s.data
                    })
                }
            }
            return s.common.async ? Promise.resolve().then(async () => {
                const l = [];
                for (const d of u) {
                    const h = await d.key
                      , f = await d.value;
                    l.push({
                        key: h,
                        value: f,
                        alwaysSet: d.alwaysSet
                    })
                }
                return l
            }
            ).then(l => lr.mergeObjectSync(r, l)) : lr.mergeObjectSync(r, u)
        }
        get shape() {
            return this._def.shape()
        }
        strict(e) {
            return ve.errToObj,
            new xt({
                ...this._def,
                unknownKeys: "strict",
                ...e !== void 0 ? {
                    errorMap: (t, r) => {
                        var s, i, a, c;
                        const u = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, t, r).message) !== null && a !== void 0 ? a : r.defaultError;
                        return t.code === "unrecognized_keys" ? {
                            message: (c = ve.errToObj(e).message) !== null && c !== void 0 ? c : u
                        } : {
                            message: u
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new xt({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new xt({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        extend(e) {
            return new xt({
                ...this._def,
                shape: () => ({
                    ...this._def.shape(),
                    ...e
                })
            })
        }
        merge(e) {
            return new xt({
                unknownKeys: e._def.unknownKeys,
                catchall: e._def.catchall,
                shape: () => ({
                    ...this._def.shape(),
                    ...e._def.shape()
                }),
                typeName: Y.ZodObject
            })
        }
        setKey(e, t) {
            return this.augment({
                [e]: t
            })
        }
        catchall(e) {
            return new xt({
                ...this._def,
                catchall: e
            })
        }
        pick(e) {
            const t = {};
            return Ve.objectKeys(e).forEach(r => {
                e[r] && this.shape[r] && (t[r] = this.shape[r])
            }
            ),
            new xt({
                ...this._def,
                shape: () => t
            })
        }
        omit(e) {
            const t = {};
            return Ve.objectKeys(this.shape).forEach(r => {
                e[r] || (t[r] = this.shape[r])
            }
            ),
            new xt({
                ...this._def,
                shape: () => t
            })
        }
        deepPartial() {
            return Yc(this)
        }
        partial(e) {
            const t = {};
            return Ve.objectKeys(this.shape).forEach(r => {
                const s = this.shape[r];
                e && !e[r] ? t[r] = s : t[r] = s.optional()
            }
            ),
            new xt({
                ...this._def,
                shape: () => t
            })
        }
        required(e) {
            const t = {};
            return Ve.objectKeys(this.shape).forEach(r => {
                if (e && !e[r])
                    t[r] = this.shape[r];
                else {
                    let i = this.shape[r];
                    for (; i instanceof In; )
                        i = i._def.innerType;
                    t[r] = i
                }
            }
            ),
            new xt({
                ...this._def,
                shape: () => t
            })
        }
        keyof() {
            return iT(Ve.objectKeys(this.shape))
        }
    }
    xt.create = (n, e) => new xt({
        shape: () => n,
        unknownKeys: "strip",
        catchall: qs.create(),
        typeName: Y.ZodObject,
        ...Re(e)
    }),
    xt.strictCreate = (n, e) => new xt({
        shape: () => n,
        unknownKeys: "strict",
        catchall: qs.create(),
        typeName: Y.ZodObject,
        ...Re(e)
    }),
    xt.lazycreate = (n, e) => new xt({
        shape: n,
        unknownKeys: "strip",
        catchall: qs.create(),
        typeName: Y.ZodObject,
        ...Re(e)
    });
    class Jd extends $e {
        _parse(e) {
            const {ctx: t} = this._processInputParams(e)
              , r = this._def.options;
            function s(i) {
                for (const c of i)
                    if (c.result.status === "valid")
                        return c.result;
                for (const c of i)
                    if (c.result.status === "dirty")
                        return t.common.issues.push(...c.ctx.common.issues),
                        c.result;
                const a = i.map(c => new Zr(c.ctx.common.issues));
                return de(t, {
                    code: re.invalid_union,
                    unionErrors: a
                }),
                Ae
            }
            if (t.common.async)
                return Promise.all(r.map(async i => {
                    const a = {
                        ...t,
                        common: {
                            ...t.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await i._parseAsync({
                            data: t.data,
                            path: t.path,
                            parent: a
                        }),
                        ctx: a
                    }
                }
                )).then(s);
            {
                let i;
                const a = [];
                for (const u of r) {
                    const l = {
                        ...t,
                        common: {
                            ...t.common,
                            issues: []
                        },
                        parent: null
                    }
                      , d = u._parseSync({
                        data: t.data,
                        path: t.path,
                        parent: l
                    });
                    if (d.status === "valid")
                        return d;
                    d.status === "dirty" && !i && (i = {
                        result: d,
                        ctx: l
                    }),
                    l.common.issues.length && a.push(l.common.issues)
                }
                if (i)
                    return t.common.issues.push(...i.ctx.common.issues),
                    i.result;
                const c = a.map(u => new Zr(u));
                return de(t, {
                    code: re.invalid_union,
                    unionErrors: c
                }),
                Ae
            }
        }
        get options() {
            return this._def.options
        }
    }
    Jd.create = (n, e) => new Jd({
        options: n,
        typeName: Y.ZodUnion,
        ...Re(e)
    });
    const Us = n => n instanceof Yd ? Us(n.schema) : n instanceof An ? Us(n.innerType()) : n instanceof Qd ? [n.value] : n instanceof Mi ? n.options : n instanceof eh ? Ve.objectValues(n.enum) : n instanceof th ? Us(n._def.innerType) : n instanceof Vd ? [void 0] : n instanceof Gd ? [null] : n instanceof In ? [void 0, ...Us(n.unwrap())] : n instanceof Ni ? [null, ...Us(n.unwrap())] : n instanceof y_ || n instanceof sh ? Us(n.unwrap()) : n instanceof rh ? Us(n._def.innerType) : [];
    class Iy extends $e {
        _parse(e) {
            const {ctx: t} = this._processInputParams(e);
            if (t.parsedType !== he.object)
                return de(t, {
                    code: re.invalid_type,
                    expected: he.object,
                    received: t.parsedType
                }),
                Ae;
            const r = this.discriminator
              , s = t.data[r]
              , i = this.optionsMap.get(s);
            return i ? t.common.async ? i._parseAsync({
                data: t.data,
                path: t.path,
                parent: t
            }) : i._parseSync({
                data: t.data,
                path: t.path,
                parent: t
            }) : (de(t, {
                code: re.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [r]
            }),
            Ae)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get options() {
            return this._def.options
        }
        get optionsMap() {
            return this._def.optionsMap
        }
        static create(e, t, r) {
            const s = new Map;
            for (const i of t) {
                const a = Us(i.shape[e]);
                if (!a.length)
                    throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
                for (const c of a) {
                    if (s.has(c))
                        throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(c)}`);
                    s.set(c, i)
                }
            }
            return new Iy({
                typeName: Y.ZodDiscriminatedUnion,
                discriminator: e,
                options: t,
                optionsMap: s,
                ...Re(r)
            })
        }
    }
    function g_(n, e) {
        const t = Bs(n)
          , r = Bs(e);
        if (n === e)
            return {
                valid: !0,
                data: n
            };
        if (t === he.object && r === he.object) {
            const s = Ve.objectKeys(e)
              , i = Ve.objectKeys(n).filter(c => s.indexOf(c) !== -1)
              , a = {
                ...n,
                ...e
            };
            for (const c of i) {
                const u = g_(n[c], e[c]);
                if (!u.valid)
                    return {
                        valid: !1
                    };
                a[c] = u.data
            }
            return {
                valid: !0,
                data: a
            }
        } else if (t === he.array && r === he.array) {
            if (n.length !== e.length)
                return {
                    valid: !1
                };
            const s = [];
            for (let i = 0; i < n.length; i++) {
                const a = n[i]
                  , c = e[i]
                  , u = g_(a, c);
                if (!u.valid)
                    return {
                        valid: !1
                    };
                s.push(u.data)
            }
            return {
                valid: !0,
                data: s
            }
        } else
            return t === he.date && r === he.date && +n == +e ? {
                valid: !0,
                data: n
            } : {
                valid: !1
            }
    }
    class Zd extends $e {
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e)
              , s = (i, a) => {
                if (f_(i) || f_(a))
                    return Ae;
                const c = g_(i.value, a.value);
                return c.valid ? ((p_(i) || p_(a)) && t.dirty(),
                {
                    status: t.value,
                    value: c.data
                }) : (de(r, {
                    code: re.invalid_intersection_types
                }),
                Ae)
            }
            ;
            return r.common.async ? Promise.all([this._def.left._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }), this._def.right._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            })]).then( ([i,a]) => s(i, a)) : s(this._def.left._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            }), this._def.right._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            }))
        }
    }
    Zd.create = (n, e, t) => new Zd({
        left: n,
        right: e,
        typeName: Y.ZodIntersection,
        ...Re(t)
    });
    class ps extends $e {
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e);
            if (r.parsedType !== he.array)
                return de(r, {
                    code: re.invalid_type,
                    expected: he.array,
                    received: r.parsedType
                }),
                Ae;
            if (r.data.length < this._def.items.length)
                return de(r, {
                    code: re.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }),
                Ae;
            !this._def.rest && r.data.length > this._def.items.length && (de(r, {
                code: re.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            t.dirty());
            const i = [...r.data].map( (a, c) => {
                const u = this._def.items[c] || this._def.rest;
                return u ? u._parse(new fs(r,a,r.path,c)) : null
            }
            ).filter(a => !!a);
            return r.common.async ? Promise.all(i).then(a => lr.mergeArray(t, a)) : lr.mergeArray(t, i)
        }
        get items() {
            return this._def.items
        }
        rest(e) {
            return new ps({
                ...this._def,
                rest: e
            })
        }
    }
    ps.create = (n, e) => {
        if (!Array.isArray(n))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new ps({
            items: n,
            typeName: Y.ZodTuple,
            rest: null,
            ...Re(e)
        })
    }
    ;
    class Xd extends $e {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e);
            if (r.parsedType !== he.object)
                return de(r, {
                    code: re.invalid_type,
                    expected: he.object,
                    received: r.parsedType
                }),
                Ae;
            const s = []
              , i = this._def.keyType
              , a = this._def.valueType;
            for (const c in r.data)
                s.push({
                    key: i._parse(new fs(r,c,r.path,c)),
                    value: a._parse(new fs(r,r.data[c],r.path,c)),
                    alwaysSet: c in r.data
                });
            return r.common.async ? lr.mergeObjectAsync(t, s) : lr.mergeObjectSync(t, s)
        }
        get element() {
            return this._def.valueType
        }
        static create(e, t, r) {
            return t instanceof $e ? new Xd({
                keyType: e,
                valueType: t,
                typeName: Y.ZodRecord,
                ...Re(r)
            }) : new Xd({
                keyType: Pn.create(),
                valueType: e,
                typeName: Y.ZodRecord,
                ...Re(t)
            })
        }
    }
    class Oy extends $e {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e);
            if (r.parsedType !== he.map)
                return de(r, {
                    code: re.invalid_type,
                    expected: he.map,
                    received: r.parsedType
                }),
                Ae;
            const s = this._def.keyType
              , i = this._def.valueType
              , a = [...r.data.entries()].map( ([c,u], l) => ({
                key: s._parse(new fs(r,c,r.path,[l, "key"])),
                value: i._parse(new fs(r,u,r.path,[l, "value"]))
            }));
            if (r.common.async) {
                const c = new Map;
                return Promise.resolve().then(async () => {
                    for (const u of a) {
                        const l = await u.key
                          , d = await u.value;
                        if (l.status === "aborted" || d.status === "aborted")
                            return Ae;
                        (l.status === "dirty" || d.status === "dirty") && t.dirty(),
                        c.set(l.value, d.value)
                    }
                    return {
                        status: t.value,
                        value: c
                    }
                }
                )
            } else {
                const c = new Map;
                for (const u of a) {
                    const l = u.key
                      , d = u.value;
                    if (l.status === "aborted" || d.status === "aborted")
                        return Ae;
                    (l.status === "dirty" || d.status === "dirty") && t.dirty(),
                    c.set(l.value, d.value)
                }
                return {
                    status: t.value,
                    value: c
                }
            }
        }
    }
    Oy.create = (n, e, t) => new Oy({
        valueType: e,
        keyType: n,
        typeName: Y.ZodMap,
        ...Re(t)
    });
    class no extends $e {
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e);
            if (r.parsedType !== he.set)
                return de(r, {
                    code: re.invalid_type,
                    expected: he.set,
                    received: r.parsedType
                }),
                Ae;
            const s = this._def;
            s.minSize !== null && r.data.size < s.minSize.value && (de(r, {
                code: re.too_small,
                minimum: s.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: s.minSize.message
            }),
            t.dirty()),
            s.maxSize !== null && r.data.size > s.maxSize.value && (de(r, {
                code: re.too_big,
                maximum: s.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: s.maxSize.message
            }),
            t.dirty());
            const i = this._def.valueType;
            function a(u) {
                const l = new Set;
                for (const d of u) {
                    if (d.status === "aborted")
                        return Ae;
                    d.status === "dirty" && t.dirty(),
                    l.add(d.value)
                }
                return {
                    status: t.value,
                    value: l
                }
            }
            const c = [...r.data.values()].map( (u, l) => i._parse(new fs(r,u,r.path,l)));
            return r.common.async ? Promise.all(c).then(u => a(u)) : a(c)
        }
        min(e, t) {
            return new no({
                ...this._def,
                minSize: {
                    value: e,
                    message: ve.toString(t)
                }
            })
        }
        max(e, t) {
            return new no({
                ...this._def,
                maxSize: {
                    value: e,
                    message: ve.toString(t)
                }
            })
        }
        size(e, t) {
            return this.min(e, t).max(e, t)
        }
        nonempty(e) {
            return this.min(1, e)
        }
    }
    no.create = (n, e) => new no({
        valueType: n,
        minSize: null,
        maxSize: null,
        typeName: Y.ZodSet,
        ...Re(e)
    });
    class Qc extends $e {
        constructor() {
            super(...arguments),
            this.validate = this.implement
        }
        _parse(e) {
            const {ctx: t} = this._processInputParams(e);
            if (t.parsedType !== he.function)
                return de(t, {
                    code: re.invalid_type,
                    expected: he.function,
                    received: t.parsedType
                }),
                Ae;
            function r(c, u) {
                return ky({
                    data: c,
                    path: t.path,
                    errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Cy(), Jc].filter(l => !!l),
                    issueData: {
                        code: re.invalid_arguments,
                        argumentsError: u
                    }
                })
            }
            function s(c, u) {
                return ky({
                    data: c,
                    path: t.path,
                    errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Cy(), Jc].filter(l => !!l),
                    issueData: {
                        code: re.invalid_return_type,
                        returnTypeError: u
                    }
                })
            }
            const i = {
                errorMap: t.common.contextualErrorMap
            }
              , a = t.data;
            if (this._def.returns instanceof eu) {
                const c = this;
                return br(async function(...u) {
                    const l = new Zr([])
                      , d = await c._def.args.parseAsync(u, i).catch(p => {
                        throw l.addIssue(r(u, p)),
                        l
                    }
                    )
                      , h = await Reflect.apply(a, this, d);
                    return await c._def.returns._def.type.parseAsync(h, i).catch(p => {
                        throw l.addIssue(s(h, p)),
                        l
                    }
                    )
                })
            } else {
                const c = this;
                return br(function(...u) {
                    const l = c._def.args.safeParse(u, i);
                    if (!l.success)
                        throw new Zr([r(u, l.error)]);
                    const d = Reflect.apply(a, this, l.data)
                      , h = c._def.returns.safeParse(d, i);
                    if (!h.success)
                        throw new Zr([s(d, h.error)]);
                    return h.data
                })
            }
        }
        parameters() {
            return this._def.args
        }
        returnType() {
            return this._def.returns
        }
        args(...e) {
            return new Qc({
                ...this._def,
                args: ps.create(e).rest(ro.create())
            })
        }
        returns(e) {
            return new Qc({
                ...this._def,
                returns: e
            })
        }
        implement(e) {
            return this.parse(e)
        }
        strictImplement(e) {
            return this.parse(e)
        }
        static create(e, t, r) {
            return new Qc({
                args: e || ps.create([]).rest(ro.create()),
                returns: t || ro.create(),
                typeName: Y.ZodFunction,
                ...Re(r)
            })
        }
    }
    class Yd extends $e {
        get schema() {
            return this._def.getter()
        }
        _parse(e) {
            const {ctx: t} = this._processInputParams(e);
            return this._def.getter()._parse({
                data: t.data,
                path: t.path,
                parent: t
            })
        }
    }
    Yd.create = (n, e) => new Yd({
        getter: n,
        typeName: Y.ZodLazy,
        ...Re(e)
    });
    class Qd extends $e {
        _parse(e) {
            if (e.data !== this._def.value) {
                const t = this._getOrReturnCtx(e);
                return de(t, {
                    received: t.data,
                    code: re.invalid_literal,
                    expected: this._def.value
                }),
                Ae
            }
            return {
                status: "valid",
                value: e.data
            }
        }
        get value() {
            return this._def.value
        }
    }
    Qd.create = (n, e) => new Qd({
        value: n,
        typeName: Y.ZodLiteral,
        ...Re(e)
    });
    function iT(n, e) {
        return new Mi({
            values: n,
            typeName: Y.ZodEnum,
            ...Re(e)
        })
    }
    class Mi extends $e {
        constructor() {
            super(...arguments),
            Hd.set(this, void 0)
        }
        _parse(e) {
            if (typeof e.data != "string") {
                const t = this._getOrReturnCtx(e)
                  , r = this._def.values;
                return de(t, {
                    expected: Ve.joinValues(r),
                    received: t.parsedType,
                    code: re.invalid_type
                }),
                Ae
            }
            if (Py(this, Hd) || eT(this, Hd, new Set(this._def.values)),
            !Py(this, Hd).has(e.data)) {
                const t = this._getOrReturnCtx(e)
                  , r = this._def.values;
                return de(t, {
                    received: t.data,
                    code: re.invalid_enum_value,
                    options: r
                }),
                Ae
            }
            return br(e.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            const e = {};
            for (const t of this._def.values)
                e[t] = t;
            return e
        }
        get Values() {
            const e = {};
            for (const t of this._def.values)
                e[t] = t;
            return e
        }
        get Enum() {
            const e = {};
            for (const t of this._def.values)
                e[t] = t;
            return e
        }
        extract(e, t=this._def) {
            return Mi.create(e, {
                ...this._def,
                ...t
            })
        }
        exclude(e, t=this._def) {
            return Mi.create(this.options.filter(r => !e.includes(r)), {
                ...this._def,
                ...t
            })
        }
    }
    Hd = new WeakMap,
    Mi.create = iT;
    class eh extends $e {
        constructor() {
            super(...arguments),
            Wd.set(this, void 0)
        }
        _parse(e) {
            const t = Ve.getValidEnumValues(this._def.values)
              , r = this._getOrReturnCtx(e);
            if (r.parsedType !== he.string && r.parsedType !== he.number) {
                const s = Ve.objectValues(t);
                return de(r, {
                    expected: Ve.joinValues(s),
                    received: r.parsedType,
                    code: re.invalid_type
                }),
                Ae
            }
            if (Py(this, Wd) || eT(this, Wd, new Set(Ve.getValidEnumValues(this._def.values))),
            !Py(this, Wd).has(e.data)) {
                const s = Ve.objectValues(t);
                return de(r, {
                    received: r.data,
                    code: re.invalid_enum_value,
                    options: s
                }),
                Ae
            }
            return br(e.data)
        }
        get enum() {
            return this._def.values
        }
    }
    Wd = new WeakMap,
    eh.create = (n, e) => new eh({
        values: n,
        typeName: Y.ZodNativeEnum,
        ...Re(e)
    });
    class eu extends $e {
        unwrap() {
            return this._def.type
        }
        _parse(e) {
            const {ctx: t} = this._processInputParams(e);
            if (t.parsedType !== he.promise && t.common.async === !1)
                return de(t, {
                    code: re.invalid_type,
                    expected: he.promise,
                    received: t.parsedType
                }),
                Ae;
            const r = t.parsedType === he.promise ? t.data : Promise.resolve(t.data);
            return br(r.then(s => this._def.type.parseAsync(s, {
                path: t.path,
                errorMap: t.common.contextualErrorMap
            })))
        }
    }
    eu.create = (n, e) => new eu({
        type: n,
        typeName: Y.ZodPromise,
        ...Re(e)
    });
    class An extends $e {
        innerType() {
            return this._def.schema
        }
        sourceType() {
            return this._def.schema._def.typeName === Y.ZodEffects ? this._def.schema.sourceType() : this._def.schema
        }
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e)
              , s = this._def.effect || null
              , i = {
                addIssue: a => {
                    de(r, a),
                    a.fatal ? t.abort() : t.dirty()
                }
                ,
                get path() {
                    return r.path
                }
            };
            if (i.addIssue = i.addIssue.bind(i),
            s.type === "preprocess") {
                const a = s.transform(r.data, i);
                if (r.common.async)
                    return Promise.resolve(a).then(async c => {
                        if (t.value === "aborted")
                            return Ae;
                        const u = await this._def.schema._parseAsync({
                            data: c,
                            path: r.path,
                            parent: r
                        });
                        return u.status === "aborted" ? Ae : u.status === "dirty" || t.value === "dirty" ? Zc(u.value) : u
                    }
                    );
                {
                    if (t.value === "aborted")
                        return Ae;
                    const c = this._def.schema._parseSync({
                        data: a,
                        path: r.path,
                        parent: r
                    });
                    return c.status === "aborted" ? Ae : c.status === "dirty" || t.value === "dirty" ? Zc(c.value) : c
                }
            }
            if (s.type === "refinement") {
                const a = c => {
                    const u = s.refinement(c, i);
                    if (r.common.async)
                        return Promise.resolve(u);
                    if (u instanceof Promise)
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return c
                }
                ;
                if (r.common.async === !1) {
                    const c = this._def.schema._parseSync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    });
                    return c.status === "aborted" ? Ae : (c.status === "dirty" && t.dirty(),
                    a(c.value),
                    {
                        status: t.value,
                        value: c.value
                    })
                } else
                    return this._def.schema._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    }).then(c => c.status === "aborted" ? Ae : (c.status === "dirty" && t.dirty(),
                    a(c.value).then( () => ({
                        status: t.value,
                        value: c.value
                    }))))
            }
            if (s.type === "transform")
                if (r.common.async === !1) {
                    const a = this._def.schema._parseSync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    });
                    if (!eo(a))
                        return a;
                    const c = s.transform(a.value, i);
                    if (c instanceof Promise)
                        throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: t.value,
                        value: c
                    }
                } else
                    return this._def.schema._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    }).then(a => eo(a) ? Promise.resolve(s.transform(a.value, i)).then(c => ({
                        status: t.value,
                        value: c
                    })) : a);
            Ve.assertNever(s)
        }
    }
    An.create = (n, e, t) => new An({
        schema: n,
        typeName: Y.ZodEffects,
        effect: e,
        ...Re(t)
    }),
    An.createWithPreprocess = (n, e, t) => new An({
        schema: e,
        effect: {
            type: "preprocess",
            transform: n
        },
        typeName: Y.ZodEffects,
        ...Re(t)
    });
    class In extends $e {
        _parse(e) {
            return this._getType(e) === he.undefined ? br(void 0) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    In.create = (n, e) => new In({
        innerType: n,
        typeName: Y.ZodOptional,
        ...Re(e)
    });
    class Ni extends $e {
        _parse(e) {
            return this._getType(e) === he.null ? br(null) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    Ni.create = (n, e) => new Ni({
        innerType: n,
        typeName: Y.ZodNullable,
        ...Re(e)
    });
    class th extends $e {
        _parse(e) {
            const {ctx: t} = this._processInputParams(e);
            let r = t.data;
            return t.parsedType === he.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({
                data: r,
                path: t.path,
                parent: t
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    }
    th.create = (n, e) => new th({
        innerType: n,
        typeName: Y.ZodDefault,
        defaultValue: typeof e.default == "function" ? e.default : () => e.default,
        ...Re(e)
    });
    class rh extends $e {
        _parse(e) {
            const {ctx: t} = this._processInputParams(e)
              , r = {
                ...t,
                common: {
                    ...t.common,
                    issues: []
                }
            }
              , s = this._def.innerType._parse({
                data: r.data,
                path: r.path,
                parent: {
                    ...r
                }
            });
            return Kd(s) ? s.then(i => ({
                status: "valid",
                value: i.status === "valid" ? i.value : this._def.catchValue({
                    get error() {
                        return new Zr(r.common.issues)
                    },
                    input: r.data
                })
            })) : {
                status: "valid",
                value: s.status === "valid" ? s.value : this._def.catchValue({
                    get error() {
                        return new Zr(r.common.issues)
                    },
                    input: r.data
                })
            }
        }
        removeCatch() {
            return this._def.innerType
        }
    }
    rh.create = (n, e) => new rh({
        innerType: n,
        typeName: Y.ZodCatch,
        catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
        ...Re(e)
    });
    class Ry extends $e {
        _parse(e) {
            if (this._getType(e) !== he.nan) {
                const r = this._getOrReturnCtx(e);
                return de(r, {
                    code: re.invalid_type,
                    expected: he.nan,
                    received: r.parsedType
                }),
                Ae
            }
            return {
                status: "valid",
                value: e.data
            }
        }
    }
    Ry.create = n => new Ry({
        typeName: Y.ZodNaN,
        ...Re(n)
    });
    const tU = Symbol("zod_brand");
    class y_ extends $e {
        _parse(e) {
            const {ctx: t} = this._processInputParams(e)
              , r = t.data;
            return this._def.type._parse({
                data: r,
                path: t.path,
                parent: t
            })
        }
        unwrap() {
            return this._def.type
        }
    }
    class nh extends $e {
        _parse(e) {
            const {status: t, ctx: r} = this._processInputParams(e);
            if (r.common.async)
                return (async () => {
                    const i = await this._def.in._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: r
                    });
                    return i.status === "aborted" ? Ae : i.status === "dirty" ? (t.dirty(),
                    Zc(i.value)) : this._def.out._parseAsync({
                        data: i.value,
                        path: r.path,
                        parent: r
                    })
                }
                )();
            {
                const s = this._def.in._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return s.status === "aborted" ? Ae : s.status === "dirty" ? (t.dirty(),
                {
                    status: "dirty",
                    value: s.value
                }) : this._def.out._parseSync({
                    data: s.value,
                    path: r.path,
                    parent: r
                })
            }
        }
        static create(e, t) {
            return new nh({
                in: e,
                out: t,
                typeName: Y.ZodPipeline
            })
        }
    }
    class sh extends $e {
        _parse(e) {
            const t = this._def.innerType._parse(e)
              , r = s => (eo(s) && (s.value = Object.freeze(s.value)),
            s);
            return Kd(t) ? t.then(s => r(s)) : r(t)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    sh.create = (n, e) => new sh({
        innerType: n,
        typeName: Y.ZodReadonly,
        ...Re(e)
    });
    function aT(n, e={}, t) {
        return n ? Xc.create().superRefine( (r, s) => {
            var i, a;
            if (!n(r)) {
                const c = typeof e == "function" ? e(r) : typeof e == "string" ? {
                    message: e
                } : e
                  , u = (a = (i = c.fatal) !== null && i !== void 0 ? i : t) !== null && a !== void 0 ? a : !0
                  , l = typeof c == "string" ? {
                    message: c
                } : c;
                s.addIssue({
                    code: "custom",
                    ...l,
                    fatal: u
                })
            }
        }
        ) : Xc.create()
    }
    const rU = {
        object: xt.lazycreate
    };
    var Y;
    (function(n) {
        n.ZodString = "ZodString",
        n.ZodNumber = "ZodNumber",
        n.ZodNaN = "ZodNaN",
        n.ZodBigInt = "ZodBigInt",
        n.ZodBoolean = "ZodBoolean",
        n.ZodDate = "ZodDate",
        n.ZodSymbol = "ZodSymbol",
        n.ZodUndefined = "ZodUndefined",
        n.ZodNull = "ZodNull",
        n.ZodAny = "ZodAny",
        n.ZodUnknown = "ZodUnknown",
        n.ZodNever = "ZodNever",
        n.ZodVoid = "ZodVoid",
        n.ZodArray = "ZodArray",
        n.ZodObject = "ZodObject",
        n.ZodUnion = "ZodUnion",
        n.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        n.ZodIntersection = "ZodIntersection",
        n.ZodTuple = "ZodTuple",
        n.ZodRecord = "ZodRecord",
        n.ZodMap = "ZodMap",
        n.ZodSet = "ZodSet",
        n.ZodFunction = "ZodFunction",
        n.ZodLazy = "ZodLazy",
        n.ZodLiteral = "ZodLiteral",
        n.ZodEnum = "ZodEnum",
        n.ZodEffects = "ZodEffects",
        n.ZodNativeEnum = "ZodNativeEnum",
        n.ZodOptional = "ZodOptional",
        n.ZodNullable = "ZodNullable",
        n.ZodDefault = "ZodDefault",
        n.ZodCatch = "ZodCatch",
        n.ZodPromise = "ZodPromise",
        n.ZodBranded = "ZodBranded",
        n.ZodPipeline = "ZodPipeline",
        n.ZodReadonly = "ZodReadonly"
    }
    )(Y || (Y = {}));
    const nU = (n, e={
        message: `Input not instance of ${n.name}`
    }) => aT(t => t instanceof n, e)
      , oT = Pn.create
      , cT = Oi.create
      , sU = Ry.create
      , iU = Ri.create
      , uT = zd.create
      , aU = to.create
      , oU = Ty.create
      , cU = Vd.create
      , uU = Gd.create
      , lU = Xc.create
      , dU = ro.create
      , hU = qs.create
      , fU = Ay.create
      , pU = Tn.create
      , mU = xt.create
      , gU = xt.strictCreate
      , yU = Jd.create
      , wU = Iy.create
      , bU = Zd.create
      , vU = ps.create
      , _U = Xd.create
      , SU = Oy.create
      , EU = no.create
      , xU = Qc.create
      , CU = Yd.create
      , kU = Qd.create
      , PU = Mi.create
      , TU = eh.create
      , AU = eu.create
      , lT = An.create
      , IU = In.create
      , OU = Ni.create
      , RU = An.createWithPreprocess
      , MU = nh.create;
    var fe = Object.freeze({
        __proto__: null,
        defaultErrorMap: Jc,
        setErrorMap: Rq,
        getErrorMap: Cy,
        makeIssue: ky,
        EMPTY_PATH: Mq,
        addIssueToContext: de,
        ParseStatus: lr,
        INVALID: Ae,
        DIRTY: Zc,
        OK: br,
        isAborted: f_,
        isDirty: p_,
        isValid: eo,
        isAsync: Kd,
        get util() {
            return Ve
        },
        get objectUtil() {
            return h_
        },
        ZodParsedType: he,
        getParsedType: Bs,
        ZodType: $e,
        datetimeRegex: sT,
        ZodString: Pn,
        ZodNumber: Oi,
        ZodBigInt: Ri,
        ZodBoolean: zd,
        ZodDate: to,
        ZodSymbol: Ty,
        ZodUndefined: Vd,
        ZodNull: Gd,
        ZodAny: Xc,
        ZodUnknown: ro,
        ZodNever: qs,
        ZodVoid: Ay,
        ZodArray: Tn,
        ZodObject: xt,
        ZodUnion: Jd,
        ZodDiscriminatedUnion: Iy,
        ZodIntersection: Zd,
        ZodTuple: ps,
        ZodRecord: Xd,
        ZodMap: Oy,
        ZodSet: no,
        ZodFunction: Qc,
        ZodLazy: Yd,
        ZodLiteral: Qd,
        ZodEnum: Mi,
        ZodNativeEnum: eh,
        ZodPromise: eu,
        ZodEffects: An,
        ZodTransformer: An,
        ZodOptional: In,
        ZodNullable: Ni,
        ZodDefault: th,
        ZodCatch: rh,
        ZodNaN: Ry,
        BRAND: tU,
        ZodBranded: y_,
        ZodPipeline: nh,
        ZodReadonly: sh,
        custom: aT,
        Schema: $e,
        ZodSchema: $e,
        late: rU,
        get ZodFirstPartyTypeKind() {
            return Y
        },
        coerce: {
            string: n => Pn.create({
                ...n,
                coerce: !0
            }),
            number: n => Oi.create({
                ...n,
                coerce: !0
            }),
            boolean: n => zd.create({
                ...n,
                coerce: !0
            }),
            bigint: n => Ri.create({
                ...n,
                coerce: !0
            }),
            date: n => to.create({
                ...n,
                coerce: !0
            })
        },
        any: lU,
        array: pU,
        bigint: iU,
        boolean: uT,
        date: aU,
        discriminatedUnion: wU,
        effect: lT,
        enum: PU,
        function: xU,
        instanceof: nU,
        intersection: bU,
        lazy: CU,
        literal: kU,
        map: SU,
        nan: sU,
        nativeEnum: TU,
        never: hU,
        null: uU,
        nullable: OU,
        number: cT,
        object: mU,
        oboolean: () => uT().optional(),
        onumber: () => cT().optional(),
        optional: IU,
        ostring: () => oT().optional(),
        pipeline: MU,
        preprocess: RU,
        promise: AU,
        record: _U,
        set: EU,
        strictObject: gU,
        string: oT,
        symbol: oU,
        transformer: lT,
        tuple: vU,
        undefined: cU,
        union: yU,
        unknown: dU,
        void: fU,
        NEVER: Ae,
        ZodIssueCode: re,
        quotelessJson: Oq,
        ZodError: Zr
    })
      , Ie = (n => (n.SYSTEM = "system",
    n.USER = "user",
    n.PLANNER = "planner",
    n.NAVIGATOR = "navigator",
    n.VALIDATOR = "validator",
    n))(Ie || {})
      , w_ = (n => (n.EXECUTION = "execution",
    n))(w_ || {})
      , ke = (n => (n.TASK_START = "task.start",
    n.TASK_OK = "task.ok",
    n.TASK_FAIL = "task.fail",
    n.TASK_PAUSE = "task.pause",
    n.TASK_RESUME = "task.resume",
    n.TASK_CANCEL = "task.cancel",
    n.STEP_START = "step.start",
    n.STEP_OK = "step.ok",
    n.STEP_FAIL = "step.fail",
    n.STEP_CANCEL = "step.cancel",
    n.ACT_START = "act.start",
    n.ACT_OK = "act.ok",
    n.ACT_FAIL = "act.fail",
    n))(ke || {});
    class NU {
        constructor(e, t, r, s=Date.now(), i="execution") {
            this.actor = e,
            this.state = t,
            this.data = r,
            this.timestamp = s,
            this.type = i
        }
    }
    const $U = {
        maxSteps: 100,
        maxActionsPerStep: 10,
        maxFailures: 3,
        retryDelay: 10,
        maxInputTokens: 128e3,
        maxErrorLength: 400,
        useVision: !1,
        useVisionForPlanner: !1,
        validateOutput: !0,
        includeAttributes: ["title", "type", "name", "role", "tabindex", "aria-label", "placeholder", "value", "alt", "aria-expanded"],
        planningInterval: 3
    };
    class LU {
        constructor(e, t, r, s, i) {
            this.taskId = e,
            this.browserContext = t,
            this.messageManager = r,
            this.eventManager = s,
            this.options = {
                ...$U,
                ...i
            },
            this.paused = !1,
            this.stopped = !1,
            this.nSteps = 0,
            this.consecutiveFailures = 0,
            this.stepInfo = null,
            this.actionResults = [],
            this.stateMessageAdded = !1
        }
        async emitEvent(e, t, r) {
            const s = new NU(e,t,{
                taskId: this.taskId,
                step: this.nSteps,
                maxSteps: this.options.maxSteps,
                details: r
            });
            await this.eventManager.emit(s)
        }
        async pause() {
            this.paused = !0
        }
        async resume() {
            this.paused = !1
        }
        async stop() {
            this.stopped = !0
        }
    }
    class Tt {
        constructor(e={}) {
            this.isDone = e.isDone ?? !1,
            this.extractedContent = e.extractedContent ?? null,
            this.error = e.error ?? null,
            this.includeInMemory = e.includeInMemory ?? !1
        }
    }
    const FU = fe.object({
        page_summary: fe.string(),
        evaluation_previous_goal: fe.string(),
        memory: fe.string(),
        next_goal: fe.string()
    });
    function dT(n, e=b_) {
        n = n.trim();
        const t = /```(json)?(.*)```/s.exec(n);
        return e(t ? t[2] : n)
    }
    function b_(n) {
        if (typeof n > "u")
            return null;
        try {
            return JSON.parse(n)
        } catch {}
        let e = "";
        const t = [];
        let r = !1
          , s = !1;
        for (let i of n) {
            if (r)
                i === '"' && !s ? r = !1 : i === `
` && !s ? i = "\\n" : i === "\\" ? s = !s : s = !1;
            else if (i === '"')
                r = !0,
                s = !1;
            else if (i === "{")
                t.push("}");
            else if (i === "[")
                t.push("]");
            else if (i === "}" || i === "]")
                if (t && t[t.length - 1] === i)
                    t.pop();
                else
                    return null;
            e += i
        }
        r && (e += '"');
        for (let i = t.length - 1; i >= 0; i -= 1)
            e += t[i];
        try {
            return JSON.parse(e)
        } catch {
            return null
        }
    }
    var v_, hT;
    function jU() {
        return hT || (hT = 1,
        v_ = function(n, e) {
            if (typeof n != "string")
                throw new TypeError("Expected a string");
            return e = typeof e > "u" ? "_" : e,
            n.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase()
        }
        ),
        v_
    }
    var DU = jU();
    const BU = De(DU);
    var My = {
        exports: {}
    }, fT;
    function qU() {
        if (fT)
            return My.exports;
        fT = 1;
        const n = /[\p{Lu}]/u
          , e = /[\p{Ll}]/u
          , t = /^[\p{Lu}](?![\p{Lu}])/gu
          , r = /([\p{Alpha}\p{N}_]|$)/u
          , s = /[_.\- ]+/
          , i = new RegExp("^" + s.source)
          , a = new RegExp(s.source + r.source,"gu")
          , c = new RegExp("\\d+" + r.source,"gu")
          , u = (f, p, g) => {
            let y = !1
              , m = !1
              , w = !1;
            for (let E = 0; E < f.length; E++) {
                const v = f[E];
                y && n.test(v) ? (f = f.slice(0, E) + "-" + f.slice(E),
                y = !1,
                w = m,
                m = !0,
                E++) : m && w && e.test(v) ? (f = f.slice(0, E - 1) + "-" + f.slice(E - 1),
                w = m,
                m = !1,
                y = !0) : (y = p(v) === v && g(v) !== v,
                w = m,
                m = g(v) === v && p(v) !== v)
            }
            return f
        }
          , l = (f, p) => (t.lastIndex = 0,
        f.replace(t, g => p(g)))
          , d = (f, p) => (a.lastIndex = 0,
        c.lastIndex = 0,
        f.replace(a, (g, y) => p(y)).replace(c, g => p(g)))
          , h = (f, p) => {
            if (!(typeof f == "string" || Array.isArray(f)))
                throw new TypeError("Expected the input to be `string | string[]`");
            if (p = {
                pascalCase: !1,
                preserveConsecutiveUppercase: !1,
                ...p
            },
            Array.isArray(f) ? f = f.map(w => w.trim()).filter(w => w.length).join("-") : f = f.trim(),
            f.length === 0)
                return "";
            const g = p.locale === !1 ? w => w.toLowerCase() : w => w.toLocaleLowerCase(p.locale)
              , y = p.locale === !1 ? w => w.toUpperCase() : w => w.toLocaleUpperCase(p.locale);
            return f.length === 1 ? p.pascalCase ? y(f) : g(f) : (f !== g(f) && (f = u(f, g, y)),
            f = f.replace(i, ""),
            p.preserveConsecutiveUppercase ? f = l(f, g) : f = g(f),
            p.pascalCase && (f = y(f.charAt(0)) + f.slice(1)),
            d(f, y))
        }
        ;
        return My.exports = h,
        My.exports.default = h,
        My.exports
    }
    qU();
    function UU(n, e) {
        return (e == null ? void 0 : e[n]) || BU(n)
    }
    function KU(n, e, t) {
        const r = {};
        for (const s in n)
            Object.hasOwn(n, s) && (r[e(s, t)] = n[s]);
        return r
    }
    function pT(n) {
        return Array.isArray(n) ? [...n] : {
            ...n
        }
    }
    function HU(n, e) {
        const t = pT(n);
        for (const [r,s] of Object.entries(e)) {
            const [i,...a] = r.split(".").reverse();
            let c = t;
            for (const u of a.reverse()) {
                if (c[u] === void 0)
                    break;
                c[u] = pT(c[u]),
                c = c[u]
            }
            c[i] !== void 0 && (c[i] = {
                lc: 1,
                type: "secret",
                id: [s]
            })
        }
        return t
    }
    function mT(n) {
        const e = Object.getPrototypeOf(n);
        return typeof n.lc_name == "function" && (typeof e.lc_name != "function" || n.lc_name() !== e.lc_name()) ? n.lc_name() : n.name
    }
    class so {
        static lc_name() {
            return this.name
        }
        get lc_id() {
            return [...this.lc_namespace, mT(this.constructor)]
        }
        get lc_secrets() {}
        get lc_attributes() {}
        get lc_aliases() {}
        constructor(e, ...t) {
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "lc_kwargs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.lc_kwargs = e || {}
        }
        toJSON() {
            if (!this.lc_serializable)
                return this.toJSONNotImplemented();
            if (this.lc_kwargs instanceof so || typeof this.lc_kwargs != "object" || Array.isArray(this.lc_kwargs))
                return this.toJSONNotImplemented();
            const e = {}
              , t = {}
              , r = Object.keys(this.lc_kwargs).reduce( (s, i) => (s[i] = i in this ? this[i] : this.lc_kwargs[i],
            s), {});
            for (let s = Object.getPrototypeOf(this); s; s = Object.getPrototypeOf(s))
                Object.assign(e, Reflect.get(s, "lc_aliases", this)),
                Object.assign(t, Reflect.get(s, "lc_secrets", this)),
                Object.assign(r, Reflect.get(s, "lc_attributes", this));
            return Object.keys(t).forEach(s => {
                let i = this
                  , a = r;
                const [c,...u] = s.split(".").reverse();
                for (const l of u.reverse()) {
                    if (!(l in i) || i[l] === void 0)
                        return;
                    (!(l in a) || a[l] === void 0) && (typeof i[l] == "object" && i[l] != null ? a[l] = {} : Array.isArray(i[l]) && (a[l] = [])),
                    i = i[l],
                    a = a[l]
                }
                c in i && i[c] !== void 0 && (a[c] = a[c] || i[c])
            }
            ),
            {
                lc: 1,
                type: "constructor",
                id: this.lc_id,
                kwargs: KU(Object.keys(t).length ? HU(r, t) : r, UU, e)
            }
        }
        toJSONNotImplemented() {
            return {
                lc: 1,
                type: "not_implemented",
                id: this.lc_id
            }
        }
    }
    function tu(n, e) {
        return typeof n == "string" ? typeof e == "string" ? n + e : [{
            type: "text",
            text: n
        }, ...e] : Array.isArray(e) ? Ny(n, e) ?? [...n, ...e] : [...n, {
            type: "text",
            text: e
        }]
    }
    function WU(n, e) {
        return n === "error" || e === "error" ? "error" : "success"
    }
    function zU(n, e) {
        function t(r, s) {
            if (typeof r != "object" || r === null || r === void 0)
                return r;
            if (s >= e)
                return Array.isArray(r) ? "[Array]" : "[Object]";
            if (Array.isArray(r))
                return r.map(a => t(a, s + 1));
            const i = {};
            for (const a of Object.keys(r))
                i[a] = t(r[a], s + 1);
            return i
        }
        return JSON.stringify(t(n, 0), null, 2)
    }
    class ru extends so {
        get lc_aliases() {
            return {
                additional_kwargs: "additional_kwargs",
                response_metadata: "response_metadata"
            }
        }
        get text() {
            return typeof this.content == "string" ? this.content : ""
        }
        getType() {
            return this._getType()
        }
        constructor(e, t) {
            typeof e == "string" && (e = {
                content: e,
                additional_kwargs: t,
                response_metadata: {}
            }),
            e.additional_kwargs || (e.additional_kwargs = {}),
            e.response_metadata || (e.response_metadata = {}),
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "messages"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "content", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "additional_kwargs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "response_metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "id", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.name = e.name,
            this.content = e.content,
            this.additional_kwargs = e.additional_kwargs,
            this.response_metadata = e.response_metadata,
            this.id = e.id
        }
        toDict() {
            return {
                type: this._getType(),
                data: this.toJSON().kwargs
            }
        }
        static lc_name() {
            return "BaseMessage"
        }
        get _printableFields() {
            return {
                id: this.id,
                content: this.content,
                name: this.name,
                additional_kwargs: this.additional_kwargs,
                response_metadata: this.response_metadata
            }
        }
        _updateId(e) {
            this.id = e,
            this.lc_kwargs.id = e
        }
        get[Symbol.toStringTag]() {
            return this.constructor.lc_name()
        }
        [Symbol.for("nodejs.util.inspect.custom")](e) {
            if (e === null)
                return this;
            const t = zU(this._printableFields, Math.max(4, e));
            return `${this.constructor.lc_name()} ${t}`
        }
    }
    function vr(n, e) {
        const t = {
            ...n
        };
        for (const [r,s] of Object.entries(e))
            if (t[r] == null)
                t[r] = s;
            else {
                if (s == null)
                    continue;
                if (typeof t[r] != typeof s || Array.isArray(t[r]) !== Array.isArray(s))
                    throw new Error(`field[${r}] already exists in the message chunk, but with a different type.`);
                if (typeof t[r] == "string") {
                    if (r === "type")
                        continue;
                    t[r] += s
                } else if (typeof t[r] == "object" && !Array.isArray(t[r]))
                    t[r] = vr(t[r], s);
                else if (Array.isArray(t[r]))
                    t[r] = Ny(t[r], s);
                else {
                    if (t[r] === s)
                        continue;
                    console.warn(`field[${r}] already exists in this message chunk and value has unsupported type.`)
                }
            }
        return t
    }
    function Ny(n, e) {
        if (!(n === void 0 && e === void 0)) {
            if (n === void 0 || e === void 0)
                return n || e;
            {
                const t = [...n];
                for (const r of e)
                    if (typeof r == "object" && "index"in r && typeof r.index == "number") {
                        const s = t.findIndex(i => i.index === r.index);
                        s !== -1 ? t[s] = vr(t[s], r) : t.push(r)
                    } else {
                        if (typeof r == "object" && "text"in r && r.text === "")
                            continue;
                        t.push(r)
                    }
                return t
            }
        }
    }
    function VU(n, e) {
        if (!n && !e)
            throw new Error("Cannot merge two undefined objects.");
        if (!n || !e)
            return n || e;
        if (typeof n != typeof e)
            throw new Error(`Cannot merge objects of different types.
Left ${typeof n}
Right ${typeof e}`);
        if (typeof n == "string" && typeof e == "string")
            return n + e;
        if (Array.isArray(n) && Array.isArray(e))
            return Ny(n, e);
        if (typeof n == "object" && typeof e == "object")
            return vr(n, e);
        if (n === e)
            return n;
        throw new Error(`Can not merge objects of different types.
Left ${n}
Right ${e}`)
    }
    class nu extends ru {
    }
    function GU(n) {
        return typeof n.role == "string"
    }
    function ih(n) {
        return typeof (n == null ? void 0 : n._getType) == "function"
    }
    function JU(n) {
        return ih(n) && typeof n.concat == "function"
    }
    class $y extends ru {
        static lc_name() {
            return "ToolMessage"
        }
        get lc_aliases() {
            return {
                tool_call_id: "tool_call_id"
            }
        }
        constructor(e, t, r) {
            typeof e == "string" && (e = {
                content: e,
                name: r,
                tool_call_id: t
            }),
            super(e),
            Object.defineProperty(this, "lc_direct_tool_output", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "status", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tool_call_id", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "artifact", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.tool_call_id = e.tool_call_id,
            this.artifact = e.artifact,
            this.status = e.status
        }
        _getType() {
            return "tool"
        }
        static isInstance(e) {
            return e._getType() === "tool"
        }
        get _printableFields() {
            return {
                ...super._printableFields,
                tool_call_id: this.tool_call_id,
                artifact: this.artifact
            }
        }
    }
    class __ extends nu {
        constructor(e) {
            super(e),
            Object.defineProperty(this, "tool_call_id", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "status", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "artifact", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.tool_call_id = e.tool_call_id,
            this.artifact = e.artifact,
            this.status = e.status
        }
        static lc_name() {
            return "ToolMessageChunk"
        }
        _getType() {
            return "tool"
        }
        concat(e) {
            return new __({
                content: tu(this.content, e.content),
                additional_kwargs: vr(this.additional_kwargs, e.additional_kwargs),
                response_metadata: vr(this.response_metadata, e.response_metadata),
                artifact: VU(this.artifact, e.artifact),
                tool_call_id: this.tool_call_id,
                id: this.id ?? e.id,
                status: WU(this.status, e.status)
            })
        }
        get _printableFields() {
            return {
                ...super._printableFields,
                tool_call_id: this.tool_call_id,
                artifact: this.artifact
            }
        }
    }
    function ZU(n) {
        const e = []
          , t = [];
        for (const r of n)
            if (r.function) {
                const s = r.function.name;
                try {
                    const i = JSON.parse(r.function.arguments)
                      , a = {
                        name: s || "",
                        args: i || {},
                        id: r.id
                    };
                    e.push(a)
                } catch {
                    t.push({
                        name: s,
                        args: r.function.arguments,
                        id: r.id,
                        error: "Malformed args."
                    })
                }
            } else
                continue;
        return [e, t]
    }
    class pn extends ru {
        get lc_aliases() {
            return {
                ...super.lc_aliases,
                tool_calls: "tool_calls",
                invalid_tool_calls: "invalid_tool_calls"
            }
        }
        constructor(e, t) {
            var s;
            let r;
            if (typeof e == "string")
                r = {
                    content: e,
                    tool_calls: [],
                    invalid_tool_calls: [],
                    additional_kwargs: t ?? {}
                };
            else {
                r = e;
                const i = (s = r.additional_kwargs) == null ? void 0 : s.tool_calls
                  , a = r.tool_calls;
                i != null && i.length > 0 && (a === void 0 || a.length === 0) && console.warn(["New LangChain packages are available that more efficiently handle", `tool calling.

Please upgrade your packages to versions that set`, "message tool calls. e.g., `yarn add @langchain/anthropic`,", "yarn add @langchain/openai`, etc."].join(" "));
                try {
                    if (i != null && a === void 0) {
                        const [c,u] = ZU(i);
                        r.tool_calls = c ?? [],
                        r.invalid_tool_calls = u ?? []
                    } else
                        r.tool_calls = r.tool_calls ?? [],
                        r.invalid_tool_calls = r.invalid_tool_calls ?? []
                } catch {
                    r.tool_calls = [],
                    r.invalid_tool_calls = []
                }
            }
            super(r),
            Object.defineProperty(this, "tool_calls", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "invalid_tool_calls", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "usage_metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            typeof r != "string" && (this.tool_calls = r.tool_calls ?? this.tool_calls,
            this.invalid_tool_calls = r.invalid_tool_calls ?? this.invalid_tool_calls),
            this.usage_metadata = r.usage_metadata
        }
        static lc_name() {
            return "AIMessage"
        }
        _getType() {
            return "ai"
        }
        get _printableFields() {
            return {
                ...super._printableFields,
                tool_calls: this.tool_calls,
                invalid_tool_calls: this.invalid_tool_calls,
                usage_metadata: this.usage_metadata
            }
        }
    }
    function ah(n) {
        return n._getType() === "ai"
    }
    function gT(n) {
        return n._getType() === "ai"
    }
    class _r extends nu {
        constructor(e) {
            let t;
            if (typeof e == "string")
                t = {
                    content: e,
                    tool_calls: [],
                    invalid_tool_calls: [],
                    tool_call_chunks: []
                };
            else if (e.tool_call_chunks === void 0)
                t = {
                    ...e,
                    tool_calls: e.tool_calls ?? [],
                    invalid_tool_calls: [],
                    tool_call_chunks: [],
                    usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
                };
            else {
                const r = []
                  , s = [];
                for (const i of e.tool_call_chunks) {
                    let a = {};
                    try {
                        if (a = b_(i.args || "{}"),
                        a === null || typeof a != "object" || Array.isArray(a))
                            throw new Error("Malformed tool call chunk args.");
                        r.push({
                            name: i.name ?? "",
                            args: a,
                            id: i.id,
                            type: "tool_call"
                        })
                    } catch {
                        s.push({
                            name: i.name,
                            args: i.args,
                            id: i.id,
                            error: "Malformed args.",
                            type: "invalid_tool_call"
                        })
                    }
                }
                t = {
                    ...e,
                    tool_calls: r,
                    invalid_tool_calls: s,
                    usage_metadata: e.usage_metadata !== void 0 ? e.usage_metadata : void 0
                }
            }
            super(t),
            Object.defineProperty(this, "tool_calls", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "invalid_tool_calls", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "tool_call_chunks", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "usage_metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.tool_call_chunks = t.tool_call_chunks ?? this.tool_call_chunks,
            this.tool_calls = t.tool_calls ?? this.tool_calls,
            this.invalid_tool_calls = t.invalid_tool_calls ?? this.invalid_tool_calls,
            this.usage_metadata = t.usage_metadata
        }
        get lc_aliases() {
            return {
                ...super.lc_aliases,
                tool_calls: "tool_calls",
                invalid_tool_calls: "invalid_tool_calls",
                tool_call_chunks: "tool_call_chunks"
            }
        }
        static lc_name() {
            return "AIMessageChunk"
        }
        _getType() {
            return "ai"
        }
        get _printableFields() {
            return {
                ...super._printableFields,
                tool_calls: this.tool_calls,
                tool_call_chunks: this.tool_call_chunks,
                invalid_tool_calls: this.invalid_tool_calls,
                usage_metadata: this.usage_metadata
            }
        }
        concat(e) {
            var r, s, i, a, c, u, l, d, h, f, p, g, y, m, w, E, v, _, A, C, k, x, N, R, F, O, T, L, q, Z, j, $, B, D, z, G, ee, V, K, se;
            const t = {
                content: tu(this.content, e.content),
                additional_kwargs: vr(this.additional_kwargs, e.additional_kwargs),
                response_metadata: vr(this.response_metadata, e.response_metadata),
                tool_call_chunks: [],
                id: this.id ?? e.id
            };
            if (this.tool_call_chunks !== void 0 || e.tool_call_chunks !== void 0) {
                const ye = Ny(this.tool_call_chunks, e.tool_call_chunks);
                ye !== void 0 && ye.length > 0 && (t.tool_call_chunks = ye)
            }
            if (this.usage_metadata !== void 0 || e.usage_metadata !== void 0) {
                const ye = {
                    ...(((s = (r = this.usage_metadata) == null ? void 0 : r.input_token_details) == null ? void 0 : s.audio) !== void 0 || ((a = (i = e.usage_metadata) == null ? void 0 : i.input_token_details) == null ? void 0 : a.audio) !== void 0) && {
                        audio: (((u = (c = this.usage_metadata) == null ? void 0 : c.input_token_details) == null ? void 0 : u.audio) ?? 0) + (((d = (l = e.usage_metadata) == null ? void 0 : l.input_token_details) == null ? void 0 : d.audio) ?? 0)
                    },
                    ...(((f = (h = this.usage_metadata) == null ? void 0 : h.input_token_details) == null ? void 0 : f.cache_read) !== void 0 || ((g = (p = e.usage_metadata) == null ? void 0 : p.input_token_details) == null ? void 0 : g.cache_read) !== void 0) && {
                        cache_read: (((m = (y = this.usage_metadata) == null ? void 0 : y.input_token_details) == null ? void 0 : m.cache_read) ?? 0) + (((E = (w = e.usage_metadata) == null ? void 0 : w.input_token_details) == null ? void 0 : E.cache_read) ?? 0)
                    },
                    ...(((_ = (v = this.usage_metadata) == null ? void 0 : v.input_token_details) == null ? void 0 : _.cache_creation) !== void 0 || ((C = (A = e.usage_metadata) == null ? void 0 : A.input_token_details) == null ? void 0 : C.cache_creation) !== void 0) && {
                        cache_creation: (((x = (k = this.usage_metadata) == null ? void 0 : k.input_token_details) == null ? void 0 : x.cache_creation) ?? 0) + (((R = (N = e.usage_metadata) == null ? void 0 : N.input_token_details) == null ? void 0 : R.cache_creation) ?? 0)
                    }
                }
                  , ue = {
                    ...(((O = (F = this.usage_metadata) == null ? void 0 : F.output_token_details) == null ? void 0 : O.audio) !== void 0 || ((L = (T = e.usage_metadata) == null ? void 0 : T.output_token_details) == null ? void 0 : L.audio) !== void 0) && {
                        audio: (((Z = (q = this.usage_metadata) == null ? void 0 : q.output_token_details) == null ? void 0 : Z.audio) ?? 0) + ((($ = (j = e.usage_metadata) == null ? void 0 : j.output_token_details) == null ? void 0 : $.audio) ?? 0)
                    },
                    ...(((D = (B = this.usage_metadata) == null ? void 0 : B.output_token_details) == null ? void 0 : D.reasoning) !== void 0 || ((G = (z = e.usage_metadata) == null ? void 0 : z.output_token_details) == null ? void 0 : G.reasoning) !== void 0) && {
                        reasoning: (((V = (ee = this.usage_metadata) == null ? void 0 : ee.output_token_details) == null ? void 0 : V.reasoning) ?? 0) + (((se = (K = e.usage_metadata) == null ? void 0 : K.output_token_details) == null ? void 0 : se.reasoning) ?? 0)
                    }
                }
                  , He = this.usage_metadata ?? {
                    input_tokens: 0,
                    output_tokens: 0,
                    total_tokens: 0
                }
                  , pe = e.usage_metadata ?? {
                    input_tokens: 0,
                    output_tokens: 0,
                    total_tokens: 0
                }
                  , I = {
                    input_tokens: He.input_tokens + pe.input_tokens,
                    output_tokens: He.output_tokens + pe.output_tokens,
                    total_tokens: He.total_tokens + pe.total_tokens,
                    ...Object.keys(ye).length > 0 && {
                        input_token_details: ye
                    },
                    ...Object.keys(ue).length > 0 && {
                        output_token_details: ue
                    }
                };
                t.usage_metadata = I
            }
            return new _r(t)
        }
    }
    class su extends ru {
        static lc_name() {
            return "ChatMessage"
        }
        static _chatMessageClass() {
            return su
        }
        constructor(e, t) {
            typeof e == "string" && (e = {
                content: e,
                role: t
            }),
            super(e),
            Object.defineProperty(this, "role", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.role = e.role
        }
        _getType() {
            return "generic"
        }
        static isInstance(e) {
            return e._getType() === "generic"
        }
        get _printableFields() {
            return {
                ...super._printableFields,
                role: this.role
            }
        }
    }
    class Ly extends nu {
        static lc_name() {
            return "ChatMessageChunk"
        }
        constructor(e, t) {
            typeof e == "string" && (e = {
                content: e,
                role: t
            }),
            super(e),
            Object.defineProperty(this, "role", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.role = e.role
        }
        _getType() {
            return "generic"
        }
        concat(e) {
            return new Ly({
                content: tu(this.content, e.content),
                additional_kwargs: vr(this.additional_kwargs, e.additional_kwargs),
                response_metadata: vr(this.response_metadata, e.response_metadata),
                role: this.role,
                id: this.id ?? e.id
            })
        }
        get _printableFields() {
            return {
                ...super._printableFields,
                role: this.role
            }
        }
    }
    class Fy extends nu {
        static lc_name() {
            return "FunctionMessageChunk"
        }
        _getType() {
            return "function"
        }
        concat(e) {
            return new Fy({
                content: tu(this.content, e.content),
                additional_kwargs: vr(this.additional_kwargs, e.additional_kwargs),
                response_metadata: vr(this.response_metadata, e.response_metadata),
                name: this.name ?? "",
                id: this.id ?? e.id
            })
        }
    }
    class Ct extends ru {
        static lc_name() {
            return "HumanMessage"
        }
        _getType() {
            return "human"
        }
    }
    class jy extends nu {
        static lc_name() {
            return "HumanMessageChunk"
        }
        _getType() {
            return "human"
        }
        concat(e) {
            return new jy({
                content: tu(this.content, e.content),
                additional_kwargs: vr(this.additional_kwargs, e.additional_kwargs),
                response_metadata: vr(this.response_metadata, e.response_metadata),
                id: this.id ?? e.id
            })
        }
    }
    class iu extends ru {
        static lc_name() {
            return "SystemMessage"
        }
        _getType() {
            return "system"
        }
    }
    class oh extends nu {
        static lc_name() {
            return "SystemMessageChunk"
        }
        _getType() {
            return "system"
        }
        concat(e) {
            return new oh({
                content: tu(this.content, e.content),
                additional_kwargs: vr(this.additional_kwargs, e.additional_kwargs),
                response_metadata: vr(this.response_metadata, e.response_metadata),
                id: this.id ?? e.id
            })
        }
    }
    function S_(n, e) {
        return n.lc_error_code = e,
        n.message = `${n.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`,
        n
    }
    function yT(n) {
        return !!(n && typeof n == "object" && "type"in n && n.type === "tool_call")
    }
    class XU extends Error {
        constructor(e, t) {
            super(e),
            Object.defineProperty(this, "output", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.output = t
        }
    }
    function YU(n) {
        return yT(n) ? n : typeof n.id == "string" && n.type === "function" && typeof n.function == "object" && n.function !== null && "arguments"in n.function && typeof n.function.arguments == "string" && "name"in n.function && typeof n.function.name == "string" ? {
            id: n.id,
            args: JSON.parse(n.function.arguments),
            name: n.function.name,
            type: "tool_call"
        } : n
    }
    function QU(n) {
        return typeof n == "object" && n != null && n.lc === 1 && Array.isArray(n.id) && n.kwargs != null && typeof n.kwargs == "object"
    }
    function E_(n) {
        let e, t;
        if (QU(n)) {
            const r = n.id.at(-1);
            r === "HumanMessage" || r === "HumanMessageChunk" ? e = "user" : r === "AIMessage" || r === "AIMessageChunk" ? e = "assistant" : r === "SystemMessage" || r === "SystemMessageChunk" ? e = "system" : e = "unknown",
            t = n.kwargs
        } else {
            const {type: r, ...s} = n;
            e = r,
            t = s
        }
        if (e === "human" || e === "user")
            return new Ct(t);
        if (e === "ai" || e === "assistant") {
            const {tool_calls: r, ...s} = t;
            if (!Array.isArray(r))
                return new pn(t);
            const i = r.map(YU);
            return new pn({
                ...s,
                tool_calls: i
            })
        } else {
            if (e === "system")
                return new iu(t);
            if (e === "developer")
                return new iu({
                    ...t,
                    additional_kwargs: {
                        ...t.additional_kwargs,
                        __openai_role__: "developer"
                    }
                });
            if (e === "tool" && "tool_call_id"in t)
                return new $y({
                    ...t,
                    content: t.content,
                    tool_call_id: t.tool_call_id,
                    name: t.name
                });
            throw S_(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(n, null, 2)}`), "MESSAGE_COERCION_FAILURE")
        }
    }
    function ch(n) {
        if (typeof n == "string")
            return new Ct(n);
        if (ih(n))
            return n;
        if (Array.isArray(n)) {
            const [e,t] = n;
            return E_({
                type: e,
                content: t
            })
        } else if (GU(n)) {
            const {role: e, ...t} = n;
            return E_({
                ...t,
                type: e
            })
        } else
            return E_(n)
    }
    function wT(n, e="Human", t="AI") {
        const r = [];
        for (const s of n) {
            let i;
            if (s._getType() === "human")
                i = e;
            else if (s._getType() === "ai")
                i = t;
            else if (s._getType() === "system")
                i = "System";
            else if (s._getType() === "function")
                i = "Function";
            else if (s._getType() === "tool")
                i = "Tool";
            else if (s._getType() === "generic")
                i = s.role;
            else
                throw new Error(`Got unsupported message type: ${s._getType()}`);
            const a = s.name ? `${s.name}, ` : ""
              , c = typeof s.content == "string" ? s.content : JSON.stringify(s.content, null, 2);
            r.push(`${i}: ${a}${c}`)
        }
        return r.join(`
`)
    }
    function e3(n) {
        var t;
        const e = n._getType();
        if (e === "human")
            return new jy({
                ...n
            });
        if (e === "ai") {
            let r = {
                ...n
            };
            return "tool_calls"in r && (r = {
                ...r,
                tool_call_chunks: (t = r.tool_calls) == null ? void 0 : t.map(s => ({
                    ...s,
                    type: "tool_call_chunk",
                    index: void 0,
                    args: JSON.stringify(s.args)
                }))
            }),
            new _r({
                ...r
            })
        } else {
            if (e === "system")
                return new oh({
                    ...n
                });
            if (e === "function")
                return new Fy({
                    ...n
                });
            if (su.isInstance(n))
                return new Ly({
                    ...n
                });
            throw new Error("Unknown message type.")
        }
    }
    var uh = {
        exports: {}
    }, x_ = {}, C_, bT;
    function t3() {
        if (bT)
            return C_;
        bT = 1;
        function n(e, t) {
            typeof t == "boolean" && (t = {
                forever: t
            }),
            this._originalTimeouts = JSON.parse(JSON.stringify(e)),
            this._timeouts = e,
            this._options = t || {},
            this._maxRetryTime = t && t.maxRetryTime || 1 / 0,
            this._fn = null,
            this._errors = [],
            this._attempts = 1,
            this._operationTimeout = null,
            this._operationTimeoutCb = null,
            this._timeout = null,
            this._operationStart = null,
            this._timer = null,
            this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0))
        }
        return C_ = n,
        n.prototype.reset = function() {
            this._attempts = 1,
            this._timeouts = this._originalTimeouts.slice(0)
        }
        ,
        n.prototype.stop = function() {
            this._timeout && clearTimeout(this._timeout),
            this._timer && clearTimeout(this._timer),
            this._timeouts = [],
            this._cachedTimeouts = null
        }
        ,
        n.prototype.retry = function(e) {
            if (this._timeout && clearTimeout(this._timeout),
            !e)
                return !1;
            var t = new Date().getTime();
            if (e && t - this._operationStart >= this._maxRetryTime)
                return this._errors.push(e),
                this._errors.unshift(new Error("RetryOperation timeout occurred")),
                !1;
            this._errors.push(e);
            var r = this._timeouts.shift();
            if (r === void 0)
                if (this._cachedTimeouts)
                    this._errors.splice(0, this._errors.length - 1),
                    r = this._cachedTimeouts.slice(-1);
                else
                    return !1;
            var s = this;
            return this._timer = setTimeout(function() {
                s._attempts++,
                s._operationTimeoutCb && (s._timeout = setTimeout(function() {
                    s._operationTimeoutCb(s._attempts)
                }, s._operationTimeout),
                s._options.unref && s._timeout.unref()),
                s._fn(s._attempts)
            }, r),
            this._options.unref && this._timer.unref(),
            !0
        }
        ,
        n.prototype.attempt = function(e, t) {
            this._fn = e,
            t && (t.timeout && (this._operationTimeout = t.timeout),
            t.cb && (this._operationTimeoutCb = t.cb));
            var r = this;
            this._operationTimeoutCb && (this._timeout = setTimeout(function() {
                r._operationTimeoutCb()
            }, r._operationTimeout)),
            this._operationStart = new Date().getTime(),
            this._fn(this._attempts)
        }
        ,
        n.prototype.try = function(e) {
            console.log("Using RetryOperation.try() is deprecated"),
            this.attempt(e)
        }
        ,
        n.prototype.start = function(e) {
            console.log("Using RetryOperation.start() is deprecated"),
            this.attempt(e)
        }
        ,
        n.prototype.start = n.prototype.try,
        n.prototype.errors = function() {
            return this._errors
        }
        ,
        n.prototype.attempts = function() {
            return this._attempts
        }
        ,
        n.prototype.mainError = function() {
            if (this._errors.length === 0)
                return null;
            for (var e = {}, t = null, r = 0, s = 0; s < this._errors.length; s++) {
                var i = this._errors[s]
                  , a = i.message
                  , c = (e[a] || 0) + 1;
                e[a] = c,
                c >= r && (t = i,
                r = c)
            }
            return t
        }
        ,
        C_
    }
    var vT;
    function r3() {
        return vT || (vT = 1,
        function(n) {
            var e = t3();
            n.operation = function(t) {
                var r = n.timeouts(t);
                return new e(r,{
                    forever: t && (t.forever || t.retries === 1 / 0),
                    unref: t && t.unref,
                    maxRetryTime: t && t.maxRetryTime
                })
            }
            ,
            n.timeouts = function(t) {
                if (t instanceof Array)
                    return [].concat(t);
                var r = {
                    retries: 10,
                    factor: 2,
                    minTimeout: 1 * 1e3,
                    maxTimeout: 1 / 0,
                    randomize: !1
                };
                for (var s in t)
                    r[s] = t[s];
                if (r.minTimeout > r.maxTimeout)
                    throw new Error("minTimeout is greater than maxTimeout");
                for (var i = [], a = 0; a < r.retries; a++)
                    i.push(this.createTimeout(a, r));
                return t && t.forever && !i.length && i.push(this.createTimeout(a, r)),
                i.sort(function(c, u) {
                    return c - u
                }),
                i
            }
            ,
            n.createTimeout = function(t, r) {
                var s = r.randomize ? Math.random() + 1 : 1
                  , i = Math.round(s * Math.max(r.minTimeout, 1) * Math.pow(r.factor, t));
                return i = Math.min(i, r.maxTimeout),
                i
            }
            ,
            n.wrap = function(t, r, s) {
                if (r instanceof Array && (s = r,
                r = null),
                !s) {
                    s = [];
                    for (var i in t)
                        typeof t[i] == "function" && s.push(i)
                }
                for (var a = 0; a < s.length; a++) {
                    var c = s[a]
                      , u = t[c];
                    t[c] = (function(d) {
                        var h = n.operation(r)
                          , f = Array.prototype.slice.call(arguments, 1)
                          , p = f.pop();
                        f.push(function(g) {
                            h.retry(g) || (g && (arguments[0] = h.mainError()),
                            p.apply(this, arguments))
                        }),
                        h.attempt(function() {
                            d.apply(t, f)
                        })
                    }
                    ).bind(t, u),
                    t[c].options = r
                }
            }
        }(x_)),
        x_
    }
    var k_, _T;
    function n3() {
        return _T || (_T = 1,
        k_ = r3()),
        k_
    }
    var ST;
    function s3() {
        if (ST)
            return uh.exports;
        ST = 1;
        const n = n3()
          , e = ["Failed to fetch", "NetworkError when attempting to fetch resource.", "The Internet connection appears to be offline.", "Network request failed"];
        class t extends Error {
            constructor(c) {
                super(),
                c instanceof Error ? (this.originalError = c,
                {message: c} = c) : (this.originalError = new Error(c),
                this.originalError.stack = this.stack),
                this.name = "AbortError",
                this.message = c
            }
        }
        const r = (a, c, u) => {
            const l = u.retries - (c - 1);
            return a.attemptNumber = c,
            a.retriesLeft = l,
            a
        }
          , s = a => e.includes(a)
          , i = (a, c) => new Promise( (u, l) => {
            c = {
                onFailedAttempt: () => {}
                ,
                retries: 10,
                ...c
            };
            const d = n.operation(c);
            d.attempt(async h => {
                try {
                    u(await a(h))
                } catch (f) {
                    if (!(f instanceof Error)) {
                        l(new TypeError(`Non-error was thrown: "${f}". You should only throw errors.`));
                        return
                    }
                    if (f instanceof t)
                        d.stop(),
                        l(f.originalError);
                    else if (f instanceof TypeError && !s(f.message))
                        d.stop(),
                        l(f);
                    else {
                        r(f, h, c);
                        try {
                            await c.onFailedAttempt(f)
                        } catch (p) {
                            l(p);
                            return
                        }
                        d.retry(f) || l(d.mainError())
                    }
                }
            }
            )
        }
        );
        return uh.exports = i,
        uh.exports.default = i,
        uh.exports.AbortError = t,
        uh.exports
    }
    var i3 = s3();
    const Dy = De(i3)
      , a3 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
    function lh(n) {
        return typeof n == "string" && a3.test(n)
    }
    for (var or = [], P_ = 0; P_ < 256; ++P_)
        or.push((P_ + 256).toString(16).slice(1));
    function o3(n, e=0) {
        return (or[n[e + 0]] + or[n[e + 1]] + or[n[e + 2]] + or[n[e + 3]] + "-" + or[n[e + 4]] + or[n[e + 5]] + "-" + or[n[e + 6]] + or[n[e + 7]] + "-" + or[n[e + 8]] + or[n[e + 9]] + "-" + or[n[e + 10]] + or[n[e + 11]] + or[n[e + 12]] + or[n[e + 13]] + or[n[e + 14]] + or[n[e + 15]]).toLowerCase()
    }
    var By, c3 = new Uint8Array(16);
    function u3() {
        if (!By && (By = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto),
        !By))
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return By(c3)
    }
    var l3 = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    const ET = {
        randomUUID: l3
    };
    function Rr(n, e, t) {
        if (ET.randomUUID && !e && !n)
            return ET.randomUUID();
        n = n || {};
        var r = n.random || (n.rng || u3)();
        return r[6] = r[6] & 15 | 64,
        r[8] = r[8] & 63 | 128,
        o3(r)
    }
    var qy = {}, T_ = {
        exports: {}
    }, xT;
    function d3() {
        return xT || (xT = 1,
        function(n) {
            var e = Object.prototype.hasOwnProperty
              , t = "~";
            function r() {}
            Object.create && (r.prototype = Object.create(null),
            new r().__proto__ || (t = !1));
            function s(u, l, d) {
                this.fn = u,
                this.context = l,
                this.once = d || !1
            }
            function i(u, l, d, h, f) {
                if (typeof d != "function")
                    throw new TypeError("The listener must be a function");
                var p = new s(d,h || u,f)
                  , g = t ? t + l : l;
                return u._events[g] ? u._events[g].fn ? u._events[g] = [u._events[g], p] : u._events[g].push(p) : (u._events[g] = p,
                u._eventsCount++),
                u
            }
            function a(u, l) {
                --u._eventsCount === 0 ? u._events = new r : delete u._events[l]
            }
            function c() {
                this._events = new r,
                this._eventsCount = 0
            }
            c.prototype.eventNames = function() {
                var l = [], d, h;
                if (this._eventsCount === 0)
                    return l;
                for (h in d = this._events)
                    e.call(d, h) && l.push(t ? h.slice(1) : h);
                return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l
            }
            ,
            c.prototype.listeners = function(l) {
                var d = t ? t + l : l
                  , h = this._events[d];
                if (!h)
                    return [];
                if (h.fn)
                    return [h.fn];
                for (var f = 0, p = h.length, g = new Array(p); f < p; f++)
                    g[f] = h[f].fn;
                return g
            }
            ,
            c.prototype.listenerCount = function(l) {
                var d = t ? t + l : l
                  , h = this._events[d];
                return h ? h.fn ? 1 : h.length : 0
            }
            ,
            c.prototype.emit = function(l, d, h, f, p, g) {
                var y = t ? t + l : l;
                if (!this._events[y])
                    return !1;
                var m = this._events[y], w = arguments.length, E, v;
                if (m.fn) {
                    switch (m.once && this.removeListener(l, m.fn, void 0, !0),
                    w) {
                    case 1:
                        return m.fn.call(m.context),
                        !0;
                    case 2:
                        return m.fn.call(m.context, d),
                        !0;
                    case 3:
                        return m.fn.call(m.context, d, h),
                        !0;
                    case 4:
                        return m.fn.call(m.context, d, h, f),
                        !0;
                    case 5:
                        return m.fn.call(m.context, d, h, f, p),
                        !0;
                    case 6:
                        return m.fn.call(m.context, d, h, f, p, g),
                        !0
                    }
                    for (v = 1,
                    E = new Array(w - 1); v < w; v++)
                        E[v - 1] = arguments[v];
                    m.fn.apply(m.context, E)
                } else {
                    var _ = m.length, A;
                    for (v = 0; v < _; v++)
                        switch (m[v].once && this.removeListener(l, m[v].fn, void 0, !0),
                        w) {
                        case 1:
                            m[v].fn.call(m[v].context);
                            break;
                        case 2:
                            m[v].fn.call(m[v].context, d);
                            break;
                        case 3:
                            m[v].fn.call(m[v].context, d, h);
                            break;
                        case 4:
                            m[v].fn.call(m[v].context, d, h, f);
                            break;
                        default:
                            if (!E)
                                for (A = 1,
                                E = new Array(w - 1); A < w; A++)
                                    E[A - 1] = arguments[A];
                            m[v].fn.apply(m[v].context, E)
                        }
                }
                return !0
            }
            ,
            c.prototype.on = function(l, d, h) {
                return i(this, l, d, h, !1)
            }
            ,
            c.prototype.once = function(l, d, h) {
                return i(this, l, d, h, !0)
            }
            ,
            c.prototype.removeListener = function(l, d, h, f) {
                var p = t ? t + l : l;
                if (!this._events[p])
                    return this;
                if (!d)
                    return a(this, p),
                    this;
                var g = this._events[p];
                if (g.fn)
                    g.fn === d && (!f || g.once) && (!h || g.context === h) && a(this, p);
                else {
                    for (var y = 0, m = [], w = g.length; y < w; y++)
                        (g[y].fn !== d || f && !g[y].once || h && g[y].context !== h) && m.push(g[y]);
                    m.length ? this._events[p] = m.length === 1 ? m[0] : m : a(this, p)
                }
                return this
            }
            ,
            c.prototype.removeAllListeners = function(l) {
                var d;
                return l ? (d = t ? t + l : l,
                this._events[d] && a(this, d)) : (this._events = new r,
                this._eventsCount = 0),
                this
            }
            ,
            c.prototype.off = c.prototype.removeListener,
            c.prototype.addListener = c.prototype.on,
            c.prefixed = t,
            c.EventEmitter = c,
            n.exports = c
        }(T_)),
        T_.exports
    }
    var dh = {
        exports: {}
    }, A_, CT;
    function h3() {
        return CT || (CT = 1,
        A_ = (n, e) => (e = e || ( () => {}
        ),
        n.then(t => new Promise(r => {
            r(e())
        }
        ).then( () => t), t => new Promise(r => {
            r(e())
        }
        ).then( () => {
            throw t
        }
        )))),
        A_
    }
    var kT;
    function f3() {
        if (kT)
            return dh.exports;
        kT = 1;
        const n = h3();
        class e extends Error {
            constructor(s) {
                super(s),
                this.name = "TimeoutError"
            }
        }
        const t = (r, s, i) => new Promise( (a, c) => {
            if (typeof s != "number" || s < 0)
                throw new TypeError("Expected `milliseconds` to be a positive number");
            if (s === 1 / 0) {
                a(r);
                return
            }
            const u = setTimeout( () => {
                if (typeof i == "function") {
                    try {
                        a(i())
                    } catch (h) {
                        c(h)
                    }
                    return
                }
                const l = typeof i == "string" ? i : `Promise timed out after ${s} milliseconds`
                  , d = i instanceof Error ? i : new e(l);
                typeof r.cancel == "function" && r.cancel(),
                c(d)
            }
            , s);
            n(r.then(a, c), () => {
                clearTimeout(u)
            }
            )
        }
        );
        return dh.exports = t,
        dh.exports.default = t,
        dh.exports.TimeoutError = e,
        dh.exports
    }
    var Uy = {}, Ky = {}, PT;
    function p3() {
        if (PT)
            return Ky;
        PT = 1,
        Object.defineProperty(Ky, "__esModule", {
            value: !0
        });
        function n(e, t, r) {
            let s = 0
              , i = e.length;
            for (; i > 0; ) {
                const a = i / 2 | 0;
                let c = s + a;
                r(e[c], t) <= 0 ? (s = ++c,
                i -= a + 1) : i = a
            }
            return s
        }
        return Ky.default = n,
        Ky
    }
    var TT;
    function m3() {
        if (TT)
            return Uy;
        TT = 1,
        Object.defineProperty(Uy, "__esModule", {
            value: !0
        });
        const n = p3();
        class e {
            constructor() {
                this._queue = []
            }
            enqueue(r, s) {
                s = Object.assign({
                    priority: 0
                }, s);
                const i = {
                    priority: s.priority,
                    run: r
                };
                if (this.size && this._queue[this.size - 1].priority >= s.priority) {
                    this._queue.push(i);
                    return
                }
                const a = n.default(this._queue, i, (c, u) => u.priority - c.priority);
                this._queue.splice(a, 0, i)
            }
            dequeue() {
                const r = this._queue.shift();
                return r == null ? void 0 : r.run
            }
            filter(r) {
                return this._queue.filter(s => s.priority === r.priority).map(s => s.run)
            }
            get size() {
                return this._queue.length
            }
        }
        return Uy.default = e,
        Uy
    }
    var AT;
    function g3() {
        if (AT)
            return qy;
        AT = 1,
        Object.defineProperty(qy, "__esModule", {
            value: !0
        });
        const n = d3()
          , e = f3()
          , t = m3()
          , r = () => {}
          , s = new e.TimeoutError;
        class i extends n {
            constructor(c) {
                var u, l, d, h;
                if (super(),
                this._intervalCount = 0,
                this._intervalEnd = 0,
                this._pendingCount = 0,
                this._resolveEmpty = r,
                this._resolveIdle = r,
                c = Object.assign({
                    carryoverConcurrencyCount: !1,
                    intervalCap: 1 / 0,
                    interval: 0,
                    concurrency: 1 / 0,
                    autoStart: !0,
                    queueClass: t.default
                }, c),
                !(typeof c.intervalCap == "number" && c.intervalCap >= 1))
                    throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(l = (u = c.intervalCap) === null || u === void 0 ? void 0 : u.toString()) !== null && l !== void 0 ? l : ""}\` (${typeof c.intervalCap})`);
                if (c.interval === void 0 || !(Number.isFinite(c.interval) && c.interval >= 0))
                    throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(h = (d = c.interval) === null || d === void 0 ? void 0 : d.toString()) !== null && h !== void 0 ? h : ""}\` (${typeof c.interval})`);
                this._carryoverConcurrencyCount = c.carryoverConcurrencyCount,
                this._isIntervalIgnored = c.intervalCap === 1 / 0 || c.interval === 0,
                this._intervalCap = c.intervalCap,
                this._interval = c.interval,
                this._queue = new c.queueClass,
                this._queueClass = c.queueClass,
                this.concurrency = c.concurrency,
                this._timeout = c.timeout,
                this._throwOnTimeout = c.throwOnTimeout === !0,
                this._isPaused = c.autoStart === !1
            }
            get _doesIntervalAllowAnother() {
                return this._isIntervalIgnored || this._intervalCount < this._intervalCap
            }
            get _doesConcurrentAllowAnother() {
                return this._pendingCount < this._concurrency
            }
            _next() {
                this._pendingCount--,
                this._tryToStartAnother(),
                this.emit("next")
            }
            _resolvePromises() {
                this._resolveEmpty(),
                this._resolveEmpty = r,
                this._pendingCount === 0 && (this._resolveIdle(),
                this._resolveIdle = r,
                this.emit("idle"))
            }
            _onResumeInterval() {
                this._onInterval(),
                this._initializeIntervalIfNeeded(),
                this._timeoutId = void 0
            }
            _isIntervalPaused() {
                const c = Date.now();
                if (this._intervalId === void 0) {
                    const u = this._intervalEnd - c;
                    if (u < 0)
                        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
                    else
                        return this._timeoutId === void 0 && (this._timeoutId = setTimeout( () => {
                            this._onResumeInterval()
                        }
                        , u)),
                        !0
                }
                return !1
            }
            _tryToStartAnother() {
                if (this._queue.size === 0)
                    return this._intervalId && clearInterval(this._intervalId),
                    this._intervalId = void 0,
                    this._resolvePromises(),
                    !1;
                if (!this._isPaused) {
                    const c = !this._isIntervalPaused();
                    if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                        const u = this._queue.dequeue();
                        return u ? (this.emit("active"),
                        u(),
                        c && this._initializeIntervalIfNeeded(),
                        !0) : !1
                    }
                }
                return !1
            }
            _initializeIntervalIfNeeded() {
                this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval( () => {
                    this._onInterval()
                }
                , this._interval),
                this._intervalEnd = Date.now() + this._interval)
            }
            _onInterval() {
                this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId),
                this._intervalId = void 0),
                this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0,
                this._processQueue()
            }
            _processQueue() {
                for (; this._tryToStartAnother(); )
                    ;
            }
            get concurrency() {
                return this._concurrency
            }
            set concurrency(c) {
                if (!(typeof c == "number" && c >= 1))
                    throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${c}\` (${typeof c})`);
                this._concurrency = c,
                this._processQueue()
            }
            async add(c, u={}) {
                return new Promise( (l, d) => {
                    const h = async () => {
                        this._pendingCount++,
                        this._intervalCount++;
                        try {
                            const f = this._timeout === void 0 && u.timeout === void 0 ? c() : e.default(Promise.resolve(c()), u.timeout === void 0 ? this._timeout : u.timeout, () => {
                                (u.throwOnTimeout === void 0 ? this._throwOnTimeout : u.throwOnTimeout) && d(s)
                            }
                            );
                            l(await f)
                        } catch (f) {
                            d(f)
                        }
                        this._next()
                    }
                    ;
                    this._queue.enqueue(h, u),
                    this._tryToStartAnother(),
                    this.emit("add")
                }
                )
            }
            async addAll(c, u) {
                return Promise.all(c.map(async l => this.add(l, u)))
            }
            start() {
                return this._isPaused ? (this._isPaused = !1,
                this._processQueue(),
                this) : this
            }
            pause() {
                this._isPaused = !0
            }
            clear() {
                this._queue = new this._queueClass
            }
            async onEmpty() {
                if (this._queue.size !== 0)
                    return new Promise(c => {
                        const u = this._resolveEmpty;
                        this._resolveEmpty = () => {
                            u(),
                            c()
                        }
                    }
                    )
            }
            async onIdle() {
                if (!(this._pendingCount === 0 && this._queue.size === 0))
                    return new Promise(c => {
                        const u = this._resolveIdle;
                        this._resolveIdle = () => {
                            u(),
                            c()
                        }
                    }
                    )
            }
            get size() {
                return this._queue.size
            }
            sizeBy(c) {
                return this._queue.filter(c).length
            }
            get pending() {
                return this._pendingCount
            }
            get isPaused() {
                return this._isPaused
            }
            get timeout() {
                return this._timeout
            }
            set timeout(c) {
                this._timeout = c
            }
        }
        return qy.default = i,
        qy
    }
    var y3 = g3();
    const Ks = De(y3)
      , w3 = (...n) => fetch(...n)
      , b3 = Symbol.for("ls:fetch_implementation")
      , _e = () => globalThis[b3] ?? w3
      , v3 = [400, 401, 403, 404, 405, 406, 407, 408]
      , _3 = [409];
    let IT = class {
        constructor(e) {
            Object.defineProperty(this, "maxConcurrency", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "maxRetries", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "queue", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "onFailedResponseHook", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.maxConcurrency = e.maxConcurrency ?? 1 / 0,
            this.maxRetries = e.maxRetries ?? 6,
            "default"in Ks ? this.queue = new Ks.default({
                concurrency: this.maxConcurrency
            }) : this.queue = new Ks({
                concurrency: this.maxConcurrency
            }),
            this.onFailedResponseHook = e == null ? void 0 : e.onFailedResponseHook
        }
        call(e, ...t) {
            const r = this.onFailedResponseHook;
            return this.queue.add( () => Dy( () => e(...t).catch(s => {
                throw s instanceof Error ? s : new Error(s)
            }
            ), {
                async onFailedAttempt(s) {
                    if (s.message.startsWith("Cancel") || s.message.startsWith("TimeoutError") || s.message.startsWith("AbortError") || (s == null ? void 0 : s.code) === "ECONNABORTED")
                        throw s;
                    const i = s == null ? void 0 : s.response
                      , a = i == null ? void 0 : i.status;
                    if (a) {
                        if (v3.includes(+a))
                            throw s;
                        if (_3.includes(+a))
                            return;
                        r && await r(i)
                    }
                },
                retries: this.maxRetries,
                randomize: !0
            }), {
                throwOnTimeout: !0
            })
        }
        callWithOptions(e, t, ...r) {
            return e.signal ? Promise.race([this.call(t, ...r), new Promise( (s, i) => {
                var a;
                (a = e.signal) == null || a.addEventListener("abort", () => {
                    i(new Error("AbortError"))
                }
                )
            }
            )]) : this.call(t, ...r)
        }
        fetch(...e) {
            return this.call( () => _e()(...e).then(t => t.ok ? t : Promise.reject(t)))
        }
    }
    ;
    function OT(n) {
        return typeof (n == null ? void 0 : n._getType) == "function"
    }
    function RT(n) {
        const e = {
            type: n._getType(),
            data: {
                content: n.content
            }
        };
        return n != null && n.additional_kwargs && Object.keys(n.additional_kwargs).length > 0 && (e.data.additional_kwargs = {
            ...n.additional_kwargs
        }),
        e
    }
    function Ne(n, e) {
        if (!lh(n)) {
            const t = e !== void 0 ? `Invalid UUID for ${e}: ${n}` : `Invalid UUID: ${n}`;
            throw new Error(t)
        }
        return n
    }
    const MT = {};
    function NT(n) {
        MT[n] || (console.warn(n),
        MT[n] = !0)
    }
    var Hy = {
        exports: {}
    }, I_, $T;
    function Wy() {
        if ($T)
            return I_;
        $T = 1;
        const n = "2.0.0"
          , e = 256
          , t = Number.MAX_SAFE_INTEGER || 9007199254740991
          , r = 16
          , s = e - 6;
        return I_ = {
            MAX_LENGTH: e,
            MAX_SAFE_COMPONENT_LENGTH: r,
            MAX_SAFE_BUILD_LENGTH: s,
            MAX_SAFE_INTEGER: t,
            RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"],
            SEMVER_SPEC_VERSION: n,
            FLAG_INCLUDE_PRERELEASE: 1,
            FLAG_LOOSE: 2
        },
        I_
    }
    var O_, LT;
    function zy() {
        return LT || (LT = 1,
        O_ = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {}
        ),
        O_
    }
    var FT;
    function hh() {
        return FT || (FT = 1,
        function(n, e) {
            const {MAX_SAFE_COMPONENT_LENGTH: t, MAX_SAFE_BUILD_LENGTH: r, MAX_LENGTH: s} = Wy()
              , i = zy();
            e = n.exports = {};
            const a = e.re = []
              , c = e.safeRe = []
              , u = e.src = []
              , l = e.t = {};
            let d = 0;
            const h = "[a-zA-Z0-9-]"
              , f = [["\\s", 1], ["\\d", s], [h, r]]
              , p = y => {
                for (const [m,w] of f)
                    y = y.split(`${m}*`).join(`${m}{0,${w}}`).split(`${m}+`).join(`${m}{1,${w}}`);
                return y
            }
              , g = (y, m, w) => {
                const E = p(m)
                  , v = d++;
                i(y, v, m),
                l[y] = v,
                u[v] = m,
                a[v] = new RegExp(m,w ? "g" : void 0),
                c[v] = new RegExp(E,w ? "g" : void 0)
            }
            ;
            g("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
            g("NUMERICIDENTIFIERLOOSE", "\\d+"),
            g("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`),
            g("MAINVERSION", `(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})`),
            g("MAINVERSIONLOOSE", `(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})`),
            g("PRERELEASEIDENTIFIER", `(?:${u[l.NUMERICIDENTIFIER]}|${u[l.NONNUMERICIDENTIFIER]})`),
            g("PRERELEASEIDENTIFIERLOOSE", `(?:${u[l.NUMERICIDENTIFIERLOOSE]}|${u[l.NONNUMERICIDENTIFIER]})`),
            g("PRERELEASE", `(?:-(${u[l.PRERELEASEIDENTIFIER]}(?:\\.${u[l.PRERELEASEIDENTIFIER]})*))`),
            g("PRERELEASELOOSE", `(?:-?(${u[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[l.PRERELEASEIDENTIFIERLOOSE]})*))`),
            g("BUILDIDENTIFIER", `${h}+`),
            g("BUILD", `(?:\\+(${u[l.BUILDIDENTIFIER]}(?:\\.${u[l.BUILDIDENTIFIER]})*))`),
            g("FULLPLAIN", `v?${u[l.MAINVERSION]}${u[l.PRERELEASE]}?${u[l.BUILD]}?`),
            g("FULL", `^${u[l.FULLPLAIN]}$`),
            g("LOOSEPLAIN", `[v=\\s]*${u[l.MAINVERSIONLOOSE]}${u[l.PRERELEASELOOSE]}?${u[l.BUILD]}?`),
            g("LOOSE", `^${u[l.LOOSEPLAIN]}$`),
            g("GTLT", "((?:<|>)?=?)"),
            g("XRANGEIDENTIFIERLOOSE", `${u[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
            g("XRANGEIDENTIFIER", `${u[l.NUMERICIDENTIFIER]}|x|X|\\*`),
            g("XRANGEPLAIN", `[v=\\s]*(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:${u[l.PRERELEASE]})?${u[l.BUILD]}?)?)?`),
            g("XRANGEPLAINLOOSE", `[v=\\s]*(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:${u[l.PRERELEASELOOSE]})?${u[l.BUILD]}?)?)?`),
            g("XRANGE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAIN]}$`),
            g("XRANGELOOSE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAINLOOSE]}$`),
            g("COERCEPLAIN", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?`),
            g("COERCE", `${u[l.COERCEPLAIN]}(?:$|[^\\d])`),
            g("COERCEFULL", u[l.COERCEPLAIN] + `(?:${u[l.PRERELEASE]})?(?:${u[l.BUILD]})?(?:$|[^\\d])`),
            g("COERCERTL", u[l.COERCE], !0),
            g("COERCERTLFULL", u[l.COERCEFULL], !0),
            g("LONETILDE", "(?:~>?)"),
            g("TILDETRIM", `(\\s*)${u[l.LONETILDE]}\\s+`, !0),
            e.tildeTrimReplace = "$1~",
            g("TILDE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAIN]}$`),
            g("TILDELOOSE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAINLOOSE]}$`),
            g("LONECARET", "(?:\\^)"),
            g("CARETTRIM", `(\\s*)${u[l.LONECARET]}\\s+`, !0),
            e.caretTrimReplace = "$1^",
            g("CARET", `^${u[l.LONECARET]}${u[l.XRANGEPLAIN]}$`),
            g("CARETLOOSE", `^${u[l.LONECARET]}${u[l.XRANGEPLAINLOOSE]}$`),
            g("COMPARATORLOOSE", `^${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]})$|^$`),
            g("COMPARATOR", `^${u[l.GTLT]}\\s*(${u[l.FULLPLAIN]})$|^$`),
            g("COMPARATORTRIM", `(\\s*)${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]}|${u[l.XRANGEPLAIN]})`, !0),
            e.comparatorTrimReplace = "$1$2$3",
            g("HYPHENRANGE", `^\\s*(${u[l.XRANGEPLAIN]})\\s+-\\s+(${u[l.XRANGEPLAIN]})\\s*$`),
            g("HYPHENRANGELOOSE", `^\\s*(${u[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[l.XRANGEPLAINLOOSE]})\\s*$`),
            g("STAR", "(<|>)?=?\\s*\\*"),
            g("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
            g("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
        }(Hy, Hy.exports)),
        Hy.exports
    }
    var R_, jT;
    function M_() {
        if (jT)
            return R_;
        jT = 1;
        const n = Object.freeze({
            loose: !0
        })
          , e = Object.freeze({});
        return R_ = r => r ? typeof r != "object" ? n : r : e,
        R_
    }
    var N_, DT;
    function BT() {
        if (DT)
            return N_;
        DT = 1;
        const n = /^[0-9]+$/
          , e = (r, s) => {
            const i = n.test(r)
              , a = n.test(s);
            return i && a && (r = +r,
            s = +s),
            r === s ? 0 : i && !a ? -1 : a && !i ? 1 : r < s ? -1 : 1
        }
        ;
        return N_ = {
            compareIdentifiers: e,
            rcompareIdentifiers: (r, s) => e(s, r)
        },
        N_
    }
    var $_, qT;
    function Sr() {
        if (qT)
            return $_;
        qT = 1;
        const n = zy()
          , {MAX_LENGTH: e, MAX_SAFE_INTEGER: t} = Wy()
          , {safeRe: r, t: s} = hh()
          , i = M_()
          , {compareIdentifiers: a} = BT();
        class c {
            constructor(l, d) {
                if (d = i(d),
                l instanceof c) {
                    if (l.loose === !!d.loose && l.includePrerelease === !!d.includePrerelease)
                        return l;
                    l = l.version
                } else if (typeof l != "string")
                    throw new TypeError(`Invalid version. Must be a string. Got type "${typeof l}".`);
                if (l.length > e)
                    throw new TypeError(`version is longer than ${e} characters`);
                n("SemVer", l, d),
                this.options = d,
                this.loose = !!d.loose,
                this.includePrerelease = !!d.includePrerelease;
                const h = l.trim().match(d.loose ? r[s.LOOSE] : r[s.FULL]);
                if (!h)
                    throw new TypeError(`Invalid Version: ${l}`);
                if (this.raw = l,
                this.major = +h[1],
                this.minor = +h[2],
                this.patch = +h[3],
                this.major > t || this.major < 0)
                    throw new TypeError("Invalid major version");
                if (this.minor > t || this.minor < 0)
                    throw new TypeError("Invalid minor version");
                if (this.patch > t || this.patch < 0)
                    throw new TypeError("Invalid patch version");
                h[4] ? this.prerelease = h[4].split(".").map(f => {
                    if (/^[0-9]+$/.test(f)) {
                        const p = +f;
                        if (p >= 0 && p < t)
                            return p
                    }
                    return f
                }
                ) : this.prerelease = [],
                this.build = h[5] ? h[5].split(".") : [],
                this.format()
            }
            format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`,
                this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`),
                this.version
            }
            toString() {
                return this.version
            }
            compare(l) {
                if (n("SemVer.compare", this.version, this.options, l),
                !(l instanceof c)) {
                    if (typeof l == "string" && l === this.version)
                        return 0;
                    l = new c(l,this.options)
                }
                return l.version === this.version ? 0 : this.compareMain(l) || this.comparePre(l)
            }
            compareMain(l) {
                return l instanceof c || (l = new c(l,this.options)),
                a(this.major, l.major) || a(this.minor, l.minor) || a(this.patch, l.patch)
            }
            comparePre(l) {
                if (l instanceof c || (l = new c(l,this.options)),
                this.prerelease.length && !l.prerelease.length)
                    return -1;
                if (!this.prerelease.length && l.prerelease.length)
                    return 1;
                if (!this.prerelease.length && !l.prerelease.length)
                    return 0;
                let d = 0;
                do {
                    const h = this.prerelease[d]
                      , f = l.prerelease[d];
                    if (n("prerelease compare", d, h, f),
                    h === void 0 && f === void 0)
                        return 0;
                    if (f === void 0)
                        return 1;
                    if (h === void 0)
                        return -1;
                    if (h === f)
                        continue;
                    return a(h, f)
                } while (++d)
            }
            compareBuild(l) {
                l instanceof c || (l = new c(l,this.options));
                let d = 0;
                do {
                    const h = this.build[d]
                      , f = l.build[d];
                    if (n("build compare", d, h, f),
                    h === void 0 && f === void 0)
                        return 0;
                    if (f === void 0)
                        return 1;
                    if (h === void 0)
                        return -1;
                    if (h === f)
                        continue;
                    return a(h, f)
                } while (++d)
            }
            inc(l, d, h) {
                switch (l) {
                case "premajor":
                    this.prerelease.length = 0,
                    this.patch = 0,
                    this.minor = 0,
                    this.major++,
                    this.inc("pre", d, h);
                    break;
                case "preminor":
                    this.prerelease.length = 0,
                    this.patch = 0,
                    this.minor++,
                    this.inc("pre", d, h);
                    break;
                case "prepatch":
                    this.prerelease.length = 0,
                    this.inc("patch", d, h),
                    this.inc("pre", d, h);
                    break;
                case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", d, h),
                    this.inc("pre", d, h);
                    break;
                case "major":
                    (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++,
                    this.minor = 0,
                    this.patch = 0,
                    this.prerelease = [];
                    break;
                case "minor":
                    (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
                    this.patch = 0,
                    this.prerelease = [];
                    break;
                case "patch":
                    this.prerelease.length === 0 && this.patch++,
                    this.prerelease = [];
                    break;
                case "pre":
                    {
                        const f = Number(h) ? 1 : 0;
                        if (!d && h === !1)
                            throw new Error("invalid increment argument: identifier is empty");
                        if (this.prerelease.length === 0)
                            this.prerelease = [f];
                        else {
                            let p = this.prerelease.length;
                            for (; --p >= 0; )
                                typeof this.prerelease[p] == "number" && (this.prerelease[p]++,
                                p = -2);
                            if (p === -1) {
                                if (d === this.prerelease.join(".") && h === !1)
                                    throw new Error("invalid increment argument: identifier already exists");
                                this.prerelease.push(f)
                            }
                        }
                        if (d) {
                            let p = [d, f];
                            h === !1 && (p = [d]),
                            a(this.prerelease[0], d) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = p) : this.prerelease = p
                        }
                        break
                    }
                default:
                    throw new Error(`invalid increment argument: ${l}`)
                }
                return this.raw = this.format(),
                this.build.length && (this.raw += `+${this.build.join(".")}`),
                this
            }
        }
        return $_ = c,
        $_
    }
    var L_, UT;
    function au() {
        if (UT)
            return L_;
        UT = 1;
        const n = Sr();
        return L_ = (t, r, s=!1) => {
            if (t instanceof n)
                return t;
            try {
                return new n(t,r)
            } catch (i) {
                if (!s)
                    return null;
                throw i
            }
        }
        ,
        L_
    }
    var F_, KT;
    function S3() {
        if (KT)
            return F_;
        KT = 1;
        const n = au();
        return F_ = (t, r) => {
            const s = n(t, r);
            return s ? s.version : null
        }
        ,
        F_
    }
    var j_, HT;
    function E3() {
        if (HT)
            return j_;
        HT = 1;
        const n = au();
        return j_ = (t, r) => {
            const s = n(t.trim().replace(/^[=v]+/, ""), r);
            return s ? s.version : null
        }
        ,
        j_
    }
    var D_, WT;
    function x3() {
        if (WT)
            return D_;
        WT = 1;
        const n = Sr();
        return D_ = (t, r, s, i, a) => {
            typeof s == "string" && (a = i,
            i = s,
            s = void 0);
            try {
                return new n(t instanceof n ? t.version : t,s).inc(r, i, a).version
            } catch {
                return null
            }
        }
        ,
        D_
    }
    var B_, zT;
    function C3() {
        if (zT)
            return B_;
        zT = 1;
        const n = au();
        return B_ = (t, r) => {
            const s = n(t, null, !0)
              , i = n(r, null, !0)
              , a = s.compare(i);
            if (a === 0)
                return null;
            const c = a > 0
              , u = c ? s : i
              , l = c ? i : s
              , d = !!u.prerelease.length;
            if (!!l.prerelease.length && !d)
                return !l.patch && !l.minor ? "major" : u.patch ? "patch" : u.minor ? "minor" : "major";
            const f = d ? "pre" : "";
            return s.major !== i.major ? f + "major" : s.minor !== i.minor ? f + "minor" : s.patch !== i.patch ? f + "patch" : "prerelease"
        }
        ,
        B_
    }
    var q_, VT;
    function k3() {
        if (VT)
            return q_;
        VT = 1;
        const n = Sr();
        return q_ = (t, r) => new n(t,r).major,
        q_
    }
    var U_, GT;
    function P3() {
        if (GT)
            return U_;
        GT = 1;
        const n = Sr();
        return U_ = (t, r) => new n(t,r).minor,
        U_
    }
    var K_, JT;
    function T3() {
        if (JT)
            return K_;
        JT = 1;
        const n = Sr();
        return K_ = (t, r) => new n(t,r).patch,
        K_
    }
    var H_, ZT;
    function A3() {
        if (ZT)
            return H_;
        ZT = 1;
        const n = au();
        return H_ = (t, r) => {
            const s = n(t, r);
            return s && s.prerelease.length ? s.prerelease : null
        }
        ,
        H_
    }
    var W_, XT;
    function On() {
        if (XT)
            return W_;
        XT = 1;
        const n = Sr();
        return W_ = (t, r, s) => new n(t,s).compare(new n(r,s)),
        W_
    }
    var z_, YT;
    function I3() {
        if (YT)
            return z_;
        YT = 1;
        const n = On();
        return z_ = (t, r, s) => n(r, t, s),
        z_
    }
    var V_, QT;
    function O3() {
        if (QT)
            return V_;
        QT = 1;
        const n = On();
        return V_ = (t, r) => n(t, r, !0),
        V_
    }
    var G_, eA;
    function J_() {
        if (eA)
            return G_;
        eA = 1;
        const n = Sr();
        return G_ = (t, r, s) => {
            const i = new n(t,s)
              , a = new n(r,s);
            return i.compare(a) || i.compareBuild(a)
        }
        ,
        G_
    }
    var Z_, tA;
    function R3() {
        if (tA)
            return Z_;
        tA = 1;
        const n = J_();
        return Z_ = (t, r) => t.sort( (s, i) => n(s, i, r)),
        Z_
    }
    var X_, rA;
    function M3() {
        if (rA)
            return X_;
        rA = 1;
        const n = J_();
        return X_ = (t, r) => t.sort( (s, i) => n(i, s, r)),
        X_
    }
    var Y_, nA;
    function Vy() {
        if (nA)
            return Y_;
        nA = 1;
        const n = On();
        return Y_ = (t, r, s) => n(t, r, s) > 0,
        Y_
    }
    var Q_, sA;
    function e0() {
        if (sA)
            return Q_;
        sA = 1;
        const n = On();
        return Q_ = (t, r, s) => n(t, r, s) < 0,
        Q_
    }
    var t0, iA;
    function aA() {
        if (iA)
            return t0;
        iA = 1;
        const n = On();
        return t0 = (t, r, s) => n(t, r, s) === 0,
        t0
    }
    var r0, oA;
    function cA() {
        if (oA)
            return r0;
        oA = 1;
        const n = On();
        return r0 = (t, r, s) => n(t, r, s) !== 0,
        r0
    }
    var n0, uA;
    function s0() {
        if (uA)
            return n0;
        uA = 1;
        const n = On();
        return n0 = (t, r, s) => n(t, r, s) >= 0,
        n0
    }
    var i0, lA;
    function a0() {
        if (lA)
            return i0;
        lA = 1;
        const n = On();
        return i0 = (t, r, s) => n(t, r, s) <= 0,
        i0
    }
    var o0, dA;
    function hA() {
        if (dA)
            return o0;
        dA = 1;
        const n = aA()
          , e = cA()
          , t = Vy()
          , r = s0()
          , s = e0()
          , i = a0();
        return o0 = (c, u, l, d) => {
            switch (u) {
            case "===":
                return typeof c == "object" && (c = c.version),
                typeof l == "object" && (l = l.version),
                c === l;
            case "!==":
                return typeof c == "object" && (c = c.version),
                typeof l == "object" && (l = l.version),
                c !== l;
            case "":
            case "=":
            case "==":
                return n(c, l, d);
            case "!=":
                return e(c, l, d);
            case ">":
                return t(c, l, d);
            case ">=":
                return r(c, l, d);
            case "<":
                return s(c, l, d);
            case "<=":
                return i(c, l, d);
            default:
                throw new TypeError(`Invalid operator: ${u}`)
            }
        }
        ,
        o0
    }
    var c0, fA;
    function N3() {
        if (fA)
            return c0;
        fA = 1;
        const n = Sr()
          , e = au()
          , {safeRe: t, t: r} = hh();
        return c0 = (i, a) => {
            if (i instanceof n)
                return i;
            if (typeof i == "number" && (i = String(i)),
            typeof i != "string")
                return null;
            a = a || {};
            let c = null;
            if (!a.rtl)
                c = i.match(a.includePrerelease ? t[r.COERCEFULL] : t[r.COERCE]);
            else {
                const p = a.includePrerelease ? t[r.COERCERTLFULL] : t[r.COERCERTL];
                let g;
                for (; (g = p.exec(i)) && (!c || c.index + c[0].length !== i.length); )
                    (!c || g.index + g[0].length !== c.index + c[0].length) && (c = g),
                    p.lastIndex = g.index + g[1].length + g[2].length;
                p.lastIndex = -1
            }
            if (c === null)
                return null;
            const u = c[2]
              , l = c[3] || "0"
              , d = c[4] || "0"
              , h = a.includePrerelease && c[5] ? `-${c[5]}` : ""
              , f = a.includePrerelease && c[6] ? `+${c[6]}` : "";
            return e(`${u}.${l}.${d}${h}${f}`, a)
        }
        ,
        c0
    }
    var u0, pA;
    function $3() {
        if (pA)
            return u0;
        pA = 1;
        class n {
            constructor() {
                this.max = 1e3,
                this.map = new Map
            }
            get(t) {
                const r = this.map.get(t);
                if (r !== void 0)
                    return this.map.delete(t),
                    this.map.set(t, r),
                    r
            }
            delete(t) {
                return this.map.delete(t)
            }
            set(t, r) {
                if (!this.delete(t) && r !== void 0) {
                    if (this.map.size >= this.max) {
                        const i = this.map.keys().next().value;
                        this.delete(i)
                    }
                    this.map.set(t, r)
                }
                return this
            }
        }
        return u0 = n,
        u0
    }
    var l0, mA;
    function Rn() {
        if (mA)
            return l0;
        mA = 1;
        const n = /\s+/g;
        class e {
            constructor(q, Z) {
                if (Z = s(Z),
                q instanceof e)
                    return q.loose === !!Z.loose && q.includePrerelease === !!Z.includePrerelease ? q : new e(q.raw,Z);
                if (q instanceof i)
                    return this.raw = q.value,
                    this.set = [[q]],
                    this.formatted = void 0,
                    this;
                if (this.options = Z,
                this.loose = !!Z.loose,
                this.includePrerelease = !!Z.includePrerelease,
                this.raw = q.trim().replace(n, " "),
                this.set = this.raw.split("||").map(j => this.parseRange(j.trim())).filter(j => j.length),
                !this.set.length)
                    throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
                if (this.set.length > 1) {
                    const j = this.set[0];
                    if (this.set = this.set.filter($ => !y($[0])),
                    this.set.length === 0)
                        this.set = [j];
                    else if (this.set.length > 1) {
                        for (const $ of this.set)
                            if ($.length === 1 && m($[0])) {
                                this.set = [$];
                                break
                            }
                    }
                }
                this.formatted = void 0
            }
            get range() {
                if (this.formatted === void 0) {
                    this.formatted = "";
                    for (let q = 0; q < this.set.length; q++) {
                        q > 0 && (this.formatted += "||");
                        const Z = this.set[q];
                        for (let j = 0; j < Z.length; j++)
                            j > 0 && (this.formatted += " "),
                            this.formatted += Z[j].toString().trim()
                    }
                }
                return this.formatted
            }
            format() {
                return this.range
            }
            toString() {
                return this.range
            }
            parseRange(q) {
                const j = ((this.options.includePrerelease && p) | (this.options.loose && g)) + ":" + q
                  , $ = r.get(j);
                if ($)
                    return $;
                const B = this.options.loose
                  , D = B ? u[l.HYPHENRANGELOOSE] : u[l.HYPHENRANGE];
                q = q.replace(D, O(this.options.includePrerelease)),
                a("hyphen replace", q),
                q = q.replace(u[l.COMPARATORTRIM], d),
                a("comparator trim", q),
                q = q.replace(u[l.TILDETRIM], h),
                a("tilde trim", q),
                q = q.replace(u[l.CARETTRIM], f),
                a("caret trim", q);
                let z = q.split(" ").map(K => E(K, this.options)).join(" ").split(/\s+/).map(K => F(K, this.options));
                B && (z = z.filter(K => (a("loose invalid filter", K, this.options),
                !!K.match(u[l.COMPARATORLOOSE])))),
                a("range list", z);
                const G = new Map
                  , ee = z.map(K => new i(K,this.options));
                for (const K of ee) {
                    if (y(K))
                        return [K];
                    G.set(K.value, K)
                }
                G.size > 1 && G.has("") && G.delete("");
                const V = [...G.values()];
                return r.set(j, V),
                V
            }
            intersects(q, Z) {
                if (!(q instanceof e))
                    throw new TypeError("a Range is required");
                return this.set.some(j => w(j, Z) && q.set.some($ => w($, Z) && j.every(B => $.every(D => B.intersects(D, Z)))))
            }
            test(q) {
                if (!q)
                    return !1;
                if (typeof q == "string")
                    try {
                        q = new c(q,this.options)
                    } catch {
                        return !1
                    }
                for (let Z = 0; Z < this.set.length; Z++)
                    if (T(this.set[Z], q, this.options))
                        return !0;
                return !1
            }
        }
        l0 = e;
        const t = $3()
          , r = new t
          , s = M_()
          , i = Gy()
          , a = zy()
          , c = Sr()
          , {safeRe: u, t: l, comparatorTrimReplace: d, tildeTrimReplace: h, caretTrimReplace: f} = hh()
          , {FLAG_INCLUDE_PRERELEASE: p, FLAG_LOOSE: g} = Wy()
          , y = L => L.value === "<0.0.0-0"
          , m = L => L.value === ""
          , w = (L, q) => {
            let Z = !0;
            const j = L.slice();
            let $ = j.pop();
            for (; Z && j.length; )
                Z = j.every(B => $.intersects(B, q)),
                $ = j.pop();
            return Z
        }
          , E = (L, q) => (a("comp", L, q),
        L = C(L, q),
        a("caret", L),
        L = _(L, q),
        a("tildes", L),
        L = x(L, q),
        a("xrange", L),
        L = R(L, q),
        a("stars", L),
        L)
          , v = L => !L || L.toLowerCase() === "x" || L === "*"
          , _ = (L, q) => L.trim().split(/\s+/).map(Z => A(Z, q)).join(" ")
          , A = (L, q) => {
            const Z = q.loose ? u[l.TILDELOOSE] : u[l.TILDE];
            return L.replace(Z, (j, $, B, D, z) => {
                a("tilde", L, j, $, B, D, z);
                let G;
                return v($) ? G = "" : v(B) ? G = `>=${$}.0.0 <${+$ + 1}.0.0-0` : v(D) ? G = `>=${$}.${B}.0 <${$}.${+B + 1}.0-0` : z ? (a("replaceTilde pr", z),
                G = `>=${$}.${B}.${D}-${z} <${$}.${+B + 1}.0-0`) : G = `>=${$}.${B}.${D} <${$}.${+B + 1}.0-0`,
                a("tilde return", G),
                G
            }
            )
        }
          , C = (L, q) => L.trim().split(/\s+/).map(Z => k(Z, q)).join(" ")
          , k = (L, q) => {
            a("caret", L, q);
            const Z = q.loose ? u[l.CARETLOOSE] : u[l.CARET]
              , j = q.includePrerelease ? "-0" : "";
            return L.replace(Z, ($, B, D, z, G) => {
                a("caret", L, $, B, D, z, G);
                let ee;
                return v(B) ? ee = "" : v(D) ? ee = `>=${B}.0.0${j} <${+B + 1}.0.0-0` : v(z) ? B === "0" ? ee = `>=${B}.${D}.0${j} <${B}.${+D + 1}.0-0` : ee = `>=${B}.${D}.0${j} <${+B + 1}.0.0-0` : G ? (a("replaceCaret pr", G),
                B === "0" ? D === "0" ? ee = `>=${B}.${D}.${z}-${G} <${B}.${D}.${+z + 1}-0` : ee = `>=${B}.${D}.${z}-${G} <${B}.${+D + 1}.0-0` : ee = `>=${B}.${D}.${z}-${G} <${+B + 1}.0.0-0`) : (a("no pr"),
                B === "0" ? D === "0" ? ee = `>=${B}.${D}.${z}${j} <${B}.${D}.${+z + 1}-0` : ee = `>=${B}.${D}.${z}${j} <${B}.${+D + 1}.0-0` : ee = `>=${B}.${D}.${z} <${+B + 1}.0.0-0`),
                a("caret return", ee),
                ee
            }
            )
        }
          , x = (L, q) => (a("replaceXRanges", L, q),
        L.split(/\s+/).map(Z => N(Z, q)).join(" "))
          , N = (L, q) => {
            L = L.trim();
            const Z = q.loose ? u[l.XRANGELOOSE] : u[l.XRANGE];
            return L.replace(Z, (j, $, B, D, z, G) => {
                a("xRange", L, j, $, B, D, z, G);
                const ee = v(B)
                  , V = ee || v(D)
                  , K = V || v(z)
                  , se = K;
                return $ === "=" && se && ($ = ""),
                G = q.includePrerelease ? "-0" : "",
                ee ? $ === ">" || $ === "<" ? j = "<0.0.0-0" : j = "*" : $ && se ? (V && (D = 0),
                z = 0,
                $ === ">" ? ($ = ">=",
                V ? (B = +B + 1,
                D = 0,
                z = 0) : (D = +D + 1,
                z = 0)) : $ === "<=" && ($ = "<",
                V ? B = +B + 1 : D = +D + 1),
                $ === "<" && (G = "-0"),
                j = `${$ + B}.${D}.${z}${G}`) : V ? j = `>=${B}.0.0${G} <${+B + 1}.0.0-0` : K && (j = `>=${B}.${D}.0${G} <${B}.${+D + 1}.0-0`),
                a("xRange return", j),
                j
            }
            )
        }
          , R = (L, q) => (a("replaceStars", L, q),
        L.trim().replace(u[l.STAR], ""))
          , F = (L, q) => (a("replaceGTE0", L, q),
        L.trim().replace(u[q.includePrerelease ? l.GTE0PRE : l.GTE0], ""))
          , O = L => (q, Z, j, $, B, D, z, G, ee, V, K, se) => (v(j) ? Z = "" : v($) ? Z = `>=${j}.0.0${L ? "-0" : ""}` : v(B) ? Z = `>=${j}.${$}.0${L ? "-0" : ""}` : D ? Z = `>=${Z}` : Z = `>=${Z}${L ? "-0" : ""}`,
        v(ee) ? G = "" : v(V) ? G = `<${+ee + 1}.0.0-0` : v(K) ? G = `<${ee}.${+V + 1}.0-0` : se ? G = `<=${ee}.${V}.${K}-${se}` : L ? G = `<${ee}.${V}.${+K + 1}-0` : G = `<=${G}`,
        `${Z} ${G}`.trim())
          , T = (L, q, Z) => {
            for (let j = 0; j < L.length; j++)
                if (!L[j].test(q))
                    return !1;
            if (q.prerelease.length && !Z.includePrerelease) {
                for (let j = 0; j < L.length; j++)
                    if (a(L[j].semver),
                    L[j].semver !== i.ANY && L[j].semver.prerelease.length > 0) {
                        const $ = L[j].semver;
                        if ($.major === q.major && $.minor === q.minor && $.patch === q.patch)
                            return !0
                    }
                return !1
            }
            return !0
        }
        ;
        return l0
    }
    var d0, gA;
    function Gy() {
        if (gA)
            return d0;
        gA = 1;
        const n = Symbol("SemVer ANY");
        class e {
            static get ANY() {
                return n
            }
            constructor(d, h) {
                if (h = t(h),
                d instanceof e) {
                    if (d.loose === !!h.loose)
                        return d;
                    d = d.value
                }
                d = d.trim().split(/\s+/).join(" "),
                a("comparator", d, h),
                this.options = h,
                this.loose = !!h.loose,
                this.parse(d),
                this.semver === n ? this.value = "" : this.value = this.operator + this.semver.version,
                a("comp", this)
            }
            parse(d) {
                const h = this.options.loose ? r[s.COMPARATORLOOSE] : r[s.COMPARATOR]
                  , f = d.match(h);
                if (!f)
                    throw new TypeError(`Invalid comparator: ${d}`);
                this.operator = f[1] !== void 0 ? f[1] : "",
                this.operator === "=" && (this.operator = ""),
                f[2] ? this.semver = new c(f[2],this.options.loose) : this.semver = n
            }
            toString() {
                return this.value
            }
            test(d) {
                if (a("Comparator.test", d, this.options.loose),
                this.semver === n || d === n)
                    return !0;
                if (typeof d == "string")
                    try {
                        d = new c(d,this.options)
                    } catch {
                        return !1
                    }
                return i(d, this.operator, this.semver, this.options)
            }
            intersects(d, h) {
                if (!(d instanceof e))
                    throw new TypeError("a Comparator is required");
                return this.operator === "" ? this.value === "" ? !0 : new u(d.value,h).test(this.value) : d.operator === "" ? d.value === "" ? !0 : new u(this.value,h).test(d.semver) : (h = t(h),
                h.includePrerelease && (this.value === "<0.0.0-0" || d.value === "<0.0.0-0") || !h.includePrerelease && (this.value.startsWith("<0.0.0") || d.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && d.operator.startsWith(">") || this.operator.startsWith("<") && d.operator.startsWith("<") || this.semver.version === d.semver.version && this.operator.includes("=") && d.operator.includes("=") || i(this.semver, "<", d.semver, h) && this.operator.startsWith(">") && d.operator.startsWith("<") || i(this.semver, ">", d.semver, h) && this.operator.startsWith("<") && d.operator.startsWith(">")))
            }
        }
        d0 = e;
        const t = M_()
          , {safeRe: r, t: s} = hh()
          , i = hA()
          , a = zy()
          , c = Sr()
          , u = Rn();
        return d0
    }
    var h0, yA;
    function Jy() {
        if (yA)
            return h0;
        yA = 1;
        const n = Rn();
        return h0 = (t, r, s) => {
            try {
                r = new n(r,s)
            } catch {
                return !1
            }
            return r.test(t)
        }
        ,
        h0
    }
    var f0, wA;
    function L3() {
        if (wA)
            return f0;
        wA = 1;
        const n = Rn();
        return f0 = (t, r) => new n(t,r).set.map(s => s.map(i => i.value).join(" ").trim().split(" ")),
        f0
    }
    var p0, bA;
    function F3() {
        if (bA)
            return p0;
        bA = 1;
        const n = Sr()
          , e = Rn();
        return p0 = (r, s, i) => {
            let a = null
              , c = null
              , u = null;
            try {
                u = new e(s,i)
            } catch {
                return null
            }
            return r.forEach(l => {
                u.test(l) && (!a || c.compare(l) === -1) && (a = l,
                c = new n(a,i))
            }
            ),
            a
        }
        ,
        p0
    }
    var m0, vA;
    function j3() {
        if (vA)
            return m0;
        vA = 1;
        const n = Sr()
          , e = Rn();
        return m0 = (r, s, i) => {
            let a = null
              , c = null
              , u = null;
            try {
                u = new e(s,i)
            } catch {
                return null
            }
            return r.forEach(l => {
                u.test(l) && (!a || c.compare(l) === 1) && (a = l,
                c = new n(a,i))
            }
            ),
            a
        }
        ,
        m0
    }
    var g0, _A;
    function D3() {
        if (_A)
            return g0;
        _A = 1;
        const n = Sr()
          , e = Rn()
          , t = Vy();
        return g0 = (s, i) => {
            s = new e(s,i);
            let a = new n("0.0.0");
            if (s.test(a) || (a = new n("0.0.0-0"),
            s.test(a)))
                return a;
            a = null;
            for (let c = 0; c < s.set.length; ++c) {
                const u = s.set[c];
                let l = null;
                u.forEach(d => {
                    const h = new n(d.semver.version);
                    switch (d.operator) {
                    case ">":
                        h.prerelease.length === 0 ? h.patch++ : h.prerelease.push(0),
                        h.raw = h.format();
                    case "":
                    case ">=":
                        (!l || t(h, l)) && (l = h);
                        break;
                    case "<":
                    case "<=":
                        break;
                    default:
                        throw new Error(`Unexpected operation: ${d.operator}`)
                    }
                }
                ),
                l && (!a || t(a, l)) && (a = l)
            }
            return a && s.test(a) ? a : null
        }
        ,
        g0
    }
    var y0, SA;
    function B3() {
        if (SA)
            return y0;
        SA = 1;
        const n = Rn();
        return y0 = (t, r) => {
            try {
                return new n(t,r).range || "*"
            } catch {
                return null
            }
        }
        ,
        y0
    }
    var w0, EA;
    function b0() {
        if (EA)
            return w0;
        EA = 1;
        const n = Sr()
          , e = Gy()
          , {ANY: t} = e
          , r = Rn()
          , s = Jy()
          , i = Vy()
          , a = e0()
          , c = a0()
          , u = s0();
        return w0 = (d, h, f, p) => {
            d = new n(d,p),
            h = new r(h,p);
            let g, y, m, w, E;
            switch (f) {
            case ">":
                g = i,
                y = c,
                m = a,
                w = ">",
                E = ">=";
                break;
            case "<":
                g = a,
                y = u,
                m = i,
                w = "<",
                E = "<=";
                break;
            default:
                throw new TypeError('Must provide a hilo val of "<" or ">"')
            }
            if (s(d, h, p))
                return !1;
            for (let v = 0; v < h.set.length; ++v) {
                const _ = h.set[v];
                let A = null
                  , C = null;
                if (_.forEach(k => {
                    k.semver === t && (k = new e(">=0.0.0")),
                    A = A || k,
                    C = C || k,
                    g(k.semver, A.semver, p) ? A = k : m(k.semver, C.semver, p) && (C = k)
                }
                ),
                A.operator === w || A.operator === E || (!C.operator || C.operator === w) && y(d, C.semver))
                    return !1;
                if (C.operator === E && m(d, C.semver))
                    return !1
            }
            return !0
        }
        ,
        w0
    }
    var v0, xA;
    function q3() {
        if (xA)
            return v0;
        xA = 1;
        const n = b0();
        return v0 = (t, r, s) => n(t, r, ">", s),
        v0
    }
    var _0, CA;
    function U3() {
        if (CA)
            return _0;
        CA = 1;
        const n = b0();
        return _0 = (t, r, s) => n(t, r, "<", s),
        _0
    }
    var S0, kA;
    function K3() {
        if (kA)
            return S0;
        kA = 1;
        const n = Rn();
        return S0 = (t, r, s) => (t = new n(t,s),
        r = new n(r,s),
        t.intersects(r, s)),
        S0
    }
    var E0, PA;
    function H3() {
        if (PA)
            return E0;
        PA = 1;
        const n = Jy()
          , e = On();
        return E0 = (t, r, s) => {
            const i = [];
            let a = null
              , c = null;
            const u = t.sort( (f, p) => e(f, p, s));
            for (const f of u)
                n(f, r, s) ? (c = f,
                a || (a = f)) : (c && i.push([a, c]),
                c = null,
                a = null);
            a && i.push([a, null]);
            const l = [];
            for (const [f,p] of i)
                f === p ? l.push(f) : !p && f === u[0] ? l.push("*") : p ? f === u[0] ? l.push(`<=${p}`) : l.push(`${f} - ${p}`) : l.push(`>=${f}`);
            const d = l.join(" || ")
              , h = typeof r.raw == "string" ? r.raw : String(r);
            return d.length < h.length ? d : r
        }
        ,
        E0
    }
    var x0, TA;
    function W3() {
        if (TA)
            return x0;
        TA = 1;
        const n = Rn()
          , e = Gy()
          , {ANY: t} = e
          , r = Jy()
          , s = On()
          , i = (h, f, p={}) => {
            if (h === f)
                return !0;
            h = new n(h,p),
            f = new n(f,p);
            let g = !1;
            e: for (const y of h.set) {
                for (const m of f.set) {
                    const w = u(y, m, p);
                    if (g = g || w !== null,
                    w)
                        continue e
                }
                if (g)
                    return !1
            }
            return !0
        }
          , a = [new e(">=0.0.0-0")]
          , c = [new e(">=0.0.0")]
          , u = (h, f, p) => {
            if (h === f)
                return !0;
            if (h.length === 1 && h[0].semver === t) {
                if (f.length === 1 && f[0].semver === t)
                    return !0;
                p.includePrerelease ? h = a : h = c
            }
            if (f.length === 1 && f[0].semver === t) {
                if (p.includePrerelease)
                    return !0;
                f = c
            }
            const g = new Set;
            let y, m;
            for (const x of h)
                x.operator === ">" || x.operator === ">=" ? y = l(y, x, p) : x.operator === "<" || x.operator === "<=" ? m = d(m, x, p) : g.add(x.semver);
            if (g.size > 1)
                return null;
            let w;
            if (y && m) {
                if (w = s(y.semver, m.semver, p),
                w > 0)
                    return null;
                if (w === 0 && (y.operator !== ">=" || m.operator !== "<="))
                    return null
            }
            for (const x of g) {
                if (y && !r(x, String(y), p) || m && !r(x, String(m), p))
                    return null;
                for (const N of f)
                    if (!r(x, String(N), p))
                        return !1;
                return !0
            }
            let E, v, _, A, C = m && !p.includePrerelease && m.semver.prerelease.length ? m.semver : !1, k = y && !p.includePrerelease && y.semver.prerelease.length ? y.semver : !1;
            C && C.prerelease.length === 1 && m.operator === "<" && C.prerelease[0] === 0 && (C = !1);
            for (const x of f) {
                if (A = A || x.operator === ">" || x.operator === ">=",
                _ = _ || x.operator === "<" || x.operator === "<=",
                y) {
                    if (k && x.semver.prerelease && x.semver.prerelease.length && x.semver.major === k.major && x.semver.minor === k.minor && x.semver.patch === k.patch && (k = !1),
                    x.operator === ">" || x.operator === ">=") {
                        if (E = l(y, x, p),
                        E === x && E !== y)
                            return !1
                    } else if (y.operator === ">=" && !r(y.semver, String(x), p))
                        return !1
                }
                if (m) {
                    if (C && x.semver.prerelease && x.semver.prerelease.length && x.semver.major === C.major && x.semver.minor === C.minor && x.semver.patch === C.patch && (C = !1),
                    x.operator === "<" || x.operator === "<=") {
                        if (v = d(m, x, p),
                        v === x && v !== m)
                            return !1
                    } else if (m.operator === "<=" && !r(m.semver, String(x), p))
                        return !1
                }
                if (!x.operator && (m || y) && w !== 0)
                    return !1
            }
            return !(y && _ && !m && w !== 0 || m && A && !y && w !== 0 || k || C)
        }
          , l = (h, f, p) => {
            if (!h)
                return f;
            const g = s(h.semver, f.semver, p);
            return g > 0 ? h : g < 0 || f.operator === ">" && h.operator === ">=" ? f : h
        }
          , d = (h, f, p) => {
            if (!h)
                return f;
            const g = s(h.semver, f.semver, p);
            return g < 0 ? h : g > 0 || f.operator === "<" && h.operator === "<=" ? f : h
        }
        ;
        return x0 = i,
        x0
    }
    var C0, AA;
    function z3() {
        if (AA)
            return C0;
        AA = 1;
        const n = hh()
          , e = Wy()
          , t = Sr()
          , r = BT()
          , s = au()
          , i = S3()
          , a = E3()
          , c = x3()
          , u = C3()
          , l = k3()
          , d = P3()
          , h = T3()
          , f = A3()
          , p = On()
          , g = I3()
          , y = O3()
          , m = J_()
          , w = R3()
          , E = M3()
          , v = Vy()
          , _ = e0()
          , A = aA()
          , C = cA()
          , k = s0()
          , x = a0()
          , N = hA()
          , R = N3()
          , F = Gy()
          , O = Rn()
          , T = Jy()
          , L = L3()
          , q = F3()
          , Z = j3()
          , j = D3()
          , $ = B3()
          , B = b0()
          , D = q3()
          , z = U3()
          , G = K3()
          , ee = H3()
          , V = W3();
        return C0 = {
            parse: s,
            valid: i,
            clean: a,
            inc: c,
            diff: u,
            major: l,
            minor: d,
            patch: h,
            prerelease: f,
            compare: p,
            rcompare: g,
            compareLoose: y,
            compareBuild: m,
            sort: w,
            rsort: E,
            gt: v,
            lt: _,
            eq: A,
            neq: C,
            gte: k,
            lte: x,
            cmp: N,
            coerce: R,
            Comparator: F,
            Range: O,
            satisfies: T,
            toComparators: L,
            maxSatisfying: q,
            minSatisfying: Z,
            minVersion: j,
            validRange: $,
            outside: B,
            gtr: D,
            ltr: z,
            intersects: G,
            simplifyRange: ee,
            subset: V,
            SemVer: t,
            re: n.re,
            src: n.src,
            tokens: n.t,
            SEMVER_SPEC_VERSION: e.SEMVER_SPEC_VERSION,
            RELEASE_TYPES: e.RELEASE_TYPES,
            compareIdentifiers: r.compareIdentifiers,
            rcompareIdentifiers: r.rcompareIdentifiers
        },
        C0
    }
    z3();
    function $i(n) {
        if (!n || n.split("/").length > 2 || n.startsWith("/") || n.endsWith("/") || n.split(":").length > 2)
            throw new Error(`Invalid identifier format: ${n}`);
        const [e,t] = n.split(":")
          , r = t || "latest";
        if (e.includes("/")) {
            const [s,i] = e.split("/", 2);
            if (!s || !i)
                throw new Error(`Invalid identifier format: ${n}`);
            return [s, i, r]
        } else {
            if (!e)
                throw new Error(`Invalid identifier format: ${n}`);
            return ["-", e, r]
        }
    }
    class V3 extends Error {
        constructor(e) {
            super(e),
            this.name = "LangSmithConflictError"
        }
    }
    async function Me(n, e, t) {
        let r;
        if (n.ok) {
            t && (r = await n.text());
            return
        }
        r = await n.text();
        const s = `Failed to ${e}. Received status [${n.status}]: ${n.statusText}. Server response: ${r}`;
        throw n.status === 409 ? new V3(s) : new Error(s)
    }
    var IA = "[...]"
      , G3 = {
        result: "[Circular]"
    }
      , Zy = []
      , ou = [];
    function J3() {
        return {
            depthLimit: Number.MAX_SAFE_INTEGER,
            edgesLimit: Number.MAX_SAFE_INTEGER
        }
    }
    function Xr(n, e, t, r) {
        var a;
        try {
            return JSON.stringify(n, e, t)
        } catch (c) {
            if (!((a = c.message) != null && a.includes("Converting circular structure to JSON")))
                return console.warn("[WARNING]: LangSmith received unserializable value."),
                "[Unserializable]";
            console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance."),
            typeof r > "u" && (r = J3()),
            P0(n, "", 0, [], void 0, 0, r);
            var s;
            try {
                ou.length === 0 ? s = JSON.stringify(n, e, t) : s = JSON.stringify(n, Z3(e), t)
            } catch {
                return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]")
            } finally {
                for (; Zy.length !== 0; ) {
                    var i = Zy.pop();
                    i.length === 4 ? Object.defineProperty(i[0], i[1], i[3]) : i[0][i[1]] = i[2]
                }
            }
            return s
        }
    }
    function k0(n, e, t, r) {
        var s = Object.getOwnPropertyDescriptor(r, t);
        s.get !== void 0 ? s.configurable ? (Object.defineProperty(r, t, {
            value: n
        }),
        Zy.push([r, t, e, s])) : ou.push([e, t, n]) : (r[t] = n,
        Zy.push([r, t, e]))
    }
    function P0(n, e, t, r, s, i, a) {
        i += 1;
        var c;
        if (typeof n == "object" && n !== null) {
            for (c = 0; c < r.length; c++)
                if (r[c] === n) {
                    k0(G3, n, e, s);
                    return
                }
            if (typeof a.depthLimit < "u" && i > a.depthLimit) {
                k0(IA, n, e, s);
                return
            }
            if (typeof a.edgesLimit < "u" && t + 1 > a.edgesLimit) {
                k0(IA, n, e, s);
                return
            }
            if (r.push(n),
            Array.isArray(n))
                for (c = 0; c < n.length; c++)
                    P0(n[c], c, c, r, n, i, a);
            else {
                var u = Object.keys(n);
                for (c = 0; c < u.length; c++) {
                    var l = u[c];
                    P0(n[l], l, c, r, n, i, a)
                }
            }
            r.pop()
        }
    }
    function Z3(n) {
        return n = typeof n < "u" ? n : function(e, t) {
            return t
        }
        ,
        function(e, t) {
            if (ou.length > 0)
                for (var r = 0; r < ou.length; r++) {
                    var s = ou[r];
                    if (s[1] === e && s[0] === t) {
                        t = s[2],
                        ou.splice(r, 1);
                        break
                    }
                }
            return n.call(this, e, t)
        }
    }
    function OA(n) {
        const e = NA()
          , t = u2()
          , r = n.extra ?? {}
          , s = r.metadata;
        return n.extra = {
            ...r,
            runtime: {
                ...e,
                ...r == null ? void 0 : r.runtime
            },
            metadata: {
                ...t,
                ...t.revision_id || n.revision_id ? {
                    revision_id: n.revision_id ?? t.revision_id
                } : {},
                ...s
            }
        },
        n
    }
    const X3 = () => {
        const n = Li("TRACING_SAMPLING_RATE");
        if (n === void 0)
            return;
        const e = parseFloat(n);
        if (e < 0 || e > 1)
            throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${e}`);
        return e
    }
      , Y3 = n => {
        const t = n.replace("http://", "").replace("https://", "").split("/")[0].split(":")[0];
        return t === "localhost" || t === "127.0.0.1" || t === "::1"
    }
    ;
    async function Q3(n) {
        const e = [];
        for await(const t of n)
            e.push(t);
        return e
    }
    function T0(n) {
        if (n !== void 0)
            return n.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1")
    }
    const e2 = async n => {
        if ((n == null ? void 0 : n.status) === 429) {
            const e = parseInt(n.headers.get("retry-after") ?? "30", 10) * 1e3;
            if (e > 0)
                return await new Promise(t => setTimeout(t, e)),
                !0
        }
        return !1
    }
    ;
    class t2 {
        constructor() {
            Object.defineProperty(this, "items", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "sizeBytes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 0
            })
        }
        peek() {
            return this.items[0]
        }
        push(e) {
            let t;
            const r = new Promise(i => {
                t = i
            }
            )
              , s = Xr(e.item).length;
            return this.items.push({
                action: e.action,
                payload: e.item,
                itemPromiseResolve: t,
                itemPromise: r,
                size: s
            }),
            this.sizeBytes += s,
            r
        }
        pop(e) {
            var s;
            if (e < 1)
                throw new Error("Number of bytes to pop off may not be less than 1.");
            const t = [];
            let r = 0;
            for (; r + (((s = this.peek()) == null ? void 0 : s.size) ?? 0) < e && this.items.length > 0; ) {
                const i = this.items.shift();
                i && (t.push(i),
                r += i.size,
                this.sizeBytes -= i.size)
            }
            if (t.length === 0 && this.items.length > 0) {
                const i = this.items.shift();
                t.push(i),
                r += i.size,
                this.sizeBytes -= i.size
            }
            return [t.map(i => ({
                action: i.action,
                item: i.payload
            })), () => t.forEach(i => i.itemPromiseResolve())]
        }
    }
    const r2 = 20971520
      , n2 = 2500;
    class fh {
        constructor(e={}) {
            var r;
            Object.defineProperty(this, "apiKey", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "apiUrl", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "webUrl", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "caller", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "batchIngestCaller", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "timeout_ms", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "_tenantId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: null
            }),
            Object.defineProperty(this, "hideInputs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "hideOutputs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tracingSampleRate", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "filteredPostUuids", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: new Set
            }),
            Object.defineProperty(this, "autoBatchTracing", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "autoBatchQueue", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: new t2
            }),
            Object.defineProperty(this, "autoBatchTimeout", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "autoBatchAggregationDelayMs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 250
            }),
            Object.defineProperty(this, "batchSizeBytesLimit", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "fetchOptions", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "settings", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "blockOnRootRunFinalization", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: io("LANGSMITH_TRACING_BACKGROUND") === "false"
            }),
            Object.defineProperty(this, "traceBatchConcurrency", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 5
            }),
            Object.defineProperty(this, "_serverInfo", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "_getServerInfoPromise", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "manualFlushMode", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            });
            const t = fh.getDefaultClientConfig();
            if (this.tracingSampleRate = X3(),
            this.apiUrl = T0(e.apiUrl ?? t.apiUrl) ?? "",
            this.apiUrl.endsWith("/") && (this.apiUrl = this.apiUrl.slice(0, -1)),
            this.apiKey = T0(e.apiKey ?? t.apiKey),
            this.webUrl = T0(e.webUrl ?? t.webUrl),
            (r = this.webUrl) != null && r.endsWith("/") && (this.webUrl = this.webUrl.slice(0, -1)),
            this.timeout_ms = e.timeout_ms ?? 9e4,
            this.caller = new IT(e.callerOptions ?? {}),
            this.traceBatchConcurrency = e.traceBatchConcurrency ?? this.traceBatchConcurrency,
            this.traceBatchConcurrency < 1)
                throw new Error("Trace batch concurrency must be positive.");
            this.batchIngestCaller = new IT({
                maxRetries: 2,
                maxConcurrency: this.traceBatchConcurrency,
                ...e.callerOptions ?? {},
                onFailedResponseHook: e2
            }),
            this.hideInputs = e.hideInputs ?? e.anonymizer ?? t.hideInputs,
            this.hideOutputs = e.hideOutputs ?? e.anonymizer ?? t.hideOutputs,
            this.autoBatchTracing = e.autoBatchTracing ?? this.autoBatchTracing,
            this.blockOnRootRunFinalization = e.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization,
            this.batchSizeBytesLimit = e.batchSizeBytesLimit,
            this.fetchOptions = e.fetchOptions || {},
            this.manualFlushMode = e.manualFlushMode ?? this.manualFlushMode
        }
        static getDefaultClientConfig() {
            const e = Li("API_KEY")
              , t = Li("ENDPOINT") ?? "https://api.smith.langchain.com"
              , r = Li("HIDE_INPUTS") === "true"
              , s = Li("HIDE_OUTPUTS") === "true";
            return {
                apiUrl: t,
                apiKey: e,
                webUrl: void 0,
                hideInputs: r,
                hideOutputs: s
            }
        }
        getHostUrl() {
            return this.webUrl ? this.webUrl : Y3(this.apiUrl) ? (this.webUrl = "http://localhost:3000",
            this.webUrl) : this.apiUrl.endsWith("/api/v1") ? (this.webUrl = this.apiUrl.replace("/api/v1", ""),
            this.webUrl) : this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api") ? (this.webUrl = this.apiUrl.replace("/api", ""),
            this.webUrl) : this.apiUrl.split(".", 1)[0].includes("dev") ? (this.webUrl = "https://dev.smith.langchain.com",
            this.webUrl) : this.apiUrl.split(".", 1)[0].includes("eu") ? (this.webUrl = "https://eu.smith.langchain.com",
            this.webUrl) : this.apiUrl.split(".", 1)[0].includes("beta") ? (this.webUrl = "https://beta.smith.langchain.com",
            this.webUrl) : (this.webUrl = "https://smith.langchain.com",
            this.webUrl)
        }
        get headers() {
            const e = {
                "User-Agent": `langsmith-js/${RA}`
            };
            return this.apiKey && (e["x-api-key"] = `${this.apiKey}`),
            e
        }
        processInputs(e) {
            return this.hideInputs === !1 ? e : this.hideInputs === !0 ? {} : typeof this.hideInputs == "function" ? this.hideInputs(e) : e
        }
        processOutputs(e) {
            return this.hideOutputs === !1 ? e : this.hideOutputs === !0 ? {} : typeof this.hideOutputs == "function" ? this.hideOutputs(e) : e
        }
        prepareRunCreateOrUpdateInputs(e) {
            const t = {
                ...e
            };
            return t.inputs !== void 0 && (t.inputs = this.processInputs(t.inputs)),
            t.outputs !== void 0 && (t.outputs = this.processOutputs(t.outputs)),
            t
        }
        async _getResponse(e, t) {
            const r = (t == null ? void 0 : t.toString()) ?? ""
              , s = `${this.apiUrl}${e}?${r}`
              , i = await this.caller.call(_e(), s, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(i, `Failed to fetch ${e}`),
            i
        }
        async _get(e, t) {
            return (await this._getResponse(e, t)).json()
        }
        async*_getPaginated(e, t=new URLSearchParams, r) {
            let s = Number(t.get("offset")) || 0;
            const i = Number(t.get("limit")) || 100;
            for (; ; ) {
                t.set("offset", String(s)),
                t.set("limit", String(i));
                const a = `${this.apiUrl}${e}?${t}`
                  , c = await this.caller.call(_e(), a, {
                    method: "GET",
                    headers: this.headers,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await Me(c, `Failed to fetch ${e}`);
                const u = r ? r(await c.json()) : await c.json();
                if (u.length === 0 || (yield u,
                u.length < i))
                    break;
                s += u.length
            }
        }
        async*_getCursorPaginatedList(e, t=null, r="POST", s="runs") {
            const i = t ? {
                ...t
            } : {};
            for (; ; ) {
                const c = await (await this.caller.call(_e(), `${this.apiUrl}${e}`, {
                    method: r,
                    headers: {
                        ...this.headers,
                        "Content-Type": "application/json"
                    },
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions,
                    body: JSON.stringify(i)
                })).json();
                if (!c || !c[s])
                    break;
                yield c[s];
                const u = c.cursors;
                if (!u || !u.next)
                    break;
                i.cursor = u.next
            }
        }
        _filterForSampling(e, t=!1) {
            if (this.tracingSampleRate === void 0)
                return e;
            if (t) {
                const r = [];
                for (const s of e)
                    this.filteredPostUuids.has(s.id) ? this.filteredPostUuids.delete(s.id) : r.push(s);
                return r
            } else {
                const r = [];
                for (const s of e)
                    s.id !== s.trace_id && !this.filteredPostUuids.has(s.trace_id) || Math.random() < this.tracingSampleRate ? r.push(s) : this.filteredPostUuids.add(s.id);
                return r
            }
        }
        async _getBatchSizeLimitBytes() {
            var t;
            const e = await this._ensureServerInfo();
            return this.batchSizeBytesLimit ?? ((t = e.batch_ingest_config) == null ? void 0 : t.size_limit_bytes) ?? r2
        }
        async _getMultiPartSupport() {
            var t;
            return ((t = (await this._ensureServerInfo()).instance_flags) == null ? void 0 : t.dataset_examples_multipart_enabled) ?? !1
        }
        drainAutoBatchQueue(e) {
            const t = [];
            for (; this.autoBatchQueue.items.length > 0; ) {
                const [r,s] = this.autoBatchQueue.pop(e);
                if (!r.length) {
                    s();
                    break
                }
                const i = this._processBatch(r, s).catch(console.error);
                t.push(i)
            }
            return Promise.all(t)
        }
        async _processBatch(e, t) {
            var r;
            if (!e.length) {
                t();
                return
            }
            try {
                const s = {
                    runCreates: e.filter(a => a.action === "create").map(a => a.item),
                    runUpdates: e.filter(a => a.action === "update").map(a => a.item)
                }
                  , i = await this._ensureServerInfo();
                (r = i == null ? void 0 : i.batch_ingest_config) != null && r.use_multipart_endpoint ? await this.multipartIngestRuns(s) : await this.batchIngestRuns(s)
            } finally {
                t()
            }
        }
        async processRunOperation(e) {
            clearTimeout(this.autoBatchTimeout),
            this.autoBatchTimeout = void 0,
            e.action === "create" && (e.item = OA(e.item));
            const t = this.autoBatchQueue.push(e);
            if (this.manualFlushMode)
                return t;
            const r = await this._getBatchSizeLimitBytes();
            return this.autoBatchQueue.sizeBytes > r && this.drainAutoBatchQueue(r),
            this.autoBatchQueue.items.length > 0 && (this.autoBatchTimeout = setTimeout( () => {
                this.autoBatchTimeout = void 0,
                this.drainAutoBatchQueue(r)
            }
            , this.autoBatchAggregationDelayMs)),
            t
        }
        async _getServerInfo() {
            const e = await _e()(`${this.apiUrl}/info`, {
                method: "GET",
                headers: {
                    Accept: "application/json"
                },
                signal: AbortSignal.timeout(n2),
                ...this.fetchOptions
            });
            return await Me(e, "get server info"),
            e.json()
        }
        async _ensureServerInfo() {
            return this._getServerInfoPromise === void 0 && (this._getServerInfoPromise = (async () => {
                if (this._serverInfo === void 0)
                    try {
                        this._serverInfo = await this._getServerInfo()
                    } catch {
                        console.warn("[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.")
                    }
                return this._serverInfo ?? {}
            }
            )()),
            this._getServerInfoPromise.then(e => (this._serverInfo === void 0 && (this._getServerInfoPromise = void 0),
            e))
        }
        async _getSettings() {
            return this.settings || (this.settings = this._get("/settings")),
            await this.settings
        }
        async flush() {
            const e = await this._getBatchSizeLimitBytes();
            await this.drainAutoBatchQueue(e)
        }
        async createRun(e) {
            if (!this._filterForSampling([e]).length)
                return;
            const t = {
                ...this.headers,
                "Content-Type": "application/json"
            }
              , r = e.project_name;
            delete e.project_name;
            const s = this.prepareRunCreateOrUpdateInputs({
                session_name: r,
                ...e,
                start_time: e.start_time ?? Date.now()
            });
            if (this.autoBatchTracing && s.trace_id !== void 0 && s.dotted_order !== void 0) {
                this.processRunOperation({
                    action: "create",
                    item: s
                }).catch(console.error);
                return
            }
            const i = OA(s)
              , a = await this.caller.call(_e(), `${this.apiUrl}/runs`, {
                method: "POST",
                headers: t,
                body: Xr(i),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(a, "create run", !0)
        }
        async batchIngestRuns({runCreates: e, runUpdates: t}) {
            if (e === void 0 && t === void 0)
                return;
            let r = (e == null ? void 0 : e.map(c => this.prepareRunCreateOrUpdateInputs(c))) ?? []
              , s = (t == null ? void 0 : t.map(c => this.prepareRunCreateOrUpdateInputs(c))) ?? [];
            if (r.length > 0 && s.length > 0) {
                const c = r.reduce( (l, d) => (d.id && (l[d.id] = d),
                l), {})
                  , u = [];
                for (const l of s)
                    l.id !== void 0 && c[l.id] ? c[l.id] = {
                        ...c[l.id],
                        ...l
                    } : u.push(l);
                r = Object.values(c),
                s = u
            }
            const i = {
                post: this._filterForSampling(r),
                patch: this._filterForSampling(s, !0)
            };
            if (!i.post.length && !i.patch.length)
                return;
            const a = {
                post: [],
                patch: []
            };
            for (const c of ["post", "patch"]) {
                const u = c
                  , l = i[u].reverse();
                let d = l.pop();
                for (; d !== void 0; )
                    a[u].push(d),
                    d = l.pop()
            }
            (a.post.length > 0 || a.patch.length > 0) && await this._postBatchIngestRuns(Xr(a))
        }
        async _postBatchIngestRuns(e) {
            const t = {
                ...this.headers,
                "Content-Type": "application/json",
                Accept: "application/json"
            }
              , r = await this.batchIngestCaller.call(_e(), `${this.apiUrl}/runs/batch`, {
                method: "POST",
                headers: t,
                body: e,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(r, "batch create run", !0)
        }
        async multipartIngestRuns({runCreates: e, runUpdates: t}) {
            if (e === void 0 && t === void 0)
                return;
            const r = {};
            let s = [];
            for (const d of e ?? []) {
                const h = this.prepareRunCreateOrUpdateInputs(d);
                h.id !== void 0 && h.attachments !== void 0 && (r[h.id] = h.attachments),
                delete h.attachments,
                s.push(h)
            }
            let i = [];
            for (const d of t ?? [])
                i.push(this.prepareRunCreateOrUpdateInputs(d));
            if (s.find(d => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
                throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');
            if (i.find(d => d.trace_id === void 0 || d.dotted_order === void 0) !== void 0)
                throw new Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');
            if (s.length > 0 && i.length > 0) {
                const d = s.reduce( (f, p) => (p.id && (f[p.id] = p),
                f), {})
                  , h = [];
                for (const f of i)
                    f.id !== void 0 && d[f.id] ? d[f.id] = {
                        ...d[f.id],
                        ...f
                    } : h.push(f);
                s = Object.values(d),
                i = h
            }
            if (s.length === 0 && i.length === 0)
                return;
            const u = []
              , l = [];
            for (const [d,h] of [["post", s], ["patch", i]])
                for (const f of h) {
                    const {inputs: p, outputs: g, events: y, attachments: m, ...w} = f
                      , E = {
                        inputs: p,
                        outputs: g,
                        events: y
                    }
                      , v = Xr(w);
                    l.push({
                        name: `${d}.${w.id}`,
                        payload: new Blob([v],{
                            type: `application/json; length=${v.length}`
                        })
                    });
                    for (const [_,A] of Object.entries(E)) {
                        if (A === void 0)
                            continue;
                        const C = Xr(A);
                        l.push({
                            name: `${d}.${w.id}.${_}`,
                            payload: new Blob([C],{
                                type: `application/json; length=${C.length}`
                            })
                        })
                    }
                    if (w.id !== void 0) {
                        const _ = r[w.id];
                        if (_) {
                            delete r[w.id];
                            for (const [A,C] of Object.entries(_)) {
                                let k, x;
                                if (Array.isArray(C) ? [k,x] = C : (k = C.mimeType,
                                x = C.data),
                                A.includes(".")) {
                                    console.warn(`Skipping attachment '${A}' for run ${w.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                                    continue
                                }
                                l.push({
                                    name: `attachment.${w.id}.${A}`,
                                    payload: new Blob([x],{
                                        type: `${k}; length=${x.byteLength}`
                                    })
                                })
                            }
                        }
                    }
                    u.push(`trace=${w.trace_id},id=${w.id}`)
                }
            await this._sendMultipartRequest(l, u.join("; "))
        }
        async _sendMultipartRequest(e, t) {
            try {
                const r = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2)
                  , s = [];
                for (const u of e)
                    s.push(new Blob([`--${r}\r
`])),
                    s.push(new Blob([`Content-Disposition: form-data; name="${u.name}"\r
`, `Content-Type: ${u.payload.type}\r
\r
`])),
                    s.push(u.payload),
                    s.push(new Blob([`\r
`]));
                s.push(new Blob([`--${r}--\r
`]));
                const a = await new Blob(s).arrayBuffer()
                  , c = await this.batchIngestCaller.call(_e(), `${this.apiUrl}/runs/multipart`, {
                    method: "POST",
                    headers: {
                        ...this.headers,
                        "Content-Type": `multipart/form-data; boundary=${r}`
                    },
                    body: a,
                    signal: AbortSignal.timeout(this.timeout_ms),
                    ...this.fetchOptions
                });
                await Me(c, "ingest multipart runs", !0)
            } catch (r) {
                console.warn(`${r.message.trim()}

Context: ${t}`)
            }
        }
        async updateRun(e, t) {
            Ne(e),
            t.inputs && (t.inputs = this.processInputs(t.inputs)),
            t.outputs && (t.outputs = this.processOutputs(t.outputs));
            const r = {
                ...t,
                id: e
            };
            if (!this._filterForSampling([r], !0).length)
                return;
            if (this.autoBatchTracing && r.trace_id !== void 0 && r.dotted_order !== void 0) {
                if (t.end_time !== void 0 && r.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
                    await this.processRunOperation({
                        action: "update",
                        item: r
                    }).catch(console.error);
                    return
                } else
                    this.processRunOperation({
                        action: "update",
                        item: r
                    }).catch(console.error);
                return
            }
            const s = {
                ...this.headers,
                "Content-Type": "application/json"
            }
              , i = await this.caller.call(_e(), `${this.apiUrl}/runs/${e}`, {
                method: "PATCH",
                headers: s,
                body: Xr(t),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(i, "update run", !0)
        }
        async readRun(e, {loadChildRuns: t}={
            loadChildRuns: !1
        }) {
            Ne(e);
            let r = await this._get(`/runs/${e}`);
            return t && r.child_run_ids && (r = await this._loadChildRuns(r)),
            r
        }
        async getRunUrl({runId: e, run: t, projectOpts: r}) {
            if (t !== void 0) {
                let s;
                t.session_id ? s = t.session_id : r != null && r.projectName ? s = (await this.readProject({
                    projectName: r == null ? void 0 : r.projectName
                })).id : r != null && r.projectId ? s = r == null ? void 0 : r.projectId : s = (await this.readProject({
                    projectName: Li("PROJECT") || "default"
                })).id;
                const i = await this._getTenantId();
                return `${this.getHostUrl()}/o/${i}/projects/p/${s}/r/${t.id}?poll=true`
            } else if (e !== void 0) {
                const s = await this.readRun(e);
                if (!s.app_path)
                    throw new Error(`Run ${e} has no app_path`);
                return `${this.getHostUrl()}${s.app_path}`
            } else
                throw new Error("Must provide either runId or run")
        }
        async _loadChildRuns(e) {
            const t = await Q3(this.listRuns({
                id: e.child_run_ids
            }))
              , r = {}
              , s = {};
            t.sort( (i, a) => ((i == null ? void 0 : i.dotted_order) ?? "").localeCompare((a == null ? void 0 : a.dotted_order) ?? ""));
            for (const i of t) {
                if (i.parent_run_id === null || i.parent_run_id === void 0)
                    throw new Error(`Child run ${i.id} has no parent`);
                i.parent_run_id in r || (r[i.parent_run_id] = []),
                r[i.parent_run_id].push(i),
                s[i.id] = i
            }
            e.child_runs = r[e.id] || [];
            for (const i in r)
                i !== e.id && (s[i].child_runs = r[i]);
            return e
        }
        async*listRuns(e) {
            const {projectId: t, projectName: r, parentRunId: s, traceId: i, referenceExampleId: a, startTime: c, executionOrder: u, isRoot: l, runType: d, error: h, id: f, query: p, filter: g, traceFilter: y, treeFilter: m, limit: w, select: E} = e;
            let v = [];
            if (t && (v = Array.isArray(t) ? t : [t]),
            r) {
                const k = Array.isArray(r) ? r : [r]
                  , x = await Promise.all(k.map(N => this.readProject({
                    projectName: N
                }).then(R => R.id)));
                v.push(...x)
            }
            const _ = ["app_path", "child_run_ids", "completion_cost", "completion_tokens", "dotted_order", "end_time", "error", "events", "extra", "feedback_stats", "first_token_time", "id", "inputs", "name", "outputs", "parent_run_id", "parent_run_ids", "prompt_cost", "prompt_tokens", "reference_example_id", "run_type", "session_id", "start_time", "status", "tags", "total_cost", "total_tokens", "trace_id"]
              , A = {
                session: v.length ? v : null,
                run_type: d,
                reference_example: a,
                query: p,
                filter: g,
                trace_filter: y,
                tree_filter: m,
                execution_order: u,
                parent_run: s,
                start_time: c ? c.toISOString() : null,
                error: h,
                id: f,
                limit: w,
                trace: i,
                select: E || _,
                is_root: l
            };
            let C = 0;
            for await(const k of this._getCursorPaginatedList("/runs/query", A))
                if (w) {
                    if (C >= w)
                        break;
                    if (k.length + C > w) {
                        yield*k.slice(0, w - C);
                        break
                    }
                    C += k.length,
                    yield*k
                } else
                    yield*k
        }
        async getRunStats({id: e, trace: t, parentRun: r, runType: s, projectNames: i, projectIds: a, referenceExampleIds: c, startTime: u, endTime: l, error: d, query: h, filter: f, traceFilter: p, treeFilter: g, isRoot: y, dataSourceType: m}) {
            let w = a || [];
            i && (w = [...a || [], ...await Promise.all(i.map(C => this.readProject({
                projectName: C
            }).then(k => k.id)))]);
            const v = Object.fromEntries(Object.entries({
                id: e,
                trace: t,
                parent_run: r,
                run_type: s,
                session: w,
                reference_example: c,
                start_time: u,
                end_time: l,
                error: d,
                query: h,
                filter: f,
                trace_filter: p,
                tree_filter: g,
                is_root: y,
                data_source_type: m
            }).filter( ([C,k]) => k !== void 0));
            return await (await this.caller.call(_e(), `${this.apiUrl}/runs/stats`, {
                method: "POST",
                headers: this.headers,
                body: JSON.stringify(v),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json()
        }
        async shareRun(e, {shareId: t}={}) {
            const r = {
                run_id: e,
                share_token: t || Rr()
            };
            Ne(e);
            const i = await (await this.caller.call(_e(), `${this.apiUrl}/runs/${e}/share`, {
                method: "PUT",
                headers: this.headers,
                body: JSON.stringify(r),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json();
            if (i === null || !("share_token"in i))
                throw new Error("Invalid response from server");
            return `${this.getHostUrl()}/public/${i.share_token}/r`
        }
        async unshareRun(e) {
            Ne(e);
            const t = await this.caller.call(_e(), `${this.apiUrl}/runs/${e}/share`, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(t, "unshare run", !0)
        }
        async readRunSharedLink(e) {
            Ne(e);
            const r = await (await this.caller.call(_e(), `${this.apiUrl}/runs/${e}/share`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json();
            if (!(r === null || !("share_token"in r)))
                return `${this.getHostUrl()}/public/${r.share_token}/r`
        }
        async listSharedRuns(e, {runIds: t}={}) {
            const r = new URLSearchParams({
                share_token: e
            });
            if (t !== void 0)
                for (const a of t)
                    r.append("id", a);
            return Ne(e),
            await (await this.caller.call(_e(), `${this.apiUrl}/public/${e}/runs${r}`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json()
        }
        async readDatasetSharedSchema(e, t) {
            if (!e && !t)
                throw new Error("Either datasetId or datasetName must be given");
            e || (e = (await this.readDataset({
                datasetName: t
            })).id),
            Ne(e);
            const s = await (await this.caller.call(_e(), `${this.apiUrl}/datasets/${e}/share`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json();
            return s.url = `${this.getHostUrl()}/public/${s.share_token}/d`,
            s
        }
        async shareDataset(e, t) {
            if (!e && !t)
                throw new Error("Either datasetId or datasetName must be given");
            e || (e = (await this.readDataset({
                datasetName: t
            })).id);
            const r = {
                dataset_id: e
            };
            Ne(e);
            const i = await (await this.caller.call(_e(), `${this.apiUrl}/datasets/${e}/share`, {
                method: "PUT",
                headers: this.headers,
                body: JSON.stringify(r),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json();
            return i.url = `${this.getHostUrl()}/public/${i.share_token}/d`,
            i
        }
        async unshareDataset(e) {
            Ne(e);
            const t = await this.caller.call(_e(), `${this.apiUrl}/datasets/${e}/share`, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(t, "unshare dataset", !0)
        }
        async readSharedDataset(e) {
            return Ne(e),
            await (await this.caller.call(_e(), `${this.apiUrl}/public/${e}/datasets`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json()
        }
        async listSharedExamples(e, t) {
            const r = {};
            t != null && t.exampleIds && (r.id = t.exampleIds);
            const s = new URLSearchParams;
            Object.entries(r).forEach( ([c,u]) => {
                Array.isArray(u) ? u.forEach(l => s.append(c, l)) : s.append(c, u)
            }
            );
            const i = await this.caller.call(_e(), `${this.apiUrl}/public/${e}/examples?${s.toString()}`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })
              , a = await i.json();
            if (!i.ok)
                throw "detail"in a ? new Error(`Failed to list shared examples.
Status: ${i.status}
Message: ${a.detail.join(`
`)}`) : new Error(`Failed to list shared examples: ${i.status} ${i.statusText}`);
            return a.map(c => ({
                ...c,
                _hostUrl: this.getHostUrl()
            }))
        }
        async createProject({projectName: e, description: t=null, metadata: r=null, upsert: s=!1, projectExtra: i=null, referenceDatasetId: a=null}) {
            const c = s ? "?upsert=true" : ""
              , u = `${this.apiUrl}/sessions${c}`
              , l = i || {};
            r && (l.metadata = r);
            const d = {
                name: e,
                extra: l,
                description: t
            };
            a !== null && (d.reference_dataset_id = a);
            const h = await this.caller.call(_e(), u, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(d),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(h, "create project"),
            await h.json()
        }
        async updateProject(e, {name: t=null, description: r=null, metadata: s=null, projectExtra: i=null, endTime: a=null}) {
            const c = `${this.apiUrl}/sessions/${e}`;
            let u = i;
            s && (u = {
                ...u || {},
                metadata: s
            });
            const l = {
                name: t,
                extra: u,
                description: r,
                end_time: a ? new Date(a).toISOString() : null
            }
              , d = await this.caller.call(_e(), c, {
                method: "PATCH",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(l),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(d, "update project"),
            await d.json()
        }
        async hasProject({projectId: e, projectName: t}) {
            let r = "/sessions";
            const s = new URLSearchParams;
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either projectName or projectId, not both");
            if (e !== void 0)
                Ne(e),
                r += `/${e}`;
            else if (t !== void 0)
                s.append("name", t);
            else
                throw new Error("Must provide projectName or projectId");
            const i = await this.caller.call(_e(), `${this.apiUrl}${r}?${s}`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            try {
                const a = await i.json();
                return i.ok ? Array.isArray(a) ? a.length > 0 : !0 : !1
            } catch {
                return !1
            }
        }
        async readProject({projectId: e, projectName: t, includeStats: r}) {
            let s = "/sessions";
            const i = new URLSearchParams;
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either projectName or projectId, not both");
            if (e !== void 0)
                Ne(e),
                s += `/${e}`;
            else if (t !== void 0)
                i.append("name", t);
            else
                throw new Error("Must provide projectName or projectId");
            r !== void 0 && i.append("include_stats", r.toString());
            const a = await this._get(s, i);
            let c;
            if (Array.isArray(a)) {
                if (a.length === 0)
                    throw new Error(`Project[id=${e}, name=${t}] not found`);
                c = a[0]
            } else
                c = a;
            return c
        }
        async getProjectUrl({projectId: e, projectName: t}) {
            if (e === void 0 && t === void 0)
                throw new Error("Must provide either projectName or projectId");
            const r = await this.readProject({
                projectId: e,
                projectName: t
            })
              , s = await this._getTenantId();
            return `${this.getHostUrl()}/o/${s}/projects/p/${r.id}`
        }
        async getDatasetUrl({datasetId: e, datasetName: t}) {
            if (e === void 0 && t === void 0)
                throw new Error("Must provide either datasetName or datasetId");
            const r = await this.readDataset({
                datasetId: e,
                datasetName: t
            })
              , s = await this._getTenantId();
            return `${this.getHostUrl()}/o/${s}/datasets/${r.id}`
        }
        async _getTenantId() {
            if (this._tenantId !== null)
                return this._tenantId;
            const e = new URLSearchParams({
                limit: "1"
            });
            for await(const t of this._getPaginated("/sessions", e))
                return this._tenantId = t[0].tenant_id,
                t[0].tenant_id;
            throw new Error("No projects found to resolve tenant.")
        }
        async*listProjects({projectIds: e, name: t, nameContains: r, referenceDatasetId: s, referenceDatasetName: i, referenceFree: a, metadata: c}={}) {
            const u = new URLSearchParams;
            if (e !== void 0)
                for (const l of e)
                    u.append("id", l);
            if (t !== void 0 && u.append("name", t),
            r !== void 0 && u.append("name_contains", r),
            s !== void 0)
                u.append("reference_dataset", s);
            else if (i !== void 0) {
                const l = await this.readDataset({
                    datasetName: i
                });
                u.append("reference_dataset", l.id)
            }
            a !== void 0 && u.append("reference_free", a.toString()),
            c !== void 0 && u.append("metadata", JSON.stringify(c));
            for await(const l of this._getPaginated("/sessions", u))
                yield*l
        }
        async deleteProject({projectId: e, projectName: t}) {
            let r;
            if (e === void 0 && t === void 0)
                throw new Error("Must provide projectName or projectId");
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either projectName or projectId, not both");
            e === void 0 ? r = (await this.readProject({
                projectName: t
            })).id : r = e,
            Ne(r);
            const s = await this.caller.call(_e(), `${this.apiUrl}/sessions/${r}`, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(s, `delete session ${r} (${t})`, !0)
        }
        async uploadCsv({csvFile: e, fileName: t, inputKeys: r, outputKeys: s, description: i, dataType: a, name: c}) {
            const u = `${this.apiUrl}/datasets/upload`
              , l = new FormData;
            l.append("file", e, t),
            r.forEach(f => {
                l.append("input_keys", f)
            }
            ),
            s.forEach(f => {
                l.append("output_keys", f)
            }
            ),
            i && l.append("description", i),
            a && l.append("data_type", a),
            c && l.append("name", c);
            const d = await this.caller.call(_e(), u, {
                method: "POST",
                headers: this.headers,
                body: l,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(d, "upload CSV"),
            await d.json()
        }
        async createDataset(e, {description: t, dataType: r, inputsSchema: s, outputsSchema: i, metadata: a}={}) {
            const c = {
                name: e,
                description: t,
                extra: a ? {
                    metadata: a
                } : void 0
            };
            r && (c.data_type = r),
            s && (c.inputs_schema_definition = s),
            i && (c.outputs_schema_definition = i);
            const u = await this.caller.call(_e(), `${this.apiUrl}/datasets`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(c),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(u, "create dataset"),
            await u.json()
        }
        async readDataset({datasetId: e, datasetName: t}) {
            let r = "/datasets";
            const s = new URLSearchParams({
                limit: "1"
            });
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            if (e !== void 0)
                Ne(e),
                r += `/${e}`;
            else if (t !== void 0)
                s.append("name", t);
            else
                throw new Error("Must provide datasetName or datasetId");
            const i = await this._get(r, s);
            let a;
            if (Array.isArray(i)) {
                if (i.length === 0)
                    throw new Error(`Dataset[id=${e}, name=${t}] not found`);
                a = i[0]
            } else
                a = i;
            return a
        }
        async hasDataset({datasetId: e, datasetName: t}) {
            try {
                return await this.readDataset({
                    datasetId: e,
                    datasetName: t
                }),
                !0
            } catch (r) {
                if (r instanceof Error && r.message.toLocaleLowerCase().includes("not found"))
                    return !1;
                throw r
            }
        }
        async diffDatasetVersions({datasetId: e, datasetName: t, fromVersion: r, toVersion: s}) {
            let i = e;
            if (i === void 0 && t === void 0)
                throw new Error("Must provide either datasetName or datasetId");
            if (i !== void 0 && t !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            i === void 0 && (i = (await this.readDataset({
                datasetName: t
            })).id);
            const a = new URLSearchParams({
                from_version: typeof r == "string" ? r : r.toISOString(),
                to_version: typeof s == "string" ? s : s.toISOString()
            });
            return await this._get(`/datasets/${i}/versions/diff`, a)
        }
        async readDatasetOpenaiFinetuning({datasetId: e, datasetName: t}) {
            const r = "/datasets";
            if (e === void 0)
                if (t !== void 0)
                    e = (await this.readDataset({
                        datasetName: t
                    })).id;
                else
                    throw new Error("Must provide datasetName or datasetId");
            return (await (await this._getResponse(`${r}/${e}/openai_ft`)).text()).trim().split(`
`).map(c => JSON.parse(c))
        }
        async*listDatasets({limit: e=100, offset: t=0, datasetIds: r, datasetName: s, datasetNameContains: i, metadata: a}={}) {
            const c = "/datasets"
              , u = new URLSearchParams({
                limit: e.toString(),
                offset: t.toString()
            });
            if (r !== void 0)
                for (const l of r)
                    u.append("id", l);
            s !== void 0 && u.append("name", s),
            i !== void 0 && u.append("name_contains", i),
            a !== void 0 && u.append("metadata", JSON.stringify(a));
            for await(const l of this._getPaginated(c, u))
                yield*l
        }
        async updateDataset(e) {
            const {datasetId: t, datasetName: r, ...s} = e;
            if (!t && !r)
                throw new Error("Must provide either datasetName or datasetId");
            const i = t ?? (await this.readDataset({
                datasetName: r
            })).id;
            Ne(i);
            const a = await this.caller.call(_e(), `${this.apiUrl}/datasets/${i}`, {
                method: "PATCH",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(s),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(a, "update dataset"),
            await a.json()
        }
        async updateDatasetTag(e) {
            const {datasetId: t, datasetName: r, asOf: s, tag: i} = e;
            if (!t && !r)
                throw new Error("Must provide either datasetName or datasetId");
            const a = t ?? (await this.readDataset({
                datasetName: r
            })).id;
            Ne(a);
            const c = await this.caller.call(_e(), `${this.apiUrl}/datasets/${a}/tags`, {
                method: "PUT",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    as_of: typeof s == "string" ? s : s.toISOString(),
                    tag: i
                }),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(c, "update dataset tags")
        }
        async deleteDataset({datasetId: e, datasetName: t}) {
            let r = "/datasets"
              , s = e;
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            if (t !== void 0 && (s = (await this.readDataset({
                datasetName: t
            })).id),
            s !== void 0)
                Ne(s),
                r += `/${s}`;
            else
                throw new Error("Must provide datasetName or datasetId");
            const i = await this.caller.call(_e(), this.apiUrl + r, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(i, `delete ${r}`),
            await i.json()
        }
        async indexDataset({datasetId: e, datasetName: t, tag: r}) {
            let s = e;
            if (!s && !t)
                throw new Error("Must provide either datasetName or datasetId");
            if (s && t)
                throw new Error("Must provide either datasetName or datasetId, not both");
            s || (s = (await this.readDataset({
                datasetName: t
            })).id),
            Ne(s);
            const i = {
                tag: r
            }
              , a = await this.caller.call(_e(), `${this.apiUrl}/datasets/${s}/index`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(i),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(a, "index dataset"),
            await a.json()
        }
        async similarExamples(e, t, r, {filter: s}={}) {
            const i = {
                limit: r,
                inputs: e
            };
            s !== void 0 && (i.filter = s),
            Ne(t);
            const a = await this.caller.call(_e(), `${this.apiUrl}/datasets/${t}/search`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(i),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(a, "fetch similar examples"),
            (await a.json()).examples
        }
        async createExample(e, t, {datasetId: r, datasetName: s, createdAt: i, exampleId: a, metadata: c, split: u, sourceRunId: l}) {
            let d = r;
            if (d === void 0 && s === void 0)
                throw new Error("Must provide either datasetName or datasetId");
            if (d !== void 0 && s !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            d === void 0 && (d = (await this.readDataset({
                datasetName: s
            })).id);
            const h = i || new Date
              , f = {
                dataset_id: d,
                inputs: e,
                outputs: t,
                created_at: h == null ? void 0 : h.toISOString(),
                id: a,
                metadata: c,
                split: u,
                source_run_id: l
            }
              , p = await this.caller.call(_e(), `${this.apiUrl}/examples`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(f),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(p, "create example"),
            await p.json()
        }
        async createExamples(e) {
            const {inputs: t, outputs: r, metadata: s, sourceRunIds: i, exampleIds: a, datasetId: c, datasetName: u} = e;
            let l = c;
            if (l === void 0 && u === void 0)
                throw new Error("Must provide either datasetName or datasetId");
            if (l !== void 0 && u !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            l === void 0 && (l = (await this.readDataset({
                datasetName: u
            })).id);
            const d = t.map( (p, g) => ({
                dataset_id: l,
                inputs: p,
                outputs: r ? r[g] : void 0,
                metadata: s ? s[g] : void 0,
                split: e.splits ? e.splits[g] : void 0,
                id: a ? a[g] : void 0,
                source_run_id: i ? i[g] : void 0
            }))
              , h = await this.caller.call(_e(), `${this.apiUrl}/examples/bulk`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(d),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(h, "create examples"),
            await h.json()
        }
        async createLLMExample(e, t, r) {
            return this.createExample({
                input: e
            }, {
                output: t
            }, r)
        }
        async createChatExample(e, t, r) {
            const s = e.map(a => OT(a) ? RT(a) : a)
              , i = OT(t) ? RT(t) : t;
            return this.createExample({
                input: s
            }, {
                output: i
            }, r)
        }
        async readExample(e) {
            Ne(e);
            const t = `/examples/${e}`
              , r = await this._get(t)
              , {attachment_urls: s, ...i} = r
              , a = i;
            return s && (a.attachments = Object.entries(s).reduce( (c, [u,l]) => (c[u.slice(11)] = {
                presigned_url: l.presigned_url,
                mime_type: l.mime_type
            },
            c), {})),
            a
        }
        async*listExamples({datasetId: e, datasetName: t, exampleIds: r, asOf: s, splits: i, inlineS3Urls: a, metadata: c, limit: u, offset: l, filter: d, includeAttachments: h}={}) {
            let f;
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            if (e !== void 0)
                f = e;
            else if (t !== void 0)
                f = (await this.readDataset({
                    datasetName: t
                })).id;
            else
                throw new Error("Must provide a datasetName or datasetId");
            const p = new URLSearchParams({
                dataset: f
            })
              , g = s ? typeof s == "string" ? s : s == null ? void 0 : s.toISOString() : void 0;
            g && p.append("as_of", g);
            const y = a ?? !0;
            if (p.append("inline_s3_urls", y.toString()),
            r !== void 0)
                for (const w of r)
                    p.append("id", w);
            if (i !== void 0)
                for (const w of i)
                    p.append("splits", w);
            if (c !== void 0) {
                const w = JSON.stringify(c);
                p.append("metadata", w)
            }
            u !== void 0 && p.append("limit", u.toString()),
            l !== void 0 && p.append("offset", l.toString()),
            d !== void 0 && p.append("filter", d),
            h === !0 && ["attachment_urls", "outputs", "metadata"].forEach(w => p.append("select", w));
            let m = 0;
            for await(const w of this._getPaginated("/examples", p)) {
                for (const E of w) {
                    const {attachment_urls: v, ..._} = E
                      , A = _;
                    v && (A.attachments = Object.entries(v).reduce( (C, [k,x]) => (C[k.slice(11)] = {
                        presigned_url: x.presigned_url,
                        mime_type: x.mime_type || void 0
                    },
                    C), {})),
                    yield A,
                    m++
                }
                if (u !== void 0 && m >= u)
                    break
            }
        }
        async deleteExample(e) {
            Ne(e);
            const t = `/examples/${e}`
              , r = await this.caller.call(_e(), this.apiUrl + t, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(r, `delete ${t}`),
            await r.json()
        }
        async updateExample(e, t) {
            Ne(e);
            const r = await this.caller.call(_e(), `${this.apiUrl}/examples/${e}`, {
                method: "PATCH",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(t),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(r, "update example"),
            await r.json()
        }
        async updateExamples(e) {
            const t = await this.caller.call(_e(), `${this.apiUrl}/examples/bulk`, {
                method: "PATCH",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(e),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(t, "update examples"),
            await t.json()
        }
        async readDatasetVersion({datasetId: e, datasetName: t, asOf: r, tag: s}) {
            let i;
            if (e ? i = e : i = (await this.readDataset({
                datasetName: t
            })).id,
            Ne(i),
            r && s || !r && !s)
                throw new Error("Exactly one of asOf and tag must be specified.");
            const a = new URLSearchParams;
            r !== void 0 && a.append("as_of", typeof r == "string" ? r : r.toISOString()),
            s !== void 0 && a.append("tag", s);
            const c = await this.caller.call(_e(), `${this.apiUrl}/datasets/${i}/version?${a.toString()}`, {
                method: "GET",
                headers: {
                    ...this.headers
                },
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(c, "read dataset version"),
            await c.json()
        }
        async listDatasetSplits({datasetId: e, datasetName: t, asOf: r}) {
            let s;
            if (e === void 0 && t === void 0)
                throw new Error("Must provide dataset name or ID");
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            e === void 0 ? s = (await this.readDataset({
                datasetName: t
            })).id : s = e,
            Ne(s);
            const i = new URLSearchParams
              , a = r ? typeof r == "string" ? r : r == null ? void 0 : r.toISOString() : void 0;
            return a && i.append("as_of", a),
            await this._get(`/datasets/${s}/splits`, i)
        }
        async updateDatasetSplits({datasetId: e, datasetName: t, splitName: r, exampleIds: s, remove: i=!1}) {
            let a;
            if (e === void 0 && t === void 0)
                throw new Error("Must provide dataset name or ID");
            if (e !== void 0 && t !== void 0)
                throw new Error("Must provide either datasetName or datasetId, not both");
            e === void 0 ? a = (await this.readDataset({
                datasetName: t
            })).id : a = e,
            Ne(a);
            const c = {
                split_name: r,
                examples: s.map(l => (Ne(l),
                l)),
                remove: i
            }
              , u = await this.caller.call(_e(), `${this.apiUrl}/datasets/${a}/splits`, {
                method: "PUT",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(c),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(u, "update dataset splits", !0)
        }
        async evaluateRun(e, t, {sourceInfo: r, loadChildRuns: s, referenceExample: i}={
            loadChildRuns: !1
        }) {
            NT("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
            let a;
            if (typeof e == "string")
                a = await this.readRun(e, {
                    loadChildRuns: s
                });
            else if (typeof e == "object" && "id"in e)
                a = e;
            else
                throw new Error(`Invalid run type: ${typeof e}`);
            a.reference_example_id !== null && a.reference_example_id !== void 0 && (i = await this.readExample(a.reference_example_id));
            const c = await t.evaluateRun(a, i)
              , [u,l] = await this._logEvaluationFeedback(c, a, r);
            return l[0]
        }
        async createFeedback(e, t, {score: r, value: s, correction: i, comment: a, sourceInfo: c, feedbackSourceType: u="api", sourceRunId: l, feedbackId: d, feedbackConfig: h, projectId: f, comparativeExperimentId: p}) {
            var E;
            if (!e && !f)
                throw new Error("One of runId or projectId must be provided");
            if (e && f)
                throw new Error("Only one of runId or projectId can be provided");
            const g = {
                type: u ?? "api",
                metadata: c ?? {}
            };
            l !== void 0 && (g == null ? void 0 : g.metadata) !== void 0 && !g.metadata.__run && (g.metadata.__run = {
                run_id: l
            }),
            (g == null ? void 0 : g.metadata) !== void 0 && ((E = g.metadata.__run) == null ? void 0 : E.run_id) !== void 0 && Ne(g.metadata.__run.run_id);
            const y = {
                id: d ?? Rr(),
                run_id: e,
                key: t,
                score: r,
                value: s,
                correction: i,
                comment: a,
                feedback_source: g,
                comparative_experiment_id: p,
                feedbackConfig: h,
                session_id: f
            }
              , m = `${this.apiUrl}/feedback`
              , w = await this.caller.call(_e(), m, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(y),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(w, "create feedback", !0),
            y
        }
        async updateFeedback(e, {score: t, value: r, correction: s, comment: i}) {
            const a = {};
            t != null && (a.score = t),
            r != null && (a.value = r),
            s != null && (a.correction = s),
            i != null && (a.comment = i),
            Ne(e);
            const c = await this.caller.call(_e(), `${this.apiUrl}/feedback/${e}`, {
                method: "PATCH",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(a),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(c, "update feedback", !0)
        }
        async readFeedback(e) {
            Ne(e);
            const t = `/feedback/${e}`;
            return await this._get(t)
        }
        async deleteFeedback(e) {
            Ne(e);
            const t = `/feedback/${e}`
              , r = await this.caller.call(_e(), this.apiUrl + t, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(r, `delete ${t}`),
            await r.json()
        }
        async*listFeedback({runIds: e, feedbackKeys: t, feedbackSourceTypes: r}={}) {
            const s = new URLSearchParams;
            if (e && s.append("run", e.join(",")),
            t)
                for (const i of t)
                    s.append("key", i);
            if (r)
                for (const i of r)
                    s.append("source", i);
            for await(const i of this._getPaginated("/feedback", s))
                yield*i
        }
        async createPresignedFeedbackToken(e, t, {expiration: r, feedbackConfig: s}={}) {
            const i = {
                run_id: e,
                feedback_key: t,
                feedback_config: s
            };
            return r ? typeof r == "string" ? i.expires_at = r : (r != null && r.hours || r != null && r.minutes || r != null && r.days) && (i.expires_in = r) : i.expires_in = {
                hours: 3
            },
            await (await this.caller.call(_e(), `${this.apiUrl}/feedback/tokens`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(i),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json()
        }
        async createComparativeExperiment({name: e, experimentIds: t, referenceDatasetId: r, createdAt: s, description: i, metadata: a, id: c}) {
            var d;
            if (t.length === 0)
                throw new Error("At least one experiment is required");
            if (r || (r = (await this.readProject({
                projectId: t[0]
            })).reference_dataset_id),
            !r == null)
                throw new Error("A reference dataset is required");
            const u = {
                id: c,
                name: e,
                experiment_ids: t,
                reference_dataset_id: r,
                description: i,
                created_at: (d = s ?? new Date) == null ? void 0 : d.toISOString(),
                extra: {}
            };
            return a && (u.extra.metadata = a),
            await (await this.caller.call(_e(), `${this.apiUrl}/datasets/comparative`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(u),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json()
        }
        async*listPresignedFeedbackTokens(e) {
            Ne(e);
            const t = new URLSearchParams({
                run_id: e
            });
            for await(const r of this._getPaginated("/feedback/tokens", t))
                yield*r
        }
        _selectEvalResults(e) {
            let t;
            return "results"in e ? t = e.results : t = [e],
            t
        }
        async _logEvaluationFeedback(e, t, r) {
            const s = this._selectEvalResults(e)
              , i = [];
            for (const a of s) {
                let c = r || {};
                a.evaluatorInfo && (c = {
                    ...a.evaluatorInfo,
                    ...c
                });
                let u = null;
                a.targetRunId ? u = a.targetRunId : t && (u = t.id),
                i.push(await this.createFeedback(u, a.key, {
                    score: a.score,
                    value: a.value,
                    comment: a.comment,
                    correction: a.correction,
                    sourceInfo: c,
                    sourceRunId: a.sourceRunId,
                    feedbackConfig: a.feedbackConfig,
                    feedbackSourceType: "model"
                }))
            }
            return [s, i]
        }
        async logEvaluationFeedback(e, t, r) {
            const [s] = await this._logEvaluationFeedback(e, t, r);
            return s
        }
        async*listAnnotationQueues(e={}) {
            const {queueIds: t, name: r, nameContains: s, limit: i} = e
              , a = new URLSearchParams;
            t && t.forEach( (u, l) => {
                Ne(u, `queueIds[${l}]`),
                a.append("ids", u)
            }
            ),
            r && a.append("name", r),
            s && a.append("name_contains", s),
            a.append("limit", (i !== void 0 ? Math.min(i, 100) : 100).toString());
            let c = 0;
            for await(const u of this._getPaginated("/annotation-queues", a))
                if (yield*u,
                c++,
                i !== void 0 && c >= i)
                    break
        }
        async createAnnotationQueue(e) {
            const {name: t, description: r, queueId: s} = e
              , i = {
                name: t,
                description: r,
                id: s || Rr()
            }
              , a = await this.caller.call(_e(), `${this.apiUrl}/annotation-queues`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(Object.fromEntries(Object.entries(i).filter( ([u,l]) => l !== void 0))),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(a, "create annotation queue"),
            await a.json()
        }
        async readAnnotationQueue(e) {
            const t = await this.listAnnotationQueues({
                queueIds: [e]
            }).next();
            if (t.done)
                throw new Error(`Annotation queue with ID ${e} not found`);
            return t.value
        }
        async updateAnnotationQueue(e, t) {
            const {name: r, description: s} = t
              , i = await this.caller.call(_e(), `${this.apiUrl}/annotation-queues/${Ne(e, "queueId")}`, {
                method: "PATCH",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    name: r,
                    description: s
                }),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(i, "update annotation queue")
        }
        async deleteAnnotationQueue(e) {
            const t = await this.caller.call(_e(), `${this.apiUrl}/annotation-queues/${Ne(e, "queueId")}`, {
                method: "DELETE",
                headers: {
                    ...this.headers,
                    Accept: "application/json"
                },
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(t, "delete annotation queue")
        }
        async addRunsToAnnotationQueue(e, t) {
            const r = await this.caller.call(_e(), `${this.apiUrl}/annotation-queues/${Ne(e, "queueId")}/runs`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(t.map( (s, i) => Ne(s, `runIds[${i}]`).toString())),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(r, "add runs to annotation queue")
        }
        async getRunFromAnnotationQueue(e, t) {
            const r = `/annotation-queues/${Ne(e, "queueId")}/run`
              , s = await this.caller.call(_e(), `${this.apiUrl}${r}/${t}`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(s, "get run from annotation queue"),
            await s.json()
        }
        async deleteRunFromAnnotationQueue(e, t) {
            const r = await this.caller.call(_e(), `${this.apiUrl}/annotation-queues/${Ne(e, "queueId")}/runs/${Ne(t, "queueRunId")}`, {
                method: "DELETE",
                headers: {
                    ...this.headers,
                    Accept: "application/json"
                },
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(r, "delete run from annotation queue")
        }
        async getSizeFromAnnotationQueue(e) {
            const t = await this.caller.call(_e(), `${this.apiUrl}/annotation-queues/${Ne(e, "queueId")}/size`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(t, "get size from annotation queue"),
            await t.json()
        }
        async _currentTenantIsOwner(e) {
            const t = await this._getSettings();
            return e == "-" || t.tenant_handle === e
        }
        async _ownerConflictError(e, t) {
            const r = await this._getSettings();
            return new Error(`Cannot ${e} for another tenant.

      Current tenant: ${r.tenant_handle}

      Requested tenant: ${t}`)
        }
        async _getLatestCommitHash(e) {
            const t = await this.caller.call(_e(), `${this.apiUrl}/commits/${e}/?limit=1&offset=0`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })
              , r = await t.json();
            if (!t.ok) {
                const s = typeof r.detail == "string" ? r.detail : JSON.stringify(r.detail)
                  , i = new Error(`Error ${t.status}: ${t.statusText}
${s}`);
                throw i.statusCode = t.status,
                i
            }
            if (r.commits.length !== 0)
                return r.commits[0].commit_hash
        }
        async _likeOrUnlikePrompt(e, t) {
            const [r,s,i] = $i(e)
              , a = await this.caller.call(_e(), `${this.apiUrl}/likes/${r}/${s}`, {
                method: "POST",
                body: JSON.stringify({
                    like: t
                }),
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(a, `${t ? "like" : "unlike"} prompt`),
            await a.json()
        }
        async _getPromptUrl(e) {
            const [t,r,s] = $i(e);
            if (await this._currentTenantIsOwner(t)) {
                const i = await this._getSettings();
                return s !== "latest" ? `${this.getHostUrl()}/prompts/${r}/${s.substring(0, 8)}?organizationId=${i.id}` : `${this.getHostUrl()}/prompts/${r}?organizationId=${i.id}`
            } else
                return s !== "latest" ? `${this.getHostUrl()}/hub/${t}/${r}/${s.substring(0, 8)}` : `${this.getHostUrl()}/hub/${t}/${r}`
        }
        async promptExists(e) {
            return !!await this.getPrompt(e)
        }
        async likePrompt(e) {
            return this._likeOrUnlikePrompt(e, !0)
        }
        async unlikePrompt(e) {
            return this._likeOrUnlikePrompt(e, !1)
        }
        async*listCommits(e) {
            for await(const t of this._getPaginated(`/commits/${e}/`, new URLSearchParams, r => r.commits))
                yield*t
        }
        async*listPrompts(e) {
            const t = new URLSearchParams;
            t.append("sort_field", (e == null ? void 0 : e.sortField) ?? "updated_at"),
            t.append("sort_direction", "desc"),
            t.append("is_archived", (!!(e != null && e.isArchived)).toString()),
            (e == null ? void 0 : e.isPublic) !== void 0 && t.append("is_public", e.isPublic.toString()),
            e != null && e.query && t.append("query", e.query);
            for await(const r of this._getPaginated("/repos", t, s => s.repos))
                yield*r
        }
        async getPrompt(e) {
            const [t,r,s] = $i(e)
              , i = await this.caller.call(_e(), `${this.apiUrl}/repos/${t}/${r}`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            if (i.status === 404)
                return null;
            await Me(i, "get prompt");
            const a = await i.json();
            return a.repo ? a.repo : null
        }
        async createPrompt(e, t) {
            const r = await this._getSettings();
            if (t != null && t.isPublic && !r.tenant_handle)
                throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
            const [s,i,a] = $i(e);
            if (!await this._currentTenantIsOwner(s))
                throw await this._ownerConflictError("create a prompt", s);
            const c = {
                repo_handle: i,
                ...(t == null ? void 0 : t.description) && {
                    description: t.description
                },
                ...(t == null ? void 0 : t.readme) && {
                    readme: t.readme
                },
                ...(t == null ? void 0 : t.tags) && {
                    tags: t.tags
                },
                is_public: !!(t != null && t.isPublic)
            }
              , u = await this.caller.call(_e(), `${this.apiUrl}/repos/`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(c),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(u, "create prompt");
            const {repo: l} = await u.json();
            return l
        }
        async createCommit(e, t, r) {
            if (!await this.promptExists(e))
                throw new Error("Prompt does not exist, you must create it first.");
            const [s,i,a] = $i(e)
              , c = (r == null ? void 0 : r.parentCommitHash) === "latest" || !(r != null && r.parentCommitHash) ? await this._getLatestCommitHash(`${s}/${i}`) : r == null ? void 0 : r.parentCommitHash
              , u = {
                manifest: JSON.parse(JSON.stringify(t)),
                parent_commit: c
            }
              , l = await this.caller.call(_e(), `${this.apiUrl}/commits/${s}/${i}`, {
                method: "POST",
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(u),
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(l, "create commit");
            const d = await l.json();
            return this._getPromptUrl(`${s}/${i}${d.commit_hash ? `:${d.commit_hash}` : ""}`)
        }
        async updateExamplesMultipart(e, t=[]) {
            if (!await this._getMultiPartSupport())
                throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
            const r = new FormData;
            for (const a of t) {
                const c = a.id
                  , u = {
                    ...a.metadata && {
                        metadata: a.metadata
                    },
                    ...a.split && {
                        split: a.split
                    }
                }
                  , l = Xr(u)
                  , d = new Blob([l],{
                    type: "application/json"
                });
                if (r.append(c, d),
                a.inputs) {
                    const h = Xr(a.inputs)
                      , f = new Blob([h],{
                        type: "application/json"
                    });
                    r.append(`${c}.inputs`, f)
                }
                if (a.outputs) {
                    const h = Xr(a.outputs)
                      , f = new Blob([h],{
                        type: "application/json"
                    });
                    r.append(`${c}.outputs`, f)
                }
                if (a.attachments)
                    for (const [h,f] of Object.entries(a.attachments)) {
                        let p, g;
                        Array.isArray(f) ? [p,g] = f : (p = f.mimeType,
                        g = f.data);
                        const y = new Blob([g],{
                            type: `${p}; length=${g.byteLength}`
                        });
                        r.append(`${c}.attachment.${h}`, y)
                    }
                if (a.attachments_operations) {
                    const h = Xr(a.attachments_operations)
                      , f = new Blob([h],{
                        type: "application/json"
                    });
                    r.append(`${c}.attachments_operations`, f)
                }
            }
            return await (await this.caller.call(_e(), `${this.apiUrl}/v1/platform/datasets/${e}/examples`, {
                method: "PATCH",
                headers: this.headers,
                body: r
            })).json()
        }
        async uploadExamplesMultipart(e, t=[]) {
            if (!await this._getMultiPartSupport())
                throw new Error("Your LangSmith version does not allow using the multipart examples endpoint, please update to the latest version.");
            const r = new FormData;
            for (const a of t) {
                const c = (a.id ?? Rr()).toString()
                  , u = {
                    created_at: a.created_at,
                    ...a.metadata && {
                        metadata: a.metadata
                    },
                    ...a.split && {
                        split: a.split
                    }
                }
                  , l = Xr(u)
                  , d = new Blob([l],{
                    type: "application/json"
                });
                r.append(c, d);
                const h = Xr(a.inputs)
                  , f = new Blob([h],{
                    type: "application/json"
                });
                if (r.append(`${c}.inputs`, f),
                a.outputs) {
                    const p = Xr(a.outputs)
                      , g = new Blob([p],{
                        type: "application/json"
                    });
                    r.append(`${c}.outputs`, g)
                }
                if (a.attachments)
                    for (const [p,g] of Object.entries(a.attachments)) {
                        let y, m;
                        Array.isArray(g) ? [y,m] = g : (y = g.mimeType,
                        m = g.data);
                        const w = new Blob([m],{
                            type: `${y}; length=${m.byteLength}`
                        });
                        r.append(`${c}.attachment.${p}`, w)
                    }
            }
            return await (await this.caller.call(_e(), `${this.apiUrl}/v1/platform/datasets/${e}/examples`, {
                method: "POST",
                headers: this.headers,
                body: r
            })).json()
        }
        async updatePrompt(e, t) {
            if (!await this.promptExists(e))
                throw new Error("Prompt does not exist, you must create it first.");
            const [r,s] = $i(e);
            if (!await this._currentTenantIsOwner(r))
                throw await this._ownerConflictError("update a prompt", r);
            const i = {};
            if ((t == null ? void 0 : t.description) !== void 0 && (i.description = t.description),
            (t == null ? void 0 : t.readme) !== void 0 && (i.readme = t.readme),
            (t == null ? void 0 : t.tags) !== void 0 && (i.tags = t.tags),
            (t == null ? void 0 : t.isPublic) !== void 0 && (i.is_public = t.isPublic),
            (t == null ? void 0 : t.isArchived) !== void 0 && (i.is_archived = t.isArchived),
            Object.keys(i).length === 0)
                throw new Error("No valid update options provided");
            const a = await this.caller.call(_e(), `${this.apiUrl}/repos/${r}/${s}`, {
                method: "PATCH",
                body: JSON.stringify(i),
                headers: {
                    ...this.headers,
                    "Content-Type": "application/json"
                },
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            return await Me(a, "update prompt"),
            a.json()
        }
        async deletePrompt(e) {
            if (!await this.promptExists(e))
                throw new Error("Prompt does not exist, you must create it first.");
            const [t,r,s] = $i(e);
            if (!await this._currentTenantIsOwner(t))
                throw await this._ownerConflictError("delete a prompt", t);
            return await (await this.caller.call(_e(), `${this.apiUrl}/repos/${t}/${r}`, {
                method: "DELETE",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            })).json()
        }
        async pullPromptCommit(e, t) {
            const [r,s,i] = $i(e)
              , a = await this.caller.call(_e(), `${this.apiUrl}/commits/${r}/${s}/${i}${t != null && t.includeModel ? "?include_model=true" : ""}`, {
                method: "GET",
                headers: this.headers,
                signal: AbortSignal.timeout(this.timeout_ms),
                ...this.fetchOptions
            });
            await Me(a, "pull prompt commit");
            const c = await a.json();
            return {
                owner: r,
                repo: s,
                commit_hash: c.commit_hash,
                manifest: c.manifest,
                examples: c.examples
            }
        }
        async _pullPrompt(e, t) {
            const r = await this.pullPromptCommit(e, {
                includeModel: t == null ? void 0 : t.includeModel
            });
            return JSON.stringify(r.manifest)
        }
        async pushPrompt(e, t) {
            return await this.promptExists(e) ? t && Object.keys(t).some(s => s !== "object") && await this.updatePrompt(e, {
                description: t == null ? void 0 : t.description,
                readme: t == null ? void 0 : t.readme,
                tags: t == null ? void 0 : t.tags,
                isPublic: t == null ? void 0 : t.isPublic
            }) : await this.createPrompt(e, {
                description: t == null ? void 0 : t.description,
                readme: t == null ? void 0 : t.readme,
                tags: t == null ? void 0 : t.tags,
                isPublic: t == null ? void 0 : t.isPublic
            }),
            t != null && t.object ? await this.createCommit(e, t == null ? void 0 : t.object, {
                parentCommitHash: t == null ? void 0 : t.parentCommitHash
            }) : await this._getPromptUrl(e)
        }
        async clonePublicDataset(e, t={}) {
            const {sourceApiUrl: r=this.apiUrl, datasetName: s} = t
              , [i,a] = this.parseTokenOrUrl(e, r)
              , c = new fh({
                apiUrl: i,
                apiKey: "placeholder"
            })
              , u = await c.readSharedDataset(a)
              , l = s || u.name;
            try {
                if (await this.hasDataset({
                    datasetId: l
                })) {
                    console.log(`Dataset ${l} already exists in your tenant. Skipping.`);
                    return
                }
            } catch {}
            const d = await c.listSharedExamples(a)
              , h = await this.createDataset(l, {
                description: u.description,
                dataType: u.data_type || "kv",
                inputsSchema: u.inputs_schema_definition ?? void 0,
                outputsSchema: u.outputs_schema_definition ?? void 0
            });
            try {
                await this.createExamples({
                    inputs: d.map(f => f.inputs),
                    outputs: d.flatMap(f => f.outputs ? [f.outputs] : []),
                    datasetId: h.id
                })
            } catch (f) {
                throw console.error(`An error occurred while creating dataset ${l}. You should delete it manually.`),
                f
            }
        }
        parseTokenOrUrl(e, t, r=2, s="dataset") {
            try {
                return Ne(e),
                [t, e]
            } catch {}
            try {
                const a = new URL(e).pathname.split("/").filter(c => c !== "");
                if (a.length >= r) {
                    const c = a[a.length - r];
                    return [t, c]
                } else
                    throw new Error(`Invalid public ${s} URL: ${e}`)
            } catch {
                throw new Error(`Invalid public ${s} URL or token: ${e}`)
            }
        }
        awaitPendingTraceBatches() {
            return this.manualFlushMode ? (console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."),
            Promise.resolve()) : Promise.all([...this.autoBatchQueue.items.map( ({itemPromise: e}) => e), this.batchIngestCaller.queue.onIdle()])
        }
    }
    const RA = "0.3.4";
    let Hs;
    const s2 = () => typeof window < "u" && typeof window.document < "u"
      , i2 = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope"
      , a2 = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"))
      , MA = () => typeof Deno < "u"
      , o2 = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !MA()
      , c2 = () => Hs || (s2() ? Hs = "browser" : o2() ? Hs = "node" : i2() ? Hs = "webworker" : a2() ? Hs = "jsdom" : MA() ? Hs = "deno" : Hs = "other",
    Hs);
    let A0;
    function NA() {
        if (A0 === void 0) {
            const n = c2()
              , e = d2();
            A0 = {
                library: "langsmith",
                runtime: n,
                sdk: "langsmith-js",
                sdk_version: RA,
                ...e
            }
        }
        return A0
    }
    function u2() {
        const n = l2() || {}
          , e = {}
          , t = ["LANGCHAIN_API_KEY", "LANGCHAIN_ENDPOINT", "LANGCHAIN_TRACING_V2", "LANGCHAIN_PROJECT", "LANGCHAIN_SESSION", "LANGSMITH_API_KEY", "LANGSMITH_ENDPOINT", "LANGSMITH_TRACING_V2", "LANGSMITH_PROJECT", "LANGSMITH_SESSION"];
        for (const [r,s] of Object.entries(n))
            (r.startsWith("LANGCHAIN_") || r.startsWith("LANGSMITH_")) && typeof s == "string" && !t.includes(r) && !r.toLowerCase().includes("key") && !r.toLowerCase().includes("secret") && !r.toLowerCase().includes("token") && (r === "LANGCHAIN_REVISION_ID" ? e.revision_id = s : e[r] = s);
        return e
    }
    function l2() {
        try {
            return typeof process < "u" && process.env ? Object.entries(process.env).reduce( (n, [e,t]) => (n[e] = String(t),
            n), {}) : void 0
        } catch {
            return
        }
    }
    function io(n) {
        var e;
        try {
            return typeof process < "u" ? (e = process.env) == null ? void 0 : e[n] : void 0
        } catch {
            return
        }
    }
    function Li(n) {
        return io(`LANGSMITH_${n}`) || io(`LANGCHAIN_${n}`)
    }
    let I0;
    function d2() {
        if (I0 !== void 0)
            return I0;
        const n = ["VERCEL_GIT_COMMIT_SHA", "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA", "COMMIT_REF", "RENDER_GIT_COMMIT", "CI_COMMIT_SHA", "CIRCLE_SHA1", "CF_PAGES_COMMIT_SHA", "REACT_APP_GIT_SHA", "SOURCE_VERSION", "GITHUB_SHA", "TRAVIS_COMMIT", "GIT_COMMIT", "BUILD_VCS_NUMBER", "bamboo_planRepository_revision", "Build.SourceVersion", "BITBUCKET_COMMIT", "DRONE_COMMIT_SHA", "SEMAPHORE_GIT_SHA", "BUILDKITE_COMMIT"]
          , e = {};
        for (const t of n) {
            const r = io(t);
            r !== void 0 && (e[t] = r)
        }
        return I0 = e,
        e
    }
    const h2 = n => !!["TRACING_V2", "TRACING"].find(t => Li(t) === "true")
      , O0 = Symbol.for("lc:context_variables");
    function f2(n) {
        return n.replace(/[-:.]/g, "")
    }
    function p2(n, e, t=1) {
        const r = t.toFixed(0).slice(0, 3).padStart(3, "0");
        return f2(`${new Date(n).toISOString().slice(0, -1)}${r}Z`) + e
    }
    class Xy {
        constructor(e, t) {
            Object.defineProperty(this, "metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.metadata = e,
            this.tags = t
        }
        static fromHeader(e) {
            const t = e.split(",");
            let r = {}
              , s = [];
            for (const i of t) {
                const [a,c] = i.split("=")
                  , u = decodeURIComponent(c);
                a === "langsmith-metadata" ? r = JSON.parse(u) : a === "langsmith-tags" && (s = u.split(","))
            }
            return new Xy(r,s)
        }
        toHeader() {
            const e = [];
            return this.metadata && Object.keys(this.metadata).length > 0 && e.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`),
            this.tags && this.tags.length > 0 && e.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`),
            e.join(",")
        }
    }
    class Yr {
        constructor(e) {
            var c;
            if (Object.defineProperty(this, "id", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "run_type", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "project_name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "parent_run", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "child_runs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "start_time", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "end_time", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "extra", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "error", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "serialized", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "inputs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "outputs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "reference_example_id", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "client", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "events", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "trace_id", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "dotted_order", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tracingEnabled", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "execution_order", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "child_execution_order", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "attachments", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            $A(e)) {
                Object.assign(this, {
                    ...e
                });
                return
            }
            const t = Yr.getDefaultConfig()
              , {metadata: r, ...s} = e
              , i = s.client ?? Yr.getSharedClient()
              , a = {
                ...r,
                ...(c = s == null ? void 0 : s.extra) == null ? void 0 : c.metadata
            };
            if (s.extra = {
                ...s.extra,
                metadata: a
            },
            Object.assign(this, {
                ...t,
                ...s,
                client: i
            }),
            this.trace_id || (this.parent_run ? this.trace_id = this.parent_run.trace_id ?? this.id : this.trace_id = this.id),
            this.execution_order ?? (this.execution_order = 1),
            this.child_execution_order ?? (this.child_execution_order = 1),
            !this.dotted_order) {
                const u = p2(this.start_time, this.id, this.execution_order);
                this.parent_run ? this.dotted_order = this.parent_run.dotted_order + "." + u : this.dotted_order = u
            }
        }
        static getDefaultConfig() {
            return {
                id: Rr(),
                run_type: "chain",
                project_name: Li("PROJECT") ?? io("LANGCHAIN_SESSION") ?? "default",
                child_runs: [],
                api_url: io("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
                api_key: io("LANGCHAIN_API_KEY"),
                caller_options: {},
                start_time: Date.now(),
                serialized: {},
                inputs: {},
                extra: {}
            }
        }
        static getSharedClient() {
            return Yr.sharedClient || (Yr.sharedClient = new fh),
            Yr.sharedClient
        }
        createChild(e) {
            var u, l, d, h, f, p;
            const t = this.child_execution_order + 1
              , r = new Yr({
                ...e,
                parent_run: this,
                project_name: this.project_name,
                client: this.client,
                tracingEnabled: this.tracingEnabled,
                execution_order: t,
                child_execution_order: t
            });
            O0 in this && (r[O0] = this[O0]);
            const s = Symbol.for("lc:child_config")
              , i = ((u = e.extra) == null ? void 0 : u[s]) ?? this.extra[s];
            if (g2(i)) {
                const g = {
                    ...i
                }
                  , y = m2(g.callbacks) ? (d = (l = g.callbacks).copy) == null ? void 0 : d.call(l) : void 0;
                y && (Object.assign(y, {
                    _parentRunId: r.id
                }),
                (p = (f = (h = y.handlers) == null ? void 0 : h.find(LA)) == null ? void 0 : f.updateFromRunTree) == null || p.call(f, r),
                g.callbacks = y),
                r.extra[s] = g
            }
            const a = new Set;
            let c = this;
            for (; c != null && !a.has(c.id); )
                a.add(c.id),
                c.child_execution_order = Math.max(c.child_execution_order, t),
                c = c.parent_run;
            return this.child_runs.push(r),
            r
        }
        async end(e, t, r=Date.now(), s) {
            this.outputs = this.outputs ?? e,
            this.error = this.error ?? t,
            this.end_time = this.end_time ?? r,
            s && Object.keys(s).length > 0 && (this.extra = this.extra ? {
                ...this.extra,
                metadata: {
                    ...this.extra.metadata,
                    ...s
                }
            } : {
                metadata: s
            })
        }
        _convertToCreate(e, t, r=!0) {
            var u;
            const s = e.extra ?? {};
            if (s.runtime || (s.runtime = {}),
            t)
                for (const [l,d] of Object.entries(t))
                    s.runtime[l] || (s.runtime[l] = d);
            let i, a;
            return r ? (a = (u = e.parent_run) == null ? void 0 : u.id,
            i = []) : (i = e.child_runs.map(l => this._convertToCreate(l, t, r)),
            a = void 0),
            {
                id: e.id,
                name: e.name,
                start_time: e.start_time,
                end_time: e.end_time,
                run_type: e.run_type,
                reference_example_id: e.reference_example_id,
                extra: s,
                serialized: e.serialized,
                error: e.error,
                inputs: e.inputs,
                outputs: e.outputs,
                session_name: e.project_name,
                child_runs: i,
                parent_run_id: a,
                trace_id: e.trace_id,
                dotted_order: e.dotted_order,
                tags: e.tags,
                attachments: e.attachments
            }
        }
        async postRun(e=!0) {
            try {
                const t = NA()
                  , r = await this._convertToCreate(this, t, !0);
                if (await this.client.createRun(r),
                !e) {
                    NT("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
                    for (const s of this.child_runs)
                        await s.postRun(!1)
                }
            } catch (t) {
                console.error(`Error in postRun for run ${this.id}:`, t)
            }
        }
        async patchRun() {
            var e;
            try {
                const t = {
                    end_time: this.end_time,
                    error: this.error,
                    inputs: this.inputs,
                    outputs: this.outputs,
                    parent_run_id: (e = this.parent_run) == null ? void 0 : e.id,
                    reference_example_id: this.reference_example_id,
                    extra: this.extra,
                    events: this.events,
                    dotted_order: this.dotted_order,
                    trace_id: this.trace_id,
                    tags: this.tags,
                    attachments: this.attachments
                };
                await this.client.updateRun(this.id, t)
            } catch (t) {
                console.error(`Error in patchRun for run ${this.id}`, t)
            }
        }
        toJSON() {
            return this._convertToCreate(this, void 0, !1)
        }
        static fromRunnableConfig(e, t) {
            var l, d, h, f;
            const r = e == null ? void 0 : e.callbacks;
            let s, i, a, c = h2();
            if (r) {
                const p = ((l = r == null ? void 0 : r.getParentRunId) == null ? void 0 : l.call(r)) ?? ""
                  , g = (d = r == null ? void 0 : r.handlers) == null ? void 0 : d.find(y => (y == null ? void 0 : y.name) == "langchain_tracer");
                s = (h = g == null ? void 0 : g.getRun) == null ? void 0 : h.call(g, p),
                i = g == null ? void 0 : g.projectName,
                a = g == null ? void 0 : g.client,
                c = c || !!g
            }
            return s ? new Yr({
                name: s.name,
                id: s.id,
                trace_id: s.trace_id,
                dotted_order: s.dotted_order,
                client: a,
                tracingEnabled: c,
                project_name: i,
                tags: [...new Set(((s == null ? void 0 : s.tags) ?? []).concat((e == null ? void 0 : e.tags) ?? []))],
                extra: {
                    metadata: {
                        ...(f = s == null ? void 0 : s.extra) == null ? void 0 : f.metadata,
                        ...e == null ? void 0 : e.metadata
                    }
                }
            }).createChild(t) : new Yr({
                ...t,
                client: a,
                tracingEnabled: c,
                project_name: i
            })
        }
        static fromDottedOrder(e) {
            return this.fromHeaders({
                "langsmith-trace": e
            })
        }
        static fromHeaders(e, t) {
            var l;
            const r = "get"in e && typeof e.get == "function" ? {
                "langsmith-trace": e.get("langsmith-trace"),
                baggage: e.get("baggage")
            } : e
              , s = r["langsmith-trace"];
            if (!s || typeof s != "string")
                return;
            const i = s.trim()
              , a = i.split(".").map(d => {
                const [h,f] = d.split("Z");
                return {
                    strTime: h,
                    time: Date.parse(h + "Z"),
                    uuid: f
                }
            }
            )
              , c = a[0].uuid
              , u = {
                ...t,
                name: (t == null ? void 0 : t.name) ?? "parent",
                run_type: (t == null ? void 0 : t.run_type) ?? "chain",
                start_time: (t == null ? void 0 : t.start_time) ?? Date.now(),
                id: (l = a.at(-1)) == null ? void 0 : l.uuid,
                trace_id: c,
                dotted_order: i
            };
            if (r.baggage && typeof r.baggage == "string") {
                const d = Xy.fromHeader(r.baggage);
                u.metadata = d.metadata,
                u.tags = d.tags
            }
            return new Yr(u)
        }
        toHeaders(e) {
            var r;
            const t = {
                "langsmith-trace": this.dotted_order,
                baggage: new Xy((r = this.extra) == null ? void 0 : r.metadata,this.tags).toHeader()
            };
            if (e)
                for (const [s,i] of Object.entries(t))
                    e.set(s, i);
            return t
        }
    }
    Object.defineProperty(Yr, "sharedClient", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: null
    });
    function $A(n) {
        return n !== void 0 && typeof n.createChild == "function" && typeof n.postRun == "function"
    }
    function LA(n) {
        return typeof n == "object" && n != null && typeof n.name == "string" && n.name === "langchain_tracer"
    }
    function FA(n) {
        return Array.isArray(n) && n.some(e => LA(e))
    }
    function m2(n) {
        return typeof n == "object" && n != null && Array.isArray(n.handlers)
    }
    function g2(n) {
        var e;
        return n !== void 0 && typeof n.callbacks == "object" && (FA((e = n.callbacks) == null ? void 0 : e.handlers) || FA(n.callbacks))
    }
    let y2 = class {
        getStore() {}
        run(e, t) {
            return t()
        }
    }
    ;
    const R0 = Symbol.for("ls:tracing_async_local_storage")
      , w2 = new y2;
    let b2 = class {
        getInstance() {
            return globalThis[R0] ?? w2
        }
        initializeGlobalInstance(e) {
            globalThis[R0] === void 0 && (globalThis[R0] = e)
        }
    }
    ;
    const v2 = new b2
      , _2 = () => {
        const n = v2.getInstance().getStore();
        if (!$A(n))
            throw new Error(["Could not get the current run tree.", "", "Please make sure you are calling this method within a traceable function and that tracing is enabled."].join(`
`));
        return n
    }
    ;
    function M0(n) {
        return typeof n == "function" && "langsmith:traceable"in n
    }
    /*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
    const S2 = Object.prototype.hasOwnProperty;
    function N0(n, e) {
        return S2.call(n, e)
    }
    function $0(n) {
        if (Array.isArray(n)) {
            const t = new Array(n.length);
            for (let r = 0; r < t.length; r++)
                t[r] = "" + r;
            return t
        }
        if (Object.keys)
            return Object.keys(n);
        let e = [];
        for (let t in n)
            N0(n, t) && e.push(t);
        return e
    }
    function ms(n) {
        switch (typeof n) {
        case "object":
            return JSON.parse(JSON.stringify(n));
        case "undefined":
            return null;
        default:
            return n
        }
    }
    function L0(n) {
        let e = 0;
        const t = n.length;
        let r;
        for (; e < t; ) {
            if (r = n.charCodeAt(e),
            r >= 48 && r <= 57) {
                e++;
                continue
            }
            return !1
        }
        return !0
    }
    function cu(n) {
        return n.indexOf("/") === -1 && n.indexOf("~") === -1 ? n : n.replace(/~/g, "~0").replace(/\//g, "~1")
    }
    function E2(n) {
        return n.replace(/~1/g, "/").replace(/~0/g, "~")
    }
    function F0(n) {
        if (n === void 0)
            return !0;
        if (n) {
            if (Array.isArray(n)) {
                for (let t = 0, r = n.length; t < r; t++)
                    if (F0(n[t]))
                        return !0
            } else if (typeof n == "object") {
                const t = $0(n)
                  , r = t.length;
                for (var e = 0; e < r; e++)
                    if (F0(n[t[e]]))
                        return !0
            }
        }
        return !1
    }
    function jA(n, e) {
        const t = [n];
        for (const r in e) {
            const s = typeof e[r] == "object" ? JSON.stringify(e[r], null, 2) : e[r];
            typeof s < "u" && t.push(`${r}: ${s}`)
        }
        return t.join(`
`)
    }
    class x2 extends Error {
        constructor(e, t, r, s, i) {
            super(jA(e, {
                name: t,
                index: r,
                operation: s,
                tree: i
            })),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: t
            }),
            Object.defineProperty(this, "index", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }),
            Object.defineProperty(this, "operation", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: s
            }),
            Object.defineProperty(this, "tree", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: i
            }),
            Object.setPrototypeOf(this, new.target.prototype),
            this.message = jA(e, {
                name: t,
                index: r,
                operation: s,
                tree: i
            })
        }
    }
    const Mt = x2
      , uu = {
        add: function(n, e, t) {
            return n[e] = this.value,
            {
                newDocument: t
            }
        },
        remove: function(n, e, t) {
            var r = n[e];
            return delete n[e],
            {
                newDocument: t,
                removed: r
            }
        },
        replace: function(n, e, t) {
            var r = n[e];
            return n[e] = this.value,
            {
                newDocument: t,
                removed: r
            }
        },
        move: function(n, e, t) {
            let r = j0(t, this.path);
            r && (r = ms(r));
            const s = ph(t, {
                op: "remove",
                path: this.from
            }).removed;
            return ph(t, {
                op: "add",
                path: this.path,
                value: s
            }),
            {
                newDocument: t,
                removed: r
            }
        },
        copy: function(n, e, t) {
            const r = j0(t, this.from);
            return ph(t, {
                op: "add",
                path: this.path,
                value: ms(r)
            }),
            {
                newDocument: t
            }
        },
        test: function(n, e, t) {
            return {
                newDocument: t,
                test: Qy(n[e], this.value)
            }
        },
        _get: function(n, e, t) {
            return this.value = n[e],
            {
                newDocument: t
            }
        }
    };
    var C2 = {
        add: function(n, e, t) {
            return L0(e) ? n.splice(e, 0, this.value) : n[e] = this.value,
            {
                newDocument: t,
                index: e
            }
        },
        remove: function(n, e, t) {
            var r = n.splice(e, 1);
            return {
                newDocument: t,
                removed: r[0]
            }
        },
        replace: function(n, e, t) {
            var r = n[e];
            return n[e] = this.value,
            {
                newDocument: t,
                removed: r
            }
        },
        move: uu.move,
        copy: uu.copy,
        test: uu.test,
        _get: uu._get
    };
    function j0(n, e) {
        if (e == "")
            return n;
        var t = {
            op: "_get",
            path: e
        };
        return ph(n, t),
        t.value
    }
    function ph(n, e, t=!1, r=!0, s=!0, i=0) {
        if (t && (typeof t == "function" ? t(e, 0, n, e.path) : D0(e, 0)),
        e.path === "") {
            let a = {
                newDocument: n
            };
            if (e.op === "add")
                return a.newDocument = e.value,
                a;
            if (e.op === "replace")
                return a.newDocument = e.value,
                a.removed = n,
                a;
            if (e.op === "move" || e.op === "copy")
                return a.newDocument = j0(n, e.from),
                e.op === "move" && (a.removed = n),
                a;
            if (e.op === "test") {
                if (a.test = Qy(n, e.value),
                a.test === !1)
                    throw new Mt("Test operation failed","TEST_OPERATION_FAILED",i,e,n);
                return a.newDocument = n,
                a
            } else {
                if (e.op === "remove")
                    return a.removed = n,
                    a.newDocument = null,
                    a;
                if (e.op === "_get")
                    return e.value = n,
                    a;
                if (t)
                    throw new Mt("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",i,e,n);
                return a
            }
        } else {
            r || (n = ms(n));
            const c = (e.path || "").split("/");
            let u = n, l = 1, d = c.length, h, f, p;
            for (typeof t == "function" ? p = t : p = D0; ; ) {
                if (f = c[l],
                f && f.indexOf("~") != -1 && (f = E2(f)),
                s && (f == "__proto__" || f == "prototype" && l > 0 && c[l - 1] == "constructor"))
                    throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
                if (t && h === void 0 && (u[f] === void 0 ? h = c.slice(0, l).join("/") : l == d - 1 && (h = e.path),
                h !== void 0 && p(e, 0, n, h)),
                l++,
                Array.isArray(u)) {
                    if (f === "-")
                        f = u.length;
                    else {
                        if (t && !L0(f))
                            throw new Mt("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index","OPERATION_PATH_ILLEGAL_ARRAY_INDEX",i,e,n);
                        L0(f) && (f = ~~f)
                    }
                    if (l >= d) {
                        if (t && e.op === "add" && f > u.length)
                            throw new Mt("The specified index MUST NOT be greater than the number of elements in the array","OPERATION_VALUE_OUT_OF_BOUNDS",i,e,n);
                        const g = C2[e.op].call(e, u, f, n);
                        if (g.test === !1)
                            throw new Mt("Test operation failed","TEST_OPERATION_FAILED",i,e,n);
                        return g
                    }
                } else if (l >= d) {
                    const g = uu[e.op].call(e, u, f, n);
                    if (g.test === !1)
                        throw new Mt("Test operation failed","TEST_OPERATION_FAILED",i,e,n);
                    return g
                }
                if (u = u[f],
                t && l < d && (!u || typeof u != "object"))
                    throw new Mt("Cannot perform operation at the desired path","OPERATION_PATH_UNRESOLVABLE",i,e,n)
            }
        }
    }
    function Yy(n, e, t, r=!0, s=!0) {
        if (t && !Array.isArray(e))
            throw new Mt("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");
        r || (n = ms(n));
        const i = new Array(e.length);
        for (let a = 0, c = e.length; a < c; a++)
            i[a] = ph(n, e[a], t, !0, s, a),
            n = i[a].newDocument;
        return i.newDocument = n,
        i
    }
    function D0(n, e, t, r) {
        if (typeof n != "object" || n === null || Array.isArray(n))
            throw new Mt("Operation is not an object","OPERATION_NOT_AN_OBJECT",e,n,t);
        if (uu[n.op]) {
            if (typeof n.path != "string")
                throw new Mt("Operation `path` property is not a string","OPERATION_PATH_INVALID",e,n,t);
            if (n.path.indexOf("/") !== 0 && n.path.length > 0)
                throw new Mt('Operation `path` property must start with "/"',"OPERATION_PATH_INVALID",e,n,t);
            if ((n.op === "move" || n.op === "copy") && typeof n.from != "string")
                throw new Mt("Operation `from` property is not present (applicable in `move` and `copy` operations)","OPERATION_FROM_REQUIRED",e,n,t);
            if ((n.op === "add" || n.op === "replace" || n.op === "test") && n.value === void 0)
                throw new Mt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_REQUIRED",e,n,t);
            if ((n.op === "add" || n.op === "replace" || n.op === "test") && F0(n.value))
                throw new Mt("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",e,n,t);
            if (t) {
                if (n.op == "add") {
                    var s = n.path.split("/").length
                      , i = r.split("/").length;
                    if (s !== i + 1 && s !== i)
                        throw new Mt("Cannot perform an `add` operation at the desired path","OPERATION_PATH_CANNOT_ADD",e,n,t)
                } else if (n.op === "replace" || n.op === "remove" || n.op === "_get") {
                    if (n.path !== r)
                        throw new Mt("Cannot perform the operation at a path that does not exist","OPERATION_PATH_UNRESOLVABLE",e,n,t)
                } else if (n.op === "move" || n.op === "copy") {
                    var a = {
                        op: "_get",
                        path: n.from,
                        value: void 0
                    }
                      , c = k2([a], t);
                    if (c && c.name === "OPERATION_PATH_UNRESOLVABLE")
                        throw new Mt("Cannot perform the operation from a path that does not exist","OPERATION_FROM_UNRESOLVABLE",e,n,t)
                }
            }
        } else
            throw new Mt("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",e,n,t)
    }
    function k2(n, e, t) {
        try {
            if (!Array.isArray(n))
                throw new Mt("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");
            if (e)
                Yy(ms(e), ms(n), t || !0);
            else {
                t = t || D0;
                for (var r = 0; r < n.length; r++)
                    t(n[r], r, e, void 0)
            }
        } catch (s) {
            if (s instanceof Mt)
                return s;
            throw s
        }
    }
    function Qy(n, e) {
        if (n === e)
            return !0;
        if (n && e && typeof n == "object" && typeof e == "object") {
            var t = Array.isArray(n), r = Array.isArray(e), s, i, a;
            if (t && r) {
                if (i = n.length,
                i != e.length)
                    return !1;
                for (s = i; s-- !== 0; )
                    if (!Qy(n[s], e[s]))
                        return !1;
                return !0
            }
            if (t != r)
                return !1;
            var c = Object.keys(n);
            if (i = c.length,
            i !== Object.keys(e).length)
                return !1;
            for (s = i; s-- !== 0; )
                if (!e.hasOwnProperty(c[s]))
                    return !1;
            for (s = i; s-- !== 0; )
                if (a = c[s],
                !Qy(n[a], e[a]))
                    return !1;
            return !0
        }
        return n !== n && e !== e
    }
    /*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */
    function DA(n, e, t, r, s) {
        if (e !== n) {
            typeof e.toJSON == "function" && (e = e.toJSON());
            for (var i = $0(e), a = $0(n), c = !1, u = a.length - 1; u >= 0; u--) {
                var l = a[u]
                  , d = n[l];
                if (N0(e, l) && !(e[l] === void 0 && d !== void 0 && Array.isArray(e) === !1)) {
                    var h = e[l];
                    typeof d == "object" && d != null && typeof h == "object" && h != null && Array.isArray(d) === Array.isArray(h) ? DA(d, h, t, r + "/" + cu(l), s) : d !== h && (s && t.push({
                        op: "test",
                        path: r + "/" + cu(l),
                        value: ms(d)
                    }),
                    t.push({
                        op: "replace",
                        path: r + "/" + cu(l),
                        value: ms(h)
                    }))
                } else
                    Array.isArray(n) === Array.isArray(e) ? (s && t.push({
                        op: "test",
                        path: r + "/" + cu(l),
                        value: ms(d)
                    }),
                    t.push({
                        op: "remove",
                        path: r + "/" + cu(l)
                    }),
                    c = !0) : (s && t.push({
                        op: "test",
                        path: r,
                        value: n
                    }),
                    t.push({
                        op: "replace",
                        path: r,
                        value: e
                    }))
            }
            if (!(!c && i.length == a.length))
                for (var u = 0; u < i.length; u++) {
                    var l = i[u];
                    !N0(n, l) && e[l] !== void 0 && t.push({
                        op: "add",
                        path: r + "/" + cu(l),
                        value: ms(e[l])
                    })
                }
        }
    }
    function P2(n, e, t=!1) {
        var r = [];
        return DA(n, e, r, "", t),
        r
    }
    const T2 = () => typeof window < "u" && typeof window.document < "u"
      , A2 = () => typeof globalThis == "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope"
      , I2 = () => typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"))
      , B0 = () => typeof Deno < "u"
      , O2 = () => typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u" && !B0()
      , R2 = () => {
        let n;
        return T2() ? n = "browser" : O2() ? n = "node" : A2() ? n = "webworker" : I2() ? n = "jsdom" : B0() ? n = "deno" : n = "other",
        n
    }
    ;
    let q0;
    async function M2() {
        return q0 === void 0 && (q0 = {
            library: "langchain-js",
            runtime: R2()
        }),
        q0
    }
    function mn(n) {
        var e;
        try {
            return typeof process < "u" ? (e = process.env) == null ? void 0 : e[n] : B0() ? Deno == null ? void 0 : Deno.env.get(n) : void 0
        } catch {
            return
        }
    }
    class N2 {
    }
    function $2(n) {
        return "lc_prefer_streaming"in n && n.lc_prefer_streaming
    }
    class mh extends N2 {
        get lc_namespace() {
            return ["langchain_core", "callbacks", this.name]
        }
        get lc_secrets() {}
        get lc_attributes() {}
        get lc_aliases() {}
        static lc_name() {
            return this.name
        }
        get lc_id() {
            return [...this.lc_namespace, mT(this.constructor)]
        }
        constructor(e) {
            super(),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "lc_kwargs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "ignoreLLM", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "ignoreChain", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "ignoreAgent", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "ignoreRetriever", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "ignoreCustomEvent", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "raiseError", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "awaitHandlers", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: mn("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
            }),
            this.lc_kwargs = e || {},
            e && (this.ignoreLLM = e.ignoreLLM ?? this.ignoreLLM,
            this.ignoreChain = e.ignoreChain ?? this.ignoreChain,
            this.ignoreAgent = e.ignoreAgent ?? this.ignoreAgent,
            this.ignoreRetriever = e.ignoreRetriever ?? this.ignoreRetriever,
            this.ignoreCustomEvent = e.ignoreCustomEvent ?? this.ignoreCustomEvent,
            this.raiseError = e.raiseError ?? this.raiseError,
            this.awaitHandlers = this.raiseError || (e._awaitHandler ?? this.awaitHandlers))
        }
        copy() {
            return new this.constructor(this)
        }
        toJSON() {
            return so.prototype.toJSON.call(this)
        }
        toJSONNotImplemented() {
            return so.prototype.toJSONNotImplemented.call(this)
        }
        static fromMethods(e) {
            class t extends mh {
                constructor() {
                    super(),
                    Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: Rr()
                    }),
                    Object.assign(this, e)
                }
            }
            return new t
        }
    }
    const L2 = n => {
        const e = n;
        return e !== void 0 && typeof e.copy == "function" && typeof e.name == "string" && typeof e.awaitHandlers == "boolean"
    }
    ;
    function U0(n, e) {
        return n && !Array.isArray(n) && typeof n == "object" ? n : {
            [e]: n
        }
    }
    function F2(n) {
        return n.replace(/[-:.]/g, "")
    }
    function j2(n, e, t) {
        const r = t.toFixed(0).slice(0, 3).padStart(3, "0");
        return F2(`${new Date(n).toISOString().slice(0, -1)}${r}Z`) + e
    }
    function gh(n) {
        return typeof n._addRunToRunMap == "function"
    }
    class yh extends mh {
        constructor(e) {
            super(...arguments),
            Object.defineProperty(this, "runMap", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: new Map
            })
        }
        copy() {
            return this
        }
        stringifyError(e) {
            return e instanceof Error ? e.message + (e != null && e.stack ? `

${e.stack}` : "") : typeof e == "string" ? e : `${e}`
        }
        _addChildRun(e, t) {
            e.child_runs.push(t)
        }
        _addRunToRunMap(e) {
            const t = j2(e.start_time, e.id, e.execution_order)
              , r = {
                ...e
            };
            if (r.parent_run_id !== void 0) {
                const s = this.runMap.get(r.parent_run_id);
                s && (this._addChildRun(s, r),
                s.child_execution_order = Math.max(s.child_execution_order, r.child_execution_order),
                r.trace_id = s.trace_id,
                s.dotted_order !== void 0 && (r.dotted_order = [s.dotted_order, t].join(".")))
            } else
                r.trace_id = r.id,
                r.dotted_order = t;
            return this.runMap.set(r.id, r),
            r
        }
        async _endTrace(e) {
            var r;
            const t = e.parent_run_id !== void 0 && this.runMap.get(e.parent_run_id);
            t ? t.child_execution_order = Math.max(t.child_execution_order, e.child_execution_order) : await this.persistRun(e),
            this.runMap.delete(e.id),
            await ((r = this.onRunUpdate) == null ? void 0 : r.call(this, e))
        }
        _getExecutionOrder(e) {
            const t = e !== void 0 && this.runMap.get(e);
            return t ? t.child_execution_order + 1 : 1
        }
        _createRunForLLMStart(e, t, r, s, i, a, c, u) {
            const l = this._getExecutionOrder(s)
              , d = Date.now()
              , h = c ? {
                ...i,
                metadata: c
            } : i
              , f = {
                id: r,
                name: u ?? e.id[e.id.length - 1],
                parent_run_id: s,
                start_time: d,
                serialized: e,
                events: [{
                    name: "start",
                    time: new Date(d).toISOString()
                }],
                inputs: {
                    prompts: t
                },
                execution_order: l,
                child_runs: [],
                child_execution_order: l,
                run_type: "llm",
                extra: h ?? {},
                tags: a || []
            };
            return this._addRunToRunMap(f)
        }
        async handleLLMStart(e, t, r, s, i, a, c, u) {
            var d, h;
            const l = this.runMap.get(r) ?? this._createRunForLLMStart(e, t, r, s, i, a, c, u);
            return await ((d = this.onRunCreate) == null ? void 0 : d.call(this, l)),
            await ((h = this.onLLMStart) == null ? void 0 : h.call(this, l)),
            l
        }
        _createRunForChatModelStart(e, t, r, s, i, a, c, u) {
            const l = this._getExecutionOrder(s)
              , d = Date.now()
              , h = c ? {
                ...i,
                metadata: c
            } : i
              , f = {
                id: r,
                name: u ?? e.id[e.id.length - 1],
                parent_run_id: s,
                start_time: d,
                serialized: e,
                events: [{
                    name: "start",
                    time: new Date(d).toISOString()
                }],
                inputs: {
                    messages: t
                },
                execution_order: l,
                child_runs: [],
                child_execution_order: l,
                run_type: "llm",
                extra: h ?? {},
                tags: a || []
            };
            return this._addRunToRunMap(f)
        }
        async handleChatModelStart(e, t, r, s, i, a, c, u) {
            var d, h;
            const l = this.runMap.get(r) ?? this._createRunForChatModelStart(e, t, r, s, i, a, c, u);
            return await ((d = this.onRunCreate) == null ? void 0 : d.call(this, l)),
            await ((h = this.onLLMStart) == null ? void 0 : h.call(this, l)),
            l
        }
        async handleLLMEnd(e, t, r, s, i) {
            var c;
            const a = this.runMap.get(t);
            if (!a || (a == null ? void 0 : a.run_type) !== "llm")
                throw new Error("No LLM run to end.");
            return a.end_time = Date.now(),
            a.outputs = e,
            a.events.push({
                name: "end",
                time: new Date(a.end_time).toISOString()
            }),
            a.extra = {
                ...a.extra,
                ...i
            },
            await ((c = this.onLLMEnd) == null ? void 0 : c.call(this, a)),
            await this._endTrace(a),
            a
        }
        async handleLLMError(e, t, r, s, i) {
            var c;
            const a = this.runMap.get(t);
            if (!a || (a == null ? void 0 : a.run_type) !== "llm")
                throw new Error("No LLM run to end.");
            return a.end_time = Date.now(),
            a.error = this.stringifyError(e),
            a.events.push({
                name: "error",
                time: new Date(a.end_time).toISOString()
            }),
            a.extra = {
                ...a.extra,
                ...i
            },
            await ((c = this.onLLMError) == null ? void 0 : c.call(this, a)),
            await this._endTrace(a),
            a
        }
        _createRunForChainStart(e, t, r, s, i, a, c, u) {
            const l = this._getExecutionOrder(s)
              , d = Date.now()
              , h = {
                id: r,
                name: u ?? e.id[e.id.length - 1],
                parent_run_id: s,
                start_time: d,
                serialized: e,
                events: [{
                    name: "start",
                    time: new Date(d).toISOString()
                }],
                inputs: t,
                execution_order: l,
                child_execution_order: l,
                run_type: c ?? "chain",
                child_runs: [],
                extra: a ? {
                    metadata: a
                } : {},
                tags: i || []
            };
            return this._addRunToRunMap(h)
        }
        async handleChainStart(e, t, r, s, i, a, c, u) {
            var d, h;
            const l = this.runMap.get(r) ?? this._createRunForChainStart(e, t, r, s, i, a, c, u);
            return await ((d = this.onRunCreate) == null ? void 0 : d.call(this, l)),
            await ((h = this.onChainStart) == null ? void 0 : h.call(this, l)),
            l
        }
        async handleChainEnd(e, t, r, s, i) {
            var c;
            const a = this.runMap.get(t);
            if (!a)
                throw new Error("No chain run to end.");
            return a.end_time = Date.now(),
            a.outputs = U0(e, "output"),
            a.events.push({
                name: "end",
                time: new Date(a.end_time).toISOString()
            }),
            (i == null ? void 0 : i.inputs) !== void 0 && (a.inputs = U0(i.inputs, "input")),
            await ((c = this.onChainEnd) == null ? void 0 : c.call(this, a)),
            await this._endTrace(a),
            a
        }
        async handleChainError(e, t, r, s, i) {
            var c;
            const a = this.runMap.get(t);
            if (!a)
                throw new Error("No chain run to end.");
            return a.end_time = Date.now(),
            a.error = this.stringifyError(e),
            a.events.push({
                name: "error",
                time: new Date(a.end_time).toISOString()
            }),
            (i == null ? void 0 : i.inputs) !== void 0 && (a.inputs = U0(i.inputs, "input")),
            await ((c = this.onChainError) == null ? void 0 : c.call(this, a)),
            await this._endTrace(a),
            a
        }
        _createRunForToolStart(e, t, r, s, i, a, c) {
            const u = this._getExecutionOrder(s)
              , l = Date.now()
              , d = {
                id: r,
                name: c ?? e.id[e.id.length - 1],
                parent_run_id: s,
                start_time: l,
                serialized: e,
                events: [{
                    name: "start",
                    time: new Date(l).toISOString()
                }],
                inputs: {
                    input: t
                },
                execution_order: u,
                child_execution_order: u,
                run_type: "tool",
                child_runs: [],
                extra: a ? {
                    metadata: a
                } : {},
                tags: i || []
            };
            return this._addRunToRunMap(d)
        }
        async handleToolStart(e, t, r, s, i, a, c) {
            var l, d;
            const u = this.runMap.get(r) ?? this._createRunForToolStart(e, t, r, s, i, a, c);
            return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)),
            await ((d = this.onToolStart) == null ? void 0 : d.call(this, u)),
            u
        }
        async handleToolEnd(e, t) {
            var s;
            const r = this.runMap.get(t);
            if (!r || (r == null ? void 0 : r.run_type) !== "tool")
                throw new Error("No tool run to end");
            return r.end_time = Date.now(),
            r.outputs = {
                output: e
            },
            r.events.push({
                name: "end",
                time: new Date(r.end_time).toISOString()
            }),
            await ((s = this.onToolEnd) == null ? void 0 : s.call(this, r)),
            await this._endTrace(r),
            r
        }
        async handleToolError(e, t) {
            var s;
            const r = this.runMap.get(t);
            if (!r || (r == null ? void 0 : r.run_type) !== "tool")
                throw new Error("No tool run to end");
            return r.end_time = Date.now(),
            r.error = this.stringifyError(e),
            r.events.push({
                name: "error",
                time: new Date(r.end_time).toISOString()
            }),
            await ((s = this.onToolError) == null ? void 0 : s.call(this, r)),
            await this._endTrace(r),
            r
        }
        async handleAgentAction(e, t) {
            var i;
            const r = this.runMap.get(t);
            if (!r || (r == null ? void 0 : r.run_type) !== "chain")
                return;
            const s = r;
            s.actions = s.actions || [],
            s.actions.push(e),
            s.events.push({
                name: "agent_action",
                time: new Date().toISOString(),
                kwargs: {
                    action: e
                }
            }),
            await ((i = this.onAgentAction) == null ? void 0 : i.call(this, r))
        }
        async handleAgentEnd(e, t) {
            var s;
            const r = this.runMap.get(t);
            !r || (r == null ? void 0 : r.run_type) !== "chain" || (r.events.push({
                name: "agent_end",
                time: new Date().toISOString(),
                kwargs: {
                    action: e
                }
            }),
            await ((s = this.onAgentEnd) == null ? void 0 : s.call(this, r)))
        }
        _createRunForRetrieverStart(e, t, r, s, i, a, c) {
            const u = this._getExecutionOrder(s)
              , l = Date.now()
              , d = {
                id: r,
                name: c ?? e.id[e.id.length - 1],
                parent_run_id: s,
                start_time: l,
                serialized: e,
                events: [{
                    name: "start",
                    time: new Date(l).toISOString()
                }],
                inputs: {
                    query: t
                },
                execution_order: u,
                child_execution_order: u,
                run_type: "retriever",
                child_runs: [],
                extra: a ? {
                    metadata: a
                } : {},
                tags: i || []
            };
            return this._addRunToRunMap(d)
        }
        async handleRetrieverStart(e, t, r, s, i, a, c) {
            var l, d;
            const u = this.runMap.get(r) ?? this._createRunForRetrieverStart(e, t, r, s, i, a, c);
            return await ((l = this.onRunCreate) == null ? void 0 : l.call(this, u)),
            await ((d = this.onRetrieverStart) == null ? void 0 : d.call(this, u)),
            u
        }
        async handleRetrieverEnd(e, t) {
            var s;
            const r = this.runMap.get(t);
            if (!r || (r == null ? void 0 : r.run_type) !== "retriever")
                throw new Error("No retriever run to end");
            return r.end_time = Date.now(),
            r.outputs = {
                documents: e
            },
            r.events.push({
                name: "end",
                time: new Date(r.end_time).toISOString()
            }),
            await ((s = this.onRetrieverEnd) == null ? void 0 : s.call(this, r)),
            await this._endTrace(r),
            r
        }
        async handleRetrieverError(e, t) {
            var s;
            const r = this.runMap.get(t);
            if (!r || (r == null ? void 0 : r.run_type) !== "retriever")
                throw new Error("No retriever run to end");
            return r.end_time = Date.now(),
            r.error = this.stringifyError(e),
            r.events.push({
                name: "error",
                time: new Date(r.end_time).toISOString()
            }),
            await ((s = this.onRetrieverError) == null ? void 0 : s.call(this, r)),
            await this._endTrace(r),
            r
        }
        async handleText(e, t) {
            var s;
            const r = this.runMap.get(t);
            !r || (r == null ? void 0 : r.run_type) !== "chain" || (r.events.push({
                name: "text",
                time: new Date().toISOString(),
                kwargs: {
                    text: e
                }
            }),
            await ((s = this.onText) == null ? void 0 : s.call(this, r)))
        }
        async handleLLMNewToken(e, t, r, s, i, a) {
            var u;
            const c = this.runMap.get(r);
            if (!c || (c == null ? void 0 : c.run_type) !== "llm")
                throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');
            return c.events.push({
                name: "new_token",
                time: new Date().toISOString(),
                kwargs: {
                    token: e,
                    idx: t,
                    chunk: a == null ? void 0 : a.chunk
                }
            }),
            await ((u = this.onLLMNewToken) == null ? void 0 : u.call(this, c, e, {
                chunk: a == null ? void 0 : a.chunk
            })),
            c
        }
    }
    var ew = {
        exports: {}
    };
    ew.exports;
    var BA;
    function D2() {
        return BA || (BA = 1,
        function(n) {
            const t = (i=0) => a => `\x1B[${38 + i};5;${a}m`
              , r = (i=0) => (a, c, u) => `\x1B[${38 + i};2;${a};${c};${u}m`;
            function s() {
                const i = new Map
                  , a = {
                    modifier: {
                        reset: [0, 0],
                        bold: [1, 22],
                        dim: [2, 22],
                        italic: [3, 23],
                        underline: [4, 24],
                        overline: [53, 55],
                        inverse: [7, 27],
                        hidden: [8, 28],
                        strikethrough: [9, 29]
                    },
                    color: {
                        black: [30, 39],
                        red: [31, 39],
                        green: [32, 39],
                        yellow: [33, 39],
                        blue: [34, 39],
                        magenta: [35, 39],
                        cyan: [36, 39],
                        white: [37, 39],
                        blackBright: [90, 39],
                        redBright: [91, 39],
                        greenBright: [92, 39],
                        yellowBright: [93, 39],
                        blueBright: [94, 39],
                        magentaBright: [95, 39],
                        cyanBright: [96, 39],
                        whiteBright: [97, 39]
                    },
                    bgColor: {
                        bgBlack: [40, 49],
                        bgRed: [41, 49],
                        bgGreen: [42, 49],
                        bgYellow: [43, 49],
                        bgBlue: [44, 49],
                        bgMagenta: [45, 49],
                        bgCyan: [46, 49],
                        bgWhite: [47, 49],
                        bgBlackBright: [100, 49],
                        bgRedBright: [101, 49],
                        bgGreenBright: [102, 49],
                        bgYellowBright: [103, 49],
                        bgBlueBright: [104, 49],
                        bgMagentaBright: [105, 49],
                        bgCyanBright: [106, 49],
                        bgWhiteBright: [107, 49]
                    }
                };
                a.color.gray = a.color.blackBright,
                a.bgColor.bgGray = a.bgColor.bgBlackBright,
                a.color.grey = a.color.blackBright,
                a.bgColor.bgGrey = a.bgColor.bgBlackBright;
                for (const [c,u] of Object.entries(a)) {
                    for (const [l,d] of Object.entries(u))
                        a[l] = {
                            open: `\x1B[${d[0]}m`,
                            close: `\x1B[${d[1]}m`
                        },
                        u[l] = a[l],
                        i.set(d[0], d[1]);
                    Object.defineProperty(a, c, {
                        value: u,
                        enumerable: !1
                    })
                }
                return Object.defineProperty(a, "codes", {
                    value: i,
                    enumerable: !1
                }),
                a.color.close = "\x1B[39m",
                a.bgColor.close = "\x1B[49m",
                a.color.ansi256 = t(),
                a.color.ansi16m = r(),
                a.bgColor.ansi256 = t(10),
                a.bgColor.ansi16m = r(10),
                Object.defineProperties(a, {
                    rgbToAnsi256: {
                        value: (c, u, l) => c === u && u === l ? c < 8 ? 16 : c > 248 ? 231 : Math.round((c - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(c / 255 * 5) + 6 * Math.round(u / 255 * 5) + Math.round(l / 255 * 5),
                        enumerable: !1
                    },
                    hexToRgb: {
                        value: c => {
                            const u = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(c.toString(16));
                            if (!u)
                                return [0, 0, 0];
                            let {colorString: l} = u.groups;
                            l.length === 3 && (l = l.split("").map(h => h + h).join(""));
                            const d = Number.parseInt(l, 16);
                            return [d >> 16 & 255, d >> 8 & 255, d & 255]
                        }
                        ,
                        enumerable: !1
                    },
                    hexToAnsi256: {
                        value: c => a.rgbToAnsi256(...a.hexToRgb(c)),
                        enumerable: !1
                    }
                }),
                a
            }
            Object.defineProperty(n, "exports", {
                enumerable: !0,
                get: s
            })
        }(ew)),
        ew.exports
    }
    var B2 = D2();
    const qA = De(B2);
    function Er(n, e) {
        return `${n.open}${e}${n.close}`
    }
    function gn(n, e) {
        try {
            return JSON.stringify(n, null, 2)
        } catch {
            return e
        }
    }
    function UA(n) {
        return typeof n == "string" ? n.trim() : n == null ? n : gn(n, n.toString())
    }
    function Fi(n) {
        if (!n.end_time)
            return "";
        const e = n.end_time - n.start_time;
        return e < 1e3 ? `${e}ms` : `${(e / 1e3).toFixed(2)}s`
    }
    const {color: Mr} = qA;
    class KA extends yh {
        constructor() {
            super(...arguments),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "console_callback_handler"
            })
        }
        persistRun(e) {
            return Promise.resolve()
        }
        getParents(e) {
            const t = [];
            let r = e;
            for (; r.parent_run_id; ) {
                const s = this.runMap.get(r.parent_run_id);
                if (s)
                    t.push(s),
                    r = s;
                else
                    break
            }
            return t
        }
        getBreadcrumbs(e) {
            const r = [...this.getParents(e).reverse(), e].map( (s, i, a) => {
                const c = `${s.execution_order}:${s.run_type}:${s.name}`;
                return i === a.length - 1 ? Er(qA.bold, c) : c
            }
            ).join(" > ");
            return Er(Mr.grey, r)
        }
        onChainStart(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.green, "[chain/start]")} [${t}] Entering Chain run with input: ${gn(e.inputs, "[inputs]")}`)
        }
        onChainEnd(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.cyan, "[chain/end]")} [${t}] [${Fi(e)}] Exiting Chain run with output: ${gn(e.outputs, "[outputs]")}`)
        }
        onChainError(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.red, "[chain/error]")} [${t}] [${Fi(e)}] Chain run errored with error: ${gn(e.error, "[error]")}`)
        }
        onLLMStart(e) {
            const t = this.getBreadcrumbs(e)
              , r = "prompts"in e.inputs ? {
                prompts: e.inputs.prompts.map(s => s.trim())
            } : e.inputs;
            console.log(`${Er(Mr.green, "[llm/start]")} [${t}] Entering LLM run with input: ${gn(r, "[inputs]")}`)
        }
        onLLMEnd(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.cyan, "[llm/end]")} [${t}] [${Fi(e)}] Exiting LLM run with output: ${gn(e.outputs, "[response]")}`)
        }
        onLLMError(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.red, "[llm/error]")} [${t}] [${Fi(e)}] LLM run errored with error: ${gn(e.error, "[error]")}`)
        }
        onToolStart(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.green, "[tool/start]")} [${t}] Entering Tool run with input: "${UA(e.inputs.input)}"`)
        }
        onToolEnd(e) {
            var r;
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.cyan, "[tool/end]")} [${t}] [${Fi(e)}] Exiting Tool run with output: "${UA((r = e.outputs) == null ? void 0 : r.output)}"`)
        }
        onToolError(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.red, "[tool/error]")} [${t}] [${Fi(e)}] Tool run errored with error: ${gn(e.error, "[error]")}`)
        }
        onRetrieverStart(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.green, "[retriever/start]")} [${t}] Entering Retriever run with input: ${gn(e.inputs, "[inputs]")}`)
        }
        onRetrieverEnd(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.cyan, "[retriever/end]")} [${t}] [${Fi(e)}] Exiting Retriever run with output: ${gn(e.outputs, "[outputs]")}`)
        }
        onRetrieverError(e) {
            const t = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.red, "[retriever/error]")} [${t}] [${Fi(e)}] Retriever run errored with error: ${gn(e.error, "[error]")}`)
        }
        onAgentAction(e) {
            const t = e
              , r = this.getBreadcrumbs(e);
            console.log(`${Er(Mr.blue, "[agent/action]")} [${r}] Agent selected action: ${gn(t.actions[t.actions.length - 1], "[action]")}`)
        }
    }
    let K0;
    const q2 = () => {
        if (K0 === void 0) {
            const n = mn("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
                blockOnRootRunFinalization: !0
            } : {};
            K0 = new fh(n)
        }
        return K0
    }
    ;
    class wh extends yh {
        constructor(e={}) {
            super(e),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "langchain_tracer"
            }),
            Object.defineProperty(this, "projectName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "exampleId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "client", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            });
            const {exampleId: t, projectName: r, client: s} = e;
            this.projectName = r ?? mn("LANGCHAIN_PROJECT") ?? mn("LANGCHAIN_SESSION"),
            this.exampleId = t,
            this.client = s ?? q2();
            const i = wh.getTraceableRunTree();
            i && this.updateFromRunTree(i)
        }
        async _convertToCreate(e, t=void 0) {
            return {
                ...e,
                extra: {
                    ...e.extra,
                    runtime: await M2()
                },
                child_runs: void 0,
                session_name: this.projectName,
                reference_example_id: e.parent_run_id ? void 0 : t
            }
        }
        async persistRun(e) {}
        async onRunCreate(e) {
            const t = await this._convertToCreate(e, this.exampleId);
            await this.client.createRun(t)
        }
        async onRunUpdate(e) {
            const t = {
                end_time: e.end_time,
                error: e.error,
                outputs: e.outputs,
                events: e.events,
                inputs: e.inputs,
                trace_id: e.trace_id,
                dotted_order: e.dotted_order,
                parent_run_id: e.parent_run_id,
                extra: e.extra
            };
            await this.client.updateRun(e.id, t)
        }
        getRun(e) {
            return this.runMap.get(e)
        }
        updateFromRunTree(e) {
            let t = e;
            const r = new Set;
            for (; t.parent_run && !(r.has(t.id) || (r.add(t.id),
            !t.parent_run)); )
                t = t.parent_run;
            r.clear();
            const s = [t];
            for (; s.length > 0; ) {
                const i = s.shift();
                !i || r.has(i.id) || (r.add(i.id),
                this.runMap.set(i.id, i),
                i.child_runs && s.push(...i.child_runs))
            }
            this.client = e.client ?? this.client,
            this.projectName = e.project_name ?? this.projectName,
            this.exampleId = e.reference_example_id ?? this.exampleId
        }
        convertToRunTree(e) {
            const t = {}
              , r = [];
            for (const [s,i] of this.runMap) {
                const a = new Yr({
                    ...i,
                    child_runs: [],
                    parent_run: void 0,
                    client: this.client,
                    project_name: this.projectName,
                    reference_example_id: this.exampleId,
                    tracingEnabled: !0
                });
                t[s] = a,
                r.push([s, i.dotted_order])
            }
            r.sort( (s, i) => !s[1] || !i[1] ? 0 : s[1].localeCompare(i[1]));
            for (const [s] of r) {
                const i = this.runMap.get(s)
                  , a = t[s];
                if (!(!i || !a) && i.parent_run_id) {
                    const c = t[i.parent_run_id];
                    c && (c.child_runs.push(a),
                    a.parent_run = c)
                }
            }
            return t[e]
        }
        static getTraceableRunTree() {
            try {
                return _2()
            } catch {
                return
            }
        }
    }
    const HA = Symbol.for("ls:tracing_async_local_storage")
      , tw = Symbol.for("lc:context_variables")
      , U2 = n => {
        globalThis[HA] = n
    }
      , bh = () => globalThis[HA];
    let vh;
    function K2() {
        const n = "default"in Ks ? Ks.default : Ks;
        return new n({
            autoStart: !0,
            concurrency: 1
        })
    }
    function H2() {
        return typeof vh > "u" && (vh = K2()),
        vh
    }
    async function Ft(n, e) {
        if (e === !0) {
            const t = bh();
            t !== void 0 ? await t.run(void 0, async () => n()) : await n()
        } else
            vh = H2(),
            vh.add(async () => {
                const t = bh();
                t !== void 0 ? await t.run(void 0, async () => n()) : await n()
            }
            )
    }
    const W2 = n => !!["LANGSMITH_TRACING_V2", "LANGCHAIN_TRACING_V2", "LANGSMITH_TRACING", "LANGCHAIN_TRACING"].find(t => mn(t) === "true");
    function WA(n) {
        var r;
        const e = bh();
        if (e === void 0)
            return;
        const t = e.getStore();
        return (r = t == null ? void 0 : t[tw]) == null ? void 0 : r[n]
    }
    const z2 = Symbol("lc:configure_hooks")
      , V2 = () => WA(z2) || [];
    class G2 {
        setHandler(e) {
            return this.setHandlers([e])
        }
    }
    class rw {
        constructor(e, t, r, s, i, a, c, u) {
            Object.defineProperty(this, "runId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: e
            }),
            Object.defineProperty(this, "handlers", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: t
            }),
            Object.defineProperty(this, "inheritableHandlers", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r
            }),
            Object.defineProperty(this, "tags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: s
            }),
            Object.defineProperty(this, "inheritableTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: i
            }),
            Object.defineProperty(this, "metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: a
            }),
            Object.defineProperty(this, "inheritableMetadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: c
            }),
            Object.defineProperty(this, "_parentRunId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: u
            })
        }
        get parentRunId() {
            return this._parentRunId
        }
        async handleText(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                try {
                    await ((r = t.handleText) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                } catch (s) {
                    if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleText: ${s}`),
                    t.raiseError)
                        throw s
                }
            }
            , t.awaitHandlers)))
        }
        async handleCustomEvent(e, t, r, s, i) {
            await Promise.all(this.handlers.map(a => Ft(async () => {
                var c;
                try {
                    await ((c = a.handleCustomEvent) == null ? void 0 : c.call(a, e, t, this.runId, this.tags, this.metadata))
                } catch (u) {
                    if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleCustomEvent: ${u}`),
                    a.raiseError)
                        throw u
                }
            }
            , a.awaitHandlers)))
        }
    }
    class J2 extends rw {
        getChild(e) {
            const t = new Nr(this.runId);
            return t.setHandlers(this.inheritableHandlers),
            t.addTags(this.inheritableTags),
            t.addMetadata(this.inheritableMetadata),
            e && t.addTags([e], !1),
            t
        }
        async handleRetrieverEnd(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                if (!t.ignoreRetriever)
                    try {
                        await ((r = t.handleRetrieverEnd) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                    } catch (s) {
                        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleRetriever`),
                        t.raiseError)
                            throw s
                    }
            }
            , t.awaitHandlers)))
        }
        async handleRetrieverError(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                if (!t.ignoreRetriever)
                    try {
                        await ((r = t.handleRetrieverError) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                    } catch (s) {
                        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleRetrieverError: ${s}`),
                        t.raiseError)
                            throw e
                    }
            }
            , t.awaitHandlers)))
        }
    }
    class zA extends rw {
        async handleLLMNewToken(e, t, r, s, i, a) {
            await Promise.all(this.handlers.map(c => Ft(async () => {
                var u;
                if (!c.ignoreLLM)
                    try {
                        await ((u = c.handleLLMNewToken) == null ? void 0 : u.call(c, e, t ?? {
                            prompt: 0,
                            completion: 0
                        }, this.runId, this._parentRunId, this.tags, a))
                    } catch (l) {
                        if ((c.raiseError ? console.error : console.warn)(`Error in handler ${c.constructor.name}, handleLLMNewToken: ${l}`),
                        c.raiseError)
                            throw l
                    }
            }
            , c.awaitHandlers)))
        }
        async handleLLMError(e, t, r, s, i) {
            await Promise.all(this.handlers.map(a => Ft(async () => {
                var c;
                if (!a.ignoreLLM)
                    try {
                        await ((c = a.handleLLMError) == null ? void 0 : c.call(a, e, this.runId, this._parentRunId, this.tags, i))
                    } catch (u) {
                        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMError: ${u}`),
                        a.raiseError)
                            throw u
                    }
            }
            , a.awaitHandlers)))
        }
        async handleLLMEnd(e, t, r, s, i) {
            await Promise.all(this.handlers.map(a => Ft(async () => {
                var c;
                if (!a.ignoreLLM)
                    try {
                        await ((c = a.handleLLMEnd) == null ? void 0 : c.call(a, e, this.runId, this._parentRunId, this.tags, i))
                    } catch (u) {
                        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleLLMEnd: ${u}`),
                        a.raiseError)
                            throw u
                    }
            }
            , a.awaitHandlers)))
        }
    }
    class Z2 extends rw {
        getChild(e) {
            const t = new Nr(this.runId);
            return t.setHandlers(this.inheritableHandlers),
            t.addTags(this.inheritableTags),
            t.addMetadata(this.inheritableMetadata),
            e && t.addTags([e], !1),
            t
        }
        async handleChainError(e, t, r, s, i) {
            await Promise.all(this.handlers.map(a => Ft(async () => {
                var c;
                if (!a.ignoreChain)
                    try {
                        await ((c = a.handleChainError) == null ? void 0 : c.call(a, e, this.runId, this._parentRunId, this.tags, i))
                    } catch (u) {
                        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleChainError: ${u}`),
                        a.raiseError)
                            throw u
                    }
            }
            , a.awaitHandlers)))
        }
        async handleChainEnd(e, t, r, s, i) {
            await Promise.all(this.handlers.map(a => Ft(async () => {
                var c;
                if (!a.ignoreChain)
                    try {
                        await ((c = a.handleChainEnd) == null ? void 0 : c.call(a, e, this.runId, this._parentRunId, this.tags, i))
                    } catch (u) {
                        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleChainEnd: ${u}`),
                        a.raiseError)
                            throw u
                    }
            }
            , a.awaitHandlers)))
        }
        async handleAgentAction(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                if (!t.ignoreAgent)
                    try {
                        await ((r = t.handleAgentAction) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                    } catch (s) {
                        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleAgentAction: ${s}`),
                        t.raiseError)
                            throw s
                    }
            }
            , t.awaitHandlers)))
        }
        async handleAgentEnd(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                if (!t.ignoreAgent)
                    try {
                        await ((r = t.handleAgentEnd) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                    } catch (s) {
                        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleAgentEnd: ${s}`),
                        t.raiseError)
                            throw s
                    }
            }
            , t.awaitHandlers)))
        }
    }
    class X2 extends rw {
        getChild(e) {
            const t = new Nr(this.runId);
            return t.setHandlers(this.inheritableHandlers),
            t.addTags(this.inheritableTags),
            t.addMetadata(this.inheritableMetadata),
            e && t.addTags([e], !1),
            t
        }
        async handleToolError(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                if (!t.ignoreAgent)
                    try {
                        await ((r = t.handleToolError) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                    } catch (s) {
                        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleToolError: ${s}`),
                        t.raiseError)
                            throw s
                    }
            }
            , t.awaitHandlers)))
        }
        async handleToolEnd(e) {
            await Promise.all(this.handlers.map(t => Ft(async () => {
                var r;
                if (!t.ignoreAgent)
                    try {
                        await ((r = t.handleToolEnd) == null ? void 0 : r.call(t, e, this.runId, this._parentRunId, this.tags))
                    } catch (s) {
                        if ((t.raiseError ? console.error : console.warn)(`Error in handler ${t.constructor.name}, handleToolEnd: ${s}`),
                        t.raiseError)
                            throw s
                    }
            }
            , t.awaitHandlers)))
        }
    }
    class Nr extends G2 {
        constructor(e, t) {
            super(),
            Object.defineProperty(this, "handlers", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "inheritableHandlers", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "tags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "inheritableTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: {}
            }),
            Object.defineProperty(this, "inheritableMetadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: {}
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "callback_manager"
            }),
            Object.defineProperty(this, "_parentRunId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.handlers = (t == null ? void 0 : t.handlers) ?? this.handlers,
            this.inheritableHandlers = (t == null ? void 0 : t.inheritableHandlers) ?? this.inheritableHandlers,
            this.tags = (t == null ? void 0 : t.tags) ?? this.tags,
            this.inheritableTags = (t == null ? void 0 : t.inheritableTags) ?? this.inheritableTags,
            this.metadata = (t == null ? void 0 : t.metadata) ?? this.metadata,
            this.inheritableMetadata = (t == null ? void 0 : t.inheritableMetadata) ?? this.inheritableMetadata,
            this._parentRunId = e
        }
        getParentRunId() {
            return this._parentRunId
        }
        async handleLLMStart(e, t, r=void 0, s=void 0, i=void 0, a=void 0, c=void 0, u=void 0) {
            return Promise.all(t.map(async (l, d) => {
                const h = d === 0 && r ? r : Rr();
                return await Promise.all(this.handlers.map(f => {
                    if (!f.ignoreLLM)
                        return gh(f) && f._createRunForLLMStart(e, [l], h, this._parentRunId, i, this.tags, this.metadata, u),
                        Ft(async () => {
                            var p;
                            try {
                                await ((p = f.handleLLMStart) == null ? void 0 : p.call(f, e, [l], h, this._parentRunId, i, this.tags, this.metadata, u))
                            } catch (g) {
                                if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${g}`),
                                f.raiseError)
                                    throw g
                            }
                        }
                        , f.awaitHandlers)
                }
                )),
                new zA(h,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)
            }
            ))
        }
        async handleChatModelStart(e, t, r=void 0, s=void 0, i=void 0, a=void 0, c=void 0, u=void 0) {
            return Promise.all(t.map(async (l, d) => {
                const h = d === 0 && r ? r : Rr();
                return await Promise.all(this.handlers.map(f => {
                    if (!f.ignoreLLM)
                        return gh(f) && f._createRunForChatModelStart(e, [l], h, this._parentRunId, i, this.tags, this.metadata, u),
                        Ft(async () => {
                            var p, g;
                            try {
                                if (f.handleChatModelStart)
                                    await ((p = f.handleChatModelStart) == null ? void 0 : p.call(f, e, [l], h, this._parentRunId, i, this.tags, this.metadata, u));
                                else if (f.handleLLMStart) {
                                    const y = wT(l);
                                    await ((g = f.handleLLMStart) == null ? void 0 : g.call(f, e, [y], h, this._parentRunId, i, this.tags, this.metadata, u))
                                }
                            } catch (y) {
                                if ((f.raiseError ? console.error : console.warn)(`Error in handler ${f.constructor.name}, handleLLMStart: ${y}`),
                                f.raiseError)
                                    throw y
                            }
                        }
                        , f.awaitHandlers)
                }
                )),
                new zA(h,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)
            }
            ))
        }
        async handleChainStart(e, t, r=Rr(), s=void 0, i=void 0, a=void 0, c=void 0) {
            return await Promise.all(this.handlers.map(u => {
                if (!u.ignoreChain)
                    return gh(u) && u._createRunForChainStart(e, t, r, this._parentRunId, this.tags, this.metadata, s, c),
                    Ft(async () => {
                        var l;
                        try {
                            await ((l = u.handleChainStart) == null ? void 0 : l.call(u, e, t, r, this._parentRunId, this.tags, this.metadata, s, c))
                        } catch (d) {
                            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleChainStart: ${d}`),
                            u.raiseError)
                                throw d
                        }
                    }
                    , u.awaitHandlers)
            }
            )),
            new Z2(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)
        }
        async handleToolStart(e, t, r=Rr(), s=void 0, i=void 0, a=void 0, c=void 0) {
            return await Promise.all(this.handlers.map(u => {
                if (!u.ignoreAgent)
                    return gh(u) && u._createRunForToolStart(e, t, r, this._parentRunId, this.tags, this.metadata, c),
                    Ft(async () => {
                        var l;
                        try {
                            await ((l = u.handleToolStart) == null ? void 0 : l.call(u, e, t, r, this._parentRunId, this.tags, this.metadata, c))
                        } catch (d) {
                            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleToolStart: ${d}`),
                            u.raiseError)
                                throw d
                        }
                    }
                    , u.awaitHandlers)
            }
            )),
            new X2(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)
        }
        async handleRetrieverStart(e, t, r=Rr(), s=void 0, i=void 0, a=void 0, c=void 0) {
            return await Promise.all(this.handlers.map(u => {
                if (!u.ignoreRetriever)
                    return gh(u) && u._createRunForRetrieverStart(e, t, r, this._parentRunId, this.tags, this.metadata, c),
                    Ft(async () => {
                        var l;
                        try {
                            await ((l = u.handleRetrieverStart) == null ? void 0 : l.call(u, e, t, r, this._parentRunId, this.tags, this.metadata, c))
                        } catch (d) {
                            if ((u.raiseError ? console.error : console.warn)(`Error in handler ${u.constructor.name}, handleRetrieverStart: ${d}`),
                            u.raiseError)
                                throw d
                        }
                    }
                    , u.awaitHandlers)
            }
            )),
            new J2(r,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)
        }
        async handleCustomEvent(e, t, r, s, i) {
            await Promise.all(this.handlers.map(a => Ft(async () => {
                var c;
                if (!a.ignoreCustomEvent)
                    try {
                        await ((c = a.handleCustomEvent) == null ? void 0 : c.call(a, e, t, r, this.tags, this.metadata))
                    } catch (u) {
                        if ((a.raiseError ? console.error : console.warn)(`Error in handler ${a.constructor.name}, handleCustomEvent: ${u}`),
                        a.raiseError)
                            throw u
                    }
            }
            , a.awaitHandlers)))
        }
        addHandler(e, t=!0) {
            this.handlers.push(e),
            t && this.inheritableHandlers.push(e)
        }
        removeHandler(e) {
            this.handlers = this.handlers.filter(t => t !== e),
            this.inheritableHandlers = this.inheritableHandlers.filter(t => t !== e)
        }
        setHandlers(e, t=!0) {
            this.handlers = [],
            this.inheritableHandlers = [];
            for (const r of e)
                this.addHandler(r, t)
        }
        addTags(e, t=!0) {
            this.removeTags(e),
            this.tags.push(...e),
            t && this.inheritableTags.push(...e)
        }
        removeTags(e) {
            this.tags = this.tags.filter(t => !e.includes(t)),
            this.inheritableTags = this.inheritableTags.filter(t => !e.includes(t))
        }
        addMetadata(e, t=!0) {
            this.metadata = {
                ...this.metadata,
                ...e
            },
            t && (this.inheritableMetadata = {
                ...this.inheritableMetadata,
                ...e
            })
        }
        removeMetadata(e) {
            for (const t of Object.keys(e))
                delete this.metadata[t],
                delete this.inheritableMetadata[t]
        }
        copy(e=[], t=!0) {
            const r = new Nr(this._parentRunId);
            for (const s of this.handlers) {
                const i = this.inheritableHandlers.includes(s);
                r.addHandler(s, i)
            }
            for (const s of this.tags) {
                const i = this.inheritableTags.includes(s);
                r.addTags([s], i)
            }
            for (const s of Object.keys(this.metadata)) {
                const i = Object.keys(this.inheritableMetadata).includes(s);
                r.addMetadata({
                    [s]: this.metadata[s]
                }, i)
            }
            for (const s of e)
                r.handlers.filter(i => i.name === "console_callback_handler").some(i => i.name === s.name) || r.addHandler(s, t);
            return r
        }
        static fromHandlers(e) {
            class t extends mh {
                constructor() {
                    super(),
                    Object.defineProperty(this, "name", {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: Rr()
                    }),
                    Object.assign(this, e)
                }
            }
            const r = new this;
            return r.addHandler(new t),
            r
        }
        static configure(e, t, r, s, i, a, c) {
            return this._configureSync(e, t, r, s, i, a, c)
        }
        static _configureSync(e, t, r, s, i, a, c) {
            var f, p;
            let u;
            (e || t) && (Array.isArray(e) || !e ? (u = new Nr,
            u.setHandlers((e == null ? void 0 : e.map(nw)) ?? [], !0)) : u = e,
            u = u.copy(Array.isArray(t) ? t.map(nw) : t == null ? void 0 : t.handlers, !1));
            const l = mn("LANGCHAIN_VERBOSE") === "true" || (c == null ? void 0 : c.verbose)
              , d = ((f = wh.getTraceableRunTree()) == null ? void 0 : f.tracingEnabled) || W2()
              , h = d || (mn("LANGCHAIN_TRACING") ?? !1);
            if (l || h) {
                if (u || (u = new Nr),
                l && !u.handlers.some(g => g.name === KA.prototype.name)) {
                    const g = new KA;
                    u.addHandler(g, !0)
                }
                if (h && !u.handlers.some(g => g.name === "langchain_tracer") && d) {
                    const g = new wh;
                    u.addHandler(g, !0),
                    u._parentRunId = ((p = wh.getTraceableRunTree()) == null ? void 0 : p.id) ?? u._parentRunId
                }
            }
            for (const {contextVar: g, inheritable: y=!0, handlerClass: m, envVar: w} of V2()) {
                const E = w && mn(w) === "true" && m;
                let v;
                const _ = g !== void 0 ? WA(g) : void 0;
                _ && L2(_) ? v = _ : E && (v = new m({})),
                v !== void 0 && (u || (u = new Nr),
                u.handlers.some(A => A.name === v.name) || u.addHandler(v, y))
            }
            return (r || s) && u && (u.addTags(r ?? []),
            u.addTags(s ?? [], !1)),
            (i || a) && u && (u.addMetadata(i ?? {}),
            u.addMetadata(a ?? {}, !1)),
            u
        }
    }
    function nw(n) {
        return "name"in n ? n : mh.fromMethods(n)
    }
    class Y2 {
        getStore() {}
        run(e, t) {
            return t()
        }
        enterWith(e) {}
    }
    const Q2 = new Y2
      , VA = Symbol.for("lc:child_config");
    class e4 {
        getInstance() {
            return bh() ?? Q2
        }
        getRunnableConfig() {
            var t, r;
            return (r = (t = this.getInstance().getStore()) == null ? void 0 : t.extra) == null ? void 0 : r[VA]
        }
        runWithConfig(e, t, r) {
            var d;
            const s = Nr._configureSync(e == null ? void 0 : e.callbacks, void 0, e == null ? void 0 : e.tags, void 0, e == null ? void 0 : e.metadata)
              , i = this.getInstance()
              , a = i.getStore()
              , c = s == null ? void 0 : s.getParentRunId()
              , u = (d = s == null ? void 0 : s.handlers) == null ? void 0 : d.find(h => (h == null ? void 0 : h.name) === "langchain_tracer");
            let l;
            return u && c ? l = u.convertToRunTree(c) : r || (l = new Yr({
                name: "<runnable_lambda>",
                tracingEnabled: !1
            })),
            l && (l.extra = {
                ...l.extra,
                [VA]: e
            }),
            a !== void 0 && a[tw] !== void 0 && (l[tw] = a[tw]),
            i.run(l, t)
        }
        initializeGlobalInstance(e) {
            bh() === void 0 && U2(e)
        }
    }
    const ji = new e4
      , H0 = 25;
    async function Mn(n) {
        return Nr._configureSync(n == null ? void 0 : n.callbacks, void 0, n == null ? void 0 : n.tags, void 0, n == null ? void 0 : n.metadata)
    }
    function GA(...n) {
        const e = {};
        for (const t of n.filter(r => !!r))
            for (const r of Object.keys(t))
                if (r === "metadata")
                    e[r] = {
                        ...e[r],
                        ...t[r]
                    };
                else if (r === "tags") {
                    const s = e[r] ?? [];
                    e[r] = [...new Set(s.concat(t[r] ?? []))]
                } else if (r === "configurable")
                    e[r] = {
                        ...e[r],
                        ...t[r]
                    };
                else if (r === "timeout")
                    e.timeout === void 0 ? e.timeout = t.timeout : t.timeout !== void 0 && (e.timeout = Math.min(e.timeout, t.timeout));
                else if (r === "signal")
                    e.signal === void 0 ? e.signal = t.signal : t.signal !== void 0 && ("any"in AbortSignal ? e.signal = AbortSignal.any([e.signal, t.signal]) : e.signal = t.signal);
                else if (r === "callbacks") {
                    const s = e.callbacks
                      , i = t.callbacks;
                    if (Array.isArray(i))
                        if (!s)
                            e.callbacks = i;
                        else if (Array.isArray(s))
                            e.callbacks = s.concat(i);
                        else {
                            const a = s.copy();
                            for (const c of i)
                                a.addHandler(nw(c), !0);
                            e.callbacks = a
                        }
                    else if (i)
                        if (!s)
                            e.callbacks = i;
                        else if (Array.isArray(s)) {
                            const a = i.copy();
                            for (const c of s)
                                a.addHandler(nw(c), !0);
                            e.callbacks = a
                        } else
                            e.callbacks = new Nr(i._parentRunId,{
                                handlers: s.handlers.concat(i.handlers),
                                inheritableHandlers: s.inheritableHandlers.concat(i.inheritableHandlers),
                                tags: Array.from(new Set(s.tags.concat(i.tags))),
                                inheritableTags: Array.from(new Set(s.inheritableTags.concat(i.inheritableTags))),
                                metadata: {
                                    ...s.metadata,
                                    ...i.metadata
                                }
                            })
                } else {
                    const s = r;
                    e[s] = t[s] ?? e[s]
                }
        return e
    }
    const t4 = new Set(["string", "number", "boolean"]);
    function it(n) {
        var r;
        const e = ji.getRunnableConfig();
        let t = {
            tags: [],
            metadata: {},
            recursionLimit: 25,
            runId: void 0
        };
        if (e) {
            const {runId: s, runName: i, ...a} = e;
            t = Object.entries(a).reduce( (c, [u,l]) => (l !== void 0 && (c[u] = l),
            c), t)
        }
        if (n && (t = Object.entries(n).reduce( (s, [i,a]) => (a !== void 0 && (s[i] = a),
        s), t)),
        t != null && t.configurable)
            for (const s of Object.keys(t.configurable))
                t4.has(typeof t.configurable[s]) && !((r = t.metadata) != null && r[s]) && (t.metadata || (t.metadata = {}),
                t.metadata[s] = t.configurable[s]);
        if (t.timeout !== void 0) {
            if (t.timeout <= 0)
                throw new Error("Timeout must be a positive number");
            const s = AbortSignal.timeout(t.timeout);
            t.signal !== void 0 ? "any"in AbortSignal && (t.signal = AbortSignal.any([t.signal, s])) : t.signal = s,
            delete t.timeout
        }
        return t
    }
    function dr(n={}, {callbacks: e, maxConcurrency: t, recursionLimit: r, runName: s, configurable: i, runId: a}={}) {
        const c = it(n);
        return e !== void 0 && (delete c.runName,
        c.callbacks = e),
        r !== void 0 && (c.recursionLimit = r),
        t !== void 0 && (c.maxConcurrency = t),
        s !== void 0 && (c.runName = s),
        i !== void 0 && (c.configurable = {
            ...c.configurable,
            ...i
        }),
        a !== void 0 && delete c.runId,
        c
    }
    function lu(n) {
        return n ? {
            configurable: n.configurable,
            recursionLimit: n.recursionLimit,
            callbacks: n.callbacks,
            tags: n.tags,
            metadata: n.metadata,
            maxConcurrency: n.maxConcurrency,
            timeout: n.timeout,
            signal: n.signal
        } : void 0
    }
    async function Di(n, e) {
        if (e === void 0)
            return n;
        let t;
        return Promise.race([n.catch(r => {
            if (!(e != null && e.aborted))
                throw r
        }
        ), new Promise( (r, s) => {
            t = () => {
                s(new Error("Aborted"))
            }
            ,
            e.addEventListener("abort", t),
            e.aborted && s(new Error("Aborted"))
        }
        )]).finally( () => e.removeEventListener("abort", t))
    }
    class Qr extends ReadableStream {
        constructor() {
            super(...arguments),
            Object.defineProperty(this, "reader", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            })
        }
        ensureReader() {
            this.reader || (this.reader = this.getReader())
        }
        async next() {
            this.ensureReader();
            try {
                const e = await this.reader.read();
                return e.done ? (this.reader.releaseLock(),
                {
                    done: !0,
                    value: void 0
                }) : {
                    done: !1,
                    value: e.value
                }
            } catch (e) {
                throw this.reader.releaseLock(),
                e
            }
        }
        async return() {
            if (this.ensureReader(),
            this.locked) {
                const e = this.reader.cancel();
                this.reader.releaseLock(),
                await e
            }
            return {
                done: !0,
                value: void 0
            }
        }
        async throw(e) {
            if (this.ensureReader(),
            this.locked) {
                const t = this.reader.cancel();
                this.reader.releaseLock(),
                await t
            }
            throw e
        }
        [Symbol.asyncIterator]() {
            return this
        }
        async[Symbol.asyncDispose]() {
            await this.return()
        }
        static fromReadableStream(e) {
            const t = e.getReader();
            return new Qr({
                start(r) {
                    return s();
                    function s() {
                        return t.read().then( ({done: i, value: a}) => {
                            if (i) {
                                r.close();
                                return
                            }
                            return r.enqueue(a),
                            s()
                        }
                        )
                    }
                },
                cancel() {
                    t.releaseLock()
                }
            })
        }
        static fromAsyncGenerator(e) {
            return new Qr({
                async pull(t) {
                    const {value: r, done: s} = await e.next();
                    s && t.close(),
                    t.enqueue(r)
                },
                async cancel(t) {
                    await e.return(t)
                }
            })
        }
    }
    function JA(n, e=2) {
        const t = Array.from({
            length: e
        }, () => []);
        return t.map(async function*(s) {
            for (; ; )
                if (s.length === 0) {
                    const i = await n.next();
                    for (const a of t)
                        a.push(i)
                } else {
                    if (s[0].done)
                        return;
                    yield s.shift().value
                }
        })
    }
    function Nn(n, e) {
        if (Array.isArray(n) && Array.isArray(e))
            return n.concat(e);
        if (typeof n == "string" && typeof e == "string")
            return n + e;
        if (typeof n == "number" && typeof e == "number")
            return n + e;
        if ("concat"in n && typeof n.concat == "function")
            return n.concat(e);
        if (typeof n == "object" && typeof e == "object") {
            const t = {
                ...n
            };
            for (const [r,s] of Object.entries(e))
                r in t && !Array.isArray(t[r]) ? t[r] = Nn(t[r], s) : t[r] = s;
            return t
        } else
            throw new Error(`Cannot concat ${typeof n} and ${typeof e}`)
    }
    class du {
        constructor(e) {
            var t;
            Object.defineProperty(this, "generator", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "setup", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "config", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "signal", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "firstResult", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "firstResultUsed", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            this.generator = e.generator,
            this.config = e.config,
            this.signal = e.signal ?? ((t = this.config) == null ? void 0 : t.signal),
            this.setup = new Promise( (r, s) => {
                ji.runWithConfig(lu(e.config), async () => {
                    this.firstResult = e.generator.next(),
                    e.startSetup ? this.firstResult.then(e.startSetup).then(r, s) : this.firstResult.then(i => r(void 0), s)
                }
                , !0)
            }
            )
        }
        async next(...e) {
            var t;
            return (t = this.signal) == null || t.throwIfAborted(),
            this.firstResultUsed ? ji.runWithConfig(lu(this.config), this.signal ? async () => Di(this.generator.next(...e), this.signal) : async () => this.generator.next(...e), !0) : (this.firstResultUsed = !0,
            this.firstResult)
        }
        async return(e) {
            return this.generator.return(e)
        }
        async throw(e) {
            return this.generator.throw(e)
        }
        [Symbol.asyncIterator]() {
            return this
        }
        async[Symbol.asyncDispose]() {
            await this.return()
        }
    }
    async function r4(n, e, t, r, ...s) {
        const i = new du({
            generator: e,
            startSetup: t,
            signal: r
        })
          , a = await i.setup;
        return {
            output: n(i, a, ...s),
            setup: a
        }
    }
    class Bi {
        constructor(e) {
            Object.defineProperty(this, "ops", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.ops = e.ops ?? []
        }
        concat(e) {
            const t = this.ops.concat(e.ops)
              , r = Yy({}, t);
            return new _h({
                ops: t,
                state: r[r.length - 1].newDocument
            })
        }
    }
    class _h extends Bi {
        constructor(e) {
            super(e),
            Object.defineProperty(this, "state", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.state = e.state
        }
        concat(e) {
            const t = this.ops.concat(e.ops)
              , r = Yy(this.state, e.ops);
            return new _h({
                ops: t,
                state: r[r.length - 1].newDocument
            })
        }
        static fromRunLogPatch(e) {
            const t = Yy({}, e.ops);
            return new _h({
                ops: e.ops,
                state: t[t.length - 1].newDocument
            })
        }
    }
    const n4 = n => n.name === "log_stream_tracer";
    async function ZA(n, e) {
        if (e === "original")
            throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
        const {inputs: t} = n;
        if (["retriever", "llm", "prompt"].includes(n.run_type))
            return t;
        if (!(Object.keys(t).length === 1 && (t == null ? void 0 : t.input) === ""))
            return t.input
    }
    async function XA(n, e) {
        const {outputs: t} = n;
        return e === "original" || ["retriever", "llm", "prompt"].includes(n.run_type) ? t : t !== void 0 && Object.keys(t).length === 1 && (t == null ? void 0 : t.output) !== void 0 ? t.output : t
    }
    function s4(n) {
        return n !== void 0 && n.message !== void 0
    }
    class YA extends yh {
        constructor(e) {
            super({
                _awaitHandler: !0,
                ...e
            }),
            Object.defineProperty(this, "autoClose", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "includeNames", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "includeTypes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "includeTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeNames", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeTypes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "_schemaFormat", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "original"
            }),
            Object.defineProperty(this, "rootId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "keyMapByRunId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: {}
            }),
            Object.defineProperty(this, "counterMapByRunName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: {}
            }),
            Object.defineProperty(this, "transformStream", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "writer", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "receiveStream", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "log_stream_tracer"
            }),
            Object.defineProperty(this, "lc_prefer_streaming", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            this.autoClose = (e == null ? void 0 : e.autoClose) ?? !0,
            this.includeNames = e == null ? void 0 : e.includeNames,
            this.includeTypes = e == null ? void 0 : e.includeTypes,
            this.includeTags = e == null ? void 0 : e.includeTags,
            this.excludeNames = e == null ? void 0 : e.excludeNames,
            this.excludeTypes = e == null ? void 0 : e.excludeTypes,
            this.excludeTags = e == null ? void 0 : e.excludeTags,
            this._schemaFormat = (e == null ? void 0 : e._schemaFormat) ?? this._schemaFormat,
            this.transformStream = new TransformStream,
            this.writer = this.transformStream.writable.getWriter(),
            this.receiveStream = Qr.fromReadableStream(this.transformStream.readable)
        }
        [Symbol.asyncIterator]() {
            return this.receiveStream
        }
        async persistRun(e) {}
        _includeRun(e) {
            if (e.id === this.rootId)
                return !1;
            const t = e.tags ?? [];
            let r = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
            return this.includeNames !== void 0 && (r = r || this.includeNames.includes(e.name)),
            this.includeTypes !== void 0 && (r = r || this.includeTypes.includes(e.run_type)),
            this.includeTags !== void 0 && (r = r || t.find(s => {
                var i;
                return (i = this.includeTags) == null ? void 0 : i.includes(s)
            }
            ) !== void 0),
            this.excludeNames !== void 0 && (r = r && !this.excludeNames.includes(e.name)),
            this.excludeTypes !== void 0 && (r = r && !this.excludeTypes.includes(e.run_type)),
            this.excludeTags !== void 0 && (r = r && t.every(s => {
                var i;
                return !((i = this.excludeTags) != null && i.includes(s))
            }
            )),
            r
        }
        async*tapOutputIterable(e, t) {
            for await(const r of t) {
                if (e !== this.rootId) {
                    const s = this.keyMapByRunId[e];
                    s && await this.writer.write(new Bi({
                        ops: [{
                            op: "add",
                            path: `/logs/${s}/streamed_output/-`,
                            value: r
                        }]
                    }))
                }
                yield r
            }
        }
        async onRunCreate(e) {
            var s;
            if (this.rootId === void 0 && (this.rootId = e.id,
            await this.writer.write(new Bi({
                ops: [{
                    op: "replace",
                    path: "",
                    value: {
                        id: e.id,
                        name: e.name,
                        type: e.run_type,
                        streamed_output: [],
                        final_output: void 0,
                        logs: {}
                    }
                }]
            }))),
            !this._includeRun(e))
                return;
            this.counterMapByRunName[e.name] === void 0 && (this.counterMapByRunName[e.name] = 0),
            this.counterMapByRunName[e.name] += 1;
            const t = this.counterMapByRunName[e.name];
            this.keyMapByRunId[e.id] = t === 1 ? e.name : `${e.name}:${t}`;
            const r = {
                id: e.id,
                name: e.name,
                type: e.run_type,
                tags: e.tags ?? [],
                metadata: ((s = e.extra) == null ? void 0 : s.metadata) ?? {},
                start_time: new Date(e.start_time).toISOString(),
                streamed_output: [],
                streamed_output_str: [],
                final_output: void 0,
                end_time: void 0
            };
            this._schemaFormat === "streaming_events" && (r.inputs = await ZA(e, this._schemaFormat)),
            await this.writer.write(new Bi({
                ops: [{
                    op: "add",
                    path: `/logs/${this.keyMapByRunId[e.id]}`,
                    value: r
                }]
            }))
        }
        async onRunUpdate(e) {
            try {
                const t = this.keyMapByRunId[e.id];
                if (t === void 0)
                    return;
                const r = [];
                this._schemaFormat === "streaming_events" && r.push({
                    op: "replace",
                    path: `/logs/${t}/inputs`,
                    value: await ZA(e, this._schemaFormat)
                }),
                r.push({
                    op: "add",
                    path: `/logs/${t}/final_output`,
                    value: await XA(e, this._schemaFormat)
                }),
                e.end_time !== void 0 && r.push({
                    op: "add",
                    path: `/logs/${t}/end_time`,
                    value: new Date(e.end_time).toISOString()
                });
                const s = new Bi({
                    ops: r
                });
                await this.writer.write(s)
            } finally {
                if (e.id === this.rootId) {
                    const t = new Bi({
                        ops: [{
                            op: "replace",
                            path: "/final_output",
                            value: await XA(e, this._schemaFormat)
                        }]
                    });
                    await this.writer.write(t),
                    this.autoClose && await this.writer.close()
                }
            }
        }
        async onLLMNewToken(e, t, r) {
            const s = this.keyMapByRunId[e.id];
            if (s === void 0)
                return;
            const i = e.inputs.messages !== void 0;
            let a;
            i ? s4(r == null ? void 0 : r.chunk) ? a = r == null ? void 0 : r.chunk : a = new _r({
                id: `run-${e.id}`,
                content: t
            }) : a = t;
            const c = new Bi({
                ops: [{
                    op: "add",
                    path: `/logs/${s}/streamed_output_str/-`,
                    value: t
                }, {
                    op: "add",
                    path: `/logs/${s}/streamed_output/-`,
                    value: a
                }]
            });
            await this.writer.write(c)
        }
    }
    const QA = "__run";
    class hu {
        constructor(e) {
            Object.defineProperty(this, "text", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "generationInfo", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.text = e.text,
            this.generationInfo = e.generationInfo
        }
        concat(e) {
            return new hu({
                text: this.text + e.text,
                generationInfo: {
                    ...this.generationInfo,
                    ...e.generationInfo
                }
            })
        }
    }
    class qi extends hu {
        constructor(e) {
            super(e),
            Object.defineProperty(this, "message", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.message = e.message
        }
        concat(e) {
            return new qi({
                text: this.text + e.text,
                generationInfo: {
                    ...this.generationInfo,
                    ...e.generationInfo
                },
                message: this.message.concat(e.message)
            })
        }
    }
    function sw({name: n, serialized: e}) {
        return n !== void 0 ? n : (e == null ? void 0 : e.name) !== void 0 ? e.name : (e == null ? void 0 : e.id) !== void 0 && Array.isArray(e == null ? void 0 : e.id) ? e.id[e.id.length - 1] : "Unnamed"
    }
    const i4 = n => n.name === "event_stream_tracer";
    class a4 extends yh {
        constructor(e) {
            super({
                _awaitHandler: !0,
                ...e
            }),
            Object.defineProperty(this, "autoClose", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "includeNames", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "includeTypes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "includeTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeNames", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeTypes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "runInfoMap", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: new Map
            }),
            Object.defineProperty(this, "tappedPromises", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: new Map
            }),
            Object.defineProperty(this, "transformStream", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "writer", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "receiveStream", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "event_stream_tracer"
            }),
            Object.defineProperty(this, "lc_prefer_streaming", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            this.autoClose = (e == null ? void 0 : e.autoClose) ?? !0,
            this.includeNames = e == null ? void 0 : e.includeNames,
            this.includeTypes = e == null ? void 0 : e.includeTypes,
            this.includeTags = e == null ? void 0 : e.includeTags,
            this.excludeNames = e == null ? void 0 : e.excludeNames,
            this.excludeTypes = e == null ? void 0 : e.excludeTypes,
            this.excludeTags = e == null ? void 0 : e.excludeTags,
            this.transformStream = new TransformStream,
            this.writer = this.transformStream.writable.getWriter(),
            this.receiveStream = Qr.fromReadableStream(this.transformStream.readable)
        }
        [Symbol.asyncIterator]() {
            return this.receiveStream
        }
        async persistRun(e) {}
        _includeRun(e) {
            const t = e.tags ?? [];
            let r = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
            return this.includeNames !== void 0 && (r = r || this.includeNames.includes(e.name)),
            this.includeTypes !== void 0 && (r = r || this.includeTypes.includes(e.runType)),
            this.includeTags !== void 0 && (r = r || t.find(s => {
                var i;
                return (i = this.includeTags) == null ? void 0 : i.includes(s)
            }
            ) !== void 0),
            this.excludeNames !== void 0 && (r = r && !this.excludeNames.includes(e.name)),
            this.excludeTypes !== void 0 && (r = r && !this.excludeTypes.includes(e.runType)),
            this.excludeTags !== void 0 && (r = r && t.every(s => {
                var i;
                return !((i = this.excludeTags) != null && i.includes(s))
            }
            )),
            r
        }
        async*tapOutputIterable(e, t) {
            const r = await t.next();
            if (r.done)
                return;
            const s = this.runInfoMap.get(e);
            if (s === void 0) {
                yield r.value;
                return
            }
            function i(c, u) {
                return c === "llm" && typeof u == "string" ? new hu({
                    text: u
                }) : u
            }
            let a = this.tappedPromises.get(e);
            if (a === void 0) {
                let c;
                a = new Promise(u => {
                    c = u
                }
                ),
                this.tappedPromises.set(e, a);
                try {
                    const u = {
                        event: `on_${s.runType}_stream`,
                        run_id: e,
                        name: s.name,
                        tags: s.tags,
                        metadata: s.metadata,
                        data: {}
                    };
                    await this.send({
                        ...u,
                        data: {
                            chunk: i(s.runType, r.value)
                        }
                    }, s),
                    yield r.value;
                    for await(const l of t)
                        s.runType !== "tool" && s.runType !== "retriever" && await this.send({
                            ...u,
                            data: {
                                chunk: i(s.runType, l)
                            }
                        }, s),
                        yield l
                } finally {
                    c()
                }
            } else {
                yield r.value;
                for await(const c of t)
                    yield c
            }
        }
        async send(e, t) {
            this._includeRun(t) && await this.writer.write(e)
        }
        async sendEndEvent(e, t) {
            const r = this.tappedPromises.get(e.run_id);
            r !== void 0 ? r.then( () => {
                this.send(e, t)
            }
            ) : await this.send(e, t)
        }
        async onLLMStart(e) {
            var a, c;
            const t = sw(e)
              , r = e.inputs.messages !== void 0 ? "chat_model" : "llm"
              , s = {
                tags: e.tags ?? [],
                metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {},
                name: t,
                runType: r,
                inputs: e.inputs
            };
            this.runInfoMap.set(e.id, s);
            const i = `on_${r}_start`;
            await this.send({
                event: i,
                data: {
                    input: e.inputs
                },
                name: t,
                tags: e.tags ?? [],
                run_id: e.id,
                metadata: ((c = e.extra) == null ? void 0 : c.metadata) ?? {}
            }, s)
        }
        async onLLMNewToken(e, t, r) {
            const s = this.runInfoMap.get(e.id);
            let i, a;
            if (s === void 0)
                throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);
            if (this.runInfoMap.size !== 1) {
                if (s.runType === "chat_model")
                    a = "on_chat_model_stream",
                    (r == null ? void 0 : r.chunk) === void 0 ? i = new _r({
                        content: t,
                        id: `run-${e.id}`
                    }) : i = r.chunk.message;
                else if (s.runType === "llm")
                    a = "on_llm_stream",
                    (r == null ? void 0 : r.chunk) === void 0 ? i = new hu({
                        text: t
                    }) : i = r.chunk;
                else
                    throw new Error(`Unexpected run type ${s.runType}`);
                await this.send({
                    event: a,
                    data: {
                        chunk: i
                    },
                    run_id: e.id,
                    name: s.name,
                    tags: s.tags,
                    metadata: s.metadata
                }, s)
            }
        }
        async onLLMEnd(e) {
            var a, c, u;
            const t = this.runInfoMap.get(e.id);
            this.runInfoMap.delete(e.id);
            let r;
            if (t === void 0)
                throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);
            const s = (a = e.outputs) == null ? void 0 : a.generations;
            let i;
            if (t.runType === "chat_model") {
                for (const l of s ?? []) {
                    if (i !== void 0)
                        break;
                    i = (c = l[0]) == null ? void 0 : c.message
                }
                r = "on_chat_model_end"
            } else if (t.runType === "llm")
                i = {
                    generations: s == null ? void 0 : s.map(l => l.map(d => ({
                        text: d.text,
                        generationInfo: d.generationInfo
                    }))),
                    llmOutput: ((u = e.outputs) == null ? void 0 : u.llmOutput) ?? {}
                },
                r = "on_llm_end";
            else
                throw new Error(`onLLMEnd: Unexpected run type: ${t.runType}`);
            await this.sendEndEvent({
                event: r,
                data: {
                    output: i,
                    input: t.inputs
                },
                run_id: e.id,
                name: t.name,
                tags: t.tags,
                metadata: t.metadata
            }, t)
        }
        async onChainStart(e) {
            var a, c;
            const t = sw(e)
              , r = e.run_type ?? "chain"
              , s = {
                tags: e.tags ?? [],
                metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {},
                name: t,
                runType: e.run_type
            };
            let i = {};
            e.inputs.input === "" && Object.keys(e.inputs).length === 1 ? (i = {},
            s.inputs = {}) : e.inputs.input !== void 0 ? (i.input = e.inputs.input,
            s.inputs = e.inputs.input) : (i.input = e.inputs,
            s.inputs = e.inputs),
            this.runInfoMap.set(e.id, s),
            await this.send({
                event: `on_${r}_start`,
                data: i,
                name: t,
                tags: e.tags ?? [],
                run_id: e.id,
                metadata: ((c = e.extra) == null ? void 0 : c.metadata) ?? {}
            }, s)
        }
        async onChainEnd(e) {
            var c;
            const t = this.runInfoMap.get(e.id);
            if (this.runInfoMap.delete(e.id),
            t === void 0)
                throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);
            const r = `on_${e.run_type}_end`
              , s = e.inputs ?? t.inputs ?? {}
              , a = {
                output: ((c = e.outputs) == null ? void 0 : c.output) ?? e.outputs,
                input: s
            };
            s.input && Object.keys(s).length === 1 && (a.input = s.input,
            t.inputs = s.input),
            await this.sendEndEvent({
                event: r,
                data: a,
                run_id: e.id,
                name: t.name,
                tags: t.tags,
                metadata: t.metadata ?? {}
            }, t)
        }
        async onToolStart(e) {
            var s, i;
            const t = sw(e)
              , r = {
                tags: e.tags ?? [],
                metadata: ((s = e.extra) == null ? void 0 : s.metadata) ?? {},
                name: t,
                runType: "tool",
                inputs: e.inputs ?? {}
            };
            this.runInfoMap.set(e.id, r),
            await this.send({
                event: "on_tool_start",
                data: {
                    input: e.inputs ?? {}
                },
                name: t,
                run_id: e.id,
                tags: e.tags ?? [],
                metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {}
            }, r)
        }
        async onToolEnd(e) {
            var s;
            const t = this.runInfoMap.get(e.id);
            if (this.runInfoMap.delete(e.id),
            t === void 0)
                throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);
            if (t.inputs === void 0)
                throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);
            const r = ((s = e.outputs) == null ? void 0 : s.output) === void 0 ? e.outputs : e.outputs.output;
            await this.sendEndEvent({
                event: "on_tool_end",
                data: {
                    output: r,
                    input: t.inputs
                },
                run_id: e.id,
                name: t.name,
                tags: t.tags,
                metadata: t.metadata
            }, t)
        }
        async onRetrieverStart(e) {
            var i, a;
            const t = sw(e)
              , s = {
                tags: e.tags ?? [],
                metadata: ((i = e.extra) == null ? void 0 : i.metadata) ?? {},
                name: t,
                runType: "retriever",
                inputs: {
                    query: e.inputs.query
                }
            };
            this.runInfoMap.set(e.id, s),
            await this.send({
                event: "on_retriever_start",
                data: {
                    input: {
                        query: e.inputs.query
                    }
                },
                name: t,
                tags: e.tags ?? [],
                run_id: e.id,
                metadata: ((a = e.extra) == null ? void 0 : a.metadata) ?? {}
            }, s)
        }
        async onRetrieverEnd(e) {
            var r;
            const t = this.runInfoMap.get(e.id);
            if (this.runInfoMap.delete(e.id),
            t === void 0)
                throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);
            await this.sendEndEvent({
                event: "on_retriever_end",
                data: {
                    output: ((r = e.outputs) == null ? void 0 : r.documents) ?? e.outputs,
                    input: t.inputs
                },
                run_id: e.id,
                name: t.name,
                tags: t.tags,
                metadata: t.metadata
            }, t)
        }
        async handleCustomEvent(e, t, r) {
            const s = this.runInfoMap.get(r);
            if (s === void 0)
                throw new Error(`handleCustomEvent: Run ID ${r} not found in run map.`);
            await this.send({
                event: "on_custom_event",
                run_id: r,
                name: e,
                tags: s.tags,
                metadata: s.metadata,
                data: t
            }, s)
        }
        async finish() {
            const e = [...this.tappedPromises.values()];
            Promise.all(e).finally( () => {
                this.writer.close()
            }
            )
        }
    }
    const o4 = [400, 401, 402, 403, 404, 405, 406, 407, 409]
      , c4 = n => {
        var t, r;
        if (n.message.startsWith("Cancel") || n.message.startsWith("AbortError") || n.name === "AbortError" || (n == null ? void 0 : n.code) === "ECONNABORTED")
            throw n;
        const e = ((t = n == null ? void 0 : n.response) == null ? void 0 : t.status) ?? (n == null ? void 0 : n.status);
        if (e && o4.includes(+e))
            throw n;
        if (((r = n == null ? void 0 : n.error) == null ? void 0 : r.code) === "insufficient_quota") {
            const s = new Error(n == null ? void 0 : n.message);
            throw s.name = "InsufficientQuotaError",
            s
        }
    }
    ;
    class W0 {
        constructor(e) {
            Object.defineProperty(this, "maxConcurrency", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "maxRetries", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "onFailedAttempt", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "queue", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.maxConcurrency = e.maxConcurrency ?? 1 / 0,
            this.maxRetries = e.maxRetries ?? 6,
            this.onFailedAttempt = e.onFailedAttempt ?? c4;
            const t = "default"in Ks ? Ks.default : Ks;
            this.queue = new t({
                concurrency: this.maxConcurrency
            })
        }
        call(e, ...t) {
            return this.queue.add( () => Dy( () => e(...t).catch(r => {
                throw r instanceof Error ? r : new Error(r)
            }
            ), {
                onFailedAttempt: this.onFailedAttempt,
                retries: this.maxRetries,
                randomize: !0
            }), {
                throwOnTimeout: !0
            })
        }
        callWithOptions(e, t, ...r) {
            return e.signal ? Promise.race([this.call(t, ...r), new Promise( (s, i) => {
                var a;
                (a = e.signal) == null || a.addEventListener("abort", () => {
                    i(new Error("AbortError"))
                }
                )
            }
            )]) : this.call(t, ...r)
        }
        fetch(...e) {
            return this.call( () => fetch(...e).then(t => t.ok ? t : Promise.reject(t)))
        }
    }
    class eI extends yh {
        constructor({config: e, onStart: t, onEnd: r, onError: s}) {
            super({
                _awaitHandler: !0
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "RootListenersTracer"
            }),
            Object.defineProperty(this, "rootId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "config", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "argOnStart", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "argOnEnd", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "argOnError", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.config = e,
            this.argOnStart = t,
            this.argOnEnd = r,
            this.argOnError = s
        }
        persistRun(e) {
            return Promise.resolve()
        }
        async onRunCreate(e) {
            this.rootId || (this.rootId = e.id,
            this.argOnStart && await this.argOnStart(e, this.config))
        }
        async onRunUpdate(e) {
            e.id === this.rootId && (e.error ? this.argOnError && await this.argOnError(e, this.config) : this.argOnEnd && await this.argOnEnd(e, this.config))
        }
    }
    function z0(n) {
        return n ? n.lc_runnable : !1
    }
    class u4 {
        constructor(e) {
            Object.defineProperty(this, "includeNames", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "includeTypes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "includeTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeNames", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeTypes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "excludeTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.includeNames = e.includeNames,
            this.includeTypes = e.includeTypes,
            this.includeTags = e.includeTags,
            this.excludeNames = e.excludeNames,
            this.excludeTypes = e.excludeTypes,
            this.excludeTags = e.excludeTags
        }
        includeEvent(e, t) {
            let r = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
            const s = e.tags ?? [];
            return this.includeNames !== void 0 && (r = r || this.includeNames.includes(e.name)),
            this.includeTypes !== void 0 && (r = r || this.includeTypes.includes(t)),
            this.includeTags !== void 0 && (r = r || s.some(i => {
                var a;
                return (a = this.includeTags) == null ? void 0 : a.includes(i)
            }
            )),
            this.excludeNames !== void 0 && (r = r && !this.excludeNames.includes(e.name)),
            this.excludeTypes !== void 0 && (r = r && !this.excludeTypes.includes(t)),
            this.excludeTags !== void 0 && (r = r && s.every(i => {
                var a;
                return !((a = this.excludeTags) != null && a.includes(i))
            }
            )),
            r
        }
    }
    const l4 = Symbol("Let zodToJsonSchema decide on which parser to use")
      , d4 = {
        name: void 0,
        $refStrategy: "root",
        basePath: ["#"],
        effectStrategy: "input",
        pipeStrategy: "all",
        dateStrategy: "format:date-time",
        mapStrategy: "entries",
        removeAdditionalStrategy: "passthrough",
        definitionPath: "definitions",
        target: "jsonSchema7",
        strictUnions: !1,
        definitions: {},
        errorMessages: !1,
        markdownDescription: !1,
        patternStrategy: "escape",
        applyRegexFlags: !1,
        emailStrategy: "format:email",
        base64Strategy: "contentEncoding:base64",
        nameStrategy: "ref"
    }
      , h4 = n => ({
        ...d4,
        ...n
    })
      , f4 = n => {
        const e = h4(n)
          , t = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
        return {
            ...e,
            currentPath: t,
            propertyPath: void 0,
            seen: new Map(Object.entries(e.definitions).map( ([r,s]) => [s._def, {
                def: s._def,
                path: [...e.basePath, e.definitionPath, r],
                jsonSchema: void 0
            }]))
        }
    }
    ;
    function tI(n, e, t, r) {
        r != null && r.errorMessages && t && (n.errorMessage = {
            ...n.errorMessage,
            [e]: t
        })
    }
    function ot(n, e, t, r, s) {
        n[e] = t,
        tI(n, e, r, s)
    }
    function p4() {
        return {}
    }
    function m4(n, e) {
        var r, s, i;
        const t = {
            type: "array"
        };
        return (r = n.type) != null && r._def && ((i = (s = n.type) == null ? void 0 : s._def) == null ? void 0 : i.typeName) !== Y.ZodAny && (t.items = nt(n.type._def, {
            ...e,
            currentPath: [...e.currentPath, "items"]
        })),
        n.minLength && ot(t, "minItems", n.minLength.value, n.minLength.message, e),
        n.maxLength && ot(t, "maxItems", n.maxLength.value, n.maxLength.message, e),
        n.exactLength && (ot(t, "minItems", n.exactLength.value, n.exactLength.message, e),
        ot(t, "maxItems", n.exactLength.value, n.exactLength.message, e)),
        t
    }
    function g4(n, e) {
        const t = {
            type: "integer",
            format: "int64"
        };
        if (!n.checks)
            return t;
        for (const r of n.checks)
            switch (r.kind) {
            case "min":
                e.target === "jsonSchema7" ? r.inclusive ? ot(t, "minimum", r.value, r.message, e) : ot(t, "exclusiveMinimum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMinimum = !0),
                ot(t, "minimum", r.value, r.message, e));
                break;
            case "max":
                e.target === "jsonSchema7" ? r.inclusive ? ot(t, "maximum", r.value, r.message, e) : ot(t, "exclusiveMaximum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMaximum = !0),
                ot(t, "maximum", r.value, r.message, e));
                break;
            case "multipleOf":
                ot(t, "multipleOf", r.value, r.message, e);
                break
            }
        return t
    }
    function y4() {
        return {
            type: "boolean"
        }
    }
    function rI(n, e) {
        return nt(n.type._def, e)
    }
    const w4 = (n, e) => nt(n.innerType._def, e);
    function nI(n, e, t) {
        const r = t ?? e.dateStrategy;
        if (Array.isArray(r))
            return {
                anyOf: r.map( (s, i) => nI(n, e, s))
            };
        switch (r) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return b4(n, e)
        }
    }
    const b4 = (n, e) => {
        const t = {
            type: "integer",
            format: "unix-time"
        };
        if (e.target === "openApi3")
            return t;
        for (const r of n.checks)
            switch (r.kind) {
            case "min":
                ot(t, "minimum", r.value, r.message, e);
                break;
            case "max":
                ot(t, "maximum", r.value, r.message, e);
                break
            }
        return t
    }
    ;
    function v4(n, e) {
        return {
            ...nt(n.innerType._def, e),
            default: n.defaultValue()
        }
    }
    function _4(n, e) {
        return e.effectStrategy === "input" ? nt(n.schema._def, e) : {}
    }
    function S4(n) {
        return {
            type: "string",
            enum: Array.from(n.values)
        }
    }
    const E4 = n => "type"in n && n.type === "string" ? !1 : "allOf"in n;
    function x4(n, e) {
        const t = [nt(n.left._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "0"]
        }), nt(n.right._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "1"]
        })].filter(i => !!i);
        let r = e.target === "jsonSchema2019-09" ? {
            unevaluatedProperties: !1
        } : void 0;
        const s = [];
        return t.forEach(i => {
            if (E4(i))
                s.push(...i.allOf),
                i.unevaluatedProperties === void 0 && (r = void 0);
            else {
                let a = i;
                if ("additionalProperties"in i && i.additionalProperties === !1) {
                    const {additionalProperties: c, ...u} = i;
                    a = u
                } else
                    r = void 0;
                s.push(a)
            }
        }
        ),
        s.length ? {
            allOf: s,
            ...r
        } : void 0
    }
    function C4(n, e) {
        const t = typeof n.value;
        return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
            type: Array.isArray(n.value) ? "array" : "object"
        } : e.target === "openApi3" ? {
            type: t === "bigint" ? "integer" : t,
            enum: [n.value]
        } : {
            type: t === "bigint" ? "integer" : t,
            const: n.value
        }
    }
    let V0;
    const $n = {
        cuid: /^[cC][^\s-]{8,}$/,
        cuid2: /^[0-9a-z]+$/,
        ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
        email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
        emoji: () => (V0 === void 0 && (V0 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")),
        V0),
        uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
        ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
        ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
        ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
        base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
        base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
        nanoid: /^[a-zA-Z0-9_-]{21}$/,
        jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    function sI(n, e) {
        const t = {
            type: "string"
        };
        if (n.checks)
            for (const r of n.checks)
                switch (r.kind) {
                case "min":
                    ot(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, r.value) : r.value, r.message, e);
                    break;
                case "max":
                    ot(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, r.value) : r.value, r.message, e);
                    break;
                case "email":
                    switch (e.emailStrategy) {
                    case "format:email":
                        Ln(t, "email", r.message, e);
                        break;
                    case "format:idn-email":
                        Ln(t, "idn-email", r.message, e);
                        break;
                    case "pattern:zod":
                        xr(t, $n.email, r.message, e);
                        break
                    }
                    break;
                case "url":
                    Ln(t, "uri", r.message, e);
                    break;
                case "uuid":
                    Ln(t, "uuid", r.message, e);
                    break;
                case "regex":
                    xr(t, r.regex, r.message, e);
                    break;
                case "cuid":
                    xr(t, $n.cuid, r.message, e);
                    break;
                case "cuid2":
                    xr(t, $n.cuid2, r.message, e);
                    break;
                case "startsWith":
                    xr(t, RegExp(`^${G0(r.value, e)}`), r.message, e);
                    break;
                case "endsWith":
                    xr(t, RegExp(`${G0(r.value, e)}$`), r.message, e);
                    break;
                case "datetime":
                    Ln(t, "date-time", r.message, e);
                    break;
                case "date":
                    Ln(t, "date", r.message, e);
                    break;
                case "time":
                    Ln(t, "time", r.message, e);
                    break;
                case "duration":
                    Ln(t, "duration", r.message, e);
                    break;
                case "length":
                    ot(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, r.value) : r.value, r.message, e),
                    ot(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, r.value) : r.value, r.message, e);
                    break;
                case "includes":
                    {
                        xr(t, RegExp(G0(r.value, e)), r.message, e);
                        break
                    }
                case "ip":
                    {
                        r.version !== "v6" && Ln(t, "ipv4", r.message, e),
                        r.version !== "v4" && Ln(t, "ipv6", r.message, e);
                        break
                    }
                case "base64url":
                    xr(t, $n.base64url, r.message, e);
                    break;
                case "jwt":
                    xr(t, $n.jwt, r.message, e);
                    break;
                case "cidr":
                    {
                        r.version !== "v6" && xr(t, $n.ipv4Cidr, r.message, e),
                        r.version !== "v4" && xr(t, $n.ipv6Cidr, r.message, e);
                        break
                    }
                case "emoji":
                    xr(t, $n.emoji(), r.message, e);
                    break;
                case "ulid":
                    {
                        xr(t, $n.ulid, r.message, e);
                        break
                    }
                case "base64":
                    {
                        switch (e.base64Strategy) {
                        case "format:binary":
                            {
                                Ln(t, "binary", r.message, e);
                                break
                            }
                        case "contentEncoding:base64":
                            {
                                ot(t, "contentEncoding", "base64", r.message, e);
                                break
                            }
                        case "pattern:zod":
                            {
                                xr(t, $n.base64, r.message, e);
                                break
                            }
                        }
                        break
                    }
                case "nanoid":
                    xr(t, $n.nanoid, r.message, e)
                }
        return t
    }
    function G0(n, e) {
        return e.patternStrategy === "escape" ? P4(n) : n
    }
    const k4 = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    function P4(n) {
        let e = "";
        for (let t = 0; t < n.length; t++)
            k4.has(n[t]) || (e += "\\"),
            e += n[t];
        return e
    }
    function Ln(n, e, t, r) {
        var s;
        n.format || (s = n.anyOf) != null && s.some(i => i.format) ? (n.anyOf || (n.anyOf = []),
        n.format && (n.anyOf.push({
            format: n.format,
            ...n.errorMessage && r.errorMessages && {
                errorMessage: {
                    format: n.errorMessage.format
                }
            }
        }),
        delete n.format,
        n.errorMessage && (delete n.errorMessage.format,
        Object.keys(n.errorMessage).length === 0 && delete n.errorMessage)),
        n.anyOf.push({
            format: e,
            ...t && r.errorMessages && {
                errorMessage: {
                    format: t
                }
            }
        })) : ot(n, "format", e, t, r)
    }
    function xr(n, e, t, r) {
        var s;
        n.pattern || (s = n.allOf) != null && s.some(i => i.pattern) ? (n.allOf || (n.allOf = []),
        n.pattern && (n.allOf.push({
            pattern: n.pattern,
            ...n.errorMessage && r.errorMessages && {
                errorMessage: {
                    pattern: n.errorMessage.pattern
                }
            }
        }),
        delete n.pattern,
        n.errorMessage && (delete n.errorMessage.pattern,
        Object.keys(n.errorMessage).length === 0 && delete n.errorMessage)),
        n.allOf.push({
            pattern: iI(e, r),
            ...t && r.errorMessages && {
                errorMessage: {
                    pattern: t
                }
            }
        })) : ot(n, "pattern", iI(e, r), t, r)
    }
    function iI(n, e) {
        var u;
        if (!e.applyRegexFlags || !n.flags)
            return n.source;
        const t = {
            i: n.flags.includes("i"),
            m: n.flags.includes("m"),
            s: n.flags.includes("s")
        }
          , r = t.i ? n.source.toLowerCase() : n.source;
        let s = ""
          , i = !1
          , a = !1
          , c = !1;
        for (let l = 0; l < r.length; l++) {
            if (i) {
                s += r[l],
                i = !1;
                continue
            }
            if (t.i) {
                if (a) {
                    if (r[l].match(/[a-z]/)) {
                        c ? (s += r[l],
                        s += `${r[l - 2]}-${r[l]}`.toUpperCase(),
                        c = !1) : r[l + 1] === "-" && ((u = r[l + 2]) != null && u.match(/[a-z]/)) ? (s += r[l],
                        c = !0) : s += `${r[l]}${r[l].toUpperCase()}`;
                        continue
                    }
                } else if (r[l].match(/[a-z]/)) {
                    s += `[${r[l]}${r[l].toUpperCase()}]`;
                    continue
                }
            }
            if (t.m) {
                if (r[l] === "^") {
                    s += `(^|(?<=[\r
]))`;
                    continue
                } else if (r[l] === "$") {
                    s += `($|(?=[\r
]))`;
                    continue
                }
            }
            if (t.s && r[l] === ".") {
                s += a ? `${r[l]}\r
` : `[${r[l]}\r
]`;
                continue
            }
            s += r[l],
            r[l] === "\\" ? i = !0 : a && r[l] === "]" ? a = !1 : !a && r[l] === "[" && (a = !0)
        }
        try {
            new RegExp(s)
        } catch {
            return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`),
            n.source
        }
        return s
    }
    function aI(n, e) {
        var r, s, i, a, c, u;
        if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."),
        e.target === "openApi3" && ((r = n.keyType) == null ? void 0 : r._def.typeName) === Y.ZodEnum)
            return {
                type: "object",
                required: n.keyType._def.values,
                properties: n.keyType._def.values.reduce( (l, d) => ({
                    ...l,
                    [d]: nt(n.valueType._def, {
                        ...e,
                        currentPath: [...e.currentPath, "properties", d]
                    }) ?? {}
                }), {}),
                additionalProperties: !1
            };
        const t = {
            type: "object",
            additionalProperties: nt(n.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalProperties"]
            }) ?? {}
        };
        if (e.target === "openApi3")
            return t;
        if (((s = n.keyType) == null ? void 0 : s._def.typeName) === Y.ZodString && ((i = n.keyType._def.checks) != null && i.length)) {
            const {type: l, ...d} = sI(n.keyType._def, e);
            return {
                ...t,
                propertyNames: d
            }
        } else {
            if (((a = n.keyType) == null ? void 0 : a._def.typeName) === Y.ZodEnum)
                return {
                    ...t,
                    propertyNames: {
                        enum: n.keyType._def.values
                    }
                };
            if (((c = n.keyType) == null ? void 0 : c._def.typeName) === Y.ZodBranded && n.keyType._def.type._def.typeName === Y.ZodString && ((u = n.keyType._def.type._def.checks) != null && u.length)) {
                const {type: l, ...d} = rI(n.keyType._def, e);
                return {
                    ...t,
                    propertyNames: d
                }
            }
        }
        return t
    }
    function T4(n, e) {
        if (e.mapStrategy === "record")
            return aI(n, e);
        const t = nt(n.keyType._def, {
            ...e,
            currentPath: [...e.currentPath, "items", "items", "0"]
        }) || {}
          , r = nt(n.valueType._def, {
            ...e,
            currentPath: [...e.currentPath, "items", "items", "1"]
        }) || {};
        return {
            type: "array",
            maxItems: 125,
            items: {
                type: "array",
                items: [t, r],
                minItems: 2,
                maxItems: 2
            }
        }
    }
    function A4(n) {
        const e = n.values
          , r = Object.keys(n.values).filter(i => typeof e[e[i]] != "number").map(i => e[i])
          , s = Array.from(new Set(r.map(i => typeof i)));
        return {
            type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
            enum: r
        }
    }
    function I4() {
        return {
            not: {}
        }
    }
    function O4(n) {
        return n.target === "openApi3" ? {
            enum: ["null"],
            nullable: !0
        } : {
            type: "null"
        }
    }
    const iw = {
        ZodString: "string",
        ZodNumber: "number",
        ZodBigInt: "integer",
        ZodBoolean: "boolean",
        ZodNull: "null"
    };
    function R4(n, e) {
        if (e.target === "openApi3")
            return oI(n, e);
        const t = n.options instanceof Map ? Array.from(n.options.values()) : n.options;
        if (t.every(r => r._def.typeName in iw && (!r._def.checks || !r._def.checks.length))) {
            const r = t.reduce( (s, i) => {
                const a = iw[i._def.typeName];
                return a && !s.includes(a) ? [...s, a] : s
            }
            , []);
            return {
                type: r.length > 1 ? r : r[0]
            }
        } else if (t.every(r => r._def.typeName === "ZodLiteral" && !r.description)) {
            const r = t.reduce( (s, i) => {
                const a = typeof i._def.value;
                switch (a) {
                case "string":
                case "number":
                case "boolean":
                    return [...s, a];
                case "bigint":
                    return [...s, "integer"];
                case "object":
                    if (i._def.value === null)
                        return [...s, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return s
                }
            }
            , []);
            if (r.length === t.length) {
                const s = r.filter( (i, a, c) => c.indexOf(i) === a);
                return {
                    type: s.length > 1 ? s : s[0],
                    enum: t.reduce( (i, a) => i.includes(a._def.value) ? i : [...i, a._def.value], [])
                }
            }
        } else if (t.every(r => r._def.typeName === "ZodEnum"))
            return {
                type: "string",
                enum: t.reduce( (r, s) => [...r, ...s._def.values.filter(i => !r.includes(i))], [])
            };
        return oI(n, e)
    }
    const oI = (n, e) => {
        const t = (n.options instanceof Map ? Array.from(n.options.values()) : n.options).map( (r, s) => nt(r._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", `${s}`]
        })).filter(r => !!r && (!e.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
        return t.length ? {
            anyOf: t
        } : void 0
    }
    ;
    function M4(n, e) {
        if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(n.innerType._def.typeName) && (!n.innerType._def.checks || !n.innerType._def.checks.length))
            return e.target === "openApi3" ? {
                type: iw[n.innerType._def.typeName],
                nullable: !0
            } : {
                type: [iw[n.innerType._def.typeName], "null"]
            };
        if (e.target === "openApi3") {
            const r = nt(n.innerType._def, {
                ...e,
                currentPath: [...e.currentPath]
            });
            return r && "$ref"in r ? {
                allOf: [r],
                nullable: !0
            } : r && {
                ...r,
                nullable: !0
            }
        }
        const t = nt(n.innerType._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", "0"]
        });
        return t && {
            anyOf: [t, {
                type: "null"
            }]
        }
    }
    function N4(n, e) {
        const t = {
            type: "number"
        };
        if (!n.checks)
            return t;
        for (const r of n.checks)
            switch (r.kind) {
            case "int":
                t.type = "integer",
                tI(t, "type", r.message, e);
                break;
            case "min":
                e.target === "jsonSchema7" ? r.inclusive ? ot(t, "minimum", r.value, r.message, e) : ot(t, "exclusiveMinimum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMinimum = !0),
                ot(t, "minimum", r.value, r.message, e));
                break;
            case "max":
                e.target === "jsonSchema7" ? r.inclusive ? ot(t, "maximum", r.value, r.message, e) : ot(t, "exclusiveMaximum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMaximum = !0),
                ot(t, "maximum", r.value, r.message, e));
                break;
            case "multipleOf":
                ot(t, "multipleOf", r.value, r.message, e);
                break
            }
        return t
    }
    function $4(n, e) {
        return e.removeAdditionalStrategy === "strict" ? n.catchall._def.typeName === "ZodNever" ? n.unknownKeys !== "strict" : nt(n.catchall._def, {
            ...e,
            currentPath: [...e.currentPath, "additionalProperties"]
        }) ?? !0 : n.catchall._def.typeName === "ZodNever" ? n.unknownKeys === "passthrough" : nt(n.catchall._def, {
            ...e,
            currentPath: [...e.currentPath, "additionalProperties"]
        }) ?? !0
    }
    function L4(n, e) {
        const t = e.target === "openAi"
          , r = {
            type: "object",
            ...Object.entries(n.shape()).reduce( (s, [i,a]) => {
                if (a === void 0 || a._def === void 0)
                    return s;
                let c = a.isOptional();
                c && t && (a instanceof In && (a = a._def.innerType),
                a.isNullable() || (a = a.nullable()),
                c = !1);
                const u = nt(a._def, {
                    ...e,
                    currentPath: [...e.currentPath, "properties", i],
                    propertyPath: [...e.currentPath, "properties", i]
                });
                return u === void 0 ? s : {
                    properties: {
                        ...s.properties,
                        [i]: u
                    },
                    required: c ? s.required : [...s.required, i]
                }
            }
            , {
                properties: {},
                required: []
            }),
            additionalProperties: $4(n, e)
        };
        return r.required.length || delete r.required,
        r
    }
    const F4 = (n, e) => {
        var r;
        if (e.currentPath.toString() === ((r = e.propertyPath) == null ? void 0 : r.toString()))
            return nt(n.innerType._def, e);
        const t = nt(n.innerType._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", "1"]
        });
        return t ? {
            anyOf: [{
                not: {}
            }, t]
        } : {}
    }
      , j4 = (n, e) => {
        if (e.pipeStrategy === "input")
            return nt(n.in._def, e);
        if (e.pipeStrategy === "output")
            return nt(n.out._def, e);
        const t = nt(n.in._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "0"]
        })
          , r = nt(n.out._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", t ? "1" : "0"]
        });
        return {
            allOf: [t, r].filter(s => s !== void 0)
        }
    }
    ;
    function D4(n, e) {
        return nt(n.type._def, e)
    }
    function B4(n, e) {
        const r = {
            type: "array",
            uniqueItems: !0,
            items: nt(n.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "items"]
            })
        };
        return n.minSize && ot(r, "minItems", n.minSize.value, n.minSize.message, e),
        n.maxSize && ot(r, "maxItems", n.maxSize.value, n.maxSize.message, e),
        r
    }
    function q4(n, e) {
        return n.rest ? {
            type: "array",
            minItems: n.items.length,
            items: n.items.map( (t, r) => nt(t._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${r}`]
            })).reduce( (t, r) => r === void 0 ? t : [...t, r], []),
            additionalItems: nt(n.rest._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalItems"]
            })
        } : {
            type: "array",
            minItems: n.items.length,
            maxItems: n.items.length,
            items: n.items.map( (t, r) => nt(t._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${r}`]
            })).reduce( (t, r) => r === void 0 ? t : [...t, r], [])
        }
    }
    function U4() {
        return {
            not: {}
        }
    }
    function K4() {
        return {}
    }
    const H4 = (n, e) => nt(n.innerType._def, e);
    function nt(n, e, t=!1) {
        var a;
        const r = e.seen.get(n);
        if (e.override) {
            const c = (a = e.override) == null ? void 0 : a.call(e, n, e, r, t);
            if (c !== l4)
                return c
        }
        if (r && !t) {
            const c = W4(r, e);
            if (c !== void 0)
                return c
        }
        const s = {
            def: n,
            path: e.currentPath,
            jsonSchema: void 0
        };
        e.seen.set(n, s);
        const i = V4(n, n.typeName, e);
        return i && G4(n, e, i),
        s.jsonSchema = i,
        i
    }
    const W4 = (n, e) => {
        switch (e.$refStrategy) {
        case "root":
            return {
                $ref: n.path.join("/")
            };
        case "relative":
            return {
                $ref: z4(e.currentPath, n.path)
            };
        case "none":
        case "seen":
            return n.path.length < e.currentPath.length && n.path.every( (t, r) => e.currentPath[r] === t) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`),
            {}) : e.$refStrategy === "seen" ? {} : void 0
        }
    }
      , z4 = (n, e) => {
        let t = 0;
        for (; t < n.length && t < e.length && n[t] === e[t]; t++)
            ;
        return [(n.length - t).toString(), ...e.slice(t)].join("/")
    }
      , V4 = (n, e, t) => {
        switch (e) {
        case Y.ZodString:
            return sI(n, t);
        case Y.ZodNumber:
            return N4(n, t);
        case Y.ZodObject:
            return L4(n, t);
        case Y.ZodBigInt:
            return g4(n, t);
        case Y.ZodBoolean:
            return y4();
        case Y.ZodDate:
            return nI(n, t);
        case Y.ZodUndefined:
            return U4();
        case Y.ZodNull:
            return O4(t);
        case Y.ZodArray:
            return m4(n, t);
        case Y.ZodUnion:
        case Y.ZodDiscriminatedUnion:
            return R4(n, t);
        case Y.ZodIntersection:
            return x4(n, t);
        case Y.ZodTuple:
            return q4(n, t);
        case Y.ZodRecord:
            return aI(n, t);
        case Y.ZodLiteral:
            return C4(n, t);
        case Y.ZodEnum:
            return S4(n);
        case Y.ZodNativeEnum:
            return A4(n);
        case Y.ZodNullable:
            return M4(n, t);
        case Y.ZodOptional:
            return F4(n, t);
        case Y.ZodMap:
            return T4(n, t);
        case Y.ZodSet:
            return B4(n, t);
        case Y.ZodLazy:
            return nt(n.getter()._def, t);
        case Y.ZodPromise:
            return D4(n, t);
        case Y.ZodNaN:
        case Y.ZodNever:
            return I4();
        case Y.ZodEffects:
            return _4(n, t);
        case Y.ZodAny:
            return p4();
        case Y.ZodUnknown:
            return K4();
        case Y.ZodDefault:
            return v4(n, t);
        case Y.ZodBranded:
            return rI(n, t);
        case Y.ZodReadonly:
            return H4(n, t);
        case Y.ZodCatch:
            return w4(n, t);
        case Y.ZodPipeline:
            return j4(n, t);
        case Y.ZodFunction:
        case Y.ZodVoid:
        case Y.ZodSymbol:
            return;
        default:
            return (r => {}
            )()
        }
    }
      , G4 = (n, e, t) => (n.description && (t.description = n.description,
    e.markdownDescription && (t.markdownDescription = n.description)),
    t)
      , Ui = (n, e) => {
        const t = f4(e)
          , r = void 0
          , s = e == null ? void 0 : e.name
          , i = nt(n._def, t, !1) ?? {}
          , a = s === void 0 ? r ? {
            ...i,
            [t.definitionPath]: r
        } : i : {
            $ref: [...t.$refStrategy === "relative" ? [] : t.basePath, t.definitionPath, s].join("/"),
            [t.definitionPath]: {
                ...r,
                [s]: i
            }
        };
        return t.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : (t.target === "jsonSchema2019-09" || t.target === "openAi") && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"),
        t.target === "openAi" && ("anyOf"in a || "oneOf"in a || "allOf"in a || "type"in a && Array.isArray(a.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."),
        a
    }
    ;
    function J0(n) {
        return n.replace(/[^a-zA-Z-_0-9]/g, "_")
    }
    const J4 = ["*", "_", "`"];
    function Z4(n) {
        let e = "";
        for (const [t,r] of Object.entries(n))
            e += `	classDef ${t} ${r};
`;
        return e
    }
    function X4(n, e, t) {
        const {firstNode: r, lastNode: s, nodeColors: i, withStyles: a=!0, curveStyle: c="linear", wrapLabelNWords: u=9} = t ?? {};
        let l = a ? `%%{init: {'flowchart': {'curve': '${c}'}}}%%
graph TD;
` : `graph TD;
`;
        if (a) {
            const p = "default"
              , g = {
                [p]: "{0}({1})"
            };
            r !== void 0 && (g[r] = "{0}([{1}]):::first"),
            s !== void 0 && (g[s] = "{0}([{1}]):::last");
            for (const [y,m] of Object.entries(n)) {
                const w = m.name.split(":").pop() ?? "";
                let v = J4.some(A => w.startsWith(A) && w.endsWith(A)) ? `<p>${w}</p>` : w;
                Object.keys(m.metadata ?? {}).length && (v += `<hr/><small><em>${Object.entries(m.metadata ?? {}).map( ([A,C]) => `${A} = ${C}`).join(`
`)}</em></small>`);
                const _ = (g[y] ?? g[p]).replace("{0}", J0(y)).replace("{1}", v);
                l += `	${_}
`
            }
        }
        const d = {};
        for (const p of e) {
            const g = p.source.split(":")
              , y = p.target.split(":")
              , m = g.filter( (w, E) => w === y[E]).join(":");
            d[m] || (d[m] = []),
            d[m].push(p)
        }
        const h = new Set;
        function f(p, g) {
            const y = p.length === 1 && p[0].source === p[0].target;
            if (g && !y) {
                const m = g.split(":").pop();
                if (h.has(m))
                    throw new Error(`Found duplicate subgraph '${m}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
                h.add(m),
                l += `	subgraph ${m}
`
            }
            for (const m of p) {
                const {source: w, target: E, data: v, conditional: _} = m;
                let A = "";
                if (v !== void 0) {
                    let C = v;
                    const k = C.split(" ");
                    k.length > u && (C = Array.from({
                        length: Math.ceil(k.length / u)
                    }, (x, N) => k.slice(N * u, (N + 1) * u).join(" ")).join("&nbsp;<br>&nbsp;")),
                    A = _ ? ` -. &nbsp;${C}&nbsp; .-> ` : ` -- &nbsp;${C}&nbsp; --> `
                } else
                    A = _ ? " -.-> " : " --> ";
                l += `	${J0(w)}${A}${J0(E)};
`
            }
            for (const m in d)
                m.startsWith(`${g}:`) && m !== g && f(d[m], m);
            g && !y && (l += `	end
`)
        }
        f(d[""] ?? [], "");
        for (const p in d)
            !p.includes(":") && p !== "" && f(d[p], p);
        return a && (l += Z4(i ?? {})),
        l
    }
    async function Y4(n, e) {
        let {backgroundColor: t="white"} = e ?? {};
        const r = btoa(n);
        t !== void 0 && (/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(t) || (t = `!${t}`));
        const s = `https://mermaid.ink/img/${r}?bgColor=${t}`
          , i = await fetch(s);
        if (!i.ok)
            throw new Error(["Failed to render the graph using the Mermaid.INK API.", `Status code: ${i.status}`, `Status text: ${i.statusText}`].join(`
`));
        return await i.blob()
    }
    function Q4(n, e) {
        if (n !== void 0 && !lh(n))
            return n;
        if (z0(e))
            try {
                let t = e.getName();
                return t = t.startsWith("Runnable") ? t.slice(8) : t,
                t
            } catch {
                return e.getName()
            }
        else
            return e.name ?? "UnknownSchema"
    }
    function e5(n) {
        return z0(n.data) ? {
            type: "runnable",
            data: {
                id: n.data.lc_id,
                name: n.data.getName()
            }
        } : {
            type: "schema",
            data: {
                ...Ui(n.data.schema),
                title: n.data.name
            }
        }
    }
    class aw {
        constructor(e) {
            Object.defineProperty(this, "nodes", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: {}
            }),
            Object.defineProperty(this, "edges", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            this.nodes = (e == null ? void 0 : e.nodes) ?? this.nodes,
            this.edges = (e == null ? void 0 : e.edges) ?? this.edges
        }
        toJSON() {
            const e = {};
            return Object.values(this.nodes).forEach( (t, r) => {
                e[t.id] = lh(t.id) ? r : t.id
            }
            ),
            {
                nodes: Object.values(this.nodes).map(t => ({
                    id: e[t.id],
                    ...e5(t)
                })),
                edges: this.edges.map(t => {
                    const r = {
                        source: e[t.source],
                        target: e[t.target]
                    };
                    return typeof t.data < "u" && (r.data = t.data),
                    typeof t.conditional < "u" && (r.conditional = t.conditional),
                    r
                }
                )
            }
        }
        addNode(e, t, r) {
            if (t !== void 0 && this.nodes[t] !== void 0)
                throw new Error(`Node with id ${t} already exists`);
            const s = t ?? Rr()
              , i = {
                id: s,
                data: e,
                name: Q4(t, e),
                metadata: r
            };
            return this.nodes[s] = i,
            i
        }
        removeNode(e) {
            delete this.nodes[e.id],
            this.edges = this.edges.filter(t => t.source !== e.id && t.target !== e.id)
        }
        addEdge(e, t, r, s) {
            if (this.nodes[e.id] === void 0)
                throw new Error(`Source node ${e.id} not in graph`);
            if (this.nodes[t.id] === void 0)
                throw new Error(`Target node ${t.id} not in graph`);
            const i = {
                source: e.id,
                target: t.id,
                data: r,
                conditional: s
            };
            return this.edges.push(i),
            i
        }
        firstNode() {
            return cI(this)
        }
        lastNode() {
            return uI(this)
        }
        extend(e, t="") {
            let r = t;
            Object.values(e.nodes).map(l => l.id).every(lh) && (r = "");
            const i = l => r ? `${r}:${l}` : l;
            Object.entries(e.nodes).forEach( ([l,d]) => {
                this.nodes[i(l)] = {
                    ...d,
                    id: i(l)
                }
            }
            );
            const a = e.edges.map(l => ({
                ...l,
                source: i(l.source),
                target: i(l.target)
            }));
            this.edges = [...this.edges, ...a];
            const c = e.firstNode()
              , u = e.lastNode();
            return [c ? {
                id: i(c.id),
                data: c.data
            } : void 0, u ? {
                id: i(u.id),
                data: u.data
            } : void 0]
        }
        trimFirstNode() {
            const e = this.firstNode();
            e && cI(this, [e.id]) && this.removeNode(e)
        }
        trimLastNode() {
            const e = this.lastNode();
            e && uI(this, [e.id]) && this.removeNode(e)
        }
        reid() {
            const e = Object.fromEntries(Object.values(this.nodes).map(s => [s.id, s.name]))
              , t = new Map;
            Object.values(e).forEach(s => {
                t.set(s, (t.get(s) || 0) + 1)
            }
            );
            const r = s => {
                const i = e[s];
                return lh(s) && t.get(i) === 1 ? i : s
            }
            ;
            return new aw({
                nodes: Object.fromEntries(Object.entries(this.nodes).map( ([s,i]) => [r(s), {
                    ...i,
                    id: r(s)
                }])),
                edges: this.edges.map(s => ({
                    ...s,
                    source: r(s.source),
                    target: r(s.target)
                }))
            })
        }
        drawMermaid(e) {
            const {withStyles: t, curveStyle: r, nodeColors: s={
                default: "fill:#f2f0ff,line-height:1.2",
                first: "fill-opacity:0",
                last: "fill:#bfb6fc"
            }, wrapLabelNWords: i} = e ?? {}
              , a = this.reid()
              , c = a.firstNode()
              , u = a.lastNode();
            return X4(a.nodes, a.edges, {
                firstNode: c == null ? void 0 : c.id,
                lastNode: u == null ? void 0 : u.id,
                withStyles: t,
                curveStyle: r,
                nodeColors: s,
                wrapLabelNWords: i
            })
        }
        async drawMermaidPng(e) {
            const t = this.drawMermaid(e);
            return Y4(t, {
                backgroundColor: e == null ? void 0 : e.backgroundColor
            })
        }
    }
    function cI(n, e=[]) {
        const t = new Set(n.edges.filter(s => !e.includes(s.source)).map(s => s.target))
          , r = [];
        for (const s of Object.values(n.nodes))
            !e.includes(s.id) && !t.has(s.id) && r.push(s);
        return r.length === 1 ? r[0] : void 0
    }
    function uI(n, e=[]) {
        const t = new Set(n.edges.filter(s => !e.includes(s.target)).map(s => s.source))
          , r = [];
        for (const s of Object.values(n.nodes))
            !e.includes(s.id) && !t.has(s.id) && r.push(s);
        return r.length === 1 ? r[0] : void 0
    }
    function t5(n) {
        const e = new TextEncoder
          , t = new ReadableStream({
            async start(r) {
                for await(const s of n)
                    r.enqueue(e.encode(`event: data
data: ${JSON.stringify(s)}

`));
                r.enqueue(e.encode(`event: end

`)),
                r.close()
            }
        });
        return Qr.fromReadableStream(t)
    }
    function lI(n) {
        return typeof n == "object" && n !== null && typeof n[Symbol.iterator] == "function" && typeof n.next == "function"
    }
    const r5 = n => n != null && typeof n == "object" && "next"in n && typeof n.next == "function";
    function Z0(n) {
        return typeof n == "object" && n !== null && typeof n[Symbol.asyncIterator] == "function"
    }
    function *dI(n, e) {
        for (; ; ) {
            const {value: t, done: r} = ji.runWithConfig(lu(n), e.next.bind(e), !0);
            if (r)
                break;
            yield t
        }
    }
    async function *X0(n, e) {
        const t = e[Symbol.asyncIterator]();
        for (; ; ) {
            const {value: r, done: s} = await ji.runWithConfig(lu(n), t.next.bind(e), !0);
            if (s)
                break;
            yield r
        }
    }
    function Gt(n, e) {
        return n && !Array.isArray(n) && !(n instanceof Date) && typeof n == "object" ? n : {
            [e]: n
        }
    }
    class jt extends so {
        constructor() {
            super(...arguments),
            Object.defineProperty(this, "lc_runnable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            })
        }
        getName(e) {
            const t = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
            return e ? `${t}${e}` : t
        }
        bind(e) {
            return new ao({
                bound: this,
                kwargs: e,
                config: {}
            })
        }
        map() {
            return new ow({
                bound: this
            })
        }
        withRetry(e) {
            return new n5({
                bound: this,
                kwargs: {},
                config: {},
                maxAttemptNumber: e == null ? void 0 : e.stopAfterAttempt,
                ...e
            })
        }
        withConfig(e) {
            return new ao({
                bound: this,
                config: e,
                kwargs: {}
            })
        }
        withFallbacks(e) {
            const t = Array.isArray(e) ? e : e.fallbacks;
            return new i5({
                runnable: this,
                fallbacks: t
            })
        }
        _getOptionsList(e, t=0) {
            if (Array.isArray(e) && e.length !== t)
                throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);
            if (Array.isArray(e))
                return e.map(it);
            if (t > 1 && !Array.isArray(e) && e.runId) {
                console.warn("Provided runId will be used only for the first element of the batch.");
                const r = Object.fromEntries(Object.entries(e).filter( ([s]) => s !== "runId"));
                return Array.from({
                    length: t
                }, (s, i) => it(i === 0 ? e : r))
            }
            return Array.from({
                length: t
            }, () => it(e))
        }
        async batch(e, t, r) {
            var u;
            const s = this._getOptionsList(t ?? {}, e.length)
              , i = ((u = s[0]) == null ? void 0 : u.maxConcurrency) ?? (r == null ? void 0 : r.maxConcurrency)
              , a = new W0({
                maxConcurrency: i,
                onFailedAttempt: l => {
                    throw l
                }
            })
              , c = e.map( (l, d) => a.call(async () => {
                try {
                    return await this.invoke(l, s[d])
                } catch (h) {
                    if (r != null && r.returnExceptions)
                        return h;
                    throw h
                }
            }
            ));
            return Promise.all(c)
        }
        async*_streamIterator(e, t) {
            yield this.invoke(e, t)
        }
        async stream(e, t) {
            const r = it(t)
              , s = new du({
                generator: this._streamIterator(e, r),
                config: r
            });
            return await s.setup,
            Qr.fromAsyncGenerator(s)
        }
        _separateRunnableConfigFromCallOptions(e) {
            let t;
            e === void 0 ? t = it(e) : t = it({
                callbacks: e.callbacks,
                tags: e.tags,
                metadata: e.metadata,
                runName: e.runName,
                configurable: e.configurable,
                recursionLimit: e.recursionLimit,
                maxConcurrency: e.maxConcurrency,
                runId: e.runId,
                timeout: e.timeout,
                signal: e.signal
            });
            const r = {
                ...e
            };
            return delete r.callbacks,
            delete r.tags,
            delete r.metadata,
            delete r.runName,
            delete r.configurable,
            delete r.recursionLimit,
            delete r.maxConcurrency,
            delete r.runId,
            delete r.timeout,
            delete r.signal,
            [t, r]
        }
        async _callWithConfig(e, t, r) {
            const s = it(r)
              , i = await Mn(s)
              , a = await (i == null ? void 0 : i.handleChainStart(this.toJSON(), Gt(t, "input"), s.runId, s == null ? void 0 : s.runType, void 0, void 0, (s == null ? void 0 : s.runName) ?? this.getName()));
            delete s.runId;
            let c;
            try {
                const u = e.call(this, t, s, a);
                c = await Di(u, r == null ? void 0 : r.signal)
            } catch (u) {
                throw await (a == null ? void 0 : a.handleChainError(u)),
                u
            }
            return await (a == null ? void 0 : a.handleChainEnd(Gt(c, "output"))),
            c
        }
        async _batchWithConfig(e, t, r, s) {
            var l;
            const i = this._getOptionsList(r ?? {}, t.length)
              , a = await Promise.all(i.map(Mn))
              , c = await Promise.all(a.map(async (d, h) => {
                const f = await (d == null ? void 0 : d.handleChainStart(this.toJSON(), Gt(t[h], "input"), i[h].runId, i[h].runType, void 0, void 0, i[h].runName ?? this.getName()));
                return delete i[h].runId,
                f
            }
            ));
            let u;
            try {
                const d = e.call(this, t, i, c, s);
                u = await Di(d, (l = i == null ? void 0 : i[0]) == null ? void 0 : l.signal)
            } catch (d) {
                throw await Promise.all(c.map(h => h == null ? void 0 : h.handleChainError(d))),
                d
            }
            return await Promise.all(c.map(d => d == null ? void 0 : d.handleChainEnd(Gt(u, "output")))),
            u
        }
        async*_transformStreamWithConfig(e, t, r) {
            let s, i = !0, a, c = !0;
            const u = it(r)
              , l = await Mn(u);
            async function *d() {
                for await(const f of e) {
                    if (i)
                        if (s === void 0)
                            s = f;
                        else
                            try {
                                s = Nn(s, f)
                            } catch {
                                s = void 0,
                                i = !1
                            }
                    yield f
                }
            }
            let h;
            try {
                const f = await r4(t.bind(this), d(), async () => l == null ? void 0 : l.handleChainStart(this.toJSON(), {
                    input: ""
                }, u.runId, u.runType, void 0, void 0, u.runName ?? this.getName()), r == null ? void 0 : r.signal, u);
                delete u.runId,
                h = f.setup;
                const p = h == null ? void 0 : h.handlers.find(i4);
                let g = f.output;
                p !== void 0 && h !== void 0 && (g = p.tapOutputIterable(h.runId, g));
                const y = h == null ? void 0 : h.handlers.find(n4);
                y !== void 0 && h !== void 0 && (g = y.tapOutputIterable(h.runId, g));
                for await(const m of g)
                    if (yield m,
                    c)
                        if (a === void 0)
                            a = m;
                        else
                            try {
                                a = Nn(a, m)
                            } catch {
                                a = void 0,
                                c = !1
                            }
            } catch (f) {
                throw await (h == null ? void 0 : h.handleChainError(f, void 0, void 0, void 0, {
                    inputs: Gt(s, "input")
                })),
                f
            }
            await (h == null ? void 0 : h.handleChainEnd(a ?? {}, void 0, void 0, void 0, {
                inputs: Gt(s, "input")
            }))
        }
        getGraph(e) {
            const t = new aw
              , r = t.addNode({
                name: `${this.getName()}Input`,
                schema: fe.any()
            })
              , s = t.addNode(this)
              , i = t.addNode({
                name: `${this.getName()}Output`,
                schema: fe.any()
            });
            return t.addEdge(r, s),
            t.addEdge(s, i),
            t
        }
        pipe(e) {
            return new Fn({
                first: this,
                last: oo(e)
            })
        }
        pick(e) {
            return this.pipe(new a5(e))
        }
        assign(e) {
            return this.pipe(new hI(new fu({
                steps: e
            })))
        }
        async*transform(e, t) {
            let r;
            for await(const s of e)
                r === void 0 ? r = s : r = Nn(r, s);
            yield*this._streamIterator(r, it(t))
        }
        async*streamLog(e, t, r) {
            const s = new YA({
                ...r,
                autoClose: !1,
                _schemaFormat: "original"
            })
              , i = it(t);
            yield*this._streamLog(e, s, i)
        }
        async*_streamLog(e, t, r) {
            const {callbacks: s} = r;
            if (s === void 0)
                r.callbacks = [t];
            else if (Array.isArray(s))
                r.callbacks = s.concat([t]);
            else {
                const u = s.copy();
                u.addHandler(t, !0),
                r.callbacks = u
            }
            const i = this.stream(e, r);
            async function a() {
                try {
                    const u = await i;
                    for await(const l of u) {
                        const d = new Bi({
                            ops: [{
                                op: "add",
                                path: "/streamed_output/-",
                                value: l
                            }]
                        });
                        await t.writer.write(d)
                    }
                } finally {
                    await t.writer.close()
                }
            }
            const c = a();
            try {
                for await(const u of t)
                    yield u
            } finally {
                await c
            }
        }
        streamEvents(e, t, r) {
            let s;
            if (t.version === "v1")
                s = this._streamEventsV1(e, t, r);
            else if (t.version === "v2")
                s = this._streamEventsV2(e, t, r);
            else
                throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');
            return t.encoding === "text/event-stream" ? t5(s) : Qr.fromAsyncGenerator(s)
        }
        async*_streamEventsV2(e, t, r) {
            var g;
            const s = new a4({
                ...r,
                autoClose: !1
            })
              , i = it(t)
              , a = i.runId ?? Rr();
            i.runId = a;
            const c = i.callbacks;
            if (c === void 0)
                i.callbacks = [s];
            else if (Array.isArray(c))
                i.callbacks = c.concat(s);
            else {
                const y = c.copy();
                y.addHandler(s, !0),
                i.callbacks = y
            }
            const u = new AbortController
              , l = this;
            async function d() {
                try {
                    let y;
                    t != null && t.signal ? "any"in AbortSignal ? y = AbortSignal.any([u.signal, t.signal]) : (y = t.signal,
                    t.signal.addEventListener("abort", () => {
                        u.abort()
                    }
                    , {
                        once: !0
                    })) : y = u.signal;
                    const m = await l.stream(e, {
                        ...i,
                        signal: y
                    })
                      , w = s.tapOutputIterable(a, m);
                    for await(const E of w)
                        if (u.signal.aborted)
                            break
                } finally {
                    await s.finish()
                }
            }
            const h = d();
            let f = !1, p;
            try {
                for await(const y of s) {
                    if (!f) {
                        y.data.input = e,
                        f = !0,
                        p = y.run_id,
                        yield y;
                        continue
                    }
                    y.run_id === p && y.event.endsWith("_end") && (g = y.data) != null && g.input && delete y.data.input,
                    yield y
                }
            } finally {
                u.abort(),
                await h
            }
        }
        async*_streamEventsV1(e, t, r) {
            let s, i = !1;
            const a = it(t)
              , c = a.tags ?? []
              , u = a.metadata ?? {}
              , l = a.runName ?? this.getName()
              , d = new YA({
                ...r,
                autoClose: !1,
                _schemaFormat: "streaming_events"
            })
              , h = new u4({
                ...r
            })
              , f = this._streamLog(e, d, a);
            for await(const g of f) {
                if (s ? s = s.concat(g) : s = _h.fromRunLogPatch(g),
                s.state === void 0)
                    throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');
                if (!i) {
                    i = !0;
                    const E = {
                        ...s.state
                    }
                      , v = {
                        run_id: E.id,
                        event: `on_${E.type}_start`,
                        name: l,
                        tags: c,
                        metadata: u,
                        data: {
                            input: e
                        }
                    };
                    h.includeEvent(v, E.type) && (yield v)
                }
                const y = g.ops.filter(E => E.path.startsWith("/logs/")).map(E => E.path.split("/")[2])
                  , m = [...new Set(y)];
                for (const E of m) {
                    let v, _ = {};
                    const A = s.state.logs[E];
                    if (A.end_time === void 0 ? A.streamed_output.length > 0 ? v = "stream" : v = "start" : v = "end",
                    v === "start")
                        A.inputs !== void 0 && (_.input = A.inputs);
                    else if (v === "end")
                        A.inputs !== void 0 && (_.input = A.inputs),
                        _.output = A.final_output;
                    else if (v === "stream") {
                        const C = A.streamed_output.length;
                        if (C !== 1)
                            throw new Error(`Expected exactly one chunk of streamed output, got ${C} instead. Encountered in: "${A.name}"`);
                        _ = {
                            chunk: A.streamed_output[0]
                        },
                        A.streamed_output = []
                    }
                    yield{
                        event: `on_${A.type}_${v}`,
                        name: A.name,
                        run_id: A.id,
                        tags: A.tags,
                        metadata: A.metadata,
                        data: _
                    }
                }
                const {state: w} = s;
                if (w.streamed_output.length > 0) {
                    const E = w.streamed_output.length;
                    if (E !== 1)
                        throw new Error(`Expected exactly one chunk of streamed output, got ${E} instead. Encountered in: "${w.name}"`);
                    const v = {
                        chunk: w.streamed_output[0]
                    };
                    w.streamed_output = [];
                    const _ = {
                        event: `on_${w.type}_stream`,
                        run_id: w.id,
                        tags: c,
                        metadata: u,
                        name: l,
                        data: v
                    };
                    h.includeEvent(_, w.type) && (yield _)
                }
            }
            const p = s == null ? void 0 : s.state;
            if (p !== void 0) {
                const g = {
                    event: `on_${p.type}_end`,
                    name: l,
                    run_id: p.id,
                    tags: c,
                    metadata: u,
                    data: {
                        output: p.final_output
                    }
                };
                h.includeEvent(g, p.type) && (yield g)
            }
        }
        static isRunnable(e) {
            return z0(e)
        }
        withListeners({onStart: e, onEnd: t, onError: r}) {
            return new ao({
                bound: this,
                config: {},
                configFactories: [s => ({
                    callbacks: [new eI({
                        config: s,
                        onStart: e,
                        onEnd: t,
                        onError: r
                    })]
                })]
            })
        }
        asTool(e) {
            return o5(this, e)
        }
    }
    class ao extends jt {
        static lc_name() {
            return "RunnableBinding"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "bound", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "config", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "kwargs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "configFactories", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.bound = e.bound,
            this.kwargs = e.kwargs,
            this.config = e.config,
            this.configFactories = e.configFactories
        }
        getName(e) {
            return this.bound.getName(e)
        }
        async _mergeConfig(...e) {
            const t = GA(this.config, ...e);
            return GA(t, ...this.configFactories ? await Promise.all(this.configFactories.map(async r => await r(t))) : [])
        }
        bind(e) {
            return new this.constructor({
                bound: this.bound,
                kwargs: {
                    ...this.kwargs,
                    ...e
                },
                config: this.config
            })
        }
        withConfig(e) {
            return new this.constructor({
                bound: this.bound,
                kwargs: this.kwargs,
                config: {
                    ...this.config,
                    ...e
                }
            })
        }
        withRetry(e) {
            return new this.constructor({
                bound: this.bound.withRetry(e),
                kwargs: this.kwargs,
                config: this.config
            })
        }
        async invoke(e, t) {
            return this.bound.invoke(e, await this._mergeConfig(it(t), this.kwargs))
        }
        async batch(e, t, r) {
            const s = Array.isArray(t) ? await Promise.all(t.map(async i => this._mergeConfig(it(i), this.kwargs))) : await this._mergeConfig(it(t), this.kwargs);
            return this.bound.batch(e, s, r)
        }
        async*_streamIterator(e, t) {
            yield*this.bound._streamIterator(e, await this._mergeConfig(it(t), this.kwargs))
        }
        async stream(e, t) {
            return this.bound.stream(e, await this._mergeConfig(it(t), this.kwargs))
        }
        async*transform(e, t) {
            yield*this.bound.transform(e, await this._mergeConfig(it(t), this.kwargs))
        }
        streamEvents(e, t, r) {
            const s = this
              , i = async function*() {
                yield*s.bound.streamEvents(e, {
                    ...await s._mergeConfig(it(t), s.kwargs),
                    version: t.version
                }, r)
            };
            return Qr.fromAsyncGenerator(i())
        }
        static isRunnableBinding(e) {
            return e.bound && jt.isRunnable(e.bound)
        }
        withListeners({onStart: e, onEnd: t, onError: r}) {
            return new ao({
                bound: this.bound,
                kwargs: this.kwargs,
                config: this.config,
                configFactories: [s => ({
                    callbacks: [new eI({
                        config: s,
                        onStart: e,
                        onEnd: t,
                        onError: r
                    })]
                })]
            })
        }
    }
    class ow extends jt {
        static lc_name() {
            return "RunnableEach"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "bound", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.bound = e.bound
        }
        bind(e) {
            return new ow({
                bound: this.bound.bind(e)
            })
        }
        async invoke(e, t) {
            return this._callWithConfig(this._invoke.bind(this), e, t)
        }
        async _invoke(e, t, r) {
            return this.bound.batch(e, dr(t, {
                callbacks: r == null ? void 0 : r.getChild()
            }))
        }
        withListeners({onStart: e, onEnd: t, onError: r}) {
            return new ow({
                bound: this.bound.withListeners({
                    onStart: e,
                    onEnd: t,
                    onError: r
                })
            })
        }
    }
    class n5 extends ao {
        static lc_name() {
            return "RunnableRetry"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "maxAttemptNumber", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 3
            }),
            Object.defineProperty(this, "onFailedAttempt", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: () => {}
            }),
            this.maxAttemptNumber = e.maxAttemptNumber ?? this.maxAttemptNumber,
            this.onFailedAttempt = e.onFailedAttempt ?? this.onFailedAttempt
        }
        _patchConfigForRetry(e, t, r) {
            const s = e > 1 ? `retry:attempt:${e}` : void 0;
            return dr(t, {
                callbacks: r == null ? void 0 : r.getChild(s)
            })
        }
        async _invoke(e, t, r) {
            return Dy(s => super.invoke(e, this._patchConfigForRetry(s, t, r)), {
                onFailedAttempt: s => this.onFailedAttempt(s, e),
                retries: Math.max(this.maxAttemptNumber - 1, 0),
                randomize: !0
            })
        }
        async invoke(e, t) {
            return this._callWithConfig(this._invoke.bind(this), e, t)
        }
        async _batch(e, t, r, s) {
            const i = {};
            try {
                await Dy(async a => {
                    const c = e.map( (f, p) => p).filter(f => i[f.toString()] === void 0 || i[f.toString()]instanceof Error)
                      , u = c.map(f => e[f])
                      , l = c.map(f => this._patchConfigForRetry(a, t == null ? void 0 : t[f], r == null ? void 0 : r[f]))
                      , d = await super.batch(u, l, {
                        ...s,
                        returnExceptions: !0
                    });
                    let h;
                    for (let f = 0; f < d.length; f += 1) {
                        const p = d[f]
                          , g = c[f];
                        p instanceof Error && h === void 0 && (h = p,
                        h.input = u[f]),
                        i[g.toString()] = p
                    }
                    if (h)
                        throw h;
                    return d
                }
                , {
                    onFailedAttempt: a => this.onFailedAttempt(a, a.input),
                    retries: Math.max(this.maxAttemptNumber - 1, 0),
                    randomize: !0
                })
            } catch (a) {
                if ((s == null ? void 0 : s.returnExceptions) !== !0)
                    throw a
            }
            return Object.keys(i).sort( (a, c) => parseInt(a, 10) - parseInt(c, 10)).map(a => i[parseInt(a, 10)])
        }
        async batch(e, t, r) {
            return this._batchWithConfig(this._batch.bind(this), e, t, r)
        }
    }
    class Fn extends jt {
        static lc_name() {
            return "RunnableSequence"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "first", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "middle", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "last", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "omitSequenceTags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            this.first = e.first,
            this.middle = e.middle ?? this.middle,
            this.last = e.last,
            this.name = e.name,
            this.omitSequenceTags = e.omitSequenceTags ?? this.omitSequenceTags
        }
        get steps() {
            return [this.first, ...this.middle, this.last]
        }
        async invoke(e, t) {
            var u;
            const r = it(t)
              , s = await Mn(r)
              , i = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), Gt(e, "input"), r.runId, void 0, void 0, void 0, r == null ? void 0 : r.runName));
            delete r.runId;
            let a = e, c;
            try {
                const l = [this.first, ...this.middle];
                for (let d = 0; d < l.length; d += 1) {
                    const f = l[d].invoke(a, dr(r, {
                        callbacks: i == null ? void 0 : i.getChild(this.omitSequenceTags ? void 0 : `seq:step:${d + 1}`)
                    }));
                    a = await Di(f, t == null ? void 0 : t.signal)
                }
                if ((u = t == null ? void 0 : t.signal) != null && u.aborted)
                    throw new Error("Aborted");
                c = await this.last.invoke(a, dr(r, {
                    callbacks: i == null ? void 0 : i.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`)
                }))
            } catch (l) {
                throw await (i == null ? void 0 : i.handleChainError(l)),
                l
            }
            return await (i == null ? void 0 : i.handleChainEnd(Gt(c, "output"))),
            c
        }
        async batch(e, t, r) {
            var u;
            const s = this._getOptionsList(t ?? {}, e.length)
              , i = await Promise.all(s.map(Mn))
              , a = await Promise.all(i.map(async (l, d) => {
                const h = await (l == null ? void 0 : l.handleChainStart(this.toJSON(), Gt(e[d], "input"), s[d].runId, void 0, void 0, void 0, s[d].runName));
                return delete s[d].runId,
                h
            }
            ));
            let c = e;
            try {
                for (let l = 0; l < this.steps.length; l += 1) {
                    const h = this.steps[l].batch(c, a.map( (f, p) => {
                        const g = f == null ? void 0 : f.getChild(this.omitSequenceTags ? void 0 : `seq:step:${l + 1}`);
                        return dr(s[p], {
                            callbacks: g
                        })
                    }
                    ), r);
                    c = await Di(h, (u = s[0]) == null ? void 0 : u.signal)
                }
            } catch (l) {
                throw await Promise.all(a.map(d => d == null ? void 0 : d.handleChainError(l))),
                l
            }
            return await Promise.all(a.map(l => l == null ? void 0 : l.handleChainEnd(Gt(c, "output")))),
            c
        }
        async*_streamIterator(e, t) {
            var h;
            const r = await Mn(t)
              , {runId: s, ...i} = t ?? {}
              , a = await (r == null ? void 0 : r.handleChainStart(this.toJSON(), Gt(e, "input"), s, void 0, void 0, void 0, i == null ? void 0 : i.runName))
              , c = [this.first, ...this.middle, this.last];
            let u = !0, l;
            async function *d() {
                yield e
            }
            try {
                let f = c[0].transform(d(), dr(i, {
                    callbacks: a == null ? void 0 : a.getChild(this.omitSequenceTags ? void 0 : "seq:step:1")
                }));
                for (let p = 1; p < c.length; p += 1)
                    f = await c[p].transform(f, dr(i, {
                        callbacks: a == null ? void 0 : a.getChild(this.omitSequenceTags ? void 0 : `seq:step:${p + 1}`)
                    }));
                for await(const p of f)
                    if ((h = t == null ? void 0 : t.signal) == null || h.throwIfAborted(),
                    yield p,
                    u)
                        if (l === void 0)
                            l = p;
                        else
                            try {
                                l = Nn(l, p)
                            } catch {
                                l = void 0,
                                u = !1
                            }
            } catch (f) {
                throw await (a == null ? void 0 : a.handleChainError(f)),
                f
            }
            await (a == null ? void 0 : a.handleChainEnd(Gt(l, "output")))
        }
        getGraph(e) {
            const t = new aw;
            let r = null;
            return this.steps.forEach( (s, i) => {
                const a = s.getGraph(e);
                i !== 0 && a.trimFirstNode(),
                i !== this.steps.length - 1 && a.trimLastNode(),
                t.extend(a);
                const c = a.firstNode();
                if (!c)
                    throw new Error(`Runnable ${s} has no first node`);
                r && t.addEdge(r, c),
                r = a.lastNode()
            }
            ),
            t
        }
        pipe(e) {
            return Fn.isRunnableSequence(e) ? new Fn({
                first: this.first,
                middle: this.middle.concat([this.last, e.first, ...e.middle]),
                last: e.last,
                name: this.name ?? e.name
            }) : new Fn({
                first: this.first,
                middle: [...this.middle, this.last],
                last: oo(e),
                name: this.name
            })
        }
        static isRunnableSequence(e) {
            return Array.isArray(e.middle) && jt.isRunnable(e)
        }
        static from([e,...t], r) {
            let s = {};
            return typeof r == "string" ? s.name = r : r !== void 0 && (s = r),
            new Fn({
                ...s,
                first: oo(e),
                middle: t.slice(0, -1).map(oo),
                last: oo(t[t.length - 1])
            })
        }
    }
    class fu extends jt {
        static lc_name() {
            return "RunnableMap"
        }
        getStepsKeys() {
            return Object.keys(this.steps)
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "steps", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.steps = {};
            for (const [t,r] of Object.entries(e.steps))
                this.steps[t] = oo(r)
        }
        static from(e) {
            return new fu({
                steps: e
            })
        }
        async invoke(e, t) {
            const r = it(t)
              , s = await Mn(r)
              , i = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), {
                input: e
            }, r.runId, void 0, void 0, void 0, r == null ? void 0 : r.runName));
            delete r.runId;
            const a = {};
            try {
                const c = Object.entries(this.steps).map(async ([u,l]) => {
                    a[u] = await l.invoke(e, dr(r, {
                        callbacks: i == null ? void 0 : i.getChild(`map:key:${u}`)
                    }))
                }
                );
                await Di(Promise.all(c), t == null ? void 0 : t.signal)
            } catch (c) {
                throw await (i == null ? void 0 : i.handleChainError(c)),
                c
            }
            return await (i == null ? void 0 : i.handleChainEnd(a)),
            a
        }
        async*_transform(e, t, r) {
            const s = {
                ...this.steps
            }
              , i = JA(e, Object.keys(s).length)
              , a = new Map(Object.entries(s).map( ([c,u], l) => {
                const d = u.transform(i[l], dr(r, {
                    callbacks: t == null ? void 0 : t.getChild(`map:key:${c}`)
                }));
                return [c, d.next().then(h => ({
                    key: c,
                    gen: d,
                    result: h
                }))]
            }
            ));
            for (; a.size; ) {
                const c = Promise.race(a.values())
                  , {key: u, result: l, gen: d} = await Di(c, r == null ? void 0 : r.signal);
                a.delete(u),
                l.done || (yield{
                    [u]: l.value
                },
                a.set(u, d.next().then(h => ({
                    key: u,
                    gen: d,
                    result: h
                }))))
            }
        }
        transform(e, t) {
            return this._transformStreamWithConfig(e, this._transform.bind(this), t)
        }
        async stream(e, t) {
            async function *r() {
                yield e
            }
            const s = it(t)
              , i = new du({
                generator: this.transform(r(), s),
                config: s
            });
            return await i.setup,
            Qr.fromAsyncGenerator(i)
        }
    }
    class Y0 extends jt {
        constructor(e) {
            if (super(e),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "func", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            !M0(e.func))
                throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
            this.func = e.func
        }
        async invoke(e, t) {
            const [r] = this._getOptionsList(t ?? {}, 1)
              , s = await Mn(r)
              , i = this.func(dr(r, {
                callbacks: s
            }), e);
            return Di(i, r == null ? void 0 : r.signal)
        }
        async*_streamIterator(e, t) {
            var i, a;
            const [r] = this._getOptionsList(t ?? {}, 1)
              , s = await this.invoke(e, t);
            if (Z0(s)) {
                for await(const c of s)
                    (i = r == null ? void 0 : r.signal) == null || i.throwIfAborted(),
                    yield c;
                return
            }
            if (r5(s)) {
                for (; ; ) {
                    (a = r == null ? void 0 : r.signal) == null || a.throwIfAborted();
                    const c = s.next();
                    if (c.done)
                        break;
                    yield c.value
                }
                return
            }
            yield s
        }
        static from(e) {
            return new Y0({
                func: e
            })
        }
    }
    function s5(n) {
        if (M0(n))
            throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.")
    }
    class Sh extends jt {
        static lc_name() {
            return "RunnableLambda"
        }
        constructor(e) {
            if (M0(e.func))
                return Y0.from(e.func);
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "func", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            s5(e.func),
            this.func = e.func
        }
        static from(e) {
            return new Sh({
                func: e
            })
        }
        async _invoke(e, t, r) {
            return new Promise( (s, i) => {
                const a = dr(t, {
                    callbacks: r == null ? void 0 : r.getChild(),
                    recursionLimit: ((t == null ? void 0 : t.recursionLimit) ?? H0) - 1
                });
                ji.runWithConfig(lu(a), async () => {
                    var c, u;
                    try {
                        let l = await this.func(e, {
                            ...a
                        });
                        if (l && jt.isRunnable(l)) {
                            if ((t == null ? void 0 : t.recursionLimit) === 0)
                                throw new Error("Recursion limit reached.");
                            l = await l.invoke(e, {
                                ...a,
                                recursionLimit: (a.recursionLimit ?? H0) - 1
                            })
                        } else if (Z0(l)) {
                            let d;
                            for await(const h of X0(a, l))
                                if ((c = t == null ? void 0 : t.signal) == null || c.throwIfAborted(),
                                d === void 0)
                                    d = h;
                                else
                                    try {
                                        d = Nn(d, h)
                                    } catch {
                                        d = h
                                    }
                            l = d
                        } else if (lI(l)) {
                            let d;
                            for (const h of dI(a, l))
                                if ((u = t == null ? void 0 : t.signal) == null || u.throwIfAborted(),
                                d === void 0)
                                    d = h;
                                else
                                    try {
                                        d = Nn(d, h)
                                    } catch {
                                        d = h
                                    }
                            l = d
                        }
                        s(l)
                    } catch (l) {
                        i(l)
                    }
                }
                )
            }
            )
        }
        async invoke(e, t) {
            return this._callWithConfig(this._invoke.bind(this), e, t)
        }
        async*_transform(e, t, r) {
            var c, u;
            let s;
            for await(const l of e)
                if (s === void 0)
                    s = l;
                else
                    try {
                        s = Nn(s, l)
                    } catch {
                        s = l
                    }
            const i = dr(r, {
                callbacks: t == null ? void 0 : t.getChild(),
                recursionLimit: ((r == null ? void 0 : r.recursionLimit) ?? H0) - 1
            })
              , a = await new Promise( (l, d) => {
                ji.runWithConfig(lu(i), async () => {
                    try {
                        const h = await this.func(s, {
                            ...i,
                            config: i
                        });
                        l(h)
                    } catch (h) {
                        d(h)
                    }
                }
                )
            }
            );
            if (a && jt.isRunnable(a)) {
                if ((r == null ? void 0 : r.recursionLimit) === 0)
                    throw new Error("Recursion limit reached.");
                const l = await a.stream(s, i);
                for await(const d of l)
                    yield d
            } else if (Z0(a))
                for await(const l of X0(i, a))
                    (c = r == null ? void 0 : r.signal) == null || c.throwIfAborted(),
                    yield l;
            else if (lI(a))
                for (const l of dI(i, a))
                    (u = r == null ? void 0 : r.signal) == null || u.throwIfAborted(),
                    yield l;
            else
                yield a
        }
        transform(e, t) {
            return this._transformStreamWithConfig(e, this._transform.bind(this), t)
        }
        async stream(e, t) {
            async function *r() {
                yield e
            }
            const s = it(t)
              , i = new du({
                generator: this.transform(r(), s),
                config: s
            });
            return await i.setup,
            Qr.fromAsyncGenerator(i)
        }
    }
    class i5 extends jt {
        static lc_name() {
            return "RunnableWithFallbacks"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "runnable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "fallbacks", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.runnable = e.runnable,
            this.fallbacks = e.fallbacks
        }
        *runnables() {
            yield this.runnable;
            for (const e of this.fallbacks)
                yield e
        }
        async invoke(e, t) {
            const r = it(t)
              , s = await Mn(r)
              , {runId: i, ...a} = r
              , c = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), Gt(e, "input"), i, void 0, void 0, void 0, a == null ? void 0 : a.runName))
              , u = dr(a, {
                callbacks: c == null ? void 0 : c.getChild()
            });
            return await ji.runWithConfig(u, async () => {
                var h;
                let d;
                for (const f of this.runnables()) {
                    (h = r == null ? void 0 : r.signal) == null || h.throwIfAborted();
                    try {
                        const p = await f.invoke(e, u);
                        return await (c == null ? void 0 : c.handleChainEnd(Gt(p, "output"))),
                        p
                    } catch (p) {
                        d === void 0 && (d = p)
                    }
                }
                throw d === void 0 ? new Error("No error stored at end of fallback.") : (await (c == null ? void 0 : c.handleChainError(d)),
                d)
            }
            )
        }
        async*_streamIterator(e, t) {
            var h;
            const r = it(t)
              , s = await Mn(r)
              , {runId: i, ...a} = r
              , c = await (s == null ? void 0 : s.handleChainStart(this.toJSON(), Gt(e, "input"), i, void 0, void 0, void 0, a == null ? void 0 : a.runName));
            let u, l;
            for (const f of this.runnables()) {
                (h = r == null ? void 0 : r.signal) == null || h.throwIfAborted();
                const p = dr(a, {
                    callbacks: c == null ? void 0 : c.getChild()
                });
                try {
                    const g = await f.stream(e, p);
                    l = X0(p, g);
                    break
                } catch (g) {
                    u === void 0 && (u = g)
                }
            }
            if (l === void 0) {
                const f = u ?? new Error("No error stored at end of fallback.");
                throw await (c == null ? void 0 : c.handleChainError(f)),
                f
            }
            let d;
            try {
                for await(const f of l) {
                    yield f;
                    try {
                        d = d === void 0 ? d : Nn(d, f)
                    } catch {
                        d = void 0
                    }
                }
            } catch (f) {
                throw await (c == null ? void 0 : c.handleChainError(f)),
                f
            }
            await (c == null ? void 0 : c.handleChainEnd(Gt(d, "output")))
        }
        async batch(e, t, r) {
            var u;
            if (r != null && r.returnExceptions)
                throw new Error("Not implemented.");
            const s = this._getOptionsList(t ?? {}, e.length)
              , i = await Promise.all(s.map(l => Mn(l)))
              , a = await Promise.all(i.map(async (l, d) => {
                const h = await (l == null ? void 0 : l.handleChainStart(this.toJSON(), Gt(e[d], "input"), s[d].runId, void 0, void 0, void 0, s[d].runName));
                return delete s[d].runId,
                h
            }
            ));
            let c;
            for (const l of this.runnables()) {
                (u = s[0].signal) == null || u.throwIfAborted();
                try {
                    const d = await l.batch(e, a.map( (h, f) => dr(s[f], {
                        callbacks: h == null ? void 0 : h.getChild()
                    })), r);
                    return await Promise.all(a.map( (h, f) => h == null ? void 0 : h.handleChainEnd(Gt(d[f], "output")))),
                    d
                } catch (d) {
                    c === void 0 && (c = d)
                }
            }
            throw c ? (await Promise.all(a.map(l => l == null ? void 0 : l.handleChainError(c))),
            c) : new Error("No error stored at end of fallbacks.")
        }
    }
    function oo(n) {
        if (typeof n == "function")
            return new Sh({
                func: n
            });
        if (jt.isRunnable(n))
            return n;
        if (!Array.isArray(n) && typeof n == "object") {
            const e = {};
            for (const [t,r] of Object.entries(n))
                e[t] = oo(r);
            return new fu({
                steps: e
            })
        } else
            throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`)
    }
    class hI extends jt {
        static lc_name() {
            return "RunnableAssign"
        }
        constructor(e) {
            e instanceof fu && (e = {
                mapper: e
            }),
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "mapper", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.mapper = e.mapper
        }
        async invoke(e, t) {
            const r = await this.mapper.invoke(e, t);
            return {
                ...e,
                ...r
            }
        }
        async*_transform(e, t, r) {
            const s = this.mapper.getStepsKeys()
              , [i,a] = JA(e)
              , c = this.mapper.transform(a, dr(r, {
                callbacks: t == null ? void 0 : t.getChild()
            }))
              , u = c.next();
            for await(const l of i) {
                if (typeof l != "object" || Array.isArray(l))
                    throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof l}`);
                const d = Object.fromEntries(Object.entries(l).filter( ([h]) => !s.includes(h)));
                Object.keys(d).length > 0 && (yield d)
            }
            yield(await u).value;
            for await(const l of c)
                yield l
        }
        transform(e, t) {
            return this._transformStreamWithConfig(e, this._transform.bind(this), t)
        }
        async stream(e, t) {
            async function *r() {
                yield e
            }
            const s = it(t)
              , i = new du({
                generator: this.transform(r(), s),
                config: s
            });
            return await i.setup,
            Qr.fromAsyncGenerator(i)
        }
    }
    class a5 extends jt {
        static lc_name() {
            return "RunnablePick"
        }
        constructor(e) {
            (typeof e == "string" || Array.isArray(e)) && (e = {
                keys: e
            }),
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "keys", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.keys = e.keys
        }
        async _pick(e) {
            if (typeof this.keys == "string")
                return e[this.keys];
            {
                const t = this.keys.map(r => [r, e[r]]).filter(r => r[1] !== void 0);
                return t.length === 0 ? void 0 : Object.fromEntries(t)
            }
        }
        async invoke(e, t) {
            return this._callWithConfig(this._pick.bind(this), e, t)
        }
        async*_transform(e) {
            for await(const t of e) {
                const r = await this._pick(t);
                r !== void 0 && (yield r)
            }
        }
        transform(e, t) {
            return this._transformStreamWithConfig(e, this._transform.bind(this), t)
        }
        async stream(e, t) {
            async function *r() {
                yield e
            }
            const s = it(t)
              , i = new du({
                generator: this.transform(r(), s),
                config: s
            });
            return await i.setup,
            Qr.fromAsyncGenerator(i)
        }
    }
    class fI extends ao {
        constructor(e) {
            const t = Fn.from([Sh.from(async r => {
                let s;
                if (yT(r))
                    try {
                        s = await this.schema.parseAsync(r.args)
                    } catch {
                        throw new XU("Received tool input did not match expected schema",JSON.stringify(r.args))
                    }
                else
                    s = r;
                return s
            }
            ).withConfig({
                runName: `${e.name}:parse_input`
            }), e.bound]).withConfig({
                runName: e.name
            });
            super({
                bound: t,
                config: e.config ?? {}
            }),
            Object.defineProperty(this, "name", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "description", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "schema", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.name = e.name,
            this.description = e.description,
            this.schema = e.schema
        }
        static lc_name() {
            return "RunnableToolLike"
        }
    }
    function o5(n, e) {
        var s;
        const t = e.name ?? n.getName()
          , r = e.description ?? ((s = e.schema) == null ? void 0 : s.description);
        return e.schema.constructor === fe.ZodString ? new fI({
            name: t,
            description: r,
            schema: fe.object({
                input: fe.string()
            }).transform(i => i.input),
            bound: n
        }) : new fI({
            name: t,
            description: r,
            schema: e.schema,
            bound: n
        })
    }
    const pI = kn("agent")
      , c5 = /<think>[\s\S]*?<\/think>/;
    class Q0 {
        constructor(e, t, r) {
            this.actions = {},
            this.modelOutputSchema = e,
            this.chatLLM = t.chatLLM,
            this.prompt = t.prompt,
            this.context = t.context,
            this.chatModelLibrary = this.chatLLM.constructor.name,
            this.modelName = this.getModelName(),
            this.withStructuredOutput = this.setWithStructuredOutput(),
            this.id = (r == null ? void 0 : r.id) || "agent",
            this.toolCallingMethod = this.setToolCallingMethod(r == null ? void 0 : r.toolCallingMethod),
            this.callOptions = r == null ? void 0 : r.callOptions,
            this.modelOutputToolName = `${this.id}_output`
        }
        getModelName() {
            return "modelName"in this.chatLLM ? this.chatLLM.modelName : "model_name"in this.chatLLM ? this.chatLLM.model_name : "model"in this.chatLLM ? this.chatLLM.model : "Unknown"
        }
        setToolCallingMethod(e) {
            if (e === "auto")
                switch (this.chatModelLibrary) {
                case "ChatGoogleGenerativeAI":
                    return null;
                case "ChatOpenAI":
                case "AzureChatOpenAI":
                    return "function_calling";
                default:
                    return null
                }
            return e || null
        }
        setWithStructuredOutput() {
            return !(this.modelName === "deepseek-reasoner" || this.modelName === "deepseek-r1")
        }
        removeThinkTags(e) {
            return e.replace(c5, "")
        }
        async invoke(e) {
            if (this.withStructuredOutput) {
                const s = await this.chatLLM.withStructuredOutput(this.modelOutputSchema, {
                    includeRaw: !0,
                    name: this.modelOutputToolName
                }).invoke(e, {
                    ...this.callOptions
                });
                if (s.parsed)
                    return s.parsed;
                throw new Error("Could not parse response")
            }
            const t = await this.chatLLM.invoke(e, {
                ...this.callOptions
            });
            if (typeof t.content == "string") {
                t.content = this.removeThinkTags(t.content);
                try {
                    const r = this.extractJsonFromModelOutput(t.content)
                      , s = this.validateModelOutput(r);
                    if (s)
                        return s
                } catch {
                    throw pI.error("Could not parse response", t),
                    new Error("Could not parse response")
                }
            }
            throw new Error("Could not parse response")
        }
        validateModelOutput(e) {
            if (!(!this.modelOutputSchema || !e))
                return this.modelOutputSchema.parse(e)
        }
        addModelOutputToMemory(e) {
            const t = this.context.messageManager
              , r = String(t.nextToolId())
              , s = [{
                name: this.modelOutputToolName,
                args: e,
                id: r,
                type: "tool_call"
            }]
              , i = new pn({
                content: "tool call",
                tool_calls: s
            });
            t.addMessageWithTokens(i);
            const a = new $y({
                content: "tool call response placeholder",
                tool_call_id: r
            });
            t.addMessageWithTokens(a)
        }
        extractJsonFromModelOutput(e) {
            try {
                let t = e;
                return e.includes("```") && (t = t.split("```")[1],
                t.includes(`
`) && (t = t.split(`
`, 2)[1])),
                JSON.parse(t)
            } catch (t) {
                throw pI.warning(`Failed to parse model output: ${e} ${t}`),
                new Error("Could not parse response.")
            }
        }
    }
    const mI = {
        name: "done",
        description: "Complete task",
        schema: fe.object({
            text: fe.string()
        })
    }
      , u5 = {
        name: "search_google",
        description: "Search Google in the current tab",
        schema: fe.object({
            query: fe.string()
        })
    }
      , l5 = {
        name: "go_to_url",
        description: "Navigate to URL in the current tab",
        schema: fe.object({
            url: fe.string()
        })
    }
      , d5 = {
        name: "go_back",
        description: "Go back to the previous page",
        schema: fe.object({})
    }
      , h5 = {
        name: "click_element",
        description: "Click element",
        schema: fe.object({
            desc: fe.string().optional(),
            index: fe.number(),
            xpath: fe.string().optional().nullable()
        })
    }
      , f5 = {
        name: "input_text",
        description: "Input text into an interactive input element",
        schema: fe.object({
            desc: fe.string().optional(),
            index: fe.number(),
            text: fe.string(),
            xpath: fe.string().optional().nullable()
        })
    }
      , p5 = {
        name: "switch_tab",
        description: "Switch to tab by id",
        schema: fe.object({
            tab_id: fe.number()
        })
    }
      , m5 = {
        name: "open_tab",
        description: "Open URL in new tab",
        schema: fe.object({
            url: fe.string()
        })
    }
      , g5 = {
        name: "extract_content",
        description: "Extract page content to retrieve specific information from the page, e.g. all company names, a specifc description, all information about, links with companies in structured format or simply links",
        schema: fe.object({
            goal: fe.string()
        })
    }
      , gI = {
        name: "cache_content",
        description: "Cache the extracted content of the page",
        schema: fe.object({
            content: fe.string()
        })
    }
      , y5 = {
        name: "scroll_down",
        description: "Scroll down the page by pixel amount - if no amount is specified, scroll down one page",
        schema: fe.object({
            desc: fe.string().optional(),
            amount: fe.number().optional().nullable()
        })
    }
      , w5 = {
        name: "scroll_up",
        description: "Scroll up the page by pixel amount - if no amount is specified, scroll up one page",
        schema: fe.object({
            desc: fe.string().optional(),
            amount: fe.number().optional().nullable()
        })
    }
      , b5 = {
        name: "send_keys",
        description: "Send strings of special keys like Backspace, Insert, PageDown, Delete, Enter. Shortcuts such as `Control+o`, `Control+Shift+T` are supported as well. This gets used in keyboard press. Be aware of different operating systems and their shortcuts",
        schema: fe.object({
            desc: fe.string().optional(),
            keys: fe.string()
        })
    }
      , v5 = {
        name: "scroll_to_text",
        description: "If you dont find something which you want to interact with, scroll to it",
        schema: fe.object({
            desc: fe.string().optional(),
            text: fe.string()
        })
    };
    fe.object({
        index: fe.number()
    }),
    fe.object({
        index: fe.number(),
        text: fe.string()
    });
    class _5 extends jt {
        get lc_attributes() {
            return {
                partialVariables: void 0
            }
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "prompts", this._getPromptType()]
            }),
            Object.defineProperty(this, "inputVariables", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "outputParser", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "partialVariables", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            });
            const {inputVariables: t} = e;
            if (t.includes("stop"))
                throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
            Object.assign(this, e)
        }
        async mergePartialAndUserVariables(e) {
            const t = this.partialVariables ?? {}
              , r = {};
            for (const [i,a] of Object.entries(t))
                typeof a == "string" ? r[i] = a : r[i] = await a();
            return {
                ...r,
                ...e
            }
        }
        async invoke(e, t) {
            const r = {
                ...this.metadata,
                ...t == null ? void 0 : t.metadata
            }
              , s = [...this.tags ?? [], ...(t == null ? void 0 : t.tags) ?? []];
            return this._callWithConfig(i => this.formatPromptValue(i), e, {
                ...t,
                tags: s,
                metadata: r,
                runType: "prompt"
            })
        }
        serialize() {
            throw new Error("Use .toJSON() instead")
        }
        static async deserialize(e) {
            switch (e._type) {
            case "prompt":
                {
                    const {PromptTemplate: t} = await Promise.resolve().then( () => CI);
                    return t.deserialize(e)
                }
            case void 0:
                {
                    const {PromptTemplate: t} = await Promise.resolve().then( () => CI);
                    return t.deserialize({
                        ...e,
                        _type: "prompt"
                    })
                }
            case "few_shot":
                {
                    const {FewShotPromptTemplate: t} = await Promise.resolve().then( () => K5);
                    return t.deserialize(e)
                }
            default:
                throw new Error(`Invalid prompt type in config: ${e._type}`)
            }
        }
    }
    class yI extends so {
    }
    class wI extends yI {
        static lc_name() {
            return "StringPromptValue"
        }
        constructor(e) {
            super({
                value: e
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "prompt_values"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "value", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.value = e
        }
        toString() {
            return this.value
        }
        toChatMessages() {
            return [new Ct(this.value)]
        }
    }
    class S5 extends yI {
        static lc_name() {
            return "ChatPromptValue"
        }
        constructor(e) {
            Array.isArray(e) && (e = {
                messages: e
            }),
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "prompt_values"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "messages", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.messages = e.messages
        }
        toString() {
            return wT(this.messages)
        }
        toChatMessages() {
            return this.messages
        }
    }
    class bI extends _5 {
        async formatPromptValue(e) {
            const t = await this.format(e);
            return new wI(t)
        }
    }
    /*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
    var E5 = Object.prototype.toString
      , pu = Array.isArray || function(e) {
        return E5.call(e) === "[object Array]"
    }
    ;
    function eS(n) {
        return typeof n == "function"
    }
    function x5(n) {
        return pu(n) ? "array" : typeof n
    }
    function tS(n) {
        return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
    }
    function vI(n, e) {
        return n != null && typeof n == "object" && e in n
    }
    function C5(n, e) {
        return n != null && typeof n != "object" && n.hasOwnProperty && n.hasOwnProperty(e)
    }
    var k5 = RegExp.prototype.test;
    function P5(n, e) {
        return k5.call(n, e)
    }
    var T5 = /\S/;
    function A5(n) {
        return !P5(T5, n)
    }
    var I5 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
    };
    function O5(n) {
        return String(n).replace(/[&<>"'`=\/]/g, function(t) {
            return I5[t]
        })
    }
    var R5 = /\s*/
      , M5 = /\s+/
      , _I = /\s*=/
      , N5 = /\s*\}/
      , $5 = /#|\^|\/|>|\{|&|=|!/;
    function L5(n, e) {
        if (!n)
            return [];
        var t = !1
          , r = []
          , s = []
          , i = []
          , a = !1
          , c = !1
          , u = ""
          , l = 0;
        function d() {
            if (a && !c)
                for (; i.length; )
                    delete s[i.pop()];
            else
                i = [];
            a = !1,
            c = !1
        }
        var h, f, p;
        function g(x) {
            if (typeof x == "string" && (x = x.split(M5, 2)),
            !pu(x) || x.length !== 2)
                throw new Error("Invalid tags: " + x);
            h = new RegExp(tS(x[0]) + "\\s*"),
            f = new RegExp("\\s*" + tS(x[1])),
            p = new RegExp("\\s*" + tS("}" + x[1]))
        }
        g(e || $r.tags);
        for (var y = new Eh(n), m, w, E, v, _, A; !y.eos(); ) {
            if (m = y.pos,
            E = y.scanUntil(h),
            E)
                for (var C = 0, k = E.length; C < k; ++C)
                    v = E.charAt(C),
                    A5(v) ? (i.push(s.length),
                    u += v) : (c = !0,
                    t = !0,
                    u += " "),
                    s.push(["text", v, m, m + 1]),
                    m += 1,
                    v === `
` && (d(),
                    u = "",
                    l = 0,
                    t = !1);
            if (!y.scan(h))
                break;
            if (a = !0,
            w = y.scan($5) || "name",
            y.scan(R5),
            w === "=" ? (E = y.scanUntil(_I),
            y.scan(_I),
            y.scanUntil(f)) : w === "{" ? (E = y.scanUntil(p),
            y.scan(N5),
            y.scanUntil(f),
            w = "&") : E = y.scanUntil(f),
            !y.scan(f))
                throw new Error("Unclosed tag at " + y.pos);
            if (w == ">" ? _ = [w, E, m, y.pos, u, l, t] : _ = [w, E, m, y.pos],
            l++,
            s.push(_),
            w === "#" || w === "^")
                r.push(_);
            else if (w === "/") {
                if (A = r.pop(),
                !A)
                    throw new Error('Unopened section "' + E + '" at ' + m);
                if (A[1] !== E)
                    throw new Error('Unclosed section "' + A[1] + '" at ' + m)
            } else
                w === "name" || w === "{" || w === "&" ? c = !0 : w === "=" && g(E)
        }
        if (d(),
        A = r.pop(),
        A)
            throw new Error('Unclosed section "' + A[1] + '" at ' + y.pos);
        return j5(F5(s))
    }
    function F5(n) {
        for (var e = [], t, r, s = 0, i = n.length; s < i; ++s)
            t = n[s],
            t && (t[0] === "text" && r && r[0] === "text" ? (r[1] += t[1],
            r[3] = t[3]) : (e.push(t),
            r = t));
        return e
    }
    function j5(n) {
        for (var e = [], t = e, r = [], s, i, a = 0, c = n.length; a < c; ++a)
            switch (s = n[a],
            s[0]) {
            case "#":
            case "^":
                t.push(s),
                r.push(s),
                t = s[4] = [];
                break;
            case "/":
                i = r.pop(),
                i[5] = s[2],
                t = r.length > 0 ? r[r.length - 1][4] : e;
                break;
            default:
                t.push(s)
            }
        return e
    }
    function Eh(n) {
        this.string = n,
        this.tail = n,
        this.pos = 0
    }
    Eh.prototype.eos = function() {
        return this.tail === ""
    }
    ,
    Eh.prototype.scan = function(e) {
        var t = this.tail.match(e);
        if (!t || t.index !== 0)
            return "";
        var r = t[0];
        return this.tail = this.tail.substring(r.length),
        this.pos += r.length,
        r
    }
    ,
    Eh.prototype.scanUntil = function(e) {
        var t = this.tail.search(e), r;
        switch (t) {
        case -1:
            r = this.tail,
            this.tail = "";
            break;
        case 0:
            r = "";
            break;
        default:
            r = this.tail.substring(0, t),
            this.tail = this.tail.substring(t)
        }
        return this.pos += r.length,
        r
    }
    ;
    function mu(n, e) {
        this.view = n,
        this.cache = {
            ".": this.view
        },
        this.parent = e
    }
    mu.prototype.push = function(e) {
        return new mu(e,this)
    }
    ,
    mu.prototype.lookup = function(e) {
        var t = this.cache, r;
        if (t.hasOwnProperty(e))
            r = t[e];
        else {
            for (var s = this, i, a, c, u = !1; s; ) {
                if (e.indexOf(".") > 0)
                    for (i = s.view,
                    a = e.split("."),
                    c = 0; i != null && c < a.length; )
                        c === a.length - 1 && (u = vI(i, a[c]) || C5(i, a[c])),
                        i = i[a[c++]];
                else
                    i = s.view[e],
                    u = vI(s.view, e);
                if (u) {
                    r = i;
                    break
                }
                s = s.parent
            }
            t[e] = r
        }
        return eS(r) && (r = r.call(this.view)),
        r
    }
    ;
    function Cr() {
        this.templateCache = {
            _cache: {},
            set: function(e, t) {
                this._cache[e] = t
            },
            get: function(e) {
                return this._cache[e]
            },
            clear: function() {
                this._cache = {}
            }
        }
    }
    Cr.prototype.clearCache = function() {
        typeof this.templateCache < "u" && this.templateCache.clear()
    }
    ,
    Cr.prototype.parse = function(e, t) {
        var r = this.templateCache
          , s = e + ":" + (t || $r.tags).join(":")
          , i = typeof r < "u"
          , a = i ? r.get(s) : void 0;
        return a == null && (a = L5(e, t),
        i && r.set(s, a)),
        a
    }
    ,
    Cr.prototype.render = function(e, t, r, s) {
        var i = this.getConfigTags(s)
          , a = this.parse(e, i)
          , c = t instanceof mu ? t : new mu(t,void 0);
        return this.renderTokens(a, c, r, e, s)
    }
    ,
    Cr.prototype.renderTokens = function(e, t, r, s, i) {
        for (var a = "", c, u, l, d = 0, h = e.length; d < h; ++d)
            l = void 0,
            c = e[d],
            u = c[0],
            u === "#" ? l = this.renderSection(c, t, r, s, i) : u === "^" ? l = this.renderInverted(c, t, r, s, i) : u === ">" ? l = this.renderPartial(c, t, r, i) : u === "&" ? l = this.unescapedValue(c, t) : u === "name" ? l = this.escapedValue(c, t, i) : u === "text" && (l = this.rawValue(c)),
            l !== void 0 && (a += l);
        return a
    }
    ,
    Cr.prototype.renderSection = function(e, t, r, s, i) {
        var a = this
          , c = ""
          , u = t.lookup(e[1]);
        function l(f) {
            return a.render(f, t, r, i)
        }
        if (u) {
            if (pu(u))
                for (var d = 0, h = u.length; d < h; ++d)
                    c += this.renderTokens(e[4], t.push(u[d]), r, s, i);
            else if (typeof u == "object" || typeof u == "string" || typeof u == "number")
                c += this.renderTokens(e[4], t.push(u), r, s, i);
            else if (eS(u)) {
                if (typeof s != "string")
                    throw new Error("Cannot use higher-order sections without the original template");
                u = u.call(t.view, s.slice(e[3], e[5]), l),
                u != null && (c += u)
            } else
                c += this.renderTokens(e[4], t, r, s, i);
            return c
        }
    }
    ,
    Cr.prototype.renderInverted = function(e, t, r, s, i) {
        var a = t.lookup(e[1]);
        if (!a || pu(a) && a.length === 0)
            return this.renderTokens(e[4], t, r, s, i)
    }
    ,
    Cr.prototype.indentPartial = function(e, t, r) {
        for (var s = t.replace(/[^ \t]/g, ""), i = e.split(`
`), a = 0; a < i.length; a++)
            i[a].length && (a > 0 || !r) && (i[a] = s + i[a]);
        return i.join(`
`)
    }
    ,
    Cr.prototype.renderPartial = function(e, t, r, s) {
        if (r) {
            var i = this.getConfigTags(s)
              , a = eS(r) ? r(e[1]) : r[e[1]];
            if (a != null) {
                var c = e[6]
                  , u = e[5]
                  , l = e[4]
                  , d = a;
                u == 0 && l && (d = this.indentPartial(a, l, c));
                var h = this.parse(d, i);
                return this.renderTokens(h, t, r, d, s)
            }
        }
    }
    ,
    Cr.prototype.unescapedValue = function(e, t) {
        var r = t.lookup(e[1]);
        if (r != null)
            return r
    }
    ,
    Cr.prototype.escapedValue = function(e, t, r) {
        var s = this.getConfigEscape(r) || $r.escape
          , i = t.lookup(e[1]);
        if (i != null)
            return typeof i == "number" && s === $r.escape ? String(i) : s(i)
    }
    ,
    Cr.prototype.rawValue = function(e) {
        return e[1]
    }
    ,
    Cr.prototype.getConfigTags = function(e) {
        return pu(e) ? e : e && typeof e == "object" ? e.tags : void 0
    }
    ,
    Cr.prototype.getConfigEscape = function(e) {
        if (e && typeof e == "object" && !pu(e))
            return e.escape
    }
    ;
    var $r = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        set templateCache(n) {
            xh.templateCache = n
        },
        get templateCache() {
            return xh.templateCache
        }
    }
      , xh = new Cr;
    $r.clearCache = function() {
        return xh.clearCache()
    }
    ,
    $r.parse = function(e, t) {
        return xh.parse(e, t)
    }
    ,
    $r.render = function(e, t, r, s) {
        if (typeof e != "string")
            throw new TypeError('Invalid template! Template should be a "string" but "' + x5(e) + '" was given as the first argument for mustache#render(template, view, partials)');
        return xh.render(e, t, r, s)
    }
    ,
    $r.escape = O5,
    $r.Scanner = Eh,
    $r.Context = mu,
    $r.Writer = Cr;
    function SI() {
        $r.escape = n => n
    }
    const EI = n => {
        const e = n.split("")
          , t = []
          , r = (i, a) => {
            for (let c = a; c < e.length; c += 1)
                if (i.includes(e[c]))
                    return c;
            return -1
        }
        ;
        let s = 0;
        for (; s < e.length; )
            if (e[s] === "{" && s + 1 < e.length && e[s + 1] === "{")
                t.push({
                    type: "literal",
                    text: "{"
                }),
                s += 2;
            else if (e[s] === "}" && s + 1 < e.length && e[s + 1] === "}")
                t.push({
                    type: "literal",
                    text: "}"
                }),
                s += 2;
            else if (e[s] === "{") {
                const i = r("}", s);
                if (i < 0)
                    throw new Error("Unclosed '{' in template.");
                t.push({
                    type: "variable",
                    name: e.slice(s + 1, i).join("")
                }),
                s = i + 1
            } else {
                if (e[s] === "}")
                    throw new Error("Single '}' in template.");
                {
                    const i = r("{}", s)
                      , a = (i < 0 ? e.slice(s) : e.slice(s, i)).join("");
                    t.push({
                        type: "literal",
                        text: a
                    }),
                    s = i < 0 ? e.length : i
                }
            }
        return t
    }
      , D5 = n => n.map(e => e[0] === "name" ? {
        type: "variable",
        name: e[1].includes(".") ? e[1].split(".")[0] : e[1]
    } : ["#", "&", "^", ">"].includes(e[0]) ? {
        type: "variable",
        name: e[1]
    } : {
        type: "literal",
        text: e[1]
    })
      , B5 = n => {
        SI();
        const e = $r.parse(n);
        return D5(e)
    }
      , rS = {
        "f-string": (n, e) => EI(n).reduce( (t, r) => {
            if (r.type === "variable") {
                if (r.name in e) {
                    const s = typeof e[r.name] == "string" ? e[r.name] : JSON.stringify(e[r.name]);
                    return t + s
                }
                throw new Error(`(f-string) Missing value for input ${r.name}`)
            }
            return t + r.text
        }
        , ""),
        mustache: (n, e) => (SI(),
        $r.render(n, e))
    }
      , q5 = {
        "f-string": EI,
        mustache: B5
    }
      , gu = (n, e, t) => {
        try {
            return rS[e](n, t)
        } catch (r) {
            throw S_(r, "INVALID_PROMPT_INPUT")
        }
    }
      , U5 = (n, e) => q5[e](n)
      , xI = (n, e, t) => {
        if (!(e in rS)) {
            const r = Object.keys(rS);
            throw new Error(`Invalid template format. Got \`${e}\`;
                         should be one of ${r}`)
        }
        try {
            const r = t.reduce( (s, i) => (s[i] = "foo",
            s), {});
            Array.isArray(n) ? n.forEach(s => {
                if (s.type === "text")
                    gu(s.text, e, r);
                else if (s.type === "image_url")
                    if (typeof s.image_url == "string")
                        gu(s.image_url, e, r);
                    else {
                        const i = s.image_url.url;
                        gu(i, e, r)
                    }
                else
                    throw new Error(`Invalid message template received. ${JSON.stringify(s, null, 2)}`)
            }
            ) : gu(n, e, r)
        } catch (r) {
            throw new Error(`Invalid prompt schema: ${r.message}`)
        }
    }
    ;
    class Ki extends bI {
        static lc_name() {
            return "PromptTemplate"
        }
        constructor(e) {
            if (super(e),
            Object.defineProperty(this, "template", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "templateFormat", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "f-string"
            }),
            Object.defineProperty(this, "validateTemplate", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "additionalContentFields", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            e.templateFormat === "mustache" && e.validateTemplate === void 0 && (this.validateTemplate = !1),
            Object.assign(this, e),
            this.validateTemplate) {
                if (this.templateFormat === "mustache")
                    throw new Error("Mustache templates cannot be validated.");
                let t = this.inputVariables;
                this.partialVariables && (t = t.concat(Object.keys(this.partialVariables))),
                xI(this.template, this.templateFormat, t)
            }
        }
        _getPromptType() {
            return "prompt"
        }
        async format(e) {
            const t = await this.mergePartialAndUserVariables(e);
            return gu(this.template, this.templateFormat, t)
        }
        static fromExamples(e, t, r, s=`

`, i="") {
            const a = [i, ...e, t].join(s);
            return new Ki({
                inputVariables: r,
                template: a
            })
        }
        static fromTemplate(e, t) {
            const {templateFormat: r="f-string", ...s} = t ?? {}
              , i = new Set;
            return U5(e, r).forEach(a => {
                a.type === "variable" && i.add(a.name)
            }
            ),
            new Ki({
                inputVariables: [...i],
                templateFormat: r,
                template: e,
                ...s
            })
        }
        async partial(e) {
            const t = this.inputVariables.filter(i => !(i in e))
              , r = {
                ...this.partialVariables ?? {},
                ...e
            }
              , s = {
                ...this,
                inputVariables: t,
                partialVariables: r
            };
            return new Ki(s)
        }
        serialize() {
            if (this.outputParser !== void 0)
                throw new Error("Cannot serialize a prompt template with an output parser");
            return {
                _type: this._getPromptType(),
                input_variables: this.inputVariables,
                template: this.template,
                template_format: this.templateFormat
            }
        }
        static async deserialize(e) {
            if (!e.template)
                throw new Error("Prompt template must have a template");
            return new Ki({
                inputVariables: e.input_variables,
                template: e.template,
                templateFormat: e.template_format
            })
        }
    }
    const CI = Object.freeze(Object.defineProperty({
        __proto__: null,
        PromptTemplate: Ki
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    class cw extends bI {
        constructor(e) {
            if (super(e),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "examples", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "exampleSelector", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "examplePrompt", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "suffix", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ""
            }),
            Object.defineProperty(this, "exampleSeparator", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: `

`
            }),
            Object.defineProperty(this, "prefix", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ""
            }),
            Object.defineProperty(this, "templateFormat", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "f-string"
            }),
            Object.defineProperty(this, "validateTemplate", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.assign(this, e),
            this.examples !== void 0 && this.exampleSelector !== void 0)
                throw new Error("Only one of 'examples' and 'example_selector' should be provided");
            if (this.examples === void 0 && this.exampleSelector === void 0)
                throw new Error("One of 'examples' and 'example_selector' should be provided");
            if (this.validateTemplate) {
                let t = this.inputVariables;
                this.partialVariables && (t = t.concat(Object.keys(this.partialVariables))),
                xI(this.prefix + this.suffix, this.templateFormat, t)
            }
        }
        _getPromptType() {
            return "few_shot"
        }
        static lc_name() {
            return "FewShotPromptTemplate"
        }
        async getExamples(e) {
            if (this.examples !== void 0)
                return this.examples;
            if (this.exampleSelector !== void 0)
                return this.exampleSelector.selectExamples(e);
            throw new Error("One of 'examples' and 'example_selector' should be provided")
        }
        async partial(e) {
            const t = this.inputVariables.filter(i => !(i in e))
              , r = {
                ...this.partialVariables ?? {},
                ...e
            }
              , s = {
                ...this,
                inputVariables: t,
                partialVariables: r
            };
            return new cw(s)
        }
        async format(e) {
            const t = await this.mergePartialAndUserVariables(e)
              , r = await this.getExamples(t)
              , s = await Promise.all(r.map(a => this.examplePrompt.format(a)))
              , i = [this.prefix, ...s, this.suffix].join(this.exampleSeparator);
            return gu(i, this.templateFormat, t)
        }
        serialize() {
            if (this.exampleSelector || !this.examples)
                throw new Error("Serializing an example selector is not currently supported");
            if (this.outputParser !== void 0)
                throw new Error("Serializing an output parser is not currently supported");
            return {
                _type: this._getPromptType(),
                input_variables: this.inputVariables,
                example_prompt: this.examplePrompt.serialize(),
                example_separator: this.exampleSeparator,
                suffix: this.suffix,
                prefix: this.prefix,
                template_format: this.templateFormat,
                examples: this.examples
            }
        }
        static async deserialize(e) {
            const {example_prompt: t} = e;
            if (!t)
                throw new Error("Missing example prompt");
            const r = await Ki.deserialize(t);
            let s;
            if (Array.isArray(e.examples))
                s = e.examples;
            else
                throw new Error("Invalid examples format. Only list or string are supported.");
            return new cw({
                inputVariables: e.input_variables,
                examplePrompt: r,
                examples: s,
                exampleSeparator: e.example_separator,
                prefix: e.prefix,
                suffix: e.suffix,
                templateFormat: e.template_format
            })
        }
    }
    const K5 = Object.freeze(Object.defineProperty({
        __proto__: null,
        FewShotPromptTemplate: cw
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , uw = kn("Action");
    class H5 extends Error {
        constructor(e) {
            super(e),
            this.name = "InvalidInputError"
        }
    }
    class Lr {
        constructor(e, t) {
            this.handler = e,
            this.schema = t
        }
        async call(e) {
            const t = this.schema.schema;
            if (t instanceof fe.ZodObject && Object.keys(t.shape || {}).length === 0)
                return await this.handler({});
            const s = this.schema.schema.safeParse(e);
            if (!s.success) {
                const i = s.error.message;
                throw new H5(i)
            }
            return await this.handler(s.data)
        }
        name() {
            return this.schema.name
        }
        prompt() {
            const e = this.schema.schema.shape || {}
              , t = Object.entries(e).map( ([s,i]) => {
                const a = i;
                return `'${s}': {'type': '${a.description}', ${a.isOptional() ? "'optional': true" : "'required': true"}}`
            }
            )
              , r = t.length > 0 ? `{${this.name()}: {${t.join(", ")}}}` : `{${this.name()}: {}}`;
            return `${this.schema.description}:
${r}`
        }
    }
    function W5(n) {
        let e = fe.object({});
        for (const t of n) {
            const r = t.schema.schema.nullable();
            e = e.extend({
                [t.name()]: r
            })
        }
        return e.partial().nullable()
    }
    class z5 {
        constructor(e, t) {
            this.context = e,
            this.extractorLLM = t
        }
        buildDefaultActions() {
            const e = []
              , t = new Lr(async m => (this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, mI.name),
            this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, m.text),
            new Tt({
                isDone: !0,
                extractedContent: m.text
            })),mI);
            e.push(t);
            const r = new Lr(async m => {
                const w = `Searching for "${m.query}" in Google`;
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w),
                await (await this.context.browserContext.getCurrentPage()).navigateTo(`https://www.google.com/search?q=${m.query}`);
                const v = `Searched for "${m.query}" in Google`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, v),
                new Tt({
                    extractedContent: v,
                    includeInMemory: !0
                })
            }
            ,u5);
            e.push(r);
            const s = new Lr(async m => {
                const w = `Navigating to ${m.url}`;
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w),
                await this.context.browserContext.navigateTo(m.url);
                const E = `Navigated to ${m.url}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, E),
                new Tt({
                    extractedContent: E,
                    includeInMemory: !0
                })
            }
            ,l5);
            e.push(s);
            const i = new Lr(async (m={}) => {
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, "Navigating back"),
                await (await this.context.browserContext.getCurrentPage()).goBack();
                const v = "Navigated back";
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, v),
                new Tt({
                    extractedContent: v,
                    includeInMemory: !0
                })
            }
            ,d5);
            e.push(i);
            const a = new Lr(async m => {
                const w = m.desc || `Click element with index ${m.index}`;
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w);
                const E = await this.context.browserContext.getCurrentPage()
                  , v = await E.getState()
                  , _ = v == null ? void 0 : v.selectorMap.get(m.index);
                if (!_)
                    throw new Error(`Element with index ${m.index} does not exist - retry or use alternative actions`);
                if (await E.isFileUploader(_)) {
                    const A = `Index ${m.index} - has an element which opens file upload dialog. To upload files please use a specific function to upload files`;
                    return uw.info(A),
                    new Tt({
                        extractedContent: A,
                        includeInMemory: !0
                    })
                }
                try {
                    const A = await this.context.browserContext.getAllTabIds();
                    await E.clickElementNode(this.context.options.useVision, _);
                    let C = `Clicked button with index ${m.index}: ${_.getAllTextTillNextClickableElement(2)}`;
                    uw.info(C);
                    const k = await this.context.browserContext.getAllTabIds();
                    if (k.size > A.size) {
                        const x = "New tab opened - switching to it";
                        C += ` - ${x}`,
                        uw.info(x);
                        const N = Array.from(k).find(R => !A.has(R));
                        N && await this.context.browserContext.switchTab(N)
                    }
                    return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, C),
                    new Tt({
                        extractedContent: C,
                        includeInMemory: !0
                    })
                } catch (A) {
                    const C = `Element no longer available with index ${m.index} - most likely the page changed`;
                    return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_FAIL, C),
                    new Tt({
                        error: A instanceof Error ? A.message : String(A)
                    })
                }
            }
            ,h5);
            e.push(a);
            const c = new Lr(async m => {
                const w = m.desc || `Input text into index ${m.index}`;
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w);
                const E = await this.context.browserContext.getCurrentPage()
                  , v = await E.getState()
                  , _ = v == null ? void 0 : v.selectorMap.get(m.index);
                if (!_)
                    throw new Error(`Element with index ${m.index} does not exist - retry or use alternative actions`);
                await E.inputTextElementNode(this.context.options.useVision, _, m.text);
                const A = `Input ${m.text} into index ${m.index}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, A),
                new Tt({
                    extractedContent: A,
                    includeInMemory: !0
                })
            }
            ,f5);
            e.push(c);
            const u = new Lr(async m => {
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, `Switching to tab ${m.tab_id}`),
                await this.context.browserContext.switchTab(m.tab_id);
                const w = `Switched to tab ${m.tab_id}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, w),
                new Tt({
                    extractedContent: w,
                    includeInMemory: !0
                })
            }
            ,p5);
            e.push(u);
            const l = new Lr(async m => {
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, `Opening ${m.url} in new tab`),
                await this.context.browserContext.openTab(m.url);
                const w = `Opened ${m.url} in new tab`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, w),
                new Tt({
                    extractedContent: w,
                    includeInMemory: !0
                })
            }
            ,m5);
            e.push(l);
            const d = new Lr(async m => {
                const w = m.goal
                  , v = await (await this.context.browserContext.getCurrentPage()).getReadabilityContent()
                  , A = await Ki.fromTemplate("Your task is to extract the content of the page. You will be given a page and a goal and you should extract all relevant information around this goal from the page. If the goal is vague, summarize the page. Respond in json format. Extraction goal: {goal}, Page: {page}").invoke({
                    goal: w,
                    page: v.content
                });
                try {
                    const k = `  Extracted from page
: ${(await this.extractorLLM.invoke(A)).content}
`;
                    return new Tt({
                        extractedContent: k,
                        includeInMemory: !0
                    })
                } catch (C) {
                    uw.error(`Error extracting content: ${Cinstanceof Error ? C.message : String(C)}`);
                    const k = "Failed to extract content from page, you need to extract content from the current state of the page and store it in the memory. Then scroll down if you still need more information.";
                    return new Tt({
                        extractedContent: k,
                        includeInMemory: !0
                    })
                }
            }
            ,g5);
            e.push(d);
            const h = new Lr(async m => {
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, gI.name);
                const w = `Cached findings: ${m.content}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, w),
                new Tt({
                    extractedContent: w,
                    includeInMemory: !0
                })
            }
            ,gI);
            e.push(h);
            const f = new Lr(async m => {
                const w = m.desc || "Scroll down the page";
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w),
                await (await this.context.browserContext.getCurrentPage()).scrollDown(m.amount);
                const _ = `Scrolled down the page by ${m.amount !== void 0 ? `${m.amount} pixels` : "one page"}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, _),
                new Tt({
                    extractedContent: _,
                    includeInMemory: !0
                })
            }
            ,y5);
            e.push(f);
            const p = new Lr(async m => {
                const w = m.desc || "Scroll up the page";
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w),
                await (await this.context.browserContext.getCurrentPage()).scrollUp(m.amount);
                const _ = `Scrolled up the page by ${m.amount !== void 0 ? `${m.amount} pixels` : "one page"}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, _),
                new Tt({
                    extractedContent: _,
                    includeInMemory: !0
                })
            }
            ,w5);
            e.push(p);
            const g = new Lr(async m => {
                const w = m.desc || `Send keys: ${m.keys}`;
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w),
                await (await this.context.browserContext.getCurrentPage()).sendKeys(m.keys);
                const v = `Sent keys: ${m.keys}`;
                return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, v),
                new Tt({
                    extractedContent: v,
                    includeInMemory: !0
                })
            }
            ,b5);
            e.push(g);
            const y = new Lr(async m => {
                const w = m.desc || `Scroll to text: ${m.text}`;
                this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_START, w);
                const E = await this.context.browserContext.getCurrentPage();
                try {
                    const _ = await E.scrollToText(m.text) ? `Scrolled to text: ${m.text}` : `Text '${m.text}' not found or not visible on page`;
                    return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_OK, _),
                    new Tt({
                        extractedContent: _,
                        includeInMemory: !0
                    })
                } catch (v) {
                    const _ = `Failed to scroll to text: ${vinstanceof Error ? v.message : String(v)}`;
                    return this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_FAIL, _),
                    new Tt({
                        error: _,
                        includeInMemory: !0
                    })
                }
            }
            ,v5);
            return e.push(y),
            e
        }
    }
    function nS(n) {
        var s;
        if (!(n instanceof Error))
            return !1;
        const e = n.message || "";
        let t = n.name || "";
        const r = (s = n.constructor) == null ? void 0 : s.name;
        return r && r !== "Error" && (t = r),
        t === "AuthenticationError" ? !0 : e.toLowerCase().includes("authentication") || e.includes("401") || e.toLowerCase().includes("api key")
    }
    class yu extends Error {
        constructor(e, t) {
            super(e),
            this.cause = t,
            this.name = "ChatModelAuthError",
            Error.captureStackTrace && Error.captureStackTrace(this, yu)
        }
        toString() {
            return `${this.name}: ${this.message}${this.cause ? ` (Caused by: ${this.cause})` : ""}`
        }
    }
    const V5 = {
        properties: {
            current_state: {
                description: "Current state of the agent",
                properties: {
                    page_summary: {
                        title: "Page Summary",
                        type: "string"
                    },
                    evaluation_previous_goal: {
                        title: "Evaluation Previous Goal",
                        type: "string"
                    },
                    memory: {
                        title: "Memory",
                        type: "string"
                    },
                    next_goal: {
                        title: "Next Goal",
                        type: "string"
                    }
                },
                required: ["page_summary", "evaluation_previous_goal", "memory", "next_goal"],
                title: "AgentBrain",
                type: "object"
            },
            action: {
                items: {
                    properties: {
                        done: {
                            properties: {
                                text: {
                                    title: "Text",
                                    type: "string"
                                }
                            },
                            required: ["text"],
                            title: "DoneAction",
                            type: "object",
                            nullable: !0
                        },
                        search_google: {
                            properties: {
                                query: {
                                    title: "Query",
                                    type: "string"
                                }
                            },
                            required: ["query"],
                            title: "SearchGoogleAction",
                            type: "object",
                            nullable: !0
                        },
                        go_to_url: {
                            properties: {
                                url: {
                                    title: "Url",
                                    type: "string"
                                }
                            },
                            required: ["url"],
                            title: "GoToUrlAction",
                            type: "object",
                            nullable: !0
                        },
                        go_back: {
                            additionalProperties: !0,
                            description: `Accepts absolutely anything in the incoming data
and discards it, so the final parsed model is empty.`,
                            properties: {},
                            title: "NoParamsAction",
                            type: "object",
                            nullable: !0
                        },
                        click_element: {
                            properties: {
                                desc: {
                                    title: "Intent",
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                index: {
                                    title: "Index",
                                    type: "integer"
                                },
                                xpath: {
                                    title: "XPath",
                                    type: "string",
                                    nullable: !0
                                }
                            },
                            required: ["desc", "index"],
                            title: "ClickElementAction",
                            type: "object",
                            nullable: !0
                        },
                        input_text: {
                            properties: {
                                desc: {
                                    title: "Intent",
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                index: {
                                    title: "Index",
                                    type: "integer"
                                },
                                text: {
                                    title: "Text",
                                    type: "string"
                                },
                                xpath: {
                                    title: "XPath",
                                    type: "string",
                                    nullable: !0
                                }
                            },
                            required: ["desc", "index", "text"],
                            title: "InputTextAction",
                            type: "object",
                            nullable: !0
                        },
                        switch_tab: {
                            properties: {
                                tab_id: {
                                    title: "Page Id",
                                    type: "integer"
                                }
                            },
                            required: ["tab_id"],
                            title: "SwitchTabAction",
                            type: "object",
                            nullable: !0
                        },
                        open_tab: {
                            properties: {
                                url: {
                                    title: "Url",
                                    type: "string"
                                }
                            },
                            required: ["url"],
                            title: "OpenTabAction",
                            type: "object",
                            nullable: !0
                        },
                        cache_content: {
                            properties: {
                                content: {
                                    title: "Content",
                                    type: "string"
                                }
                            },
                            required: ["content"],
                            title: "cache_content_parameters",
                            type: "object",
                            nullable: !0
                        },
                        scroll_down: {
                            properties: {
                                desc: {
                                    title: "Intent",
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                amount: {
                                    title: "Amount",
                                    type: "integer",
                                    nullable: !0
                                }
                            },
                            required: ["desc"],
                            title: "ScrollAction",
                            type: "object",
                            nullable: !0
                        },
                        scroll_up: {
                            properties: {
                                desc: {
                                    title: "Intent",
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                amount: {
                                    title: "Amount",
                                    type: "integer",
                                    nullable: !0
                                }
                            },
                            required: ["desc"],
                            title: "ScrollAction",
                            type: "object",
                            nullable: !0
                        },
                        send_keys: {
                            properties: {
                                desc: {
                                    title: "Intent",
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                keys: {
                                    title: "Keys",
                                    type: "string"
                                }
                            },
                            required: ["desc", "keys"],
                            title: "SendKeysAction",
                            type: "object",
                            nullable: !0
                        },
                        scroll_to_text: {
                            properties: {
                                desc: {
                                    title: "Intent",
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                text: {
                                    title: "Text",
                                    type: "string"
                                }
                            },
                            required: ["desc", "text"],
                            title: "scroll_to_text_parameters",
                            type: "object",
                            nullable: !0
                        },
                        get_dropdown_options: {
                            properties: {
                                index: {
                                    title: "Index",
                                    type: "integer"
                                }
                            },
                            required: ["index"],
                            title: "get_dropdown_options_parameters",
                            type: "object",
                            nullable: !0
                        },
                        select_dropdown_option: {
                            properties: {
                                index: {
                                    title: "Index",
                                    type: "integer"
                                },
                                text: {
                                    title: "Text",
                                    type: "string"
                                }
                            },
                            required: ["index", "text"],
                            title: "select_dropdown_option_parameters",
                            type: "object",
                            nullable: !0
                        }
                    },
                    title: "ActionModel",
                    type: "object"
                },
                title: "Action",
                type: "array"
            }
        },
        required: ["current_state", "action"],
        title: "AgentOutput",
        type: "object"
    }
      , G5 = {
        type: "object",
        properties: {
            current_state: {
                type: "object",
                description: "Current state of the agent",
                properties: {
                    page_summary: {
                        type: "string"
                    },
                    evaluation_previous_goal: {
                        type: "string"
                    },
                    memory: {
                        type: "string"
                    },
                    next_goal: {
                        type: "string"
                    }
                },
                required: ["page_summary", "evaluation_previous_goal", "memory", "next_goal"]
            },
            action: {
                type: "array",
                items: {
                    type: "object",
                    properties: {
                        done: {
                            type: "object",
                            properties: {
                                text: {
                                    type: "string"
                                }
                            },
                            required: ["text"],
                            nullable: !0
                        },
                        search_google: {
                            type: "object",
                            properties: {
                                query: {
                                    type: "string"
                                }
                            },
                            required: ["query"],
                            nullable: !0
                        },
                        go_to_url: {
                            type: "object",
                            properties: {
                                url: {
                                    type: "string"
                                }
                            },
                            required: ["url"],
                            nullable: !0
                        },
                        go_back: {
                            type: "string",
                            nullable: !0,
                            description: `Accepts absolutely anything in the incoming data
and discards it, so the final parsed model is empty.`
                        },
                        click_element: {
                            type: "object",
                            properties: {
                                desc: {
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                index: {
                                    type: "integer"
                                },
                                xpath: {
                                    type: "string",
                                    nullable: !0
                                }
                            },
                            required: ["desc", "index"],
                            nullable: !0
                        },
                        input_text: {
                            type: "object",
                            properties: {
                                desc: {
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                index: {
                                    type: "integer"
                                },
                                text: {
                                    type: "string"
                                },
                                xpath: {
                                    type: "string",
                                    nullable: !0
                                }
                            },
                            required: ["desc", "index", "text"],
                            nullable: !0
                        },
                        switch_tab: {
                            type: "object",
                            properties: {
                                tab_id: {
                                    type: "integer"
                                }
                            },
                            required: ["tab_id"],
                            nullable: !0
                        },
                        open_tab: {
                            type: "object",
                            properties: {
                                url: {
                                    type: "string"
                                }
                            },
                            required: ["url"],
                            nullable: !0
                        },
                        cache_content: {
                            type: "object",
                            properties: {
                                content: {
                                    type: "string"
                                }
                            },
                            required: ["content"],
                            nullable: !0
                        },
                        scroll_down: {
                            type: "object",
                            properties: {
                                desc: {
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                amount: {
                                    type: "integer",
                                    nullable: !0
                                }
                            },
                            required: ["desc"],
                            nullable: !0
                        },
                        scroll_up: {
                            type: "object",
                            properties: {
                                desc: {
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                amount: {
                                    type: "integer",
                                    nullable: !0
                                }
                            },
                            required: ["desc"],
                            nullable: !0
                        },
                        send_keys: {
                            type: "object",
                            properties: {
                                desc: {
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                keys: {
                                    type: "string"
                                }
                            },
                            required: ["desc", "keys"],
                            nullable: !0
                        },
                        scroll_to_text: {
                            type: "object",
                            properties: {
                                desc: {
                                    type: "string",
                                    description: "Very short explanation of the intent or purpose for calling this action"
                                },
                                text: {
                                    type: "string"
                                }
                            },
                            required: ["desc", "text"],
                            nullable: !0
                        },
                        get_dropdown_options: {
                            type: "object",
                            properties: {
                                index: {
                                    type: "integer"
                                }
                            },
                            required: ["index"],
                            nullable: !0
                        },
                        select_dropdown_option: {
                            type: "object",
                            properties: {
                                index: {
                                    type: "integer"
                                },
                                text: {
                                    type: "string"
                                }
                            },
                            required: ["index", "text"],
                            nullable: !0
                        }
                    },
                    required: []
                }
            }
        },
        required: ["current_state", "action"]
    }
      , Hi = kn("NavigatorAgent");
    class J5 {
        constructor(e) {
            this.actions = {};
            for (const t of e)
                this.registerAction(t)
        }
        registerAction(e) {
            this.actions[e.name()] = e
        }
        unregisterAction(e) {
            delete this.actions[e]
        }
        getAction(e) {
            return this.actions[e]
        }
        setupModelOutputSchema() {
            const e = W5(Object.values(this.actions));
            return fe.object({
                current_state: FU,
                action: fe.array(e)
            })
        }
    }
    class Z5 extends Q0 {
        constructor(e, t, r) {
            super(e.setupModelOutputSchema(), t, {
                ...r,
                id: "navigator"
            }),
            this.actionRegistry = e,
            this.jsonSchema = this.modelName.startsWith("gemini") ? G5 : V5
        }
        async invoke(e) {
            if (this.withStructuredOutput) {
                const s = await this.chatLLM.withStructuredOutput(this.jsonSchema, {
                    includeRaw: !0
                }).invoke(e, {
                    ...this.callOptions
                });
                if (s.parsed)
                    return s.parsed;
                throw new Error("Could not parse response")
            }
            const t = await this.chatLLM.invoke(e, {
                ...this.callOptions
            });
            if (typeof t.content == "string") {
                t.content = this.removeThinkTags(t.content);
                try {
                    const r = this.extractJsonFromModelOutput(t.content)
                      , s = this.validateModelOutput(r);
                    if (s)
                        return s
                } catch {
                    throw Hi.error("Could not parse response", t),
                    new Error("Could not parse response")
                }
            }
            throw new Error("Could not parse response")
        }
        async execute() {
            const e = {
                id: this.id
            };
            let t = !1;
            try {
                this.context.emitEvent(Ie.NAVIGATOR, ke.STEP_START, "Navigating...");
                const r = this.context.messageManager;
                if (await this.addStateMessageToMemory(),
                this.context.paused || this.context.stopped)
                    return t = !0,
                    e;
                const s = r.getMessages()
                  , i = await this.invoke(s);
                if (this.context.paused || this.context.stopped)
                    return t = !0,
                    e;
                this.removeLastStateMessageFromMemory(),
                this.addModelOutputToMemory(i);
                const a = await this.doMultiAction(i);
                if (this.context.actionResults = a,
                this.context.paused || this.context.stopped)
                    return t = !0,
                    e;
                this.context.emitEvent(Ie.NAVIGATOR, ke.STEP_OK, "Navigation done");
                let c = !1;
                return a.length > 0 && a[a.length - 1].isDone && (c = !0),
                e.result = {
                    done: c
                },
                e
            } catch (r) {
                if (this.removeLastStateMessageFromMemory(),
                nS(r))
                    throw new yu("Navigator API Authentication failed. Please verify your API key",r);
                const s = r instanceof Error ? r.message : String(r)
                  , i = `Navigation failed: ${s}`;
                return Hi.error(i),
                this.context.emitEvent(Ie.NAVIGATOR, ke.STEP_FAIL, i),
                e.error = s,
                e
            } finally {
                t && (this.removeLastStateMessageFromMemory(),
                this.context.emitEvent(Ie.NAVIGATOR, ke.STEP_CANCEL, "Navigation cancelled"))
            }
        }
        async addStateMessageToMemory() {
            if (this.context.stateMessageAdded)
                return;
            const e = this.context.messageManager
              , t = this.context.options;
            if (this.context.actionResults.length > 0) {
                let s = 0;
                for (const i of this.context.actionResults) {
                    if (i.includeInMemory) {
                        if (i.extractedContent) {
                            const a = new Ct(`Action result: ${i.extractedContent}`);
                            e.addMessageWithTokens(a)
                        }
                        if (i.error) {
                            const a = new Ct(`Action error: ${i.error.toString().slice(-t.maxErrorLength)}`);
                            Hi.info("Adding action error to memory", a.content),
                            e.addMessageWithTokens(a)
                        }
                        this.context.actionResults[s] = new Tt
                    }
                    s++
                }
            }
            const r = await this.prompt.getUserMessage(this.context);
            e.addStateMessage(r),
            this.context.stateMessageAdded = !0
        }
        async removeLastStateMessageFromMemory() {
            if (!this.context.stateMessageAdded)
                return;
            this.context.messageManager.removeLastStateMessage(),
            this.context.stateMessageAdded = !1
        }
        async doMultiAction(e) {
            var i;
            const t = [];
            let r = 0;
            Hi.info("Actions", e.action);
            let s = [];
            if (Array.isArray(e.action))
                s = e.action.filter(a => a !== null),
                s.length === 0 && Hi.warning("No valid actions found", e.action);
            else if (typeof e.action == "string")
                try {
                    Hi.warning("Unexpected action format", e.action),
                    s = JSON.parse(e.action)
                } catch {
                    throw Hi.error("Invalid action format", e.action),
                    new Error("Invalid action output format")
                }
            else
                s = [e.action];
            for (const a of s) {
                const c = Object.keys(a)[0]
                  , u = a[c];
                try {
                    if (this.context.paused || this.context.stopped)
                        return t;
                    const l = await ((i = this.actionRegistry.getAction(c)) == null ? void 0 : i.call(u));
                    if (l === void 0)
                        throw new Error(`Action ${c} not exists or returned undefined`);
                    if (t.push(l),
                    this.context.paused || this.context.stopped)
                        return t;
                    await new Promise(d => setTimeout(d, 1e3))
                } catch (l) {
                    const d = l instanceof Error ? l.message : String(l);
                    if (Hi.error("doAction error", c, u, d),
                    this.context.emitEvent(Ie.NAVIGATOR, ke.ACT_FAIL, d),
                    r++,
                    r > 3)
                        throw new Error("Too many errors in actions");
                    t.push(new Tt({
                        error: d,
                        isDone: !1,
                        includeInMemory: !0
                    }))
                }
            }
            return t
        }
    }
    const X5 = fe.object({
        observation: fe.string(),
        challenges: fe.string(),
        done: fe.boolean(),
        next_steps: fe.string(),
        reasoning: fe.string(),
        web_task: fe.boolean()
    });
    class Y5 extends Q0 {
        constructor(e, t) {
            super(X5, e, {
                ...t,
                id: "planner"
            })
        }
        async execute() {
            try {
                this.context.emitEvent(Ie.PLANNER, ke.STEP_START, "Planning...");
                const e = this.context.messageManager.getMessages()
                  , t = [this.prompt.getSystemMessage(), ...e.slice(1)];
                if (!this.context.options.useVisionForPlanner && this.context.options.useVision) {
                    const s = t[t.length - 1];
                    let i = "";
                    if (Array.isArray(s.content))
                        for (const a of s.content)
                            a.type === "text" && (i += a.text);
                    else
                        i = s.content;
                    t[t.length - 1] = new Ct(i)
                }
                const r = await this.invoke(t);
                if (!r)
                    throw new Error("Failed to validate planner output");
                return this.context.emitEvent(Ie.PLANNER, ke.STEP_OK, r.next_steps),
                {
                    id: this.id,
                    result: r
                }
            } catch (e) {
                if (nS(e))
                    throw new yu("Planner API Authentication failed. Please verify your API key",e);
                const t = e instanceof Error ? e.message : String(e);
                return this.context.emitEvent(Ie.PLANNER, ke.STEP_FAIL, `Planning failed: ${t}`),
                {
                    id: this.id,
                    error: t
                }
            }
        }
    }
    const kI = kn("ValidatorAgent")
      , Q5 = fe.object({
        is_valid: fe.boolean(),
        reason: fe.string(),
        answer: fe.string()
    });
    class eK extends Q0 {
        constructor(e, t) {
            super(Q5, e, {
                ...t,
                id: "validator"
            }),
            this.plan = null
        }
        setPlan(e) {
            this.plan = e
        }
        async execute() {
            try {
                this.context.emitEvent(Ie.VALIDATOR, ke.STEP_START, "Validating...");
                let e = await this.prompt.getUserMessage(this.context);
                this.plan && (e = new Ct(`${e.content}

The current plan is: 
${this.plan}`));
                const r = [this.prompt.getSystemMessage(), e]
                  , s = await this.invoke(r);
                if (!s)
                    throw new Error("Failed to validate task result");
                if (kI.info("validator output", JSON.stringify(s, null, 2)),
                s.is_valid)
                    this.context.emitEvent(Ie.VALIDATOR, ke.STEP_OK, s.answer);
                else {
                    const i = `The answer is not yet correct. ${s.reason}.`;
                    this.context.emitEvent(Ie.VALIDATOR, ke.STEP_FAIL, i),
                    this.context.actionResults = [new Tt({
                        extractedContent: i,
                        includeInMemory: !0
                    })]
                }
                return {
                    id: this.id,
                    result: s
                }
            } catch (e) {
                if (nS(e))
                    throw new yu("Validator API Authentication failed. Please verify your API key",e);
                const t = e instanceof Error ? e.message : String(e);
                return kI.error(`Validation failed: ${t}`),
                this.context.emitEvent(Ie.VALIDATOR, ke.STEP_FAIL, `Validation failed: ${t}`),
                {
                    id: this.id,
                    error: `Validation failed: ${t}`
                }
            }
        }
    }
    class sS {
        async buildBrowserStateUserMessage(e) {
            const t = await e.browserContext.getState()
              , r = t.elementTree.clickableElementsToString(e.options.includeAttributes)
              , s = (t.pixelsAbove || 0) > 0
              , i = (t.pixelsBelow || 0) > 0;
            let a = "";
            r !== "" ? (s ? a = `... ${t.pixelsAbove} pixels above - scroll up to see more ...
${r}` : a = `[Start of page]
${r}`,
            i ? a = `${a}
... ${t.pixelsBelow} pixels below - scroll down to see more ...` : a = `${a}
[End of page]`) : a = "empty page";
            let c = "";
            e.stepInfo && (c = `Current step: ${e.stepInfo.stepNumber + 1}/${e.stepInfo.maxSteps}`);
            const u = new Date().toISOString().slice(0, 16).replace("T", " ");
            c += `Current date and time: ${u}`;
            let l = "";
            if (e.actionResults.length > 0)
                for (let h = 0; h < e.actionResults.length; h++) {
                    const f = e.actionResults[h];
                    if (f.extractedContent && (l += `
Action result ${h + 1}/${e.actionResults.length}: ${f.extractedContent}`),
                    f.error) {
                        const p = f.error.slice(-300);
                        l += `
Action error ${h + 1}/${e.actionResults.length}: ...${p}`
                    }
                }
            const d = `
    [Task history memory ends here]
    [Current state starts here]
    You will see the following only once - if you need to remember it and you dont know it yet, write it down in the memory:
    Current tab: {id: ${t.tabId}, url: ${t.url}, title: ${t.title}}
    Other available tabs:
    ${t.tabs.filter(h => h.id !== t.tabId).map(h => ` - {id: ${h.id}, url: ${h.url}, title: ${h.title}}`).join(`
`)}
    Interactive elements from current page:
    ${a}
    ${c}
    ${l}`;
            return t.screenshot && e.options.useVision ? new Ct({
                content: [{
                    type: "text",
                    text: d
                }, {
                    type: "image_url",
                    image_url: {
                        url: `data:image/jpeg;base64,${t.screenshot}`
                    }
                }]
            }) : new Ct(d)
        }
    }
    class tK extends sS {
        constructor(e=10) {
            super(),
            this.maxActionsPerStep = e,
            this.default_action_description = "A placeholder action description"
        }
        importantRules() {
            return `
1. RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:
   {
     "current_state": {
		"page_summary": "Quick detailed summary of new information from the current page which is not yet in the task history memory. Be specific with details which are important for the task. This is not on the meta level, but should be facts. If all the information is already in the task history memory, leave this empty.",
		"evaluation_previous_goal": "Success|Failed|Unknown - Analyze the current elements and the image to check if the previous goals/actions are successful like intended by the task. Ignore the action result. The website is the ground truth. Also mention if something unexpected happened like new suggestions in an input field. Shortly state why/why not",
       "memory": "Description of what has been done and what you need to remember. Be very specific. Count here ALWAYS how many times you have done something and how many remain. E.g. 0 out of 10 websites analyzed. Continue with abc and xyz",
       "next_goal": "What needs to be done with the next actions"
     },
     "action": [
       {
         "one_action_name": {
           // action-specific parameter
         }
       },
       // ... more actions in sequence
     ]
   }

2. ACTIONS: You can specify multiple actions in the list to be executed in sequence. But always specify only one action name per item.

   Common action sequences:
   - Form filling: [
       {"input_text": {"desc": "Fill title", "index": 1, "text": "example title"}},
       {"input_text": {"desc": "Fill comment", "index": 2, "text": "example comment"}},
       {"click_element": {"desc": "Click submit button", "index": 3}}
     ]
   - Navigation: [
       {"open_tab": {"url": "https://example.com"}},
       {"go_to_url": {"url": "https://example.com"}},
     ]


3. ELEMENT INTERACTION:
   - Only use indexes that exist in the provided element list
   - Each element has a unique index number (e.g., "[33]<button>")
   - Elements marked with "[]Non-interactive text" are non-interactive (for context only)

4. NAVIGATION & ERROR HANDLING:
   - If you need to search in Google, use the search_google action. Don't need to input the search query manually, just use the action.
   - If no suitable elements exist, use other functions to complete the task
   - If stuck, try alternative approaches - like going back to a previous page, new search, new tab etc.
   - Handle popups/cookies by accepting or closing them
   - Use scroll to find elements you are looking for
   - If you want to research something, open a new tab instead of using the current tab
   - If captcha pops up, and you cant solve it, either ask for human help or try to continue the task on a different page.

5. TASK COMPLETION:
   - Use the done action as the last action as soon as the ultimate task is complete
   - Dont use "done" before you are done with everything the user asked you. 
   - If you have to do something repeatedly for example the task says for "each", or "for all", or "x times", count always inside "memory" how many times you have done it and how many remain. Don't stop until you have completed like the task asked you. Only call done after the last step.
   - Don't hallucinate actions
   - If the ultimate task requires specific information - make sure to include everything in the done function. This is what the user will see. Do not just say you are done, but include the requested information of the task.
   - Include exact relevant urls if available, but do NOT make up any urls

6. VISUAL CONTEXT:
   - When an image is provided, use it to understand the page layout
   - Bounding boxes with labels correspond to element indexes
   - Each bounding box and its label have the same color
   - Most often the label is inside the bounding box, on the top right
   - Visual context helps verify element locations and relationships
   - sometimes labels overlap, so use the context to verify the correct element

7. Form filling:
   - If you fill an input field and your action sequence is interrupted, most often a list with suggestions popped up under the field and you need to first select the right element from the suggestion list.

8. ACTION SEQUENCING:
   - Actions are executed in the order they appear in the list
   - Each action should logically follow from the previous one
   - If the page changes after an action, the sequence is interrupted and you get the new state.
   - If content only disappears the sequence continues.
   - Only provide the action sequence until you think the page will change.
   - Try to be efficient, e.g. fill forms at once, or chain actions where nothing changes on the page like saving, extracting, checkboxes...
   - only use multiple actions if it makes sense.

9. Long tasks:
- If the task is long keep track of the status in the memory. If the ultimate task requires multiple subinformation, keep track of the status in the memory.
- If you get stuck, 

10. Extraction:
- When searching for information or conducting research:
  1. First analyze and extract relevant content from the current visible state
  2. If the needed information is incomplete:
     - Use cache_content action to cache the current findings
     - Scroll down EXACTLY ONE PAGE at a time using scroll_page action
     - NEVER scroll more than one page at once as this will cause loss of information
     - Repeat the analyze-cache-scroll cycle until either:
       * All required information is found, or
       * Maximum 5 page scrolls have been performed
  3. Before completing the task:
     - Combine all cached content with the current state
     - Verify all required information is collected
     - Present the complete findings in the done action
- Important extraction guidelines:
  - Be thorough and specific when extracting information
  - Always cache findings before scrolling to avoid losing information
  - Always verify source information before caching
  - Scroll down EXACTLY ONE PAGE at a time
  - Stop after maximum 5 page scrolls
   - use maximum ${this.maxActionsPerStep} actions per sequence`
        }
        inputFormat() {
            return `
INPUT STRUCTURE:
1. Current URL: The webpage you're currently on
2. Available Tabs: List of open browser tabs
3. Interactive Elements: List in the format:
   index[:]<element_type>element_text</element_type>
   - index: Numeric identifier for interaction
   - element_type: HTML element type (button, input, etc.)
   - element_text: Visible text or element description

Example:
[33]<button>Submit Form</button>
[] Non-interactive text


Notes:
- Only elements with numeric indexes inside [] are interactive
- [] elements provide context but cannot be interacted with
`
        }
        getSystemMessage() {
            const e = `You are a precise browser automation agent that interacts with websites through structured commands. Your role is to:
1. Analyze the provided webpage elements and structure
2. Use the given information to accomplish the ultimate task
3. Respond with valid JSON containing your next action sequence and state assessment
4. If the webpage is asking for login credentials, never try to fill it by yourself. Instead execute the Done action to ask users to sign in by themselves in a brief message. Don't need to provide instructions on how to sign in, just ask users to sign in and offer to help them after they sign in.

${this.inputFormat()}

${this.importantRules()}

Functions:
${this.default_action_description}

Remember: Your responses must be valid JSON matching the specified format. Each action in the sequence must be valid.`;
            return new iu(e)
        }
        async getUserMessage(e) {
            return await this.buildBrowserStateUserMessage(e)
        }
    }
    class rK extends sS {
        getSystemMessage() {
            return new iu(`You are a helpful assistant.

RESPONSIBILITIES:
1. Judge whether the ultimate task is related to web browsing or not and set the "web_task" field.
2. If web_task is false, then just answer the task directly as a helpful assistant
  - Output the answer into "next_steps" field in the JSON object. 
  - Set "done" field to true
  - Set these fields in the JSON object to empty string: "observation", "challenges", "reasoning"
  - Be kind and helpful when answering the task
  - Do NOT offer anything that users don't explicitly ask for.
  - Do NOT make up anything, if you don't know the answer, just say "I don't know"

3. If web_task is true, then helps break down tasks into smaller steps and reason about the current state
  - Analyze the current state and history
  - Evaluate progress towards the ultimate goal
  - Identify potential challenges or roadblocks
  - Suggest the next high-level steps to take
  - If you know the direct URL, use it directly instead of searching for it (e.g. github.com, www.espn.com). Search it if you don't know the direct URL.
  - Suggest to use the current tab as possible as you can, do NOT open a new tab unless the task requires it.
  - IMPORTANT: 
    - Always prioritize working with content visible in the current viewport first:
    - Focus on elements that are immediately visible without scrolling
    - Only suggest scrolling if the required content is confirmed to not be in the current view
    - Scrolling is your LAST resort unless you are explicitly required to do so by the task
    - NEVER suggest scrolling through the entire page, only scroll ONE PAGE at a time.
4. Once web_task is set to either true or false, its value The value must never change from its first set state in the conversation.

RESPONSE FORMAT: Your must always respond with a valid JSON object with the following fields:
{
    "observation": "Brief analysis of the current state and what has been done so far",
    "done": "true or false, whether further steps are needed to complete the ultimate task",
    "challenges": "List any potential challenges or roadblocks",
    "next_steps": "List 2-3 high-level next steps to take, each step should start with a new line",
    "reasoning": "Explain your reasoning for the suggested next steps",
    "web_task": "true or false, whether the ultimate task is related to browsing the web"
}

NOTE:
  - Inside the messages you receive, there will be other AI messages from other agents with different formats.
  - Ignore the output structures of other AI messages.

REMEMBER:
  - Keep your responses concise and focused on actionable insights.`)
        }
        async getUserMessage(e) {
            return new Ct("")
        }
    }
    class nK extends sS {
        constructor(e) {
            super(),
            this.tasks = [],
            this.tasks.push(e)
        }
        tasksToValidate() {
            if (this.tasks.length === 1)
                return this.tasks[0];
            const e = this.tasks[this.tasks.length - 1]
              , t = this.tasks.slice(0, -1).map( (s, i) => `${i + 1}. ${s}`).join(`
`);
            return `
${e}

The above task is a follow up task of the following tasks, please take the previous context into account when validating the task.

Previous tasks:
${t}
`
        }
        getSystemMessage() {
            return new iu(`You are a validator of an agent who interacts with a browser.
YOUR ROLE:
1. Validate if the agent's last action matches the user's request and if the task is completed.
2. Determine if the task is fully completed
3. Answer the task based on the provided context if the task is completed

RULES of ANSWERING THE TASK:
  - Read the task description carefully, neither miss any detailed requirements nor make up any requirements
  - Compile the final answer from provided context, do NOT make up any information not provided in the context
  - Make answers concise and easy to read
  - Include relevant numerical data when available, but do NOT make up any numbers
  - Include exact urls when available, but do NOT make up any urls
  - Format the final answer in a user-friendly way

SPECIAL CASES:
1. If the task is unclear defined, you can let it pass. But if something is missing or the image does not show what was requested, do NOT let it pass
2. Try to understand the page and help the model with suggestions like scroll, do x, ... to get the solution right
3. If the webpage is asking for username or password, you should respond with:
  - is_valid: true
  - reason: describe the reason why it is valid although the task is not completed yet
  - answer: ask the user to sign in by themselves
4. If the output is correct and the task is completed, you should respond with 
  - is_valid: true
  - reason: "Task completed"
  - answer: The final answer to the task

RESPONSE FORMAT: You must ALWAYS respond with valid JSON in this exact format:
{
  "is_valid": boolean,  // true if task is completed correctly
  "reason": string      // clear explanation of validation result
  "answer": string      // empty string if is_valid is false; human-readable final answer and should not be empty if is_valid is true
}

ANSWER FORMATTING GUIDELINES:
- Start with an emoji "" if is_valid is true
- Use markdown formatting if required by the task description
- By default use plain text
- Use bullet points for multiple items if needed
- Use line breaks for better readability
- Use indentations for nested lists

<example_output>
{
  "is_valid": false, 
  "reason": "The user wanted to search for \\"cat photos\\", but the agent searched for \\"dog photos\\" instead.",
  "answer": ""
}
</example_output>

<example_output>
{
  "is_valid": true, 
  "reason": "The task is completed",
  "answer": " Successfully followed @nanobrowser_ai on X."
}
</example_output>

TASK TO VALIDATE: 
${this.tasksToValidate()}`)
        }
        async getUserMessage(e) {
            return await this.buildBrowserStateUserMessage(e)
        }
        addFollowUpTask(e) {
            this.tasks.push(e)
        }
    }
    class sK {
        constructor() {
            this.messages = [],
            this.totalTokens = 0
        }
        addMessage(e, t={
            inputTokens: 0
        }, r) {
            const s = {
                message: e,
                metadata: t
            };
            r === void 0 ? this.messages.push(s) : this.messages.splice(r, 0, s),
            this.totalTokens += t.inputTokens
        }
        removeMessage(e=-1) {
            if (this.messages.length > 0) {
                const t = this.messages.splice(e, 1)[0];
                this.totalTokens -= t.metadata.inputTokens
            }
        }
        removeLastHumanMessage() {
            if (this.messages.length > 2 && this.messages[this.messages.length - 1].message instanceof Ct) {
                const e = this.messages.pop();
                e && (this.totalTokens -= e.metadata.inputTokens)
            }
        }
    }
    const Ch = kn("MessageManager");
    class iS {
        constructor({maxInputTokens: e=128e3, estimatedCharactersPerToken: t=3, imageTokens: r=800, sensitiveData: s}={}) {
            this.maxInputTokens = e,
            this.history = new sK,
            this.estimatedCharactersPerToken = t,
            this.IMG_TOKENS = r,
            this.sensitiveData = s,
            this.toolId = 1
        }
        initTaskMessages(e, t, r) {
            if (this.addMessageWithTokens(e),
            r && r.length > 0) {
                const h = new Ct({
                    content: `Context for the task: ${r}`
                });
                this.addMessageWithTokens(h)
            }
            const s = iS.taskInstructions(t);
            if (this.addMessageWithTokens(s),
            this.sensitiveData) {
                const h = `Here are placeholders for sensitive data: ${Object.keys(this.sensitiveData)}`
                  , f = new Ct({
                    content: `${h}
To use them, write <secret>the placeholder name</secret>`
                });
                this.addMessageWithTokens(f)
            }
            const i = new Ct({
                content: "Example output:"
            });
            this.addMessageWithTokens(i);
            const a = this.nextToolId()
              , c = [{
                name: "navigator_output",
                args: {
                    current_state: {
                        page_summary: "On the page are company a,b,c wtih their revenue 1,2,3.",
                        evaluation_previous_goal: "Success - I opend the first page",
                        memory: "Starting with the new task. I have completed 1/10 steps",
                        next_goal: "Click on company a"
                    },
                    action: [{
                        click_element: {
                            index: 0
                        }
                    }]
                },
                id: String(a),
                type: "tool_call"
            }]
              , u = new pn({
                content: "example tool call",
                tool_calls: c
            });
            this.addMessageWithTokens(u);
            const l = new $y({
                content: "Browser started",
                tool_call_id: String(a)
            });
            this.addMessageWithTokens(l);
            const d = new Ct({
                content: "[Your task history memory starts here]"
            });
            this.addMessageWithTokens(d)
        }
        nextToolId() {
            const e = this.toolId;
            return this.toolId += 1,
            e
        }
        static taskInstructions(e) {
            const t = `Your ultimate task is: """${e}""". If you achieved your ultimate task, stop everything and use the done action in the next step to complete the task. If not, continue as usual.`;
            return new Ct({
                content: t
            })
        }
        length() {
            return this.history.messages.length
        }
        addNewTask(e) {
            const t = `Your new ultimate task is: """${e}""". Take the previous context into account and finish your new ultimate task. `
              , r = new Ct({
                content: t
            });
            this.addMessageWithTokens(r)
        }
        addPlan(e, t) {
            if (e) {
                const r = new pn({
                    content: e
                });
                this.addMessageWithTokens(r, t)
            }
        }
        addStateMessage(e) {
            this.addMessageWithTokens(e)
        }
        removeLastStateMessage() {
            this.history.removeLastHumanMessage()
        }
        getMessages() {
            const e = this.history.messages.map(r => r.message);
            let t = 0;
            Ch.debug(`Messages in history: ${this.history.messages.length}:`);
            for (const r of this.history.messages)
                t += r.metadata.inputTokens,
                Ch.debug(`${r.message.constructor.name} - Token count: ${r.metadata.inputTokens}`);
            return e
        }
        getMessagesWithTokens() {
            return this.history.messages
        }
        addMessageWithTokens(e, t) {
            let r = e;
            this.sensitiveData && (r = this._filterSensitiveData(e));
            const i = {
                inputTokens: this._countTokens(r)
            };
            this.history.addMessage(r, i, t)
        }
        _filterSensitiveData(e) {
            const t = r => {
                let s = r;
                if (!this.sensitiveData)
                    return s;
                for (const [i,a] of Object.entries(this.sensitiveData))
                    s = s.replace(a, `<secret>${i}</secret>`);
                return s
            }
            ;
            return typeof e.content == "string" ? e.content = t(e.content) : Array.isArray(e.content) && (e.content = e.content.map(r => typeof r == "object" && "text"in r ? {
                ...r,
                text: t(r.text)
            } : r)),
            e
        }
        _countTokens(e) {
            let t = 0;
            if (Array.isArray(e.content))
                for (const r of e.content)
                    "image_url"in r ? t += this.IMG_TOKENS : typeof r == "object" && "text"in r && (t += this._countTextTokens(r.text));
            else {
                let r = e.content;
                "tool_calls"in e && (r += JSON.stringify(e.tool_calls)),
                t += this._countTextTokens(r)
            }
            return t
        }
        _countTextTokens(e) {
            return Math.floor(e.length / this.estimatedCharactersPerToken)
        }
        cutMessages() {
            let e = this.history.totalTokens - this.maxInputTokens;
            if (e <= 0)
                return;
            const t = this.history.messages[this.history.messages.length - 1];
            if (Array.isArray(t.message.content)) {
                let l = "";
                t.message.content = t.message.content.filter(d => "image_url"in d ? (e -= this.IMG_TOKENS,
                t.metadata.inputTokens -= this.IMG_TOKENS,
                this.history.totalTokens -= this.IMG_TOKENS,
                Ch.debug(`Removed image with ${this.IMG_TOKENS} tokens - total tokens now: ${this.history.totalTokens}/${this.maxInputTokens}`),
                !1) : ("text"in d && (l += d.text),
                !0)),
                t.message.content = l,
                this.history.messages[this.history.messages.length - 1] = t
            }
            if (e <= 0)
                return;
            const r = e / t.metadata.inputTokens;
            if (r > .99)
                throw new Error(`Max token limit reached - history is too long - reduce the system prompt or task. proportion_to_remove: ${r}`);
            Ch.debug(`Removing ${(r * 100).toFixed(2)}% of the last message (${(r * t.metadata.inputTokens).toFixed(2)} / ${t.metadata.inputTokens.toFixed(2)} tokens)`);
            const s = t.message.content
              , i = Math.floor(s.length * r)
              , a = s.slice(0, -i);
            this.history.removeMessage(-1);
            const c = new Ct({
                content: a
            });
            this.addMessageWithTokens(c);
            const u = this.history.messages[this.history.messages.length - 1];
            Ch.debug(`Added message with ${u.metadata.inputTokens} tokens - total tokens now: ${this.history.totalTokens}/${this.maxInputTokens} - total messages: ${this.history.messages.length}`)
        }
        convertMessagesForNonFunctionCallingModels(e) {
            return e.map(t => {
                if (t instanceof Ct || t instanceof iu)
                    return t;
                if (t instanceof $y)
                    return new Ct({
                        content: t.content
                    });
                if (t instanceof pn) {
                    if ("tool_calls"in t) {
                        const r = JSON.stringify(t.tool_calls);
                        return new pn({
                            content: r
                        })
                    }
                    return t
                }
                throw new Error(`Unknown message type: ${t.constructor.name}`)
            }
            )
        }
        mergeSuccessiveMessages(e, t) {
            const r = [];
            let s = 0;
            for (const i of e)
                if (i instanceof t)
                    if (s += 1,
                    s > 1) {
                        const a = r[r.length - 1];
                        if (Array.isArray(i.content)) {
                            const c = i.content[0];
                            "text"in c && (a.content += c.text)
                        } else
                            a.content += i.content
                    } else
                        r.push(i);
                else
                    r.push(i),
                    s = 0;
            return r
        }
    }
    const iK = kn("event-manager");
    let aK = class {
        constructor() {
            this._subscribers = new Map
        }
        subscribe(e, t) {
            this._subscribers.has(e) || this._subscribers.set(e, []);
            const r = this._subscribers.get(e);
            r && !r.includes(t) && r.push(t)
        }
        unsubscribe(e, t) {
            if (this._subscribers.has(e)) {
                const r = this._subscribers.get(e);
                r && this._subscribers.set(e, r.filter(s => s !== t))
            }
        }
        clearSubscribers(e) {
            this._subscribers.has(e) && this._subscribers.set(e, [])
        }
        async emit(e) {
            const t = this._subscribers.get(e.type);
            if (t)
                try {
                    await Promise.all(t.map(async r => await r(e)))
                } catch (r) {
                    iK.error("Error executing event callbacks:", r)
                }
        }
    }
    ;
    const Ws = kn("Executor");
    class oK {
        constructor(e, t, r, s, i) {
            this.tasks = [];
            const a = new iS({})
              , c = (i == null ? void 0 : i.plannerLLM) ?? s
              , u = (i == null ? void 0 : i.validatorLLM) ?? s
              , l = (i == null ? void 0 : i.extractorLLM) ?? s
              , d = new aK
              , h = new LU(t,r,a,d,(i == null ? void 0 : i.agentOptions) ?? {});
            this.tasks.push(e),
            this.navigatorPrompt = new tK(h.options.maxActionsPerStep),
            this.plannerPrompt = new rK,
            this.validatorPrompt = new nK(e);
            const f = new z5(h,l)
              , p = new J5(f.buildDefaultActions());
            this.navigator = new Z5(p,{
                chatLLM: s,
                context: h,
                prompt: this.navigatorPrompt
            }),
            this.planner = new Y5({
                chatLLM: c,
                context: h,
                prompt: this.plannerPrompt
            }),
            this.validator = new eK({
                chatLLM: u,
                context: h,
                prompt: this.validatorPrompt
            }),
            this.context = h,
            this.context.messageManager.initTaskMessages(this.navigatorPrompt.getSystemMessage(), e)
        }
        subscribeExecutionEvents(e) {
            this.context.eventManager.subscribe(w_.EXECUTION, e)
        }
        clearExecutionEvents() {
            this.context.eventManager.clearSubscribers(w_.EXECUTION)
        }
        addFollowUpTask(e) {
            this.tasks.push(e),
            this.context.messageManager.addNewTask(e),
            this.validatorPrompt.addFollowUpTask(e),
            this.context.actionResults = this.context.actionResults.filter(t => t.includeInMemory)
        }
        async execute() {
            var r;
            Ws.info(` Executing task: ${this.tasks[this.tasks.length - 1]}`);
            const e = this.context;
            e.nSteps = 0;
            const t = this.context.options.maxSteps;
            try {
                this.context.emitEvent(Ie.SYSTEM, ke.TASK_START, this.context.taskId);
                let s = !1
                  , i = 0
                  , a = !1;
                for (i = 0; i < t && (e.stepInfo = {
                    stepNumber: e.nSteps,
                    maxSteps: e.options.maxSteps
                },
                Ws.info(` Step ${i + 1} / ${t}`),
                !await this.shouldStop()); i++) {
                    if (this.planner && (e.nSteps % e.options.planningInterval === 0 || a)) {
                        a = !1,
                        (this.tasks.length > 1 || i > 0) && await this.navigator.addStateMessageToMemory();
                        const c = await this.planner.execute();
                        if (c.result && (Ws.info(` Planner output: ${JSON.stringify(c.result, null, 2)}`),
                        this.context.messageManager.addPlan(JSON.stringify(c.result), this.context.messageManager.length() - 1),
                        c.result.done ? (s = !0,
                        this.validator.setPlan(c.result.next_steps)) : (this.validator.setPlan(null),
                        s = !1),
                        !c.result.web_task && c.result.done))
                            break
                    }
                    if (s || (s = await this.navigate()),
                    s && this.context.options.validateOutput && !this.context.stopped && !this.context.paused) {
                        if ((r = (await this.validator.execute()).result) != null && r.is_valid) {
                            Ws.info(" Task completed successfully");
                            break
                        }
                        a = !0
                    }
                }
                s ? this.context.emitEvent(Ie.SYSTEM, ke.TASK_OK, this.context.taskId) : i >= t ? (Ws.info(" Task failed: Max steps reached"),
                this.context.emitEvent(Ie.SYSTEM, ke.TASK_FAIL, "Task failed: Max steps reached")) : this.context.stopped ? this.context.emitEvent(Ie.SYSTEM, ke.TASK_CANCEL, "Task cancelled") : this.context.emitEvent(Ie.SYSTEM, ke.TASK_PAUSE, "Task paused")
            } catch (s) {
                const i = s instanceof Error ? s.message : String(s);
                this.context.emitEvent(Ie.SYSTEM, ke.TASK_FAIL, `Task failed: ${i}`)
            }
        }
        async navigate() {
            var t;
            const e = this.context;
            try {
                if (e.paused || e.stopped)
                    return !1;
                const r = await this.navigator.execute();
                if (e.paused || e.stopped)
                    return !1;
                if (e.nSteps++,
                r.error)
                    throw new Error(r.error);
                if (e.consecutiveFailures = 0,
                (t = r.result) != null && t.done)
                    return !0
            } catch (r) {
                if (r instanceof yu)
                    throw r;
                if (e.consecutiveFailures++,
                Ws.error(`Failed to execute step: ${r}`),
                e.consecutiveFailures >= e.options.maxFailures)
                    throw new Error("Max failures reached")
            }
            return !1
        }
        async shouldStop() {
            if (this.context.stopped)
                return Ws.info("Agent stopped"),
                !0;
            for (; this.context.paused; )
                if (await new Promise(e => setTimeout(e, 200)),
                this.context.stopped)
                    return !0;
            return this.context.consecutiveFailures >= this.context.options.maxFailures ? (Ws.error(`Stopping due to ${this.context.options.maxFailures} consecutive failures`),
            !0) : !1
        }
        async cancel() {
            this.context.stop()
        }
        async resume() {
            this.context.resume()
        }
        async pause() {
            this.context.pause()
        }
        async cleanup() {
            try {
                await this.context.browserContext.cleanup()
            } catch (e) {
                Ws.error(`Failed to cleanup browser context: ${e}`)
            }
        }
        async getCurrentTaskId() {
            return this.context.taskId
        }
    }
    const aS = "RFC3986"
      , oS = {
        RFC1738: n => String(n).replace(/%20/g, "+"),
        RFC3986: n => String(n)
    }
      , cK = "RFC1738"
      , uK = Array.isArray
      , gs = ( () => {
        const n = [];
        for (let e = 0; e < 256; ++e)
            n.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return n
    }
    )()
      , cS = 1024
      , lK = (n, e, t, r, s) => {
        if (n.length === 0)
            return n;
        let i = n;
        if (typeof n == "symbol" ? i = Symbol.prototype.toString.call(n) : typeof n != "string" && (i = String(n)),
        t === "iso-8859-1")
            return escape(i).replace(/%u[0-9a-f]{4}/gi, function(c) {
                return "%26%23" + parseInt(c.slice(2), 16) + "%3B"
            });
        let a = "";
        for (let c = 0; c < i.length; c += cS) {
            const u = i.length >= cS ? i.slice(c, c + cS) : i
              , l = [];
            for (let d = 0; d < u.length; ++d) {
                let h = u.charCodeAt(d);
                if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || s === cK && (h === 40 || h === 41)) {
                    l[l.length] = u.charAt(d);
                    continue
                }
                if (h < 128) {
                    l[l.length] = gs[h];
                    continue
                }
                if (h < 2048) {
                    l[l.length] = gs[192 | h >> 6] + gs[128 | h & 63];
                    continue
                }
                if (h < 55296 || h >= 57344) {
                    l[l.length] = gs[224 | h >> 12] + gs[128 | h >> 6 & 63] + gs[128 | h & 63];
                    continue
                }
                d += 1,
                h = 65536 + ((h & 1023) << 10 | u.charCodeAt(d) & 1023),
                l[l.length] = gs[240 | h >> 18] + gs[128 | h >> 12 & 63] + gs[128 | h >> 6 & 63] + gs[128 | h & 63]
            }
            a += l.join("")
        }
        return a
    }
    ;
    function dK(n) {
        return !n || typeof n != "object" ? !1 : !!(n.constructor && n.constructor.isBuffer && n.constructor.isBuffer(n))
    }
    function PI(n, e) {
        if (uK(n)) {
            const t = [];
            for (let r = 0; r < n.length; r += 1)
                t.push(e(n[r]));
            return t
        }
        return e(n)
    }
    const hK = Object.prototype.hasOwnProperty
      , TI = {
        brackets(n) {
            return String(n) + "[]"
        },
        comma: "comma",
        indices(n, e) {
            return String(n) + "[" + e + "]"
        },
        repeat(n) {
            return String(n)
        }
    }
      , ys = Array.isArray
      , fK = Array.prototype.push
      , AI = function(n, e) {
        fK.apply(n, ys(e) ? e : [e])
    }
      , pK = Date.prototype.toISOString
      , Dt = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: lK,
        encodeValuesOnly: !1,
        format: aS,
        formatter: oS[aS],
        indices: !1,
        serializeDate(n) {
            return pK.call(n)
        },
        skipNulls: !1,
        strictNullHandling: !1
    };
    function mK(n) {
        return typeof n == "string" || typeof n == "number" || typeof n == "boolean" || typeof n == "symbol" || typeof n == "bigint"
    }
    const uS = {};
    function II(n, e, t, r, s, i, a, c, u, l, d, h, f, p, g, y, m, w) {
        let E = n
          , v = w
          , _ = 0
          , A = !1;
        for (; (v = v.get(uS)) !== void 0 && !A; ) {
            const R = v.get(n);
            if (_ += 1,
            typeof R < "u") {
                if (R === _)
                    throw new RangeError("Cyclic object value");
                A = !0
            }
            typeof v.get(uS) > "u" && (_ = 0)
        }
        if (typeof l == "function" ? E = l(e, E) : E instanceof Date ? E = f == null ? void 0 : f(E) : t === "comma" && ys(E) && (E = PI(E, function(R) {
            return R instanceof Date ? f == null ? void 0 : f(R) : R
        })),
        E === null) {
            if (i)
                return u && !y ? u(e, Dt.encoder, m, "key", p) : e;
            E = ""
        }
        if (mK(E) || dK(E)) {
            if (u) {
                const R = y ? e : u(e, Dt.encoder, m, "key", p);
                return [(g == null ? void 0 : g(R)) + "=" + (g == null ? void 0 : g(u(E, Dt.encoder, m, "value", p)))]
            }
            return [(g == null ? void 0 : g(e)) + "=" + (g == null ? void 0 : g(String(E)))]
        }
        const C = [];
        if (typeof E > "u")
            return C;
        let k;
        if (t === "comma" && ys(E))
            y && u && (E = PI(E, u)),
            k = [{
                value: E.length > 0 ? E.join(",") || null : void 0
            }];
        else if (ys(l))
            k = l;
        else {
            const R = Object.keys(E);
            k = d ? R.sort(d) : R
        }
        const x = c ? String(e).replace(/\./g, "%2E") : String(e)
          , N = r && ys(E) && E.length === 1 ? x + "[]" : x;
        if (s && ys(E) && E.length === 0)
            return N + "[]";
        for (let R = 0; R < k.length; ++R) {
            const F = k[R]
              , O = typeof F == "object" && typeof F.value < "u" ? F.value : E[F];
            if (a && O === null)
                continue;
            const T = h && c ? F.replace(/\./g, "%2E") : F
              , L = ys(E) ? typeof t == "function" ? t(N, T) : N : N + (h ? "." + T : "[" + T + "]");
            w.set(n, _);
            const q = new WeakMap;
            q.set(uS, w),
            AI(C, II(O, L, t, r, s, i, a, c, t === "comma" && y && ys(E) ? null : u, l, d, h, f, p, g, y, m, q))
        }
        return C
    }
    function gK(n=Dt) {
        if (typeof n.allowEmptyArrays < "u" && typeof n.allowEmptyArrays != "boolean")
            throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof n.encodeDotInKeys < "u" && typeof n.encodeDotInKeys != "boolean")
            throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (n.encoder !== null && typeof n.encoder < "u" && typeof n.encoder != "function")
            throw new TypeError("Encoder has to be a function.");
        const e = n.charset || Dt.charset;
        if (typeof n.charset < "u" && n.charset !== "utf-8" && n.charset !== "iso-8859-1")
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        let t = aS;
        if (typeof n.format < "u") {
            if (!hK.call(oS, n.format))
                throw new TypeError("Unknown format option provided.");
            t = n.format
        }
        const r = oS[t];
        let s = Dt.filter;
        (typeof n.filter == "function" || ys(n.filter)) && (s = n.filter);
        let i;
        if (n.arrayFormat && n.arrayFormat in TI ? i = n.arrayFormat : "indices"in n ? i = n.indices ? "indices" : "repeat" : i = Dt.arrayFormat,
        "commaRoundTrip"in n && typeof n.commaRoundTrip != "boolean")
            throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        const a = typeof n.allowDots > "u" ? n.encodeDotInKeys ? !0 : Dt.allowDots : !!n.allowDots;
        return {
            addQueryPrefix: typeof n.addQueryPrefix == "boolean" ? n.addQueryPrefix : Dt.addQueryPrefix,
            allowDots: a,
            allowEmptyArrays: typeof n.allowEmptyArrays == "boolean" ? !!n.allowEmptyArrays : Dt.allowEmptyArrays,
            arrayFormat: i,
            charset: e,
            charsetSentinel: typeof n.charsetSentinel == "boolean" ? n.charsetSentinel : Dt.charsetSentinel,
            commaRoundTrip: !!n.commaRoundTrip,
            delimiter: typeof n.delimiter > "u" ? Dt.delimiter : n.delimiter,
            encode: typeof n.encode == "boolean" ? n.encode : Dt.encode,
            encodeDotInKeys: typeof n.encodeDotInKeys == "boolean" ? n.encodeDotInKeys : Dt.encodeDotInKeys,
            encoder: typeof n.encoder == "function" ? n.encoder : Dt.encoder,
            encodeValuesOnly: typeof n.encodeValuesOnly == "boolean" ? n.encodeValuesOnly : Dt.encodeValuesOnly,
            filter: s,
            format: t,
            formatter: r,
            serializeDate: typeof n.serializeDate == "function" ? n.serializeDate : Dt.serializeDate,
            skipNulls: typeof n.skipNulls == "boolean" ? n.skipNulls : Dt.skipNulls,
            sort: typeof n.sort == "function" ? n.sort : null,
            strictNullHandling: typeof n.strictNullHandling == "boolean" ? n.strictNullHandling : Dt.strictNullHandling
        }
    }
    function yK(n, e={}) {
        let t = n;
        const r = gK(e);
        let s, i;
        typeof r.filter == "function" ? (i = r.filter,
        t = i("", t)) : ys(r.filter) && (i = r.filter,
        s = i);
        const a = [];
        if (typeof t != "object" || t === null)
            return "";
        const c = TI[r.arrayFormat]
          , u = c === "comma" && r.commaRoundTrip;
        s || (s = Object.keys(t)),
        r.sort && s.sort(r.sort);
        const l = new WeakMap;
        for (let f = 0; f < s.length; ++f) {
            const p = s[f];
            r.skipNulls && t[p] === null || AI(a, II(t[p], p, c, u, r.allowEmptyArrays, r.strictNullHandling, r.skipNulls, r.encodeDotInKeys, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, l))
        }
        const d = a.join(r.delimiter);
        let h = r.addQueryPrefix === !0 ? "?" : "";
        return r.charsetSentinel && (r.charset === "iso-8859-1" ? h += "utf8=%26%2310003%3B&" : h += "utf8=%E2%9C%93&"),
        d.length > 0 ? h + d : ""
    }
    const wu = "4.82.0";
    let OI = !1, kh, RI, MI, lS, NI, $I, LI, FI, jI;
    function wK(n, e={
        auto: !1
    }) {
        if (OI)
            throw new Error(`you must \`import 'openai/shims/${n.kind}'\` before importing anything else from openai`);
        if (kh)
            throw new Error(`can't \`import 'openai/shims/${n.kind}'\` after \`import 'openai/shims/${kh}'\``);
        OI = e.auto,
        kh = n.kind,
        RI = n.fetch,
        MI = n.FormData,
        lS = n.File,
        NI = n.ReadableStream,
        $I = n.getMultipartRequestOptions,
        LI = n.getDefaultAgent,
        FI = n.fileFromPath,
        jI = n.isFsReadStream
    }
    let bK = class {
        constructor(e) {
            this.body = e
        }
        get[Symbol.toStringTag]() {
            return "MultipartBody"
        }
    }
    ;
    function vK({manuallyImported: n}={}) {
        const e = n ? "You may need to use polyfills" : "Add one of these imports before your first `import  from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n";
        let t, r, s, i;
        try {
            t = fetch,
            r = Request,
            s = Response,
            i = Headers
        } catch (a) {
            throw new Error(`this environment is missing the following Web Fetch API type: ${a.message}. ${e}`)
        }
        return {
            kind: "web",
            fetch: t,
            Request: r,
            Response: s,
            Headers: i,
            FormData: typeof FormData < "u" ? FormData : class {
                constructor() {
                    throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`)
                }
            }
            ,
            Blob: typeof Blob < "u" ? Blob : class {
                constructor() {
                    throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`)
                }
            }
            ,
            File: typeof File < "u" ? File : class {
                constructor() {
                    throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`)
                }
            }
            ,
            ReadableStream: typeof ReadableStream < "u" ? ReadableStream : class {
                constructor() {
                    throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`)
                }
            }
            ,
            getMultipartRequestOptions: async (a, c) => ({
                ...c,
                body: new bK(a)
            }),
            getDefaultAgent: a => {}
            ,
            fileFromPath: () => {
                throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads")
            }
            ,
            isFsReadStream: a => !1
        }
    }
    kh || wK(vK(), {
        auto: !0
    });
    class qe extends Error {
    }
    let Fr = class dC extends qe {
        constructor(e, t, r, s) {
            super(`${dC.makeMessage(e, t, r)}`),
            this.status = e,
            this.headers = s,
            this.request_id = s == null ? void 0 : s["x-request-id"],
            this.error = t;
            const i = t;
            this.code = i == null ? void 0 : i.code,
            this.param = i == null ? void 0 : i.param,
            this.type = i == null ? void 0 : i.type
        }
        static makeMessage(e, t, r) {
            const s = t != null && t.message ? typeof t.message == "string" ? t.message : JSON.stringify(t.message) : t ? JSON.stringify(t) : r;
            return e && s ? `${e} ${s}` : e ? `${e} status code (no body)` : s || "(no status code or body)"
        }
        static generate(e, t, r, s) {
            if (!e || !s)
                return new lw({
                    message: r,
                    cause: pS(t)
                });
            const i = t == null ? void 0 : t.error;
            return e === 400 ? new DI(e,i,r,s) : e === 401 ? new BI(e,i,r,s) : e === 403 ? new qI(e,i,r,s) : e === 404 ? new UI(e,i,r,s) : e === 409 ? new KI(e,i,r,s) : e === 422 ? new HI(e,i,r,s) : e === 429 ? new WI(e,i,r,s) : e >= 500 ? new zI(e,i,r,s) : new dC(e,i,r,s)
        }
    }
      , yn = class extends Fr {
        constructor({message: e}={}) {
            super(void 0, void 0, e || "Request was aborted.", void 0)
        }
    }
      , lw = class extends Fr {
        constructor({message: e, cause: t}) {
            super(void 0, void 0, e || "Connection error.", void 0),
            t && (this.cause = t)
        }
    }
      , dw = class extends lw {
        constructor({message: e}={}) {
            super({
                message: e ?? "Request timed out."
            })
        }
    }
      , DI = class extends Fr {
    }
      , BI = class extends Fr {
    }
      , qI = class extends Fr {
    }
      , UI = class extends Fr {
    }
      , KI = class extends Fr {
    }
      , HI = class extends Fr {
    }
      , WI = class extends Fr {
    }
      , zI = class extends Fr {
    }
    ;
    class VI extends qe {
        constructor() {
            super("Could not parse response content as the length limit was reached")
        }
    }
    class GI extends qe {
        constructor() {
            super("Could not parse response content as the request was rejected by the content filter")
        }
    }
    let hw = class hC {
        constructor() {
            this.buffer = [],
            this.trailingCR = !1
        }
        decode(e) {
            let t = this.decodeText(e);
            if (this.trailingCR && (t = "\r" + t,
            this.trailingCR = !1),
            t.endsWith("\r") && (this.trailingCR = !0,
            t = t.slice(0, -1)),
            !t)
                return [];
            const r = hC.NEWLINE_CHARS.has(t[t.length - 1] || "");
            let s = t.split(hC.NEWLINE_REGEXP);
            return r && s.pop(),
            s.length === 1 && !r ? (this.buffer.push(s[0]),
            []) : (this.buffer.length > 0 && (s = [this.buffer.join("") + s[0], ...s.slice(1)],
            this.buffer = []),
            r || (this.buffer = [s.pop() || ""]),
            s)
        }
        decodeText(e) {
            if (e == null)
                return "";
            if (typeof e == "string")
                return e;
            if (typeof Buffer < "u") {
                if (e instanceof Buffer)
                    return e.toString();
                if (e instanceof Uint8Array)
                    return Buffer.from(e).toString();
                throw new qe(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`)
            }
            if (typeof TextDecoder < "u") {
                if (e instanceof Uint8Array || e instanceof ArrayBuffer)
                    return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")),
                    this.textDecoder.decode(e);
                throw new qe(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`)
            }
            throw new qe("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.")
        }
        flush() {
            if (!this.buffer.length && !this.trailingCR)
                return [];
            const e = [this.buffer.join("")];
            return this.buffer = [],
            this.trailingCR = !1,
            e
        }
    }
    ;
    hw.NEWLINE_CHARS = new Set([`
`, "\r"]),
    hw.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
    function JI(n) {
        if (n[Symbol.asyncIterator])
            return n;
        const e = n.getReader();
        return {
            async next() {
                try {
                    const t = await e.read();
                    return t != null && t.done && e.releaseLock(),
                    t
                } catch (t) {
                    throw e.releaseLock(),
                    t
                }
            },
            async return() {
                const t = e.cancel();
                return e.releaseLock(),
                await t,
                {
                    done: !0,
                    value: void 0
                }
            },
            [Symbol.asyncIterator]() {
                return this
            }
        }
    }
    let Ph = class Ig {
        constructor(e, t) {
            this.iterator = e,
            this.controller = t
        }
        static fromSSEResponse(e, t) {
            let r = !1;
            async function *s() {
                if (r)
                    throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
                r = !0;
                let i = !1;
                try {
                    for await(const a of _K(e, t))
                        if (!i) {
                            if (a.data.startsWith("[DONE]")) {
                                i = !0;
                                continue
                            }
                            if (a.event === null) {
                                let c;
                                try {
                                    c = JSON.parse(a.data)
                                } catch (u) {
                                    throw console.error("Could not parse message into JSON:", a.data),
                                    console.error("From chunk:", a.raw),
                                    u
                                }
                                if (c && c.error)
                                    throw new Fr(void 0,c.error,void 0,void 0);
                                yield c
                            } else {
                                let c;
                                try {
                                    c = JSON.parse(a.data)
                                } catch (u) {
                                    throw console.error("Could not parse message into JSON:", a.data),
                                    console.error("From chunk:", a.raw),
                                    u
                                }
                                if (a.event == "error")
                                    throw new Fr(void 0,c.error,c.message,void 0);
                                yield{
                                    event: a.event,
                                    data: c
                                }
                            }
                        }
                    i = !0
                } catch (a) {
                    if (a instanceof Error && a.name === "AbortError")
                        return;
                    throw a
                } finally {
                    i || t.abort()
                }
            }
            return new Ig(s,t)
        }
        static fromReadableStream(e, t) {
            let r = !1;
            async function *s() {
                const a = new hw
                  , c = JI(e);
                for await(const u of c)
                    for (const l of a.decode(u))
                        yield l;
                for (const u of a.flush())
                    yield u
            }
            async function *i() {
                if (r)
                    throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
                r = !0;
                let a = !1;
                try {
                    for await(const c of s())
                        a || c && (yield JSON.parse(c));
                    a = !0
                } catch (c) {
                    if (c instanceof Error && c.name === "AbortError")
                        return;
                    throw c
                } finally {
                    a || t.abort()
                }
            }
            return new Ig(i,t)
        }
        [Symbol.asyncIterator]() {
            return this.iterator()
        }
        tee() {
            const e = []
              , t = []
              , r = this.iterator()
              , s = i => ({
                next: () => {
                    if (i.length === 0) {
                        const a = r.next();
                        e.push(a),
                        t.push(a)
                    }
                    return i.shift()
                }
            });
            return [new Ig( () => s(e),this.controller), new Ig( () => s(t),this.controller)]
        }
        toReadableStream() {
            const e = this;
            let t;
            const r = new TextEncoder;
            return new NI({
                async start() {
                    t = e[Symbol.asyncIterator]()
                },
                async pull(s) {
                    try {
                        const {value: i, done: a} = await t.next();
                        if (a)
                            return s.close();
                        const c = r.encode(JSON.stringify(i) + `
`);
                        s.enqueue(c)
                    } catch (i) {
                        s.error(i)
                    }
                },
                async cancel() {
                    var s;
                    await ((s = t.return) == null ? void 0 : s.call(t))
                }
            })
        }
    }
    ;
    async function *_K(n, e) {
        if (!n.body)
            throw e.abort(),
            new qe("Attempted to iterate over a response with no body");
        const t = new xK
          , r = new hw
          , s = JI(n.body);
        for await(const i of SK(s))
            for (const a of r.decode(i)) {
                const c = t.decode(a);
                c && (yield c)
            }
        for (const i of r.flush()) {
            const a = t.decode(i);
            a && (yield a)
        }
    }
    async function *SK(n) {
        let e = new Uint8Array;
        for await(const t of n) {
            if (t == null)
                continue;
            const r = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? new TextEncoder().encode(t) : t;
            let s = new Uint8Array(e.length + r.length);
            s.set(e),
            s.set(r, e.length),
            e = s;
            let i;
            for (; (i = EK(e)) !== -1; )
                yield e.slice(0, i),
                e = e.slice(i)
        }
        e.length > 0 && (yield e)
    }
    function EK(n) {
        for (let r = 0; r < n.length - 2; r++) {
            if (n[r] === 10 && n[r + 1] === 10 || n[r] === 13 && n[r + 1] === 13)
                return r + 2;
            if (n[r] === 13 && n[r + 1] === 10 && r + 3 < n.length && n[r + 2] === 13 && n[r + 3] === 10)
                return r + 4
        }
        return -1
    }
    let xK = class {
        constructor() {
            this.event = null,
            this.data = [],
            this.chunks = []
        }
        decode(e) {
            if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)),
            !e) {
                if (!this.event && !this.data.length)
                    return null;
                const i = {
                    event: this.event,
                    data: this.data.join(`
`),
                    raw: this.chunks
                };
                return this.event = null,
                this.data = [],
                this.chunks = [],
                i
            }
            if (this.chunks.push(e),
            e.startsWith(":"))
                return null;
            let[t,r,s] = CK(e, ":");
            return s.startsWith(" ") && (s = s.substring(1)),
            t === "event" ? this.event = s : t === "data" && this.data.push(s),
            null
        }
    }
    ;
    function CK(n, e) {
        const t = n.indexOf(e);
        return t !== -1 ? [n.substring(0, t), e, n.substring(t + e.length)] : [n, "", ""]
    }
    const ZI = n => n != null && typeof n == "object" && typeof n.url == "string" && typeof n.blob == "function"
      , XI = n => n != null && typeof n == "object" && typeof n.name == "string" && typeof n.lastModified == "number" && fw(n)
      , fw = n => n != null && typeof n == "object" && typeof n.size == "number" && typeof n.type == "string" && typeof n.text == "function" && typeof n.slice == "function" && typeof n.arrayBuffer == "function"
      , kK = n => XI(n) || ZI(n) || jI(n);
    async function YI(n, e, t) {
        var s;
        if (n = await n,
        XI(n))
            return n;
        if (ZI(n)) {
            const i = await n.blob();
            e || (e = new URL(n.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
            const a = fw(i) ? [await i.arrayBuffer()] : [i];
            return new lS(a,e,t)
        }
        const r = await PK(n);
        if (e || (e = AK(n) ?? "unknown_file"),
        !(t != null && t.type)) {
            const i = (s = r[0]) == null ? void 0 : s.type;
            typeof i == "string" && (t = {
                ...t,
                type: i
            })
        }
        return new lS(r,e,t)
    }
    async function PK(n) {
        var t;
        let e = [];
        if (typeof n == "string" || ArrayBuffer.isView(n) || n instanceof ArrayBuffer)
            e.push(n);
        else if (fw(n))
            e.push(await n.arrayBuffer());
        else if (IK(n))
            for await(const r of n)
                e.push(r);
        else
            throw new Error(`Unexpected data type: ${typeof n}; constructor: ${(t = n == null ? void 0 : n.constructor) == null ? void 0 : t.name}; props: ${TK(n)}`);
        return e
    }
    function TK(n) {
        return `[${Object.getOwnPropertyNames(n).map(t => `"${t}"`).join(", ")}]`
    }
    function AK(n) {
        var e;
        return dS(n.name) || dS(n.filename) || ((e = dS(n.path)) == null ? void 0 : e.split(/[\\/]/).pop())
    }
    const dS = n => {
        if (typeof n == "string")
            return n;
        if (typeof Buffer < "u" && n instanceof Buffer)
            return String(n)
    }
      , IK = n => n != null && typeof n == "object" && typeof n[Symbol.asyncIterator] == "function"
      , QI = n => n && typeof n == "object" && n.body && n[Symbol.toStringTag] === "MultipartBody"
      , bu = async n => {
        const e = await OK(n.body);
        return $I(e, n)
    }
      , OK = async n => {
        const e = new MI;
        return await Promise.all(Object.entries(n || {}).map( ([t,r]) => hS(e, t, r))),
        e
    }
      , hS = async (n, e, t) => {
        if (t !== void 0) {
            if (t == null)
                throw new TypeError(`Received null for "${e}"; to pass null in FormData, you must use the string 'null'`);
            if (typeof t == "string" || typeof t == "number" || typeof t == "boolean")
                n.append(e, String(t));
            else if (kK(t)) {
                const r = await YI(t);
                n.append(e, r)
            } else if (Array.isArray(t))
                await Promise.all(t.map(r => hS(n, e + "[]", r)));
            else if (typeof t == "object")
                await Promise.all(Object.entries(t).map( ([r,s]) => hS(n, `${e}[${r}]`, s)));
            else
                throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${t} instead`)
        }
    }
    ;
    var RK = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, MK = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, pw;
    async function e1(n) {
        const {response: e} = n;
        if (n.options.stream)
            return vu("response", e.status, e.url, e.headers, e.body),
            n.options.__streamClass ? n.options.__streamClass.fromSSEResponse(e, n.controller) : Ph.fromSSEResponse(e, n.controller);
        if (e.status === 204)
            return null;
        if (n.options.__binaryResponse)
            return e;
        const t = e.headers.get("content-type");
        if ((t == null ? void 0 : t.includes("application/json")) || (t == null ? void 0 : t.includes("application/vnd.api+json"))) {
            const i = await e.json();
            return vu("response", e.status, e.url, e.headers, i),
            t1(i, e)
        }
        const s = await e.text();
        return vu("response", e.status, e.url, e.headers, s),
        s
    }
    function t1(n, e) {
        return !n || typeof n != "object" || Array.isArray(n) ? n : Object.defineProperty(n, "_request_id", {
            value: e.headers.get("x-request-id"),
            enumerable: !1
        })
    }
    let r1 = class aL extends Promise {
        constructor(e, t=e1) {
            super(r => {
                r(null)
            }
            ),
            this.responsePromise = e,
            this.parseResponse = t
        }
        _thenUnwrap(e) {
            return new aL(this.responsePromise,async t => t1(e(await this.parseResponse(t), t), t.response))
        }
        asResponse() {
            return this.responsePromise.then(e => e.response)
        }
        async withResponse() {
            const [e,t] = await Promise.all([this.parse(), this.asResponse()]);
            return {
                data: e,
                response: t,
                request_id: t.headers.get("x-request-id")
            }
        }
        parse() {
            return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)),
            this.parsedPromise
        }
        then(e, t) {
            return this.parse().then(e, t)
        }
        catch(e) {
            return this.parse().catch(e)
        }
        finally(e) {
            return this.parse().finally(e)
        }
    }
      , NK = class {
        constructor({baseURL: e, maxRetries: t=2, timeout: r=6e5, httpAgent: s, fetch: i}) {
            this.baseURL = e,
            this.maxRetries = fS("maxRetries", t),
            this.timeout = fS("timeout", r),
            this.httpAgent = s,
            this.fetch = i ?? RI
        }
        authHeaders(e) {
            return {}
        }
        defaultHeaders(e) {
            return {
                Accept: "application/json",
                "Content-Type": "application/json",
                "User-Agent": this.getUserAgent(),
                ...BK(),
                ...this.authHeaders(e)
            }
        }
        validateHeaders(e, t) {}
        defaultIdempotencyKey() {
            return `stainless-node-retry-${HK()}`
        }
        get(e, t) {
            return this.methodRequest("get", e, t)
        }
        post(e, t) {
            return this.methodRequest("post", e, t)
        }
        patch(e, t) {
            return this.methodRequest("patch", e, t)
        }
        put(e, t) {
            return this.methodRequest("put", e, t)
        }
        delete(e, t) {
            return this.methodRequest("delete", e, t)
        }
        methodRequest(e, t, r) {
            return this.request(Promise.resolve(r).then(async s => {
                const i = s && fw(s == null ? void 0 : s.body) ? new DataView(await s.body.arrayBuffer()) : (s == null ? void 0 : s.body)instanceof DataView ? s.body : (s == null ? void 0 : s.body)instanceof ArrayBuffer ? new DataView(s.body) : s && ArrayBuffer.isView(s == null ? void 0 : s.body) ? new DataView(s.body.buffer) : s == null ? void 0 : s.body;
                return {
                    method: e,
                    path: t,
                    ...s,
                    body: i
                }
            }
            ))
        }
        getAPIList(e, t, r) {
            return this.requestAPIList(t, {
                method: "get",
                path: e,
                ...r
            })
        }
        calculateContentLength(e) {
            if (typeof e == "string") {
                if (typeof Buffer < "u")
                    return Buffer.byteLength(e, "utf8").toString();
                if (typeof TextEncoder < "u")
                    return new TextEncoder().encode(e).length.toString()
            } else if (ArrayBuffer.isView(e))
                return e.byteLength.toString();
            return null
        }
        buildRequest(e, {retryCount: t=0}={}) {
            var y;
            const {method: r, path: s, query: i, headers: a={}} = e
              , c = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : QI(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null
              , u = this.calculateContentLength(c)
              , l = this.buildURL(s, i);
            "timeout"in e && fS("timeout", e.timeout);
            const d = e.timeout ?? this.timeout
              , h = e.httpAgent ?? this.httpAgent ?? LI(l)
              , f = d + 1e3;
            typeof ((y = h == null ? void 0 : h.options) == null ? void 0 : y.timeout) == "number" && f > (h.options.timeout ?? 0) && (h.options.timeout = f),
            this.idempotencyHeader && r !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()),
            a[this.idempotencyHeader] = e.idempotencyKey);
            const p = this.buildHeaders({
                options: e,
                headers: a,
                contentLength: u,
                retryCount: t
            });
            return {
                req: {
                    method: r,
                    ...c && {
                        body: c
                    },
                    headers: p,
                    ...h && {
                        agent: h
                    },
                    signal: e.signal ?? null
                },
                url: l,
                timeout: d
            }
        }
        buildHeaders({options: e, headers: t, contentLength: r, retryCount: s}) {
            const i = {};
            r && (i["content-length"] = r);
            const a = this.defaultHeaders(e);
            return u1(i, a),
            u1(i, t),
            QI(e.body) && kh !== "node" && delete i["content-type"],
            d1(a, "x-stainless-retry-count") === void 0 && d1(t, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(s)),
            this.validateHeaders(i, t),
            i
        }
        async prepareOptions(e) {}
        async prepareRequest(e, {url: t, options: r}) {}
        parseHeaders(e) {
            return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map(t => [...t])) : {
                ...e
            } : {}
        }
        makeStatusError(e, t, r, s) {
            return Fr.generate(e, t, r, s)
        }
        request(e, t=null) {
            return new r1(this.makeRequest(e, t))
        }
        async makeRequest(e, t) {
            var h, f;
            const r = await e
              , s = r.maxRetries ?? this.maxRetries;
            t == null && (t = s),
            await this.prepareOptions(r);
            const {req: i, url: a, timeout: c} = this.buildRequest(r, {
                retryCount: s - t
            });
            if (await this.prepareRequest(i, {
                url: a,
                options: r
            }),
            vu("request", a, r, i.headers),
            (h = r.signal) != null && h.aborted)
                throw new yn;
            const u = new AbortController
              , l = await this.fetchWithTimeout(a, i, c, u).catch(pS);
            if (l instanceof Error) {
                if ((f = r.signal) != null && f.aborted)
                    throw new yn;
                if (t)
                    return this.retryRequest(r, t);
                throw l.name === "AbortError" ? new dw : new lw({
                    cause: l
                })
            }
            const d = LK(l.headers);
            if (!l.ok) {
                if (t && this.shouldRetry(l)) {
                    const E = `retrying, ${t} attempts remaining`;
                    return vu(`response (error; ${E})`, l.status, a, d),
                    this.retryRequest(r, t, d)
                }
                const p = await l.text().catch(E => pS(E).message)
                  , g = qK(p)
                  , y = g ? void 0 : p;
                throw vu(`response (error; ${t ? "(error; no more retries left)" : "(error; not retryable)"})`, l.status, a, d, y),
                this.makeStatusError(l.status, g, y, d)
            }
            return {
                response: l,
                options: r,
                controller: u
            }
        }
        requestAPIList(e, t) {
            const r = this.makeRequest(t, null);
            return new $K(this,r,e)
        }
        buildURL(e, t) {
            const r = KK(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e))
              , s = this.defaultQuery();
            return o1(s) || (t = {
                ...s,
                ...t
            }),
            typeof t == "object" && t && !Array.isArray(t) && (r.search = this.stringifyQuery(t)),
            r.toString()
        }
        stringifyQuery(e) {
            return Object.entries(e).filter( ([t,r]) => typeof r < "u").map( ([t,r]) => {
                if (typeof r == "string" || typeof r == "number" || typeof r == "boolean")
                    return `${encodeURIComponent(t)}=${encodeURIComponent(r)}`;
                if (r === null)
                    return `${encodeURIComponent(t)}=`;
                throw new qe(`Cannot stringify type ${typeof r}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`)
            }
            ).join("&")
        }
        async fetchWithTimeout(e, t, r, s) {
            const {signal: i, ...a} = t || {};
            i && i.addEventListener("abort", () => s.abort());
            const c = setTimeout( () => s.abort(), r)
              , u = {
                signal: s.signal,
                ...a
            };
            return u.method && (u.method = u.method.toUpperCase()),
            this.fetch.call(void 0, e, u).finally( () => {
                clearTimeout(c)
            }
            )
        }
        shouldRetry(e) {
            const t = e.headers.get("x-should-retry");
            return t === "true" ? !0 : t === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500
        }
        async retryRequest(e, t, r) {
            let s;
            const i = r == null ? void 0 : r["retry-after-ms"];
            if (i) {
                const c = parseFloat(i);
                Number.isNaN(c) || (s = c)
            }
            const a = r == null ? void 0 : r["retry-after"];
            if (a && !s) {
                const c = parseFloat(a);
                Number.isNaN(c) ? s = Date.parse(a) - Date.now() : s = c * 1e3
            }
            if (!(s && 0 <= s && s < 60 * 1e3)) {
                const c = e.maxRetries ?? this.maxRetries;
                s = this.calculateDefaultRetryTimeoutMillis(t, c)
            }
            return await Th(s),
            this.makeRequest(e, t - 1)
        }
        calculateDefaultRetryTimeoutMillis(e, t) {
            const i = t - e
              , a = Math.min(.5 * Math.pow(2, i), 8)
              , c = 1 - Math.random() * .25;
            return a * c * 1e3
        }
        getUserAgent() {
            return `${this.constructor.name}/JS ${wu}`
        }
    }
      , n1 = class {
        constructor(e, t, r, s) {
            pw.set(this, void 0),
            RK(this, pw, e, "f"),
            this.options = s,
            this.response = t,
            this.body = r
        }
        hasNextPage() {
            return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1
        }
        async getNextPage() {
            const e = this.nextPageInfo();
            if (!e)
                throw new qe("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
            const t = {
                ...this.options
            };
            if ("params"in e && typeof t.query == "object")
                t.query = {
                    ...t.query,
                    ...e.params
                };
            else if ("url"in e) {
                const r = [...Object.entries(t.query || {}), ...e.url.searchParams.entries()];
                for (const [s,i] of r)
                    e.url.searchParams.set(s, i);
                t.query = void 0,
                t.path = e.url.toString()
            }
            return await MK(this, pw, "f").requestAPIList(this.constructor, t)
        }
        async*iterPages() {
            let e = this;
            for (yield e; e.hasNextPage(); )
                e = await e.getNextPage(),
                yield e
        }
        async*[(pw = new WeakMap,
        Symbol.asyncIterator)]() {
            for await(const e of this.iterPages())
                for (const t of e.getPaginatedItems())
                    yield t
        }
    }
      , $K = class extends r1 {
        constructor(e, t, r) {
            super(t, async s => new r(e,s.response,await e1(s),s.options))
        }
        async*[Symbol.asyncIterator]() {
            const e = await this;
            for await(const t of e)
                yield t
        }
    }
    ;
    const LK = n => new Proxy(Object.fromEntries(n.entries()),{
        get(e, t) {
            const r = t.toString();
            return e[r.toLowerCase()] || e[r]
        }
    })
      , FK = {
        method: !0,
        path: !0,
        query: !0,
        body: !0,
        headers: !0,
        maxRetries: !0,
        stream: !0,
        timeout: !0,
        httpAgent: !0,
        signal: !0,
        idempotencyKey: !0,
        __binaryRequest: !0,
        __binaryResponse: !0,
        __streamClass: !0
    }
      , jr = n => typeof n == "object" && n !== null && !o1(n) && Object.keys(n).every(e => c1(FK, e))
      , jK = () => {
        var e;
        if (typeof Deno < "u" && Deno.build != null)
            return {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": wu,
                "X-Stainless-OS": i1(Deno.build.os),
                "X-Stainless-Arch": s1(Deno.build.arch),
                "X-Stainless-Runtime": "deno",
                "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : ((e = Deno.version) == null ? void 0 : e.deno) ?? "unknown"
            };
        if (typeof EdgeRuntime < "u")
            return {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": wu,
                "X-Stainless-OS": "Unknown",
                "X-Stainless-Arch": `other:${EdgeRuntime}`,
                "X-Stainless-Runtime": "edge",
                "X-Stainless-Runtime-Version": process.version
            };
        if (Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]")
            return {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": wu,
                "X-Stainless-OS": i1(process.platform),
                "X-Stainless-Arch": s1(process.arch),
                "X-Stainless-Runtime": "node",
                "X-Stainless-Runtime-Version": process.version
            };
        const n = DK();
        return n ? {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": wu,
            "X-Stainless-OS": "Unknown",
            "X-Stainless-Arch": "unknown",
            "X-Stainless-Runtime": `browser:${n.browser}`,
            "X-Stainless-Runtime-Version": n.version
        } : {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": wu,
            "X-Stainless-OS": "Unknown",
            "X-Stainless-Arch": "unknown",
            "X-Stainless-Runtime": "unknown",
            "X-Stainless-Runtime-Version": "unknown"
        }
    }
    ;
    function DK() {
        if (typeof navigator > "u" || !navigator)
            return null;
        const n = [{
            key: "edge",
            pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "ie",
            pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "ie",
            pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "chrome",
            pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "firefox",
            pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "safari",
            pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/
        }];
        for (const {key: e, pattern: t} of n) {
            const r = t.exec(navigator.userAgent);
            if (r) {
                const s = r[1] || 0
                  , i = r[2] || 0
                  , a = r[3] || 0;
                return {
                    browser: e,
                    version: `${s}.${i}.${a}`
                }
            }
        }
        return null
    }
    const s1 = n => n === "x32" ? "x32" : n === "x86_64" || n === "x64" ? "x64" : n === "arm" ? "arm" : n === "aarch64" || n === "arm64" ? "arm64" : n ? `other:${n}` : "unknown"
      , i1 = n => (n = n.toLowerCase(),
    n.includes("ios") ? "iOS" : n === "android" ? "Android" : n === "darwin" ? "MacOS" : n === "win32" ? "Windows" : n === "freebsd" ? "FreeBSD" : n === "openbsd" ? "OpenBSD" : n === "linux" ? "Linux" : n ? `Other:${n}` : "Unknown");
    let a1;
    const BK = () => a1 ?? (a1 = jK())
      , qK = n => {
        try {
            return JSON.parse(n)
        } catch {
            return
        }
    }
      , UK = /^[a-z][a-z0-9+.-]*:/i
      , KK = n => UK.test(n)
      , Th = n => new Promise(e => setTimeout(e, n))
      , fS = (n, e) => {
        if (typeof e != "number" || !Number.isInteger(e))
            throw new qe(`${n} must be an integer`);
        if (e < 0)
            throw new qe(`${n} must be a positive integer`);
        return e
    }
      , pS = n => {
        if (n instanceof Error)
            return n;
        if (typeof n == "object" && n !== null)
            try {
                return new Error(JSON.stringify(n))
            } catch {}
        return new Error(n)
    }
      , mw = n => {
        var e, t, r, s, i;
        if (typeof process < "u")
            return ((t = (e = process.env) == null ? void 0 : e[n]) == null ? void 0 : t.trim()) ?? void 0;
        if (typeof Deno < "u")
            return (i = (s = (r = Deno.env) == null ? void 0 : r.get) == null ? void 0 : s.call(r, n)) == null ? void 0 : i.trim()
    }
    ;
    function o1(n) {
        if (!n)
            return !0;
        for (const e in n)
            return !1;
        return !0
    }
    function c1(n, e) {
        return Object.prototype.hasOwnProperty.call(n, e)
    }
    function u1(n, e) {
        for (const t in e) {
            if (!c1(e, t))
                continue;
            const r = t.toLowerCase();
            if (!r)
                continue;
            const s = e[t];
            s === null ? delete n[r] : s !== void 0 && (n[r] = s)
        }
    }
    const l1 = new Set(["authorization", "api-key"]);
    function vu(n, ...e) {
        var t;
        if (typeof process < "u" && ((t = process == null ? void 0 : process.env) == null ? void 0 : t.DEBUG) === "true") {
            const r = e.map(s => {
                if (!s)
                    return s;
                if (s.headers) {
                    const a = {
                        ...s,
                        headers: {
                            ...s.headers
                        }
                    };
                    for (const c in s.headers)
                        l1.has(c.toLowerCase()) && (a.headers[c] = "REDACTED");
                    return a
                }
                let i = null;
                for (const a in s)
                    l1.has(a.toLowerCase()) && (i ?? (i = {
                        ...s
                    }),
                    i[a] = "REDACTED");
                return i ?? s
            }
            );
            console.log(`OpenAI:DEBUG:${n}`, ...r)
        }
    }
    const HK = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, n => {
        const e = Math.random() * 16 | 0;
        return (n === "x" ? e : e & 3 | 8).toString(16)
    }
    )
      , WK = () => typeof window < "u" && typeof window.document < "u" && typeof navigator < "u"
      , zK = n => typeof (n == null ? void 0 : n.get) == "function"
      , d1 = (n, e) => {
        var r;
        const t = e.toLowerCase();
        if (zK(n)) {
            const s = ((r = e[0]) == null ? void 0 : r.toUpperCase()) + e.substring(1).replace(/([^\w])(\w)/g, (i, a, c) => a + c.toUpperCase());
            for (const i of [e, t, e.toUpperCase(), s]) {
                const a = n.get(i);
                if (a)
                    return a
            }
        }
        for (const [s,i] of Object.entries(n))
            if (s.toLowerCase() === t)
                return Array.isArray(i) ? (i.length <= 1 || console.warn(`Received ${i.length} entries for the ${e} header, using the first entry.`),
                i[0]) : i
    }
    ;
    function mS(n) {
        return n != null && typeof n == "object" && !Array.isArray(n)
    }
    let VK = class extends n1 {
        constructor(e, t, r, s) {
            super(e, t, r, s),
            this.data = r.data || [],
            this.object = r.object
        }
        getPaginatedItems() {
            return this.data ?? []
        }
        nextPageParams() {
            return null
        }
        nextPageInfo() {
            return null
        }
    }
    ;
    class jn extends n1 {
        constructor(e, t, r, s) {
            super(e, t, r, s),
            this.data = r.data || []
        }
        getPaginatedItems() {
            return this.data ?? []
        }
        nextPageParams() {
            const e = this.nextPageInfo();
            if (!e)
                return null;
            if ("params"in e)
                return e.params;
            const t = Object.fromEntries(e.url.searchParams);
            return Object.keys(t).length ? t : null
        }
        nextPageInfo() {
            var r;
            const e = this.getPaginatedItems();
            if (!e.length)
                return null;
            const t = (r = e[e.length - 1]) == null ? void 0 : r.id;
            return t ? {
                params: {
                    after: t
                }
            } : null
        }
    }
    let st = class {
        constructor(e) {
            this._client = e
        }
    }
      , h1 = class extends st {
        create(e, t) {
            return this._client.post("/chat/completions", {
                body: e,
                ...t,
                stream: e.stream ?? !1
            })
        }
    }
      , gS = class extends st {
        constructor() {
            super(...arguments),
            this.completions = new h1(this._client)
        }
    }
    ;
    gS.Completions = h1;
    class f1 extends st {
        create(e, t) {
            return this._client.post("/audio/speech", {
                body: e,
                ...t,
                headers: {
                    Accept: "application/octet-stream",
                    ...t == null ? void 0 : t.headers
                },
                __binaryResponse: !0
            })
        }
    }
    class p1 extends st {
        create(e, t) {
            return this._client.post("/audio/transcriptions", bu({
                body: e,
                ...t
            }))
        }
    }
    class m1 extends st {
        create(e, t) {
            return this._client.post("/audio/translations", bu({
                body: e,
                ...t
            }))
        }
    }
    class Ah extends st {
        constructor() {
            super(...arguments),
            this.transcriptions = new p1(this._client),
            this.translations = new m1(this._client),
            this.speech = new f1(this._client)
        }
    }
    Ah.Transcriptions = p1,
    Ah.Translations = m1,
    Ah.Speech = f1;
    let yS = class extends st {
        create(e, t) {
            return this._client.post("/batches", {
                body: e,
                ...t
            })
        }
        retrieve(e, t) {
            return this._client.get(`/batches/${e}`, t)
        }
        list(e={}, t) {
            return jr(e) ? this.list({}, e) : this._client.getAPIList("/batches", wS, {
                query: e,
                ...t
            })
        }
        cancel(e, t) {
            return this._client.post(`/batches/${e}/cancel`, t)
        }
    }
    ;
    class wS extends jn {
    }
    yS.BatchesPage = wS;
    class bS extends st {
        create(e, t) {
            return this._client.post("/assistants", {
                body: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        retrieve(e, t) {
            return this._client.get(`/assistants/${e}`, {
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        update(e, t, r) {
            return this._client.post(`/assistants/${e}`, {
                body: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        list(e={}, t) {
            return jr(e) ? this.list({}, e) : this._client.getAPIList("/assistants", vS, {
                query: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        del(e, t) {
            return this._client.delete(`/assistants/${e}`, {
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
    }
    class vS extends jn {
    }
    bS.AssistantsPage = vS;
    function g1(n) {
        return typeof n.parse == "function"
    }
    const _u = n => (n == null ? void 0 : n.role) === "assistant"
      , y1 = n => (n == null ? void 0 : n.role) === "function"
      , w1 = n => (n == null ? void 0 : n.role) === "tool";
    var Dn = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, kt = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, _S, gw, yw, Ih, Oh, ww, Rh, zs, Mh, bw, vw, Su, b1;
    class v1 {
        constructor() {
            _S.add(this),
            this.controller = new AbortController,
            gw.set(this, void 0),
            yw.set(this, () => {}
            ),
            Ih.set(this, () => {}
            ),
            Oh.set(this, void 0),
            ww.set(this, () => {}
            ),
            Rh.set(this, () => {}
            ),
            zs.set(this, {}),
            Mh.set(this, !1),
            bw.set(this, !1),
            vw.set(this, !1),
            Su.set(this, !1),
            Dn(this, gw, new Promise( (e, t) => {
                Dn(this, yw, e, "f"),
                Dn(this, Ih, t, "f")
            }
            ), "f"),
            Dn(this, Oh, new Promise( (e, t) => {
                Dn(this, ww, e, "f"),
                Dn(this, Rh, t, "f")
            }
            ), "f"),
            kt(this, gw, "f").catch( () => {}
            ),
            kt(this, Oh, "f").catch( () => {}
            )
        }
        _run(e) {
            setTimeout( () => {
                e().then( () => {
                    this._emitFinal(),
                    this._emit("end")
                }
                , kt(this, _S, "m", b1).bind(this))
            }
            , 0)
        }
        _connected() {
            this.ended || (kt(this, yw, "f").call(this),
            this._emit("connect"))
        }
        get ended() {
            return kt(this, Mh, "f")
        }
        get errored() {
            return kt(this, bw, "f")
        }
        get aborted() {
            return kt(this, vw, "f")
        }
        abort() {
            this.controller.abort()
        }
        on(e, t) {
            return (kt(this, zs, "f")[e] || (kt(this, zs, "f")[e] = [])).push({
                listener: t
            }),
            this
        }
        off(e, t) {
            const r = kt(this, zs, "f")[e];
            if (!r)
                return this;
            const s = r.findIndex(i => i.listener === t);
            return s >= 0 && r.splice(s, 1),
            this
        }
        once(e, t) {
            return (kt(this, zs, "f")[e] || (kt(this, zs, "f")[e] = [])).push({
                listener: t,
                once: !0
            }),
            this
        }
        emitted(e) {
            return new Promise( (t, r) => {
                Dn(this, Su, !0, "f"),
                e !== "error" && this.once("error", r),
                this.once(e, t)
            }
            )
        }
        async done() {
            Dn(this, Su, !0, "f"),
            await kt(this, Oh, "f")
        }
        _emit(e, ...t) {
            if (kt(this, Mh, "f"))
                return;
            e === "end" && (Dn(this, Mh, !0, "f"),
            kt(this, ww, "f").call(this));
            const r = kt(this, zs, "f")[e];
            if (r && (kt(this, zs, "f")[e] = r.filter(s => !s.once),
            r.forEach( ({listener: s}) => s(...t))),
            e === "abort") {
                const s = t[0];
                !kt(this, Su, "f") && !(r != null && r.length) && Promise.reject(s),
                kt(this, Ih, "f").call(this, s),
                kt(this, Rh, "f").call(this, s),
                this._emit("end");
                return
            }
            if (e === "error") {
                const s = t[0];
                !kt(this, Su, "f") && !(r != null && r.length) && Promise.reject(s),
                kt(this, Ih, "f").call(this, s),
                kt(this, Rh, "f").call(this, s),
                this._emit("end")
            }
        }
        _emitFinal() {}
    }
    gw = new WeakMap,
    yw = new WeakMap,
    Ih = new WeakMap,
    Oh = new WeakMap,
    ww = new WeakMap,
    Rh = new WeakMap,
    zs = new WeakMap,
    Mh = new WeakMap,
    bw = new WeakMap,
    vw = new WeakMap,
    Su = new WeakMap,
    _S = new WeakSet,
    b1 = function(e) {
        if (Dn(this, bw, !0, "f"),
        e instanceof Error && e.name === "AbortError" && (e = new yn),
        e instanceof yn)
            return Dn(this, vw, !0, "f"),
            this._emit("abort", e);
        if (e instanceof qe)
            return this._emit("error", e);
        if (e instanceof Error) {
            const t = new qe(e.message);
            return t.cause = e,
            this._emit("error", t)
        }
        return this._emit("error", new qe(String(e)))
    }
    ;
    function GK(n, e) {
        const t = {
            ...n
        };
        return Object.defineProperties(t, {
            $brand: {
                value: "auto-parseable-response-format",
                enumerable: !1
            },
            $parseRaw: {
                value: e,
                enumerable: !1
            }
        }),
        t
    }
    function _1(n) {
        return (n == null ? void 0 : n.$brand) === "auto-parseable-response-format"
    }
    function JK(n, {parser: e, callback: t}) {
        const r = {
            ...n
        };
        return Object.defineProperties(r, {
            $brand: {
                value: "auto-parseable-tool",
                enumerable: !1
            },
            $parseRaw: {
                value: e,
                enumerable: !1
            },
            $callback: {
                value: t,
                enumerable: !1
            }
        }),
        r
    }
    function Nh(n) {
        return (n == null ? void 0 : n.$brand) === "auto-parseable-tool"
    }
    function ZK(n, e) {
        return !e || !S1(e) ? {
            ...n,
            choices: n.choices.map(t => ({
                ...t,
                message: {
                    ...t.message,
                    parsed: null,
                    tool_calls: t.message.tool_calls ?? []
                }
            }))
        } : SS(n, e)
    }
    function SS(n, e) {
        const t = n.choices.map(r => {
            var s;
            if (r.finish_reason === "length")
                throw new VI;
            if (r.finish_reason === "content_filter")
                throw new GI;
            return {
                ...r,
                message: {
                    ...r.message,
                    tool_calls: ((s = r.message.tool_calls) == null ? void 0 : s.map(i => YK(e, i))) ?? [],
                    parsed: r.message.content && !r.message.refusal ? XK(e, r.message.content) : null
                }
            }
        }
        );
        return {
            ...n,
            choices: t
        }
    }
    function XK(n, e) {
        var t, r;
        return ((t = n.response_format) == null ? void 0 : t.type) !== "json_schema" ? null : ((r = n.response_format) == null ? void 0 : r.type) === "json_schema" ? "$parseRaw"in n.response_format ? n.response_format.$parseRaw(e) : JSON.parse(e) : null
    }
    function YK(n, e) {
        var r;
        const t = (r = n.tools) == null ? void 0 : r.find(s => {
            var i;
            return ((i = s.function) == null ? void 0 : i.name) === e.function.name
        }
        );
        return {
            ...e,
            function: {
                ...e.function,
                parsed_arguments: Nh(t) ? t.$parseRaw(e.function.arguments) : t != null && t.function.strict ? JSON.parse(e.function.arguments) : null
            }
        }
    }
    function QK(n, e) {
        var r;
        if (!n)
            return !1;
        const t = (r = n.tools) == null ? void 0 : r.find(s => {
            var i;
            return ((i = s.function) == null ? void 0 : i.name) === e.function.name
        }
        );
        return Nh(t) || (t == null ? void 0 : t.function.strict) || !1
    }
    function S1(n) {
        var e;
        return _1(n.response_format) ? !0 : ((e = n.tools) == null ? void 0 : e.some(t => Nh(t) || t.type === "function" && t.function.strict === !0)) ?? !1
    }
    function eH(n) {
        for (const e of n ?? []) {
            if (e.type !== "function")
                throw new qe(`Currently only \`function\` tool types support auto-parsing; Received \`${e.type}\``);
            if (e.function.strict !== !0)
                throw new qe(`The \`${e.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`)
        }
    }
    var Dr = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, hr, ES, _w, xS, CS, kS, E1, PS;
    const x1 = 10;
    class C1 extends v1 {
        constructor() {
            super(...arguments),
            hr.add(this),
            this._chatCompletions = [],
            this.messages = []
        }
        _addChatCompletion(e) {
            var r;
            this._chatCompletions.push(e),
            this._emit("chatCompletion", e);
            const t = (r = e.choices[0]) == null ? void 0 : r.message;
            return t && this._addMessage(t),
            e
        }
        _addMessage(e, t=!0) {
            if ("content"in e || (e.content = null),
            this.messages.push(e),
            t) {
                if (this._emit("message", e),
                (y1(e) || w1(e)) && e.content)
                    this._emit("functionCallResult", e.content);
                else if (_u(e) && e.function_call)
                    this._emit("functionCall", e.function_call);
                else if (_u(e) && e.tool_calls)
                    for (const r of e.tool_calls)
                        r.type === "function" && this._emit("functionCall", r.function)
            }
        }
        async finalChatCompletion() {
            await this.done();
            const e = this._chatCompletions[this._chatCompletions.length - 1];
            if (!e)
                throw new qe("stream ended without producing a ChatCompletion");
            return e
        }
        async finalContent() {
            return await this.done(),
            Dr(this, hr, "m", ES).call(this)
        }
        async finalMessage() {
            return await this.done(),
            Dr(this, hr, "m", _w).call(this)
        }
        async finalFunctionCall() {
            return await this.done(),
            Dr(this, hr, "m", xS).call(this)
        }
        async finalFunctionCallResult() {
            return await this.done(),
            Dr(this, hr, "m", CS).call(this)
        }
        async totalUsage() {
            return await this.done(),
            Dr(this, hr, "m", kS).call(this)
        }
        allChatCompletions() {
            return [...this._chatCompletions]
        }
        _emitFinal() {
            const e = this._chatCompletions[this._chatCompletions.length - 1];
            e && this._emit("finalChatCompletion", e);
            const t = Dr(this, hr, "m", _w).call(this);
            t && this._emit("finalMessage", t);
            const r = Dr(this, hr, "m", ES).call(this);
            r && this._emit("finalContent", r);
            const s = Dr(this, hr, "m", xS).call(this);
            s && this._emit("finalFunctionCall", s);
            const i = Dr(this, hr, "m", CS).call(this);
            i != null && this._emit("finalFunctionCallResult", i),
            this._chatCompletions.some(a => a.usage) && this._emit("totalUsage", Dr(this, hr, "m", kS).call(this))
        }
        async _createChatCompletion(e, t, r) {
            const s = r == null ? void 0 : r.signal;
            s && (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort())),
            Dr(this, hr, "m", E1).call(this, t);
            const i = await e.chat.completions.create({
                ...t,
                stream: !1
            }, {
                ...r,
                signal: this.controller.signal
            });
            return this._connected(),
            this._addChatCompletion(SS(i, t))
        }
        async _runChatCompletion(e, t, r) {
            for (const s of t.messages)
                this._addMessage(s, !1);
            return await this._createChatCompletion(e, t, r)
        }
        async _runFunctions(e, t, r) {
            var f;
            const s = "function"
              , {function_call: i="auto", stream: a, ...c} = t
              , u = typeof i != "string" && (i == null ? void 0 : i.name)
              , {maxChatCompletions: l=x1} = r || {}
              , d = {};
            for (const p of t.functions)
                d[p.name || p.function.name] = p;
            const h = t.functions.map(p => ({
                name: p.name || p.function.name,
                parameters: p.parameters,
                description: p.description
            }));
            for (const p of t.messages)
                this._addMessage(p, !1);
            for (let p = 0; p < l; ++p) {
                const y = (f = (await this._createChatCompletion(e, {
                    ...c,
                    function_call: i,
                    functions: h,
                    messages: [...this.messages]
                }, r)).choices[0]) == null ? void 0 : f.message;
                if (!y)
                    throw new qe("missing message in ChatCompletion response");
                if (!y.function_call)
                    return;
                const {name: m, arguments: w} = y.function_call
                  , E = d[m];
                if (E) {
                    if (u && u !== m) {
                        const C = `Invalid function_call: ${JSON.stringify(m)}. ${JSON.stringify(u)} requested. Please try again`;
                        this._addMessage({
                            role: s,
                            name: m,
                            content: C
                        });
                        continue
                    }
                } else {
                    const C = `Invalid function_call: ${JSON.stringify(m)}. Available options are: ${h.map(k => JSON.stringify(k.name)).join(", ")}. Please try again`;
                    this._addMessage({
                        role: s,
                        name: m,
                        content: C
                    });
                    continue
                }
                let v;
                try {
                    v = g1(E) ? await E.parse(w) : w
                } catch (C) {
                    this._addMessage({
                        role: s,
                        name: m,
                        content: C instanceof Error ? C.message : String(C)
                    });
                    continue
                }
                const _ = await E.function(v, this)
                  , A = Dr(this, hr, "m", PS).call(this, _);
                if (this._addMessage({
                    role: s,
                    name: m,
                    content: A
                }),
                u)
                    return
            }
        }
        async _runTools(e, t, r) {
            var p, g, y;
            const s = "tool"
              , {tool_choice: i="auto", stream: a, ...c} = t
              , u = typeof i != "string" && ((p = i == null ? void 0 : i.function) == null ? void 0 : p.name)
              , {maxChatCompletions: l=x1} = r || {}
              , d = t.tools.map(m => {
                if (Nh(m)) {
                    if (!m.$callback)
                        throw new qe("Tool given to `.runTools()` that does not have an associated function");
                    return {
                        type: "function",
                        function: {
                            function: m.$callback,
                            name: m.function.name,
                            description: m.function.description || "",
                            parameters: m.function.parameters,
                            parse: m.$parseRaw,
                            strict: !0
                        }
                    }
                }
                return m
            }
            )
              , h = {};
            for (const m of d)
                m.type === "function" && (h[m.function.name || m.function.function.name] = m.function);
            const f = "tools"in t ? d.map(m => m.type === "function" ? {
                type: "function",
                function: {
                    name: m.function.name || m.function.function.name,
                    parameters: m.function.parameters,
                    description: m.function.description,
                    strict: m.function.strict
                }
            } : m) : void 0;
            for (const m of t.messages)
                this._addMessage(m, !1);
            for (let m = 0; m < l; ++m) {
                const E = (g = (await this._createChatCompletion(e, {
                    ...c,
                    tool_choice: i,
                    tools: f,
                    messages: [...this.messages]
                }, r)).choices[0]) == null ? void 0 : g.message;
                if (!E)
                    throw new qe("missing message in ChatCompletion response");
                if (!((y = E.tool_calls) != null && y.length))
                    return;
                for (const v of E.tool_calls) {
                    if (v.type !== "function")
                        continue;
                    const _ = v.id
                      , {name: A, arguments: C} = v.function
                      , k = h[A];
                    if (k) {
                        if (u && u !== A) {
                            const F = `Invalid tool_call: ${JSON.stringify(A)}. ${JSON.stringify(u)} requested. Please try again`;
                            this._addMessage({
                                role: s,
                                tool_call_id: _,
                                content: F
                            });
                            continue
                        }
                    } else {
                        const F = `Invalid tool_call: ${JSON.stringify(A)}. Available options are: ${Object.keys(h).map(O => JSON.stringify(O)).join(", ")}. Please try again`;
                        this._addMessage({
                            role: s,
                            tool_call_id: _,
                            content: F
                        });
                        continue
                    }
                    let x;
                    try {
                        x = g1(k) ? await k.parse(C) : C
                    } catch (F) {
                        const O = F instanceof Error ? F.message : String(F);
                        this._addMessage({
                            role: s,
                            tool_call_id: _,
                            content: O
                        });
                        continue
                    }
                    const N = await k.function(x, this)
                      , R = Dr(this, hr, "m", PS).call(this, N);
                    if (this._addMessage({
                        role: s,
                        tool_call_id: _,
                        content: R
                    }),
                    u)
                        return
                }
            }
        }
    }
    hr = new WeakSet,
    ES = function() {
        return Dr(this, hr, "m", _w).call(this).content ?? null
    }
    ,
    _w = function() {
        let e = this.messages.length;
        for (; e-- > 0; ) {
            const t = this.messages[e];
            if (_u(t)) {
                const {function_call: r, ...s} = t
                  , i = {
                    ...s,
                    content: t.content ?? null,
                    refusal: t.refusal ?? null
                };
                return r && (i.function_call = r),
                i
            }
        }
        throw new qe("stream ended without producing a ChatCompletionMessage with role=assistant")
    }
    ,
    xS = function() {
        var e, t;
        for (let r = this.messages.length - 1; r >= 0; r--) {
            const s = this.messages[r];
            if (_u(s) && (s != null && s.function_call))
                return s.function_call;
            if (_u(s) && ((e = s == null ? void 0 : s.tool_calls) != null && e.length))
                return (t = s.tool_calls.at(-1)) == null ? void 0 : t.function
        }
    }
    ,
    CS = function() {
        for (let e = this.messages.length - 1; e >= 0; e--) {
            const t = this.messages[e];
            if (y1(t) && t.content != null || w1(t) && t.content != null && typeof t.content == "string" && this.messages.some(r => {
                var s;
                return r.role === "assistant" && ((s = r.tool_calls) == null ? void 0 : s.some(i => i.type === "function" && i.id === t.tool_call_id))
            }
            ))
                return t.content
        }
    }
    ,
    kS = function() {
        const e = {
            completion_tokens: 0,
            prompt_tokens: 0,
            total_tokens: 0
        };
        for (const {usage: t} of this._chatCompletions)
            t && (e.completion_tokens += t.completion_tokens,
            e.prompt_tokens += t.prompt_tokens,
            e.total_tokens += t.total_tokens);
        return e
    }
    ,
    E1 = function(e) {
        if (e.n != null && e.n > 1)
            throw new qe("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.")
    }
    ,
    PS = function(e) {
        return typeof e == "string" ? e : e === void 0 ? "undefined" : JSON.stringify(e)
    }
    ;
    class $h extends C1 {
        static runFunctions(e, t, r) {
            const s = new $h
              , i = {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "runFunctions"
                }
            };
            return s._run( () => s._runFunctions(e, t, i)),
            s
        }
        static runTools(e, t, r) {
            const s = new $h
              , i = {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "runTools"
                }
            };
            return s._run( () => s._runTools(e, t, i)),
            s
        }
        _addMessage(e, t=!0) {
            super._addMessage(e, t),
            _u(e) && e.content && this._emit("content", e.content)
        }
    }
    const k1 = 1
      , P1 = 2
      , T1 = 4
      , A1 = 8
      , I1 = 16
      , O1 = 32
      , R1 = 64
      , M1 = 128
      , N1 = 256
      , $1 = M1 | N1
      , L1 = I1 | O1 | $1 | R1
      , F1 = k1 | P1 | L1
      , j1 = T1 | A1
      , tH = F1 | j1
      , Jt = {
        STR: k1,
        NUM: P1,
        ARR: T1,
        OBJ: A1,
        NULL: I1,
        BOOL: O1,
        NAN: R1,
        INFINITY: M1,
        MINUS_INFINITY: N1,
        INF: $1,
        SPECIAL: L1,
        ATOM: F1,
        COLLECTION: j1,
        ALL: tH
    };
    class rH extends Error {
    }
    class nH extends Error {
    }
    function sH(n, e=Jt.ALL) {
        if (typeof n != "string")
            throw new TypeError(`expecting str, got ${typeof n}`);
        if (!n.trim())
            throw new Error(`${n} is empty`);
        return iH(n.trim(), e)
    }
    const iH = (n, e) => {
        const t = n.length;
        let r = 0;
        const s = f => {
            throw new rH(`${f} at position ${r}`)
        }
          , i = f => {
            throw new nH(`${f} at position ${r}`)
        }
          , a = () => (h(),
        r >= t && s("Unexpected end of input"),
        n[r] === '"' ? c() : n[r] === "{" ? u() : n[r] === "[" ? l() : n.substring(r, r + 4) === "null" || Jt.NULL & e && t - r < 4 && "null".startsWith(n.substring(r)) ? (r += 4,
        null) : n.substring(r, r + 4) === "true" || Jt.BOOL & e && t - r < 4 && "true".startsWith(n.substring(r)) ? (r += 4,
        !0) : n.substring(r, r + 5) === "false" || Jt.BOOL & e && t - r < 5 && "false".startsWith(n.substring(r)) ? (r += 5,
        !1) : n.substring(r, r + 8) === "Infinity" || Jt.INFINITY & e && t - r < 8 && "Infinity".startsWith(n.substring(r)) ? (r += 8,
        1 / 0) : n.substring(r, r + 9) === "-Infinity" || Jt.MINUS_INFINITY & e && 1 < t - r && t - r < 9 && "-Infinity".startsWith(n.substring(r)) ? (r += 9,
        -1 / 0) : n.substring(r, r + 3) === "NaN" || Jt.NAN & e && t - r < 3 && "NaN".startsWith(n.substring(r)) ? (r += 3,
        NaN) : d())
          , c = () => {
            const f = r;
            let p = !1;
            for (r++; r < t && (n[r] !== '"' || p && n[r - 1] === "\\"); )
                p = n[r] === "\\" ? !p : !1,
                r++;
            if (n.charAt(r) == '"')
                try {
                    return JSON.parse(n.substring(f, ++r - Number(p)))
                } catch (g) {
                    i(String(g))
                }
            else if (Jt.STR & e)
                try {
                    return JSON.parse(n.substring(f, r - Number(p)) + '"')
                } catch {
                    return JSON.parse(n.substring(f, n.lastIndexOf("\\")) + '"')
                }
            s("Unterminated string literal")
        }
          , u = () => {
            r++,
            h();
            const f = {};
            try {
                for (; n[r] !== "}"; ) {
                    if (h(),
                    r >= t && Jt.OBJ & e)
                        return f;
                    const p = c();
                    h(),
                    r++;
                    try {
                        const g = a();
                        Object.defineProperty(f, p, {
                            value: g,
                            writable: !0,
                            enumerable: !0,
                            configurable: !0
                        })
                    } catch (g) {
                        if (Jt.OBJ & e)
                            return f;
                        throw g
                    }
                    h(),
                    n[r] === "," && r++
                }
            } catch {
                if (Jt.OBJ & e)
                    return f;
                s("Expected '}' at end of object")
            }
            return r++,
            f
        }
          , l = () => {
            r++;
            const f = [];
            try {
                for (; n[r] !== "]"; )
                    f.push(a()),
                    h(),
                    n[r] === "," && r++
            } catch {
                if (Jt.ARR & e)
                    return f;
                s("Expected ']' at end of array")
            }
            return r++,
            f
        }
          , d = () => {
            if (r === 0) {
                n === "-" && Jt.NUM & e && s("Not sure what '-' is");
                try {
                    return JSON.parse(n)
                } catch (p) {
                    if (Jt.NUM & e)
                        try {
                            return n[n.length - 1] === "." ? JSON.parse(n.substring(0, n.lastIndexOf("."))) : JSON.parse(n.substring(0, n.lastIndexOf("e")))
                        } catch {}
                    i(String(p))
                }
            }
            const f = r;
            for (n[r] === "-" && r++; n[r] && !",]}".includes(n[r]); )
                r++;
            r == t && !(Jt.NUM & e) && s("Unterminated number literal");
            try {
                return JSON.parse(n.substring(f, r))
            } catch {
                n.substring(f, r) === "-" && Jt.NUM & e && s("Not sure what '-' is");
                try {
                    return JSON.parse(n.substring(f, n.lastIndexOf("e")))
                } catch (g) {
                    i(String(g))
                }
            }
        }
          , h = () => {
            for (; r < t && ` 
\r	`.includes(n[r]); )
                r++
        }
        ;
        return a()
    }
      , D1 = n => sH(n, Jt.ALL ^ Jt.NUM);
    var Eu = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, lt = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, Bt, Vs, xu, Wi, TS, Sw, AS, IS, OS, Ew, RS, B1;
    class Lh extends C1 {
        constructor(e) {
            super(),
            Bt.add(this),
            Vs.set(this, void 0),
            xu.set(this, void 0),
            Wi.set(this, void 0),
            Eu(this, Vs, e, "f"),
            Eu(this, xu, [], "f")
        }
        get currentChatCompletionSnapshot() {
            return lt(this, Wi, "f")
        }
        static fromReadableStream(e) {
            const t = new Lh(null);
            return t._run( () => t._fromReadableStream(e)),
            t
        }
        static createChatCompletion(e, t, r) {
            const s = new Lh(t);
            return s._run( () => s._runChatCompletion(e, {
                ...t,
                stream: !0
            }, {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "stream"
                }
            })),
            s
        }
        async _createChatCompletion(e, t, r) {
            var a;
            super._createChatCompletion;
            const s = r == null ? void 0 : r.signal;
            s && (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort())),
            lt(this, Bt, "m", TS).call(this);
            const i = await e.chat.completions.create({
                ...t,
                stream: !0
            }, {
                ...r,
                signal: this.controller.signal
            });
            this._connected();
            for await(const c of i)
                lt(this, Bt, "m", AS).call(this, c);
            if ((a = i.controller.signal) != null && a.aborted)
                throw new yn;
            return this._addChatCompletion(lt(this, Bt, "m", Ew).call(this))
        }
        async _fromReadableStream(e, t) {
            var a;
            const r = t == null ? void 0 : t.signal;
            r && (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            lt(this, Bt, "m", TS).call(this),
            this._connected();
            const s = Ph.fromReadableStream(e, this.controller);
            let i;
            for await(const c of s)
                i && i !== c.id && this._addChatCompletion(lt(this, Bt, "m", Ew).call(this)),
                lt(this, Bt, "m", AS).call(this, c),
                i = c.id;
            if ((a = s.controller.signal) != null && a.aborted)
                throw new yn;
            return this._addChatCompletion(lt(this, Bt, "m", Ew).call(this))
        }
        [(Vs = new WeakMap,
        xu = new WeakMap,
        Wi = new WeakMap,
        Bt = new WeakSet,
        TS = function() {
            this.ended || Eu(this, Wi, void 0, "f")
        }
        ,
        Sw = function(t) {
            let r = lt(this, xu, "f")[t.index];
            return r || (r = {
                content_done: !1,
                refusal_done: !1,
                logprobs_content_done: !1,
                logprobs_refusal_done: !1,
                done_tool_calls: new Set,
                current_tool_call_index: null
            },
            lt(this, xu, "f")[t.index] = r,
            r)
        }
        ,
        AS = function(t) {
            var s, i, a, c, u, l, d, h, f, p, g, y, m, w, E;
            if (this.ended)
                return;
            const r = lt(this, Bt, "m", B1).call(this, t);
            this._emit("chunk", t, r);
            for (const v of t.choices) {
                const _ = r.choices[v.index];
                v.delta.content != null && ((s = _.message) == null ? void 0 : s.role) === "assistant" && ((i = _.message) != null && i.content) && (this._emit("content", v.delta.content, _.message.content),
                this._emit("content.delta", {
                    delta: v.delta.content,
                    snapshot: _.message.content,
                    parsed: _.message.parsed
                })),
                v.delta.refusal != null && ((a = _.message) == null ? void 0 : a.role) === "assistant" && ((c = _.message) != null && c.refusal) && this._emit("refusal.delta", {
                    delta: v.delta.refusal,
                    snapshot: _.message.refusal
                }),
                ((u = v.logprobs) == null ? void 0 : u.content) != null && ((l = _.message) == null ? void 0 : l.role) === "assistant" && this._emit("logprobs.content.delta", {
                    content: (d = v.logprobs) == null ? void 0 : d.content,
                    snapshot: ((h = _.logprobs) == null ? void 0 : h.content) ?? []
                }),
                ((f = v.logprobs) == null ? void 0 : f.refusal) != null && ((p = _.message) == null ? void 0 : p.role) === "assistant" && this._emit("logprobs.refusal.delta", {
                    refusal: (g = v.logprobs) == null ? void 0 : g.refusal,
                    snapshot: ((y = _.logprobs) == null ? void 0 : y.refusal) ?? []
                });
                const A = lt(this, Bt, "m", Sw).call(this, _);
                _.finish_reason && (lt(this, Bt, "m", OS).call(this, _),
                A.current_tool_call_index != null && lt(this, Bt, "m", IS).call(this, _, A.current_tool_call_index));
                for (const C of v.delta.tool_calls ?? [])
                    A.current_tool_call_index !== C.index && (lt(this, Bt, "m", OS).call(this, _),
                    A.current_tool_call_index != null && lt(this, Bt, "m", IS).call(this, _, A.current_tool_call_index)),
                    A.current_tool_call_index = C.index;
                for (const C of v.delta.tool_calls ?? []) {
                    const k = (m = _.message.tool_calls) == null ? void 0 : m[C.index];
                    k != null && k.type && ((k == null ? void 0 : k.type) === "function" ? this._emit("tool_calls.function.arguments.delta", {
                        name: (w = k.function) == null ? void 0 : w.name,
                        index: C.index,
                        arguments: k.function.arguments,
                        parsed_arguments: k.function.parsed_arguments,
                        arguments_delta: ((E = C.function) == null ? void 0 : E.arguments) ?? ""
                    }) : (k == null || k.type,
                    void 0))
                }
            }
        }
        ,
        IS = function(t, r) {
            var a, c, u;
            if (lt(this, Bt, "m", Sw).call(this, t).done_tool_calls.has(r))
                return;
            const i = (a = t.message.tool_calls) == null ? void 0 : a[r];
            if (!i)
                throw new Error("no tool call snapshot");
            if (!i.type)
                throw new Error("tool call snapshot missing `type`");
            if (i.type === "function") {
                const l = (u = (c = lt(this, Vs, "f")) == null ? void 0 : c.tools) == null ? void 0 : u.find(d => d.type === "function" && d.function.name === i.function.name);
                this._emit("tool_calls.function.arguments.done", {
                    name: i.function.name,
                    index: r,
                    arguments: i.function.arguments,
                    parsed_arguments: Nh(l) ? l.$parseRaw(i.function.arguments) : l != null && l.function.strict ? JSON.parse(i.function.arguments) : null
                })
            } else
                i.type
        }
        ,
        OS = function(t) {
            var s, i;
            const r = lt(this, Bt, "m", Sw).call(this, t);
            if (t.message.content && !r.content_done) {
                r.content_done = !0;
                const a = lt(this, Bt, "m", RS).call(this);
                this._emit("content.done", {
                    content: t.message.content,
                    parsed: a ? a.$parseRaw(t.message.content) : null
                })
            }
            t.message.refusal && !r.refusal_done && (r.refusal_done = !0,
            this._emit("refusal.done", {
                refusal: t.message.refusal
            })),
            (s = t.logprobs) != null && s.content && !r.logprobs_content_done && (r.logprobs_content_done = !0,
            this._emit("logprobs.content.done", {
                content: t.logprobs.content
            })),
            (i = t.logprobs) != null && i.refusal && !r.logprobs_refusal_done && (r.logprobs_refusal_done = !0,
            this._emit("logprobs.refusal.done", {
                refusal: t.logprobs.refusal
            }))
        }
        ,
        Ew = function() {
            if (this.ended)
                throw new qe("stream has ended, this shouldn't happen");
            const t = lt(this, Wi, "f");
            if (!t)
                throw new qe("request ended without sending any chunks");
            return Eu(this, Wi, void 0, "f"),
            Eu(this, xu, [], "f"),
            aH(t, lt(this, Vs, "f"))
        }
        ,
        RS = function() {
            var r;
            const t = (r = lt(this, Vs, "f")) == null ? void 0 : r.response_format;
            return _1(t) ? t : null
        }
        ,
        B1 = function(t) {
            var r, s, i, a;
            let c = lt(this, Wi, "f");
            const {choices: u, ...l} = t;
            c ? Object.assign(c, l) : c = Eu(this, Wi, {
                ...l,
                choices: []
            }, "f");
            for (const {delta: d, finish_reason: h, index: f, logprobs: p=null, ...g} of t.choices) {
                let y = c.choices[f];
                if (y || (y = c.choices[f] = {
                    finish_reason: h,
                    index: f,
                    message: {},
                    logprobs: p,
                    ...g
                }),
                p)
                    if (!y.logprobs)
                        y.logprobs = Object.assign({}, p);
                    else {
                        const {content: C, refusal: k, ...x} = p;
                        Object.assign(y.logprobs, x),
                        C && ((r = y.logprobs).content ?? (r.content = []),
                        y.logprobs.content.push(...C)),
                        k && ((s = y.logprobs).refusal ?? (s.refusal = []),
                        y.logprobs.refusal.push(...k))
                    }
                if (h && (y.finish_reason = h,
                lt(this, Vs, "f") && S1(lt(this, Vs, "f")))) {
                    if (h === "length")
                        throw new VI;
                    if (h === "content_filter")
                        throw new GI
                }
                if (Object.assign(y, g),
                !d)
                    continue;
                const {content: m, refusal: w, function_call: E, role: v, tool_calls: _, ...A} = d;
                if (Object.assign(y.message, A),
                w && (y.message.refusal = (y.message.refusal || "") + w),
                v && (y.message.role = v),
                E && (y.message.function_call ? (E.name && (y.message.function_call.name = E.name),
                E.arguments && ((i = y.message.function_call).arguments ?? (i.arguments = ""),
                y.message.function_call.arguments += E.arguments)) : y.message.function_call = E),
                m && (y.message.content = (y.message.content || "") + m,
                !y.message.refusal && lt(this, Bt, "m", RS).call(this) && (y.message.parsed = D1(y.message.content))),
                _) {
                    y.message.tool_calls || (y.message.tool_calls = []);
                    for (const {index: C, id: k, type: x, function: N, ...R} of _) {
                        const F = (a = y.message.tool_calls)[C] ?? (a[C] = {});
                        Object.assign(F, R),
                        k && (F.id = k),
                        x && (F.type = x),
                        N && (F.function ?? (F.function = {
                            name: N.name ?? "",
                            arguments: ""
                        })),
                        N != null && N.name && (F.function.name = N.name),
                        N != null && N.arguments && (F.function.arguments += N.arguments,
                        QK(lt(this, Vs, "f"), F) && (F.function.parsed_arguments = D1(F.function.arguments)))
                    }
                }
            }
            return c
        }
        ,
        Symbol.asyncIterator)]() {
            const e = []
              , t = [];
            let r = !1;
            return this.on("chunk", s => {
                const i = t.shift();
                i ? i.resolve(s) : e.push(s)
            }
            ),
            this.on("end", () => {
                r = !0;
                for (const s of t)
                    s.resolve(void 0);
                t.length = 0
            }
            ),
            this.on("abort", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            this.on("error", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            {
                next: async () => e.length ? {
                    value: e.shift(),
                    done: !1
                } : r ? {
                    value: void 0,
                    done: !0
                } : new Promise( (i, a) => t.push({
                    resolve: i,
                    reject: a
                })).then(i => i ? {
                    value: i,
                    done: !1
                } : {
                    value: void 0,
                    done: !0
                }),
                return: async () => (this.abort(),
                {
                    value: void 0,
                    done: !0
                })
            }
        }
        toReadableStream() {
            return new Ph(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()
        }
    }
    function aH(n, e) {
        const {id: t, choices: r, created: s, model: i, system_fingerprint: a, ...c} = n
          , u = {
            ...c,
            id: t,
            choices: r.map( ({message: l, finish_reason: d, index: h, logprobs: f, ...p}) => {
                if (!d)
                    throw new qe(`missing finish_reason for choice ${h}`);
                const {content: g=null, function_call: y, tool_calls: m, ...w} = l
                  , E = l.role;
                if (!E)
                    throw new qe(`missing role for choice ${h}`);
                if (y) {
                    const {arguments: v, name: _} = y;
                    if (v == null)
                        throw new qe(`missing function_call.arguments for choice ${h}`);
                    if (!_)
                        throw new qe(`missing function_call.name for choice ${h}`);
                    return {
                        ...p,
                        message: {
                            content: g,
                            function_call: {
                                arguments: v,
                                name: _
                            },
                            role: E,
                            refusal: l.refusal ?? null
                        },
                        finish_reason: d,
                        index: h,
                        logprobs: f
                    }
                }
                return m ? {
                    ...p,
                    index: h,
                    finish_reason: d,
                    logprobs: f,
                    message: {
                        ...w,
                        role: E,
                        content: g,
                        refusal: l.refusal ?? null,
                        tool_calls: m.map( (v, _) => {
                            const {function: A, type: C, id: k, ...x} = v
                              , {arguments: N, name: R, ...F} = A || {};
                            if (k == null)
                                throw new qe(`missing choices[${h}].tool_calls[${_}].id
${xw(n)}`);
                            if (C == null)
                                throw new qe(`missing choices[${h}].tool_calls[${_}].type
${xw(n)}`);
                            if (R == null)
                                throw new qe(`missing choices[${h}].tool_calls[${_}].function.name
${xw(n)}`);
                            if (N == null)
                                throw new qe(`missing choices[${h}].tool_calls[${_}].function.arguments
${xw(n)}`);
                            return {
                                ...x,
                                id: k,
                                type: C,
                                function: {
                                    ...F,
                                    name: R,
                                    arguments: N
                                }
                            }
                        }
                        )
                    }
                } : {
                    ...p,
                    message: {
                        ...w,
                        content: g,
                        role: E,
                        refusal: l.refusal ?? null
                    },
                    finish_reason: d,
                    index: h,
                    logprobs: f
                }
            }
            ),
            created: s,
            model: i,
            object: "chat.completion",
            ...a ? {
                system_fingerprint: a
            } : {}
        };
        return ZK(u, e)
    }
    function xw(n) {
        return JSON.stringify(n)
    }
    function M9(n) {}
    class Cu extends Lh {
        static fromReadableStream(e) {
            const t = new Cu(null);
            return t._run( () => t._fromReadableStream(e)),
            t
        }
        static runFunctions(e, t, r) {
            const s = new Cu(null)
              , i = {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "runFunctions"
                }
            };
            return s._run( () => s._runFunctions(e, t, i)),
            s
        }
        static runTools(e, t, r) {
            const s = new Cu(t)
              , i = {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "runTools"
                }
            };
            return s._run( () => s._runTools(e, t, i)),
            s
        }
    }
    let q1 = class extends st {
        parse(e, t) {
            return eH(e.tools),
            this._client.chat.completions.create(e, {
                ...t,
                headers: {
                    ...t == null ? void 0 : t.headers,
                    "X-Stainless-Helper-Method": "beta.chat.completions.parse"
                }
            })._thenUnwrap(r => SS(r, e))
        }
        runFunctions(e, t) {
            return e.stream ? Cu.runFunctions(this._client, e, t) : $h.runFunctions(this._client, e, t)
        }
        runTools(e, t) {
            return e.stream ? Cu.runTools(this._client, e, t) : $h.runTools(this._client, e, t)
        }
        stream(e, t) {
            return Lh.createChatCompletion(this._client, e, t)
        }
    }
    ;
    class MS extends st {
        constructor() {
            super(...arguments),
            this.completions = new q1(this._client)
        }
    }
    (function(n) {
        n.Completions = q1
    }
    )(MS || (MS = {}));
    class U1 extends st {
        create(e, t) {
            return this._client.post("/realtime/sessions", {
                body: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
    }
    class NS extends st {
        constructor() {
            super(...arguments),
            this.sessions = new U1(this._client)
        }
    }
    NS.Sessions = U1;
    var Ee = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, en = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, cr, $S, ws, Cw, Bn, co, ku, uo, kw, tn, Pw, Tw, Fh, jh, Dh, K1, H1, W1, z1, V1, G1, J1;
    class qn extends v1 {
        constructor() {
            super(...arguments),
            cr.add(this),
            $S.set(this, []),
            ws.set(this, {}),
            Cw.set(this, {}),
            Bn.set(this, void 0),
            co.set(this, void 0),
            ku.set(this, void 0),
            uo.set(this, void 0),
            kw.set(this, void 0),
            tn.set(this, void 0),
            Pw.set(this, void 0),
            Tw.set(this, void 0),
            Fh.set(this, void 0)
        }
        [($S = new WeakMap,
        ws = new WeakMap,
        Cw = new WeakMap,
        Bn = new WeakMap,
        co = new WeakMap,
        ku = new WeakMap,
        uo = new WeakMap,
        kw = new WeakMap,
        tn = new WeakMap,
        Pw = new WeakMap,
        Tw = new WeakMap,
        Fh = new WeakMap,
        cr = new WeakSet,
        Symbol.asyncIterator)]() {
            const e = []
              , t = [];
            let r = !1;
            return this.on("event", s => {
                const i = t.shift();
                i ? i.resolve(s) : e.push(s)
            }
            ),
            this.on("end", () => {
                r = !0;
                for (const s of t)
                    s.resolve(void 0);
                t.length = 0
            }
            ),
            this.on("abort", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            this.on("error", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            {
                next: async () => e.length ? {
                    value: e.shift(),
                    done: !1
                } : r ? {
                    value: void 0,
                    done: !0
                } : new Promise( (i, a) => t.push({
                    resolve: i,
                    reject: a
                })).then(i => i ? {
                    value: i,
                    done: !1
                } : {
                    value: void 0,
                    done: !0
                }),
                return: async () => (this.abort(),
                {
                    value: void 0,
                    done: !0
                })
            }
        }
        static fromReadableStream(e) {
            const t = new qn;
            return t._run( () => t._fromReadableStream(e)),
            t
        }
        async _fromReadableStream(e, t) {
            var i;
            const r = t == null ? void 0 : t.signal;
            r && (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            this._connected();
            const s = Ph.fromReadableStream(e, this.controller);
            for await(const a of s)
                Ee(this, cr, "m", jh).call(this, a);
            if ((i = s.controller.signal) != null && i.aborted)
                throw new yn;
            return this._addRun(Ee(this, cr, "m", Dh).call(this))
        }
        toReadableStream() {
            return new Ph(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()
        }
        static createToolAssistantStream(e, t, r, s, i) {
            const a = new qn;
            return a._run( () => a._runToolAssistantStream(e, t, r, s, {
                ...i,
                headers: {
                    ...i == null ? void 0 : i.headers,
                    "X-Stainless-Helper-Method": "stream"
                }
            })),
            a
        }
        async _createToolAssistantStream(e, t, r, s, i) {
            var l;
            const a = i == null ? void 0 : i.signal;
            a && (a.aborted && this.controller.abort(),
            a.addEventListener("abort", () => this.controller.abort()));
            const c = {
                ...s,
                stream: !0
            }
              , u = await e.submitToolOutputs(t, r, c, {
                ...i,
                signal: this.controller.signal
            });
            this._connected();
            for await(const d of u)
                Ee(this, cr, "m", jh).call(this, d);
            if ((l = u.controller.signal) != null && l.aborted)
                throw new yn;
            return this._addRun(Ee(this, cr, "m", Dh).call(this))
        }
        static createThreadAssistantStream(e, t, r) {
            const s = new qn;
            return s._run( () => s._threadAssistantStream(e, t, {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "stream"
                }
            })),
            s
        }
        static createAssistantStream(e, t, r, s) {
            const i = new qn;
            return i._run( () => i._runAssistantStream(e, t, r, {
                ...s,
                headers: {
                    ...s == null ? void 0 : s.headers,
                    "X-Stainless-Helper-Method": "stream"
                }
            })),
            i
        }
        currentEvent() {
            return Ee(this, Pw, "f")
        }
        currentRun() {
            return Ee(this, Tw, "f")
        }
        currentMessageSnapshot() {
            return Ee(this, Bn, "f")
        }
        currentRunStepSnapshot() {
            return Ee(this, Fh, "f")
        }
        async finalRunSteps() {
            return await this.done(),
            Object.values(Ee(this, ws, "f"))
        }
        async finalMessages() {
            return await this.done(),
            Object.values(Ee(this, Cw, "f"))
        }
        async finalRun() {
            if (await this.done(),
            !Ee(this, co, "f"))
                throw Error("Final run was not received.");
            return Ee(this, co, "f")
        }
        async _createThreadAssistantStream(e, t, r) {
            var c;
            const s = r == null ? void 0 : r.signal;
            s && (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort()));
            const i = {
                ...t,
                stream: !0
            }
              , a = await e.createAndRun(i, {
                ...r,
                signal: this.controller.signal
            });
            this._connected();
            for await(const u of a)
                Ee(this, cr, "m", jh).call(this, u);
            if ((c = a.controller.signal) != null && c.aborted)
                throw new yn;
            return this._addRun(Ee(this, cr, "m", Dh).call(this))
        }
        async _createAssistantStream(e, t, r, s) {
            var u;
            const i = s == null ? void 0 : s.signal;
            i && (i.aborted && this.controller.abort(),
            i.addEventListener("abort", () => this.controller.abort()));
            const a = {
                ...r,
                stream: !0
            }
              , c = await e.create(t, a, {
                ...s,
                signal: this.controller.signal
            });
            this._connected();
            for await(const l of c)
                Ee(this, cr, "m", jh).call(this, l);
            if ((u = c.controller.signal) != null && u.aborted)
                throw new yn;
            return this._addRun(Ee(this, cr, "m", Dh).call(this))
        }
        static accumulateDelta(e, t) {
            for (const [r,s] of Object.entries(t)) {
                if (!e.hasOwnProperty(r)) {
                    e[r] = s;
                    continue
                }
                let i = e[r];
                if (i == null) {
                    e[r] = s;
                    continue
                }
                if (r === "index" || r === "type") {
                    e[r] = s;
                    continue
                }
                if (typeof i == "string" && typeof s == "string")
                    i += s;
                else if (typeof i == "number" && typeof s == "number")
                    i += s;
                else if (mS(i) && mS(s))
                    i = this.accumulateDelta(i, s);
                else if (Array.isArray(i) && Array.isArray(s)) {
                    if (i.every(a => typeof a == "string" || typeof a == "number")) {
                        i.push(...s);
                        continue
                    }
                    for (const a of s) {
                        if (!mS(a))
                            throw new Error(`Expected array delta entry to be an object but got: ${a}`);
                        const c = a.index;
                        if (c == null)
                            throw console.error(a),
                            new Error("Expected array delta entry to have an `index` property");
                        if (typeof c != "number")
                            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${c}`);
                        const u = i[c];
                        u == null ? i.push(a) : i[c] = this.accumulateDelta(u, a)
                    }
                    continue
                } else
                    throw Error(`Unhandled record type: ${r}, deltaValue: ${s}, accValue: ${i}`);
                e[r] = i
            }
            return e
        }
        _addRun(e) {
            return e
        }
        async _threadAssistantStream(e, t, r) {
            return await this._createThreadAssistantStream(t, e, r)
        }
        async _runAssistantStream(e, t, r, s) {
            return await this._createAssistantStream(t, e, r, s)
        }
        async _runToolAssistantStream(e, t, r, s, i) {
            return await this._createToolAssistantStream(r, e, t, s, i)
        }
    }
    jh = function(e) {
        if (!this.ended)
            switch (en(this, Pw, e, "f"),
            Ee(this, cr, "m", W1).call(this, e),
            e.event) {
            case "thread.created":
                break;
            case "thread.run.created":
            case "thread.run.queued":
            case "thread.run.in_progress":
            case "thread.run.requires_action":
            case "thread.run.completed":
            case "thread.run.failed":
            case "thread.run.cancelling":
            case "thread.run.cancelled":
            case "thread.run.expired":
                Ee(this, cr, "m", J1).call(this, e);
                break;
            case "thread.run.step.created":
            case "thread.run.step.in_progress":
            case "thread.run.step.delta":
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
                Ee(this, cr, "m", H1).call(this, e);
                break;
            case "thread.message.created":
            case "thread.message.in_progress":
            case "thread.message.delta":
            case "thread.message.completed":
            case "thread.message.incomplete":
                Ee(this, cr, "m", K1).call(this, e);
                break;
            case "error":
                throw new Error("Encountered an error event in event processing - errors should be processed earlier")
            }
    }
    ,
    Dh = function() {
        if (this.ended)
            throw new qe("stream has ended, this shouldn't happen");
        if (!Ee(this, co, "f"))
            throw Error("Final run has not been received");
        return Ee(this, co, "f")
    }
    ,
    K1 = function(e) {
        const [t,r] = Ee(this, cr, "m", V1).call(this, e, Ee(this, Bn, "f"));
        en(this, Bn, t, "f"),
        Ee(this, Cw, "f")[t.id] = t;
        for (const s of r) {
            const i = t.content[s.index];
            (i == null ? void 0 : i.type) == "text" && this._emit("textCreated", i.text)
        }
        switch (e.event) {
        case "thread.message.created":
            this._emit("messageCreated", e.data);
            break;
        case "thread.message.in_progress":
            break;
        case "thread.message.delta":
            if (this._emit("messageDelta", e.data.delta, t),
            e.data.delta.content)
                for (const s of e.data.delta.content) {
                    if (s.type == "text" && s.text) {
                        let i = s.text
                          , a = t.content[s.index];
                        if (a && a.type == "text")
                            this._emit("textDelta", i, a.text);
                        else
                            throw Error("The snapshot associated with this text delta is not text or missing")
                    }
                    if (s.index != Ee(this, ku, "f")) {
                        if (Ee(this, uo, "f"))
                            switch (Ee(this, uo, "f").type) {
                            case "text":
                                this._emit("textDone", Ee(this, uo, "f").text, Ee(this, Bn, "f"));
                                break;
                            case "image_file":
                                this._emit("imageFileDone", Ee(this, uo, "f").image_file, Ee(this, Bn, "f"));
                                break
                            }
                        en(this, ku, s.index, "f")
                    }
                    en(this, uo, t.content[s.index], "f")
                }
            break;
        case "thread.message.completed":
        case "thread.message.incomplete":
            if (Ee(this, ku, "f") !== void 0) {
                const s = e.data.content[Ee(this, ku, "f")];
                if (s)
                    switch (s.type) {
                    case "image_file":
                        this._emit("imageFileDone", s.image_file, Ee(this, Bn, "f"));
                        break;
                    case "text":
                        this._emit("textDone", s.text, Ee(this, Bn, "f"));
                        break
                    }
            }
            Ee(this, Bn, "f") && this._emit("messageDone", e.data),
            en(this, Bn, void 0, "f")
        }
    }
    ,
    H1 = function(e) {
        const t = Ee(this, cr, "m", z1).call(this, e);
        switch (en(this, Fh, t, "f"),
        e.event) {
        case "thread.run.step.created":
            this._emit("runStepCreated", e.data);
            break;
        case "thread.run.step.delta":
            const r = e.data.delta;
            if (r.step_details && r.step_details.type == "tool_calls" && r.step_details.tool_calls && t.step_details.type == "tool_calls")
                for (const i of r.step_details.tool_calls)
                    i.index == Ee(this, kw, "f") ? this._emit("toolCallDelta", i, t.step_details.tool_calls[i.index]) : (Ee(this, tn, "f") && this._emit("toolCallDone", Ee(this, tn, "f")),
                    en(this, kw, i.index, "f"),
                    en(this, tn, t.step_details.tool_calls[i.index], "f"),
                    Ee(this, tn, "f") && this._emit("toolCallCreated", Ee(this, tn, "f")));
            this._emit("runStepDelta", e.data.delta, t);
            break;
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
            en(this, Fh, void 0, "f"),
            e.data.step_details.type == "tool_calls" && Ee(this, tn, "f") && (this._emit("toolCallDone", Ee(this, tn, "f")),
            en(this, tn, void 0, "f")),
            this._emit("runStepDone", e.data, t);
            break
        }
    }
    ,
    W1 = function(e) {
        Ee(this, $S, "f").push(e),
        this._emit("event", e)
    }
    ,
    z1 = function(e) {
        switch (e.event) {
        case "thread.run.step.created":
            return Ee(this, ws, "f")[e.data.id] = e.data,
            e.data;
        case "thread.run.step.delta":
            let t = Ee(this, ws, "f")[e.data.id];
            if (!t)
                throw Error("Received a RunStepDelta before creation of a snapshot");
            let r = e.data;
            if (r.delta) {
                const s = qn.accumulateDelta(t, r.delta);
                Ee(this, ws, "f")[e.data.id] = s
            }
            return Ee(this, ws, "f")[e.data.id];
        case "thread.run.step.completed":
        case "thread.run.step.failed":
        case "thread.run.step.cancelled":
        case "thread.run.step.expired":
        case "thread.run.step.in_progress":
            Ee(this, ws, "f")[e.data.id] = e.data;
            break
        }
        if (Ee(this, ws, "f")[e.data.id])
            return Ee(this, ws, "f")[e.data.id];
        throw new Error("No snapshot available")
    }
    ,
    V1 = function(e, t) {
        let r = [];
        switch (e.event) {
        case "thread.message.created":
            return [e.data, r];
        case "thread.message.delta":
            if (!t)
                throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
            let s = e.data;
            if (s.delta.content)
                for (const i of s.delta.content)
                    if (i.index in t.content) {
                        let a = t.content[i.index];
                        t.content[i.index] = Ee(this, cr, "m", G1).call(this, i, a)
                    } else
                        t.content[i.index] = i,
                        r.push(i);
            return [t, r];
        case "thread.message.in_progress":
        case "thread.message.completed":
        case "thread.message.incomplete":
            if (t)
                return [t, r];
            throw Error("Received thread message event with no existing snapshot")
        }
        throw Error("Tried to accumulate a non-message event")
    }
    ,
    G1 = function(e, t) {
        return qn.accumulateDelta(t, e)
    }
    ,
    J1 = function(e) {
        switch (en(this, Tw, e.data, "f"),
        e.event) {
        case "thread.run.created":
            break;
        case "thread.run.queued":
            break;
        case "thread.run.in_progress":
            break;
        case "thread.run.requires_action":
        case "thread.run.cancelled":
        case "thread.run.failed":
        case "thread.run.completed":
        case "thread.run.expired":
            en(this, co, e.data, "f"),
            Ee(this, tn, "f") && (this._emit("toolCallDone", Ee(this, tn, "f")),
            en(this, tn, void 0, "f"));
            break
        }
    }
    ;
    let LS = class extends st {
        create(e, t, r) {
            return this._client.post(`/threads/${e}/messages`, {
                body: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        retrieve(e, t, r) {
            return this._client.get(`/threads/${e}/messages/${t}`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        update(e, t, r, s) {
            return this._client.post(`/threads/${e}/messages/${t}`, {
                body: r,
                ...s,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...s == null ? void 0 : s.headers
                }
            })
        }
        list(e, t={}, r) {
            return jr(t) ? this.list(e, {}, t) : this._client.getAPIList(`/threads/${e}/messages`, FS, {
                query: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        del(e, t, r) {
            return this._client.delete(`/threads/${e}/messages/${t}`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
    }
    ;
    class FS extends jn {
    }
    LS.MessagesPage = FS;
    class jS extends st {
        retrieve(e, t, r, s={}, i) {
            return jr(s) ? this.retrieve(e, t, r, {}, s) : this._client.get(`/threads/${e}/runs/${t}/steps/${r}`, {
                query: s,
                ...i,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...i == null ? void 0 : i.headers
                }
            })
        }
        list(e, t, r={}, s) {
            return jr(r) ? this.list(e, t, {}, r) : this._client.getAPIList(`/threads/${e}/runs/${t}/steps`, DS, {
                query: r,
                ...s,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...s == null ? void 0 : s.headers
                }
            })
        }
    }
    class DS extends jn {
    }
    jS.RunStepsPage = DS;
    class Bh extends st {
        constructor() {
            super(...arguments),
            this.steps = new jS(this._client)
        }
        create(e, t, r) {
            const {include: s, ...i} = t;
            return this._client.post(`/threads/${e}/runs`, {
                query: {
                    include: s
                },
                body: i,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                },
                stream: t.stream ?? !1
            })
        }
        retrieve(e, t, r) {
            return this._client.get(`/threads/${e}/runs/${t}`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        update(e, t, r, s) {
            return this._client.post(`/threads/${e}/runs/${t}`, {
                body: r,
                ...s,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...s == null ? void 0 : s.headers
                }
            })
        }
        list(e, t={}, r) {
            return jr(t) ? this.list(e, {}, t) : this._client.getAPIList(`/threads/${e}/runs`, BS, {
                query: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        cancel(e, t, r) {
            return this._client.post(`/threads/${e}/runs/${t}/cancel`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        async createAndPoll(e, t, r) {
            const s = await this.create(e, t, r);
            return await this.poll(e, s.id, r)
        }
        createAndStream(e, t, r) {
            return qn.createAssistantStream(e, this._client.beta.threads.runs, t, r)
        }
        async poll(e, t, r) {
            const s = {
                ...r == null ? void 0 : r.headers,
                "X-Stainless-Poll-Helper": "true"
            };
            for (r != null && r.pollIntervalMs && (s["X-Stainless-Custom-Poll-Interval"] = r.pollIntervalMs.toString()); ; ) {
                const {data: i, response: a} = await this.retrieve(e, t, {
                    ...r,
                    headers: {
                        ...r == null ? void 0 : r.headers,
                        ...s
                    }
                }).withResponse();
                switch (i.status) {
                case "queued":
                case "in_progress":
                case "cancelling":
                    let c = 5e3;
                    if (r != null && r.pollIntervalMs)
                        c = r.pollIntervalMs;
                    else {
                        const u = a.headers.get("openai-poll-after-ms");
                        if (u) {
                            const l = parseInt(u);
                            isNaN(l) || (c = l)
                        }
                    }
                    await Th(c);
                    break;
                case "requires_action":
                case "incomplete":
                case "cancelled":
                case "completed":
                case "failed":
                case "expired":
                    return i
                }
            }
        }
        stream(e, t, r) {
            return qn.createAssistantStream(e, this._client.beta.threads.runs, t, r)
        }
        submitToolOutputs(e, t, r, s) {
            return this._client.post(`/threads/${e}/runs/${t}/submit_tool_outputs`, {
                body: r,
                ...s,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...s == null ? void 0 : s.headers
                },
                stream: r.stream ?? !1
            })
        }
        async submitToolOutputsAndPoll(e, t, r, s) {
            const i = await this.submitToolOutputs(e, t, r, s);
            return await this.poll(e, i.id, s)
        }
        submitToolOutputsStream(e, t, r, s) {
            return qn.createToolAssistantStream(e, t, this._client.beta.threads.runs, r, s)
        }
    }
    class BS extends jn {
    }
    Bh.RunsPage = BS,
    Bh.Steps = jS,
    Bh.RunStepsPage = DS;
    class Pu extends st {
        constructor() {
            super(...arguments),
            this.runs = new Bh(this._client),
            this.messages = new LS(this._client)
        }
        create(e={}, t) {
            return jr(e) ? this.create({}, e) : this._client.post("/threads", {
                body: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        retrieve(e, t) {
            return this._client.get(`/threads/${e}`, {
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        update(e, t, r) {
            return this._client.post(`/threads/${e}`, {
                body: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        del(e, t) {
            return this._client.delete(`/threads/${e}`, {
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        createAndRun(e, t) {
            return this._client.post("/threads/runs", {
                body: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                },
                stream: e.stream ?? !1
            })
        }
        async createAndRunPoll(e, t) {
            const r = await this.createAndRun(e, t);
            return await this.runs.poll(r.thread_id, r.id, t)
        }
        createAndRunStream(e, t) {
            return qn.createThreadAssistantStream(e, this._client.beta.threads, t)
        }
    }
    Pu.Runs = Bh,
    Pu.RunsPage = BS,
    Pu.Messages = LS,
    Pu.MessagesPage = FS;
    const oH = async n => {
        const e = await Promise.allSettled(n)
          , t = e.filter(s => s.status === "rejected");
        if (t.length) {
            for (const s of t)
                console.error(s.reason);
            throw new Error(`${t.length} promise(s) failed - see the above errors`)
        }
        const r = [];
        for (const s of e)
            s.status === "fulfilled" && r.push(s.value);
        return r
    }
    ;
    let qS = class extends st {
        create(e, t, r) {
            return this._client.post(`/vector_stores/${e}/files`, {
                body: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        retrieve(e, t, r) {
            return this._client.get(`/vector_stores/${e}/files/${t}`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        list(e, t={}, r) {
            return jr(t) ? this.list(e, {}, t) : this._client.getAPIList(`/vector_stores/${e}/files`, Aw, {
                query: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        del(e, t, r) {
            return this._client.delete(`/vector_stores/${e}/files/${t}`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        async createAndPoll(e, t, r) {
            const s = await this.create(e, t, r);
            return await this.poll(e, s.id, r)
        }
        async poll(e, t, r) {
            const s = {
                ...r == null ? void 0 : r.headers,
                "X-Stainless-Poll-Helper": "true"
            };
            for (r != null && r.pollIntervalMs && (s["X-Stainless-Custom-Poll-Interval"] = r.pollIntervalMs.toString()); ; ) {
                const i = await this.retrieve(e, t, {
                    ...r,
                    headers: s
                }).withResponse()
                  , a = i.data;
                switch (a.status) {
                case "in_progress":
                    let c = 5e3;
                    if (r != null && r.pollIntervalMs)
                        c = r.pollIntervalMs;
                    else {
                        const u = i.response.headers.get("openai-poll-after-ms");
                        if (u) {
                            const l = parseInt(u);
                            isNaN(l) || (c = l)
                        }
                    }
                    await Th(c);
                    break;
                case "failed":
                case "completed":
                    return a
                }
            }
        }
        async upload(e, t, r) {
            const s = await this._client.files.create({
                file: t,
                purpose: "assistants"
            }, r);
            return this.create(e, {
                file_id: s.id
            }, r)
        }
        async uploadAndPoll(e, t, r) {
            const s = await this.upload(e, t, r);
            return await this.poll(e, s.id, r)
        }
    }
    ;
    class Aw extends jn {
    }
    qS.VectorStoreFilesPage = Aw;
    class Z1 extends st {
        create(e, t, r) {
            return this._client.post(`/vector_stores/${e}/file_batches`, {
                body: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        retrieve(e, t, r) {
            return this._client.get(`/vector_stores/${e}/file_batches/${t}`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        cancel(e, t, r) {
            return this._client.post(`/vector_stores/${e}/file_batches/${t}/cancel`, {
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        async createAndPoll(e, t, r) {
            const s = await this.create(e, t);
            return await this.poll(e, s.id, r)
        }
        listFiles(e, t, r={}, s) {
            return jr(r) ? this.listFiles(e, t, {}, r) : this._client.getAPIList(`/vector_stores/${e}/file_batches/${t}/files`, Aw, {
                query: r,
                ...s,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...s == null ? void 0 : s.headers
                }
            })
        }
        async poll(e, t, r) {
            const s = {
                ...r == null ? void 0 : r.headers,
                "X-Stainless-Poll-Helper": "true"
            };
            for (r != null && r.pollIntervalMs && (s["X-Stainless-Custom-Poll-Interval"] = r.pollIntervalMs.toString()); ; ) {
                const {data: i, response: a} = await this.retrieve(e, t, {
                    ...r,
                    headers: s
                }).withResponse();
                switch (i.status) {
                case "in_progress":
                    let c = 5e3;
                    if (r != null && r.pollIntervalMs)
                        c = r.pollIntervalMs;
                    else {
                        const u = a.headers.get("openai-poll-after-ms");
                        if (u) {
                            const l = parseInt(u);
                            isNaN(l) || (c = l)
                        }
                    }
                    await Th(c);
                    break;
                case "failed":
                case "cancelled":
                case "completed":
                    return i
                }
            }
        }
        async uploadAndPoll(e, {files: t, fileIds: r=[]}, s) {
            if (t == null || t.length == 0)
                throw new Error("No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead");
            const i = (s == null ? void 0 : s.maxConcurrency) ?? 5
              , a = Math.min(i, t.length)
              , c = this._client
              , u = t.values()
              , l = [...r];
            async function d(f) {
                for (let p of f) {
                    const g = await c.files.create({
                        file: p,
                        purpose: "assistants"
                    }, s);
                    l.push(g.id)
                }
            }
            const h = Array(a).fill(u).map(d);
            return await oH(h),
            await this.createAndPoll(e, {
                file_ids: l
            })
        }
    }
    class Tu extends st {
        constructor() {
            super(...arguments),
            this.files = new qS(this._client),
            this.fileBatches = new Z1(this._client)
        }
        create(e, t) {
            return this._client.post("/vector_stores", {
                body: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        retrieve(e, t) {
            return this._client.get(`/vector_stores/${e}`, {
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        update(e, t, r) {
            return this._client.post(`/vector_stores/${e}`, {
                body: t,
                ...r,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        list(e={}, t) {
            return jr(e) ? this.list({}, e) : this._client.getAPIList("/vector_stores", US, {
                query: e,
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        del(e, t) {
            return this._client.delete(`/vector_stores/${e}`, {
                ...t,
                headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...t == null ? void 0 : t.headers
                }
            })
        }
    }
    class US extends jn {
    }
    Tu.VectorStoresPage = US,
    Tu.Files = qS,
    Tu.VectorStoreFilesPage = Aw,
    Tu.FileBatches = Z1;
    let zi = class extends st {
        constructor() {
            super(...arguments),
            this.realtime = new NS(this._client),
            this.vectorStores = new Tu(this._client),
            this.chat = new MS(this._client),
            this.assistants = new bS(this._client),
            this.threads = new Pu(this._client)
        }
    }
    ;
    zi.Realtime = NS,
    zi.VectorStores = Tu,
    zi.VectorStoresPage = US,
    zi.Assistants = bS,
    zi.AssistantsPage = vS,
    zi.Threads = Pu;
    let X1 = class extends st {
        create(e, t) {
            return this._client.post("/completions", {
                body: e,
                ...t,
                stream: e.stream ?? !1
            })
        }
    }
    ;
    class Y1 extends st {
        create(e, t) {
            return this._client.post("/embeddings", {
                body: e,
                ...t
            })
        }
    }
    class KS extends st {
        create(e, t) {
            return this._client.post("/files", bu({
                body: e,
                ...t
            }))
        }
        retrieve(e, t) {
            return this._client.get(`/files/${e}`, t)
        }
        list(e={}, t) {
            return jr(e) ? this.list({}, e) : this._client.getAPIList("/files", HS, {
                query: e,
                ...t
            })
        }
        del(e, t) {
            return this._client.delete(`/files/${e}`, t)
        }
        content(e, t) {
            return this._client.get(`/files/${e}/content`, {
                ...t,
                headers: {
                    Accept: "application/binary",
                    ...t == null ? void 0 : t.headers
                },
                __binaryResponse: !0
            })
        }
        retrieveContent(e, t) {
            return this._client.get(`/files/${e}/content`, t)
        }
        async waitForProcessing(e, {pollInterval: t=5e3, maxWait: r=30 * 60 * 1e3}={}) {
            const s = new Set(["processed", "error", "deleted"])
              , i = Date.now();
            let a = await this.retrieve(e);
            for (; !a.status || !s.has(a.status); )
                if (await Th(t),
                a = await this.retrieve(e),
                Date.now() - i > r)
                    throw new dw({
                        message: `Giving up on waiting for file ${e} to finish processing after ${r} milliseconds.`
                    });
            return a
        }
    }
    class HS extends jn {
    }
    KS.FileObjectsPage = HS;
    class WS extends st {
        list(e, t={}, r) {
            return jr(t) ? this.list(e, {}, t) : this._client.getAPIList(`/fine_tuning/jobs/${e}/checkpoints`, zS, {
                query: t,
                ...r
            })
        }
    }
    class zS extends jn {
    }
    WS.FineTuningJobCheckpointsPage = zS;
    class Au extends st {
        constructor() {
            super(...arguments),
            this.checkpoints = new WS(this._client)
        }
        create(e, t) {
            return this._client.post("/fine_tuning/jobs", {
                body: e,
                ...t
            })
        }
        retrieve(e, t) {
            return this._client.get(`/fine_tuning/jobs/${e}`, t)
        }
        list(e={}, t) {
            return jr(e) ? this.list({}, e) : this._client.getAPIList("/fine_tuning/jobs", VS, {
                query: e,
                ...t
            })
        }
        cancel(e, t) {
            return this._client.post(`/fine_tuning/jobs/${e}/cancel`, t)
        }
        listEvents(e, t={}, r) {
            return jr(t) ? this.listEvents(e, {}, t) : this._client.getAPIList(`/fine_tuning/jobs/${e}/events`, GS, {
                query: t,
                ...r
            })
        }
    }
    class VS extends jn {
    }
    class GS extends jn {
    }
    Au.FineTuningJobsPage = VS,
    Au.FineTuningJobEventsPage = GS,
    Au.Checkpoints = WS,
    Au.FineTuningJobCheckpointsPage = zS;
    class qh extends st {
        constructor() {
            super(...arguments),
            this.jobs = new Au(this._client)
        }
    }
    qh.Jobs = Au,
    qh.FineTuningJobsPage = VS,
    qh.FineTuningJobEventsPage = GS;
    class Q1 extends st {
        createVariation(e, t) {
            return this._client.post("/images/variations", bu({
                body: e,
                ...t
            }))
        }
        edit(e, t) {
            return this._client.post("/images/edits", bu({
                body: e,
                ...t
            }))
        }
        generate(e, t) {
            return this._client.post("/images/generations", {
                body: e,
                ...t
            })
        }
    }
    class JS extends st {
        retrieve(e, t) {
            return this._client.get(`/models/${e}`, t)
        }
        list(e) {
            return this._client.getAPIList("/models", ZS, e)
        }
        del(e, t) {
            return this._client.delete(`/models/${e}`, t)
        }
    }
    class ZS extends VK {
    }
    JS.ModelsPage = ZS;
    class eO extends st {
        create(e, t) {
            return this._client.post("/moderations", {
                body: e,
                ...t
            })
        }
    }
    class tO extends st {
        create(e, t, r) {
            return this._client.post(`/uploads/${e}/parts`, bu({
                body: t,
                ...r
            }))
        }
    }
    class XS extends st {
        constructor() {
            super(...arguments),
            this.parts = new tO(this._client)
        }
        create(e, t) {
            return this._client.post("/uploads", {
                body: e,
                ...t
            })
        }
        cancel(e, t) {
            return this._client.post(`/uploads/${e}/cancel`, t)
        }
        complete(e, t, r) {
            return this._client.post(`/uploads/${e}/complete`, {
                body: t,
                ...r
            })
        }
    }
    XS.Parts = tO;
    var rO;
    let Ge = class extends NK {
        constructor({baseURL: e=mw("OPENAI_BASE_URL"), apiKey: t=mw("OPENAI_API_KEY"), organization: r=mw("OPENAI_ORG_ID") ?? null, project: s=mw("OPENAI_PROJECT_ID") ?? null, ...i}={}) {
            if (t === void 0)
                throw new qe("The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' }).");
            const a = {
                apiKey: t,
                organization: r,
                project: s,
                ...i,
                baseURL: e || "https://api.openai.com/v1"
            };
            if (!a.dangerouslyAllowBrowser && WK())
                throw new qe(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
            super({
                baseURL: a.baseURL,
                timeout: a.timeout ?? 6e5,
                httpAgent: a.httpAgent,
                maxRetries: a.maxRetries,
                fetch: a.fetch
            }),
            this.completions = new X1(this),
            this.chat = new gS(this),
            this.embeddings = new Y1(this),
            this.files = new KS(this),
            this.images = new Q1(this),
            this.audio = new Ah(this),
            this.moderations = new eO(this),
            this.models = new JS(this),
            this.fineTuning = new qh(this),
            this.beta = new zi(this),
            this.batches = new yS(this),
            this.uploads = new XS(this),
            this._options = a,
            this.apiKey = t,
            this.organization = r,
            this.project = s
        }
        defaultQuery() {
            return this._options.defaultQuery
        }
        defaultHeaders(e) {
            return {
                ...super.defaultHeaders(e),
                "OpenAI-Organization": this.organization,
                "OpenAI-Project": this.project,
                ...this._options.defaultHeaders
            }
        }
        authHeaders(e) {
            return {
                Authorization: `Bearer ${this.apiKey}`
            }
        }
        stringifyQuery(e) {
            return yK(e, {
                arrayFormat: "brackets"
            })
        }
    }
    ;
    rO = Ge,
    Ge.OpenAI = rO,
    Ge.DEFAULT_TIMEOUT = 6e5,
    Ge.OpenAIError = qe,
    Ge.APIError = Fr,
    Ge.APIConnectionError = lw,
    Ge.APIConnectionTimeoutError = dw,
    Ge.APIUserAbortError = yn,
    Ge.NotFoundError = UI,
    Ge.ConflictError = KI,
    Ge.RateLimitError = WI,
    Ge.BadRequestError = DI,
    Ge.AuthenticationError = BI,
    Ge.InternalServerError = zI,
    Ge.PermissionDeniedError = qI,
    Ge.UnprocessableEntityError = HI,
    Ge.toFile = YI,
    Ge.fileFromPath = FI,
    Ge.Completions = X1,
    Ge.Chat = gS,
    Ge.Embeddings = Y1,
    Ge.Files = KS,
    Ge.FileObjectsPage = HS,
    Ge.Images = Q1,
    Ge.Audio = Ah,
    Ge.Moderations = eO,
    Ge.Models = JS,
    Ge.ModelsPage = ZS,
    Ge.FineTuning = qh,
    Ge.Beta = zi,
    Ge.Batches = yS,
    Ge.BatchesPage = wS,
    Ge.Uploads = XS;
    /*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
    var cH = typeof window == "object" ? window : {}
      , Le = "0123456789abcdef".split("")
      , uH = [-2147483648, 8388608, 32768, 128]
      , Un = [24, 16, 8, 0]
      , Zt = [];
    function Kn(n) {
        n ? (Zt[0] = Zt[16] = Zt[1] = Zt[2] = Zt[3] = Zt[4] = Zt[5] = Zt[6] = Zt[7] = Zt[8] = Zt[9] = Zt[10] = Zt[11] = Zt[12] = Zt[13] = Zt[14] = Zt[15] = 0,
        this.blocks = Zt) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        this.h0 = 1732584193,
        this.h1 = 4023233417,
        this.h2 = 2562383102,
        this.h3 = 271733878,
        this.h4 = 3285377520,
        this.block = this.start = this.bytes = this.hBytes = 0,
        this.finalized = this.hashed = !1,
        this.first = !0
    }
    Kn.prototype.update = function(n) {
        if (!this.finalized) {
            var e = typeof n != "string";
            e && n.constructor === cH.ArrayBuffer && (n = new Uint8Array(n));
            for (var t, r = 0, s, i = n.length || 0, a = this.blocks; r < i; ) {
                if (this.hashed && (this.hashed = !1,
                a[0] = this.block,
                a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0),
                e)
                    for (s = this.start; r < i && s < 64; ++r)
                        a[s >> 2] |= n[r] << Un[s++ & 3];
                else
                    for (s = this.start; r < i && s < 64; ++r)
                        t = n.charCodeAt(r),
                        t < 128 ? a[s >> 2] |= t << Un[s++ & 3] : t < 2048 ? (a[s >> 2] |= (192 | t >> 6) << Un[s++ & 3],
                        a[s >> 2] |= (128 | t & 63) << Un[s++ & 3]) : t < 55296 || t >= 57344 ? (a[s >> 2] |= (224 | t >> 12) << Un[s++ & 3],
                        a[s >> 2] |= (128 | t >> 6 & 63) << Un[s++ & 3],
                        a[s >> 2] |= (128 | t & 63) << Un[s++ & 3]) : (t = 65536 + ((t & 1023) << 10 | n.charCodeAt(++r) & 1023),
                        a[s >> 2] |= (240 | t >> 18) << Un[s++ & 3],
                        a[s >> 2] |= (128 | t >> 12 & 63) << Un[s++ & 3],
                        a[s >> 2] |= (128 | t >> 6 & 63) << Un[s++ & 3],
                        a[s >> 2] |= (128 | t & 63) << Un[s++ & 3]);
                this.lastByteIndex = s,
                this.bytes += s - this.start,
                s >= 64 ? (this.block = a[16],
                this.start = s - 64,
                this.hash(),
                this.hashed = !0) : this.start = s
            }
            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0,
            this.bytes = this.bytes % 4294967296),
            this
        }
    }
    ,
    Kn.prototype.finalize = function() {
        if (!this.finalized) {
            this.finalized = !0;
            var n = this.blocks
              , e = this.lastByteIndex;
            n[16] = this.block,
            n[e >> 2] |= uH[e & 3],
            this.block = n[16],
            e >= 56 && (this.hashed || this.hash(),
            n[0] = this.block,
            n[16] = n[1] = n[2] = n[3] = n[4] = n[5] = n[6] = n[7] = n[8] = n[9] = n[10] = n[11] = n[12] = n[13] = n[14] = n[15] = 0),
            n[14] = this.hBytes << 3 | this.bytes >>> 29,
            n[15] = this.bytes << 3,
            this.hash()
        }
    }
    ,
    Kn.prototype.hash = function() {
        var n = this.h0, e = this.h1, t = this.h2, r = this.h3, s = this.h4, i, a, c, u = this.blocks;
        for (a = 16; a < 80; ++a)
            c = u[a - 3] ^ u[a - 8] ^ u[a - 14] ^ u[a - 16],
            u[a] = c << 1 | c >>> 31;
        for (a = 0; a < 20; a += 5)
            i = e & t | ~e & r,
            c = n << 5 | n >>> 27,
            s = c + i + s + 1518500249 + u[a] << 0,
            e = e << 30 | e >>> 2,
            i = n & e | ~n & t,
            c = s << 5 | s >>> 27,
            r = c + i + r + 1518500249 + u[a + 1] << 0,
            n = n << 30 | n >>> 2,
            i = s & n | ~s & e,
            c = r << 5 | r >>> 27,
            t = c + i + t + 1518500249 + u[a + 2] << 0,
            s = s << 30 | s >>> 2,
            i = r & s | ~r & n,
            c = t << 5 | t >>> 27,
            e = c + i + e + 1518500249 + u[a + 3] << 0,
            r = r << 30 | r >>> 2,
            i = t & r | ~t & s,
            c = e << 5 | e >>> 27,
            n = c + i + n + 1518500249 + u[a + 4] << 0,
            t = t << 30 | t >>> 2;
        for (; a < 40; a += 5)
            i = e ^ t ^ r,
            c = n << 5 | n >>> 27,
            s = c + i + s + 1859775393 + u[a] << 0,
            e = e << 30 | e >>> 2,
            i = n ^ e ^ t,
            c = s << 5 | s >>> 27,
            r = c + i + r + 1859775393 + u[a + 1] << 0,
            n = n << 30 | n >>> 2,
            i = s ^ n ^ e,
            c = r << 5 | r >>> 27,
            t = c + i + t + 1859775393 + u[a + 2] << 0,
            s = s << 30 | s >>> 2,
            i = r ^ s ^ n,
            c = t << 5 | t >>> 27,
            e = c + i + e + 1859775393 + u[a + 3] << 0,
            r = r << 30 | r >>> 2,
            i = t ^ r ^ s,
            c = e << 5 | e >>> 27,
            n = c + i + n + 1859775393 + u[a + 4] << 0,
            t = t << 30 | t >>> 2;
        for (; a < 60; a += 5)
            i = e & t | e & r | t & r,
            c = n << 5 | n >>> 27,
            s = c + i + s - 1894007588 + u[a] << 0,
            e = e << 30 | e >>> 2,
            i = n & e | n & t | e & t,
            c = s << 5 | s >>> 27,
            r = c + i + r - 1894007588 + u[a + 1] << 0,
            n = n << 30 | n >>> 2,
            i = s & n | s & e | n & e,
            c = r << 5 | r >>> 27,
            t = c + i + t - 1894007588 + u[a + 2] << 0,
            s = s << 30 | s >>> 2,
            i = r & s | r & n | s & n,
            c = t << 5 | t >>> 27,
            e = c + i + e - 1894007588 + u[a + 3] << 0,
            r = r << 30 | r >>> 2,
            i = t & r | t & s | r & s,
            c = e << 5 | e >>> 27,
            n = c + i + n - 1894007588 + u[a + 4] << 0,
            t = t << 30 | t >>> 2;
        for (; a < 80; a += 5)
            i = e ^ t ^ r,
            c = n << 5 | n >>> 27,
            s = c + i + s - 899497514 + u[a] << 0,
            e = e << 30 | e >>> 2,
            i = n ^ e ^ t,
            c = s << 5 | s >>> 27,
            r = c + i + r - 899497514 + u[a + 1] << 0,
            n = n << 30 | n >>> 2,
            i = s ^ n ^ e,
            c = r << 5 | r >>> 27,
            t = c + i + t - 899497514 + u[a + 2] << 0,
            s = s << 30 | s >>> 2,
            i = r ^ s ^ n,
            c = t << 5 | t >>> 27,
            e = c + i + e - 899497514 + u[a + 3] << 0,
            r = r << 30 | r >>> 2,
            i = t ^ r ^ s,
            c = e << 5 | e >>> 27,
            n = c + i + n - 899497514 + u[a + 4] << 0,
            t = t << 30 | t >>> 2;
        this.h0 = this.h0 + n << 0,
        this.h1 = this.h1 + e << 0,
        this.h2 = this.h2 + t << 0,
        this.h3 = this.h3 + r << 0,
        this.h4 = this.h4 + s << 0
    }
    ,
    Kn.prototype.hex = function() {
        this.finalize();
        var n = this.h0
          , e = this.h1
          , t = this.h2
          , r = this.h3
          , s = this.h4;
        return Le[n >> 28 & 15] + Le[n >> 24 & 15] + Le[n >> 20 & 15] + Le[n >> 16 & 15] + Le[n >> 12 & 15] + Le[n >> 8 & 15] + Le[n >> 4 & 15] + Le[n & 15] + Le[e >> 28 & 15] + Le[e >> 24 & 15] + Le[e >> 20 & 15] + Le[e >> 16 & 15] + Le[e >> 12 & 15] + Le[e >> 8 & 15] + Le[e >> 4 & 15] + Le[e & 15] + Le[t >> 28 & 15] + Le[t >> 24 & 15] + Le[t >> 20 & 15] + Le[t >> 16 & 15] + Le[t >> 12 & 15] + Le[t >> 8 & 15] + Le[t >> 4 & 15] + Le[t & 15] + Le[r >> 28 & 15] + Le[r >> 24 & 15] + Le[r >> 20 & 15] + Le[r >> 16 & 15] + Le[r >> 12 & 15] + Le[r >> 8 & 15] + Le[r >> 4 & 15] + Le[r & 15] + Le[s >> 28 & 15] + Le[s >> 24 & 15] + Le[s >> 20 & 15] + Le[s >> 16 & 15] + Le[s >> 12 & 15] + Le[s >> 8 & 15] + Le[s >> 4 & 15] + Le[s & 15]
    }
    ,
    Kn.prototype.toString = Kn.prototype.hex,
    Kn.prototype.digest = function() {
        this.finalize();
        var n = this.h0
          , e = this.h1
          , t = this.h2
          , r = this.h3
          , s = this.h4;
        return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, r & 255, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255]
    }
    ,
    Kn.prototype.array = Kn.prototype.digest,
    Kn.prototype.arrayBuffer = function() {
        this.finalize();
        var n = new ArrayBuffer(20)
          , e = new DataView(n);
        return e.setUint32(0, this.h0),
        e.setUint32(4, this.h1),
        e.setUint32(8, this.h2),
        e.setUint32(12, this.h3),
        e.setUint32(16, this.h4),
        n
    }
    ;
    const lH = n => new Kn(!0).update(n).hex()
      , nO = (...n) => lH(n.join("_"));
    class dH {
    }
    const hH = new Map;
    class YS extends dH {
        constructor(e) {
            super(),
            Object.defineProperty(this, "cache", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.cache = e ?? new Map
        }
        lookup(e, t) {
            return Promise.resolve(this.cache.get(nO(e, t)) ?? null)
        }
        async update(e, t, r) {
            this.cache.set(nO(e, t), r)
        }
        static global() {
            return new YS(hH)
        }
    }
    var Uh = {}, sO;
    function fH() {
        if (sO)
            return Uh;
        sO = 1,
        Uh.byteLength = c,
        Uh.toByteArray = l,
        Uh.fromByteArray = f;
        for (var n = [], e = [], t = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, i = r.length; s < i; ++s)
            n[s] = r[s],
            e[r.charCodeAt(s)] = s;
        e[45] = 62,
        e[95] = 63;
        function a(p) {
            var g = p.length;
            if (g % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
            var y = p.indexOf("=");
            y === -1 && (y = g);
            var m = y === g ? 0 : 4 - y % 4;
            return [y, m]
        }
        function c(p) {
            var g = a(p)
              , y = g[0]
              , m = g[1];
            return (y + m) * 3 / 4 - m
        }
        function u(p, g, y) {
            return (g + y) * 3 / 4 - y
        }
        function l(p) {
            var g, y = a(p), m = y[0], w = y[1], E = new t(u(p, m, w)), v = 0, _ = w > 0 ? m - 4 : m, A;
            for (A = 0; A < _; A += 4)
                g = e[p.charCodeAt(A)] << 18 | e[p.charCodeAt(A + 1)] << 12 | e[p.charCodeAt(A + 2)] << 6 | e[p.charCodeAt(A + 3)],
                E[v++] = g >> 16 & 255,
                E[v++] = g >> 8 & 255,
                E[v++] = g & 255;
            return w === 2 && (g = e[p.charCodeAt(A)] << 2 | e[p.charCodeAt(A + 1)] >> 4,
            E[v++] = g & 255),
            w === 1 && (g = e[p.charCodeAt(A)] << 10 | e[p.charCodeAt(A + 1)] << 4 | e[p.charCodeAt(A + 2)] >> 2,
            E[v++] = g >> 8 & 255,
            E[v++] = g & 255),
            E
        }
        function d(p) {
            return n[p >> 18 & 63] + n[p >> 12 & 63] + n[p >> 6 & 63] + n[p & 63]
        }
        function h(p, g, y) {
            for (var m, w = [], E = g; E < y; E += 3)
                m = (p[E] << 16 & 16711680) + (p[E + 1] << 8 & 65280) + (p[E + 2] & 255),
                w.push(d(m));
            return w.join("")
        }
        function f(p) {
            for (var g, y = p.length, m = y % 3, w = [], E = 16383, v = 0, _ = y - m; v < _; v += E)
                w.push(h(p, v, v + E > _ ? _ : v + E));
            return m === 1 ? (g = p[y - 1],
            w.push(n[g >> 2] + n[g << 4 & 63] + "==")) : m === 2 && (g = (p[y - 2] << 8) + p[y - 1],
            w.push(n[g >> 10] + n[g >> 4 & 63] + n[g << 2 & 63] + "=")),
            w.join("")
        }
        return Uh
    }
    var pH = fH();
    const mH = De(pH);
    var gH = Object.defineProperty
      , yH = (n, e, t) => e in n ? gH(n, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : n[e] = t
      , wH = (n, e, t) => (yH(n, e + "", t),
    t);
    function bH(n, e) {
        let t = Array.from({
            length: n.length
        }, (r, s) => ({
            start: s,
            end: s + 1
        }));
        for (; t.length > 1; ) {
            let r = null;
            for (let s = 0; s < t.length - 1; s++) {
                const i = n.slice(t[s].start, t[s + 1].end)
                  , a = e.get(i.join(","));
                a != null && (r == null || a < r[0]) && (r = [a, s])
            }
            if (r != null) {
                const s = r[1];
                t[s] = {
                    start: t[s].start,
                    end: t[s + 1].end
                },
                t.splice(s + 1, 1)
            } else
                break
        }
        return t
    }
    function vH(n, e) {
        return n.length === 1 ? [e.get(n.join(","))] : bH(n, e).map(t => e.get(n.slice(t.start, t.end).join(","))).filter(t => t != null)
    }
    function _H(n) {
        return n.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
    }
    var QS = class {
        constructor(n, e) {
            J(this, "specialTokens");
            J(this, "inverseSpecialTokens");
            J(this, "patStr");
            J(this, "textEncoder", new TextEncoder);
            J(this, "textDecoder", new TextDecoder("utf-8"));
            J(this, "rankMap", new Map);
            J(this, "textMap", new Map);
            this.patStr = n.pat_str;
            const t = n.bpe_ranks.split(`
`).filter(Boolean).reduce( (r, s) => {
                const [i,a,...c] = s.split(" ")
                  , u = Number.parseInt(a, 10);
                return c.forEach( (l, d) => r[l] = u + d),
                r
            }
            , {});
            for (const [r,s] of Object.entries(t)) {
                const i = mH.toByteArray(r);
                this.rankMap.set(i.join(","), s),
                this.textMap.set(s, i)
            }
            this.specialTokens = {
                ...n.special_tokens,
                ...e
            },
            this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce( (r, [s,i]) => (r[i] = this.textEncoder.encode(s),
            r), {})
        }
        encode(n, e=[], t="all") {
            const r = new RegExp(this.patStr,"ug")
              , s = QS.specialTokenRegex(Object.keys(this.specialTokens))
              , i = []
              , a = new Set(e === "all" ? Object.keys(this.specialTokens) : e)
              , c = new Set(t === "all" ? Object.keys(this.specialTokens).filter(l => !a.has(l)) : t);
            if (c.size > 0) {
                const l = QS.specialTokenRegex([...c])
                  , d = n.match(l);
                if (d != null)
                    throw new Error(`The text contains a special token that is not allowed: ${d[0]}`)
            }
            let u = 0;
            for (; ; ) {
                let l = null
                  , d = u;
                for (; s.lastIndex = d,
                l = s.exec(n),
                !(l == null || a.has(l[0])); )
                    d = l.index + 1;
                const h = (l == null ? void 0 : l.index) ?? n.length;
                for (const p of n.substring(u, h).matchAll(r)) {
                    const g = this.textEncoder.encode(p[0])
                      , y = this.rankMap.get(g.join(","));
                    if (y != null) {
                        i.push(y);
                        continue
                    }
                    i.push(...vH(g, this.rankMap))
                }
                if (l == null)
                    break;
                let f = this.specialTokens[l[0]];
                i.push(f),
                u = l.index + l[0].length
            }
            return i
        }
        decode(n) {
            const e = [];
            let t = 0;
            for (let i = 0; i < n.length; ++i) {
                const a = n[i]
                  , c = this.textMap.get(a) ?? this.inverseSpecialTokens[a];
                c != null && (e.push(c),
                t += c.length)
            }
            const r = new Uint8Array(t);
            let s = 0;
            for (const i of e)
                r.set(i, s),
                s += i.length;
            return this.textDecoder.decode(r)
        }
    }
      , iO = QS;
    wH(iO, "specialTokenRegex", n => new RegExp(n.map(e => _H(e)).join("|"),"g"));
    function SH(n) {
        switch (n) {
        case "gpt2":
            return "gpt2";
        case "code-cushman-001":
        case "code-cushman-002":
        case "code-davinci-001":
        case "code-davinci-002":
        case "cushman-codex":
        case "davinci-codex":
        case "davinci-002":
        case "text-davinci-002":
        case "text-davinci-003":
            return "p50k_base";
        case "code-davinci-edit-001":
        case "text-davinci-edit-001":
            return "p50k_edit";
        case "ada":
        case "babbage":
        case "babbage-002":
        case "code-search-ada-code-001":
        case "code-search-babbage-code-001":
        case "curie":
        case "davinci":
        case "text-ada-001":
        case "text-babbage-001":
        case "text-curie-001":
        case "text-davinci-001":
        case "text-search-ada-doc-001":
        case "text-search-babbage-doc-001":
        case "text-search-curie-doc-001":
        case "text-search-davinci-doc-001":
        case "text-similarity-ada-001":
        case "text-similarity-babbage-001":
        case "text-similarity-curie-001":
        case "text-similarity-davinci-001":
            return "r50k_base";
        case "gpt-3.5-turbo-instruct-0914":
        case "gpt-3.5-turbo-instruct":
        case "gpt-3.5-turbo-16k-0613":
        case "gpt-3.5-turbo-16k":
        case "gpt-3.5-turbo-0613":
        case "gpt-3.5-turbo-0301":
        case "gpt-3.5-turbo":
        case "gpt-4-32k-0613":
        case "gpt-4-32k-0314":
        case "gpt-4-32k":
        case "gpt-4-0613":
        case "gpt-4-0314":
        case "gpt-4":
        case "gpt-3.5-turbo-1106":
        case "gpt-35-turbo":
        case "gpt-4-1106-preview":
        case "gpt-4-vision-preview":
        case "gpt-3.5-turbo-0125":
        case "gpt-4-turbo":
        case "gpt-4-turbo-2024-04-09":
        case "gpt-4-turbo-preview":
        case "gpt-4-0125-preview":
        case "text-embedding-ada-002":
        case "text-embedding-3-small":
        case "text-embedding-3-large":
            return "cl100k_base";
        case "gpt-4o":
        case "gpt-4o-2024-05-13":
        case "gpt-4o-2024-08-06":
        case "gpt-4o-mini-2024-07-18":
        case "gpt-4o-mini":
        case "o1":
        case "o1-2024-12-17":
        case "o1-mini":
        case "o1-preview":
        case "o1-preview-2024-09-12":
        case "o1-mini-2024-09-12":
        case "o3-mini":
        case "o3-mini-2025-01-31":
        case "chatgpt-4o-latest":
        case "gpt-4o-realtime":
        case "gpt-4o-realtime-preview-2024-10-01":
            return "o200k_base";
        default:
            throw new Error("Unknown model")
        }
    }
    const Iw = {}
      , EH = new W0({});
    async function xH(n) {
        return n in Iw || (Iw[n] = EH.fetch(`https://tiktoken.pages.dev/js/${n}.json`).then(e => e.json()).then(e => new iO(e)).catch(e => {
            throw delete Iw[n],
            e
        }
        )),
        await Iw[n]
    }
    async function CH(n) {
        return xH(SH(n))
    }
    const kH = n => n.startsWith("gpt-3.5-turbo-16k") ? "gpt-3.5-turbo-16k" : n.startsWith("gpt-3.5-turbo-") ? "gpt-3.5-turbo" : n.startsWith("gpt-4-32k") ? "gpt-4-32k" : n.startsWith("gpt-4-") ? "gpt-4" : n.startsWith("gpt-4o") ? "gpt-4o" : n;
    function Ow(n) {
        return typeof n != "object" || !n ? !1 : !!("type"in n && n.type === "function" && "function"in n && typeof n.function == "object" && n.function && "name"in n.function && "parameters"in n.function)
    }
    const PH = () => !1;
    class TH extends jt {
        get lc_attributes() {
            return {
                callbacks: void 0,
                verbose: void 0
            }
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "verbose", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "callbacks", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "tags", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "metadata", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.verbose = e.verbose ?? PH(),
            this.callbacks = e.callbacks,
            this.tags = e.tags ?? [],
            this.metadata = e.metadata ?? {}
        }
    }
    class AH extends TH {
        get callKeys() {
            return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"]
        }
        constructor({callbacks: e, callbackManager: t, ...r}) {
            const {cache: s, ...i} = r;
            super({
                callbacks: e ?? t,
                ...i
            }),
            Object.defineProperty(this, "caller", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "cache", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "_encoding", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            typeof s == "object" ? this.cache = s : s ? this.cache = YS.global() : this.cache = void 0,
            this.caller = new W0(r ?? {})
        }
        async getNumTokens(e) {
            if (typeof e != "string")
                return 0;
            let t = Math.ceil(e.length / 4);
            if (!this._encoding)
                try {
                    this._encoding = await CH("modelName"in this ? kH(this.modelName) : "gpt2")
                } catch (r) {
                    console.warn("Failed to calculate number of tokens, falling back to approximate count", r)
                }
            if (this._encoding)
                try {
                    t = this._encoding.encode(e).length
                } catch (r) {
                    console.warn("Failed to calculate number of tokens, falling back to approximate count", r)
                }
            return t
        }
        static _convertInputToPromptValue(e) {
            return typeof e == "string" ? new wI(e) : Array.isArray(e) ? new S5(e.map(ch)) : e
        }
        _identifyingParams() {
            return {}
        }
        _getSerializedCacheKeyParametersForCall({config: e, ...t}) {
            const r = {
                ...this._identifyingParams(),
                ...t,
                _type: this._llmType(),
                _model: this._modelType()
            };
            return Object.entries(r).filter( ([a,c]) => c !== void 0).map( ([a,c]) => `${a}:${JSON.stringify(c)}`).sort().join(",")
        }
        serialize() {
            return {
                ...this._identifyingParams(),
                _type: this._llmType(),
                _model: this._modelType()
            }
        }
        static async deserialize(e) {
            throw new Error("Use .toJSON() instead")
        }
    }
    class Vi extends jt {
        static lc_name() {
            return "RunnablePassthrough"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "runnables"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "func", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            e && (this.func = e.func)
        }
        async invoke(e, t) {
            const r = it(t);
            return this.func && await this.func(e, r),
            this._callWithConfig(s => Promise.resolve(s), e, r)
        }
        async*transform(e, t) {
            const r = it(t);
            let s, i = !0;
            for await(const a of this._transformStreamWithConfig(e, c => c, r))
                if (yield a,
                i)
                    if (s === void 0)
                        s = a;
                    else
                        try {
                            s = Nn(s, a)
                        } catch {
                            s = void 0,
                            i = !1
                        }
            this.func && s !== void 0 && await this.func(s, r)
        }
        static assign(e) {
            return new hI(new fu({
                steps: e
            }))
        }
    }
    function Rw(n) {
        return typeof (n == null ? void 0 : n.parse) == "function"
    }
    class bs extends AH {
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "chat_models", this._llmType()]
            }),
            Object.defineProperty(this, "disableStreaming", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            })
        }
        _separateRunnableConfigFromCallOptionsCompat(e) {
            const [t,r] = super._separateRunnableConfigFromCallOptions(e);
            return r.signal = t.signal,
            [t, r]
        }
        async invoke(e, t) {
            const r = bs._convertInputToPromptValue(e);
            return (await this.generatePrompt([r], t, t == null ? void 0 : t.callbacks)).generations[0][0].message
        }
        async*_streamResponseChunks(e, t, r) {
            throw new Error("Not implemented.")
        }
        async*_streamIterator(e, t) {
            var r;
            if (this._streamResponseChunks === bs.prototype._streamResponseChunks || this.disableStreaming)
                yield this.invoke(e, t);
            else {
                const i = bs._convertInputToPromptValue(e).toChatMessages()
                  , [a,c] = this._separateRunnableConfigFromCallOptionsCompat(t)
                  , u = {
                    ...a.metadata,
                    ...this.getLsParams(c)
                }
                  , l = await Nr.configure(a.callbacks, this.callbacks, a.tags, this.tags, u, this.metadata, {
                    verbose: this.verbose
                })
                  , d = {
                    options: c,
                    invocation_params: this == null ? void 0 : this.invocationParams(c),
                    batch_size: 1
                }
                  , h = await (l == null ? void 0 : l.handleChatModelStart(this.toJSON(), [i], a.runId, void 0, d, void 0, void 0, a.runName));
                let f, p;
                try {
                    for await(const g of this._streamResponseChunks(i, c, h == null ? void 0 : h[0])) {
                        if (g.message.id == null) {
                            const y = (r = h == null ? void 0 : h.at(0)) == null ? void 0 : r.runId;
                            y != null && g.message._updateId(`run-${y}`)
                        }
                        g.message.response_metadata = {
                            ...g.generationInfo,
                            ...g.message.response_metadata
                        },
                        yield g.message,
                        f ? f = f.concat(g) : f = g,
                        gT(g.message) && g.message.usage_metadata !== void 0 && (p = {
                            tokenUsage: {
                                promptTokens: g.message.usage_metadata.input_tokens,
                                completionTokens: g.message.usage_metadata.output_tokens,
                                totalTokens: g.message.usage_metadata.total_tokens
                            }
                        })
                    }
                } catch (g) {
                    throw await Promise.all((h ?? []).map(y => y == null ? void 0 : y.handleLLMError(g))),
                    g
                }
                await Promise.all((h ?? []).map(g => g == null ? void 0 : g.handleLLMEnd({
                    generations: [[f]],
                    llmOutput: p
                })))
            }
        }
        getLsParams(e) {
            const t = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
            return {
                ls_model_type: "chat",
                ls_stop: e.stop,
                ls_provider: t
            }
        }
        async _generateUncached(e, t, r, s) {
            var h, f;
            const i = e.map(p => p.map(ch));
            let a;
            if (s !== void 0 && s.length === i.length)
                a = s;
            else {
                const p = {
                    ...r.metadata,
                    ...this.getLsParams(t)
                }
                  , g = await Nr.configure(r.callbacks, this.callbacks, r.tags, this.tags, p, this.metadata, {
                    verbose: this.verbose
                })
                  , y = {
                    options: t,
                    invocation_params: this == null ? void 0 : this.invocationParams(t),
                    batch_size: 1
                };
                a = await (g == null ? void 0 : g.handleChatModelStart(this.toJSON(), i, r.runId, void 0, y, void 0, void 0, r.runName))
            }
            const c = []
              , u = [];
            if (!!(a != null && a[0].handlers.find($2)) && !this.disableStreaming && i.length === 1 && this._streamResponseChunks !== bs.prototype._streamResponseChunks)
                try {
                    const p = await this._streamResponseChunks(i[0], t, a == null ? void 0 : a[0]);
                    let g, y;
                    for await(const m of p) {
                        if (m.message.id == null) {
                            const w = (h = a == null ? void 0 : a.at(0)) == null ? void 0 : h.runId;
                            w != null && m.message._updateId(`run-${w}`)
                        }
                        g === void 0 ? g = m : g = Nn(g, m),
                        gT(m.message) && m.message.usage_metadata !== void 0 && (y = {
                            tokenUsage: {
                                promptTokens: m.message.usage_metadata.input_tokens,
                                completionTokens: m.message.usage_metadata.output_tokens,
                                totalTokens: m.message.usage_metadata.total_tokens
                            }
                        })
                    }
                    if (g === void 0)
                        throw new Error("Received empty response from chat model call.");
                    c.push([g]),
                    await (a == null ? void 0 : a[0].handleLLMEnd({
                        generations: c,
                        llmOutput: y
                    }))
                } catch (p) {
                    throw await (a == null ? void 0 : a[0].handleLLMError(p)),
                    p
                }
            else {
                const p = await Promise.allSettled(i.map( (g, y) => this._generate(g, {
                    ...t,
                    promptIndex: y
                }, a == null ? void 0 : a[y])));
                await Promise.all(p.map(async (g, y) => {
                    var m, w, E;
                    if (g.status === "fulfilled") {
                        const v = g.value;
                        for (const _ of v.generations) {
                            if (_.message.id == null) {
                                const A = (m = a == null ? void 0 : a.at(0)) == null ? void 0 : m.runId;
                                A != null && _.message._updateId(`run-${A}`)
                            }
                            _.message.response_metadata = {
                                ..._.generationInfo,
                                ..._.message.response_metadata
                            }
                        }
                        return v.generations.length === 1 && (v.generations[0].message.response_metadata = {
                            ...v.llmOutput,
                            ...v.generations[0].message.response_metadata
                        }),
                        c[y] = v.generations,
                        u[y] = v.llmOutput,
                        (w = a == null ? void 0 : a[y]) == null ? void 0 : w.handleLLMEnd({
                            generations: [v.generations],
                            llmOutput: v.llmOutput
                        })
                    } else
                        return await ((E = a == null ? void 0 : a[y]) == null ? void 0 : E.handleLLMError(g.reason)),
                        Promise.reject(g.reason)
                }
                ))
            }
            const d = {
                generations: c,
                llmOutput: u.length ? (f = this._combineLLMOutput) == null ? void 0 : f.call(this, ...u) : void 0
            };
            return Object.defineProperty(d, QA, {
                value: a ? {
                    runIds: a == null ? void 0 : a.map(p => p.runId)
                } : void 0,
                configurable: !0
            }),
            d
        }
        async _generateCached({messages: e, cache: t, llmStringKey: r, parsedOptions: s, handledOptions: i}) {
            const a = e.map(m => m.map(ch))
              , c = {
                ...i.metadata,
                ...this.getLsParams(s)
            }
              , u = await Nr.configure(i.callbacks, this.callbacks, i.tags, this.tags, c, this.metadata, {
                verbose: this.verbose
            })
              , l = {
                options: s,
                invocation_params: this == null ? void 0 : this.invocationParams(s),
                batch_size: 1
            }
              , d = await (u == null ? void 0 : u.handleChatModelStart(this.toJSON(), a, i.runId, void 0, l, void 0, void 0, i.runName))
              , h = []
              , p = (await Promise.allSettled(a.map(async (m, w) => {
                const E = bs._convertInputToPromptValue(m).toString()
                  , v = await t.lookup(E, r);
                return v == null && h.push(w),
                v
            }
            ))).map( (m, w) => ({
                result: m,
                runManager: d == null ? void 0 : d[w]
            })).filter( ({result: m}) => m.status === "fulfilled" && m.value != null || m.status === "rejected")
              , g = [];
            await Promise.all(p.map(async ({result: m, runManager: w}, E) => {
                if (m.status === "fulfilled") {
                    const v = m.value;
                    return g[E] = v.map(_ => ("message"in _ && ih(_.message) && ah(_.message) && (_.message.usage_metadata = {
                        input_tokens: 0,
                        output_tokens: 0,
                        total_tokens: 0
                    }),
                    _.generationInfo = {
                        ..._.generationInfo,
                        tokenUsage: {}
                    },
                    _)),
                    v.length && await (w == null ? void 0 : w.handleLLMNewToken(v[0].text)),
                    w == null ? void 0 : w.handleLLMEnd({
                        generations: [v]
                    }, void 0, void 0, void 0, {
                        cached: !0
                    })
                } else
                    return await (w == null ? void 0 : w.handleLLMError(m.reason, void 0, void 0, void 0, {
                        cached: !0
                    })),
                    Promise.reject(m.reason)
            }
            ));
            const y = {
                generations: g,
                missingPromptIndices: h,
                startedRunManagers: d
            };
            return Object.defineProperty(y, QA, {
                value: d ? {
                    runIds: d == null ? void 0 : d.map(m => m.runId)
                } : void 0,
                configurable: !0
            }),
            y
        }
        async generate(e, t, r) {
            let s;
            Array.isArray(t) ? s = {
                stop: t
            } : s = t;
            const i = e.map(g => g.map(ch))
              , [a,c] = this._separateRunnableConfigFromCallOptionsCompat(s);
            if (a.callbacks = a.callbacks ?? r,
            !this.cache)
                return this._generateUncached(i, c, a);
            const {cache: u} = this
              , l = this._getSerializedCacheKeyParametersForCall(c)
              , {generations: d, missingPromptIndices: h, startedRunManagers: f} = await this._generateCached({
                messages: i,
                cache: u,
                llmStringKey: l,
                parsedOptions: c,
                handledOptions: a
            });
            let p = {};
            if (h.length > 0) {
                const g = await this._generateUncached(h.map(y => i[y]), c, a, f !== void 0 ? h.map(y => f == null ? void 0 : f[y]) : void 0);
                await Promise.all(g.generations.map(async (y, m) => {
                    const w = h[m];
                    d[w] = y;
                    const E = bs._convertInputToPromptValue(i[w]).toString();
                    return u.update(E, l, y)
                }
                )),
                p = g.llmOutput ?? {}
            }
            return {
                generations: d,
                llmOutput: p
            }
        }
        invocationParams(e) {
            return {}
        }
        _modelType() {
            return "base_chat_model"
        }
        serialize() {
            return {
                ...this.invocationParams(),
                _type: this._llmType(),
                _model: this._modelType()
            }
        }
        async generatePrompt(e, t, r) {
            const s = e.map(i => i.toChatMessages());
            return this.generate(s, t, r)
        }
        async call(e, t, r) {
            return (await this.generate([e.map(ch)], t, r)).generations[0][0].message
        }
        async callPrompt(e, t, r) {
            const s = e.toChatMessages();
            return this.call(s, t, r)
        }
        async predictMessages(e, t, r) {
            return this.call(e, t, r)
        }
        async predict(e, t, r) {
            const s = new Ct(e)
              , i = await this.call([s], t, r);
            if (typeof i.content != "string")
                throw new Error("Cannot use predict when output is not a string.");
            return i.content
        }
        withStructuredOutput(e, t) {
            if (typeof this.bindTools != "function")
                throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');
            if (t != null && t.strict)
                throw new Error('"strict" mode is not supported for this model by default.');
            const r = e
              , s = t == null ? void 0 : t.name
              , i = r.description ?? "A function available to call."
              , a = t == null ? void 0 : t.method
              , c = t == null ? void 0 : t.includeRaw;
            if (a === "jsonMode")
                throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');
            let u = s ?? "extract", l;
            Rw(r) ? l = [{
                type: "function",
                function: {
                    name: u,
                    description: i,
                    parameters: Ui(r)
                }
            }] : ("name"in r && (u = r.name),
            l = [{
                type: "function",
                function: {
                    name: u,
                    description: i,
                    parameters: r
                }
            }]);
            const d = this.bindTools(l)
              , h = Sh.from(y => {
                if (!y.tool_calls || y.tool_calls.length === 0)
                    throw new Error("No tool calls found in the response.");
                const m = y.tool_calls.find(w => w.name === u);
                if (!m)
                    throw new Error(`No tool call found with name ${u}.`);
                return m.args
            }
            );
            if (!c)
                return d.pipe(h).withConfig({
                    runName: "StructuredOutput"
                });
            const f = Vi.assign({
                parsed: (y, m) => h.invoke(y.raw, m)
            })
              , p = Vi.assign({
                parsed: () => null
            })
              , g = f.withFallbacks({
                fallbacks: [p]
            });
            return Fn.from([{
                raw: d
            }, g]).withConfig({
                runName: "StructuredOutputRunnable"
            })
        }
    }
    class eE extends jt {
        parseResultWithPrompt(e, t, r) {
            return this.parseResult(e, r)
        }
        _baseMessageToString(e) {
            return typeof e.content == "string" ? e.content : this._baseMessageContentToString(e.content)
        }
        _baseMessageContentToString(e) {
            return JSON.stringify(e)
        }
        async invoke(e, t) {
            return typeof e == "string" ? this._callWithConfig(async (r, s) => this.parseResult([{
                text: r
            }], s == null ? void 0 : s.callbacks), e, {
                ...t,
                runType: "parser"
            }) : this._callWithConfig(async (r, s) => this.parseResult([{
                message: r,
                text: this._baseMessageToString(r)
            }], s == null ? void 0 : s.callbacks), e, {
                ...t,
                runType: "parser"
            })
        }
    }
    class aO extends eE {
        parseResult(e, t) {
            return this.parse(e[0].text, t)
        }
        async parseWithPrompt(e, t, r) {
            return this.parse(e, r)
        }
        _type() {
            throw new Error("_type not implemented")
        }
    }
    class Iu extends Error {
        constructor(e, t, r, s=!1) {
            if (super(e),
            Object.defineProperty(this, "llmOutput", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "observation", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "sendToLLM", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.llmOutput = t,
            this.observation = r,
            this.sendToLLM = s,
            s && (r === void 0 || t === void 0))
                throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
            S_(this, "OUTPUT_PARSING_FAILURE")
        }
    }
    function tE(n, e) {
        const t = typeof n;
        if (t !== typeof e)
            return !1;
        if (Array.isArray(n)) {
            if (!Array.isArray(e))
                return !1;
            const r = n.length;
            if (r !== e.length)
                return !1;
            for (let s = 0; s < r; s++)
                if (!tE(n[s], e[s]))
                    return !1;
            return !0
        }
        if (t === "object") {
            if (!n || !e)
                return n === e;
            const r = Object.keys(n)
              , s = Object.keys(e);
            if (r.length !== s.length)
                return !1;
            for (const a of r)
                if (!tE(n[a], e[a]))
                    return !1;
            return !0
        }
        return n === e
    }
    class IH extends aO {
        async*_transform(e) {
            for await(const t of e)
                typeof t == "string" ? yield this.parseResult([{
                    text: t
                }]) : yield this.parseResult([{
                    message: t,
                    text: this._baseMessageToString(t)
                }])
        }
        async*transform(e, t) {
            yield*this._transformStreamWithConfig(e, this._transform.bind(this), {
                ...t,
                runType: "parser"
            })
        }
    }
    class oO extends IH {
        constructor(e) {
            super(e),
            Object.defineProperty(this, "diff", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            this.diff = (e == null ? void 0 : e.diff) ?? this.diff
        }
        async*_transform(e) {
            let t, r;
            for await(const s of e) {
                if (typeof s != "string" && typeof s.content != "string")
                    throw new Error("Cannot handle non-string output.");
                let i;
                if (JU(s)) {
                    if (typeof s.content != "string")
                        throw new Error("Cannot handle non-string message output.");
                    i = new qi({
                        message: s,
                        text: s.content
                    })
                } else if (ih(s)) {
                    if (typeof s.content != "string")
                        throw new Error("Cannot handle non-string message output.");
                    i = new qi({
                        message: e3(s),
                        text: s.content
                    })
                } else
                    i = new hu({
                        text: s
                    });
                r === void 0 ? r = i : r = r.concat(i);
                const a = await this.parsePartialResult([r]);
                a != null && !tE(a, t) && (this.diff ? yield this._diff(t, a) : yield a,
                t = a)
            }
        }
        getFormatInstructions() {
            return ""
        }
    }
    class cO extends aO {
        static lc_name() {
            return "StructuredOutputParser"
        }
        toJSON() {
            return this.toJSONNotImplemented()
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "schema", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: e
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "output_parsers", "structured"]
            })
        }
        static fromZodSchema(e) {
            return new this(e)
        }
        static fromNamesAndDescriptions(e) {
            const t = fe.object(Object.fromEntries(Object.entries(e).map( ([r,s]) => [r, fe.string().describe(s)])));
            return new this(t)
        }
        getFormatInstructions() {
            return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(Ui(this.schema))}
\`\`\`
`
        }
        async parse(e) {
            try {
                const r = (e.includes("```") ? e.trim().split(/```(?:json)?/)[1] : e.trim()).replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (s, i) => `"${i.replace(/\n/g, "\\n")}"`).replace(/\n/g, "");
                return await this.schema.parseAsync(JSON.parse(r))
            } catch (t) {
                throw new Iu(`Failed to parse. Text: "${e}". Error: ${t}`,e)
            }
        }
    }
    class uO extends oO {
        constructor() {
            super(...arguments),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain_core", "output_parsers"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            })
        }
        static lc_name() {
            return "JsonOutputParser"
        }
        _diff(e, t) {
            if (t)
                return e ? P2(e, t) : [{
                    op: "replace",
                    path: "",
                    value: t
                }]
        }
        async parsePartialResult(e) {
            return dT(e[0].text)
        }
        async parse(e) {
            return dT(e, JSON.parse)
        }
        getFormatInstructions() {
            return ""
        }
    }
    function lO(n, e) {
        if (n.function === void 0)
            return;
        let t;
        if (e != null && e.partial)
            try {
                t = b_(n.function.arguments ?? "{}")
            } catch {
                return
            }
        else
            try {
                t = JSON.parse(n.function.arguments)
            } catch (s) {
                throw new Iu([`Function "${n.function.name}" arguments:`, "", n.function.arguments, "", "are not valid JSON.", `Error: ${s.message}`].join(`
`))
            }
        const r = {
            name: n.function.name,
            args: t,
            type: "tool_call"
        };
        return e != null && e.returnId && (r.id = n.id),
        r
    }
    function OH(n) {
        if (n.id === void 0)
            throw new Error('All OpenAI tool calls must have an "id" field.');
        return {
            id: n.id,
            type: "function",
            function: {
                name: n.name,
                arguments: JSON.stringify(n.args)
            }
        }
    }
    function RH(n, e) {
        var t, r;
        return {
            name: (t = n.function) == null ? void 0 : t.name,
            args: (r = n.function) == null ? void 0 : r.arguments,
            id: n.id,
            error: e,
            type: "invalid_tool_call"
        }
    }
    class MH extends oO {
        static lc_name() {
            return "JsonOutputToolsParser"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "returnId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "output_parsers", "openai_tools"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            this.returnId = (e == null ? void 0 : e.returnId) ?? this.returnId
        }
        _diff() {
            throw new Error("Not supported.")
        }
        async parse() {
            throw new Error("Not implemented.")
        }
        async parseResult(e) {
            return await this.parsePartialResult(e, !1)
        }
        async parsePartialResult(e, t=!0) {
            var a;
            const r = e[0].message;
            let s;
            if (ah(r) && ((a = r.tool_calls) != null && a.length) ? s = r.tool_calls.map(c => {
                const {id: u, ...l} = c;
                return this.returnId ? {
                    id: u,
                    ...l
                } : l
            }
            ) : r.additional_kwargs.tool_calls !== void 0 && (s = JSON.parse(JSON.stringify(r.additional_kwargs.tool_calls)).map(u => lO(u, {
                returnId: this.returnId,
                partial: t
            }))),
            !s)
                return [];
            const i = [];
            for (const c of s)
                if (c !== void 0) {
                    const u = {
                        type: c.name,
                        args: c.args,
                        id: c.id
                    };
                    i.push(u)
                }
            return i
        }
    }
    class dO extends MH {
        static lc_name() {
            return "JsonOutputKeyToolsParser"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "output_parsers", "openai_tools"]
            }),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "returnId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "keyName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "returnSingle", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "zodSchema", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.keyName = e.keyName,
            this.returnSingle = e.returnSingle ?? this.returnSingle,
            this.zodSchema = e.zodSchema
        }
        async _validateResult(e) {
            if (this.zodSchema === void 0)
                return e;
            const t = await this.zodSchema.safeParseAsync(e);
            if (t.success)
                return t.data;
            throw new Iu(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(t.error.errors)}`,JSON.stringify(e, null, 2))
        }
        async parsePartialResult(e) {
            const r = (await super.parsePartialResult(e)).filter(i => i.type === this.keyName);
            let s = r;
            if (r.length)
                return this.returnId || (s = r.map(i => i.args)),
                this.returnSingle ? s[0] : s
        }
        async parseResult(e) {
            const r = (await super.parsePartialResult(e, !1)).filter(a => a.type === this.keyName);
            let s = r;
            return r.length ? (this.returnId || (s = r.map(a => a.args)),
            this.returnSingle ? this._validateResult(s[0]) : await Promise.all(s.map(a => this._validateResult(a)))) : void 0
        }
    }
    const NH = Symbol("Let zodToJsonSchema decide on which parser to use")
      , hO = {
        name: void 0,
        $refStrategy: "root",
        effectStrategy: "input",
        pipeStrategy: "all",
        dateStrategy: "format:date-time",
        mapStrategy: "entries",
        nullableStrategy: "from-target",
        removeAdditionalStrategy: "passthrough",
        definitionPath: "definitions",
        target: "jsonSchema7",
        strictUnions: !1,
        errorMessages: !1,
        markdownDescription: !1,
        patternStrategy: "escape",
        applyRegexFlags: !1,
        emailStrategy: "format:email",
        base64Strategy: "contentEncoding:base64",
        nameStrategy: "ref"
    }
      , $H = n => typeof n == "string" ? {
        ...hO,
        basePath: ["#"],
        definitions: {},
        name: n
    } : {
        ...hO,
        basePath: ["#"],
        definitions: {},
        ...n
    }
      , rE = n => "_def"in n ? n._def : n;
    function LH(n) {
        if (!n)
            return !0;
        for (const e in n)
            return !1;
        return !0
    }
    const FH = n => {
        const e = $H(n)
          , t = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
        return {
            ...e,
            currentPath: t,
            propertyPath: void 0,
            seenRefs: new Set,
            seen: new Map(Object.entries(e.definitions).map( ([r,s]) => [rE(s), {
                def: rE(s),
                path: [...e.basePath, e.definitionPath, r],
                jsonSchema: void 0
            }]))
        }
    }
    ;
    function fO(n, e, t, r) {
        r != null && r.errorMessages && t && (n.errorMessage = {
            ...n.errorMessage,
            [e]: t
        })
    }
    function ct(n, e, t, r, s) {
        n[e] = t,
        fO(n, e, r, s)
    }
    function jH() {
        return {}
    }
    function DH(n, e) {
        var r, s;
        const t = {
            type: "array"
        };
        return ((s = (r = n.type) == null ? void 0 : r._def) == null ? void 0 : s.typeName) !== Y.ZodAny && (t.items = et(n.type._def, {
            ...e,
            currentPath: [...e.currentPath, "items"]
        })),
        n.minLength && ct(t, "minItems", n.minLength.value, n.minLength.message, e),
        n.maxLength && ct(t, "maxItems", n.maxLength.value, n.maxLength.message, e),
        n.exactLength && (ct(t, "minItems", n.exactLength.value, n.exactLength.message, e),
        ct(t, "maxItems", n.exactLength.value, n.exactLength.message, e)),
        t
    }
    function BH(n, e) {
        const t = {
            type: "integer",
            format: "int64"
        };
        if (!n.checks)
            return t;
        for (const r of n.checks)
            switch (r.kind) {
            case "min":
                e.target === "jsonSchema7" ? r.inclusive ? ct(t, "minimum", r.value, r.message, e) : ct(t, "exclusiveMinimum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMinimum = !0),
                ct(t, "minimum", r.value, r.message, e));
                break;
            case "max":
                e.target === "jsonSchema7" ? r.inclusive ? ct(t, "maximum", r.value, r.message, e) : ct(t, "exclusiveMaximum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMaximum = !0),
                ct(t, "maximum", r.value, r.message, e));
                break;
            case "multipleOf":
                ct(t, "multipleOf", r.value, r.message, e);
                break
            }
        return t
    }
    function qH() {
        return {
            type: "boolean"
        }
    }
    function UH(n, e) {
        return et(n.type._def, e)
    }
    const KH = (n, e) => et(n.innerType._def, e);
    function pO(n, e, t) {
        const r = t ?? e.dateStrategy;
        if (Array.isArray(r))
            return {
                anyOf: r.map( (s, i) => pO(n, e, s))
            };
        switch (r) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return HH(n, e)
        }
    }
    const HH = (n, e) => {
        const t = {
            type: "integer",
            format: "unix-time"
        };
        if (e.target === "openApi3")
            return t;
        for (const r of n.checks)
            switch (r.kind) {
            case "min":
                ct(t, "minimum", r.value, r.message, e);
                break;
            case "max":
                ct(t, "maximum", r.value, r.message, e);
                break
            }
        return t
    }
    ;
    function WH(n, e) {
        return {
            ...et(n.innerType._def, e),
            default: n.defaultValue()
        }
    }
    function zH(n, e, t) {
        return e.effectStrategy === "input" ? et(n.schema._def, e, t) : {}
    }
    function VH(n) {
        return {
            type: "string",
            enum: [...n.values]
        }
    }
    const GH = n => "type"in n && n.type === "string" ? !1 : "allOf"in n;
    function JH(n, e) {
        const t = [et(n.left._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "0"]
        }), et(n.right._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "1"]
        })].filter(i => !!i);
        let r = e.target === "jsonSchema2019-09" ? {
            unevaluatedProperties: !1
        } : void 0;
        const s = [];
        return t.forEach(i => {
            if (GH(i))
                s.push(...i.allOf),
                i.unevaluatedProperties === void 0 && (r = void 0);
            else {
                let a = i;
                if ("additionalProperties"in i && i.additionalProperties === !1) {
                    const {additionalProperties: c, ...u} = i;
                    a = u
                } else
                    r = void 0;
                s.push(a)
            }
        }
        ),
        s.length ? {
            allOf: s,
            ...r
        } : void 0
    }
    function ZH(n, e) {
        const t = typeof n.value;
        return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
            type: Array.isArray(n.value) ? "array" : "object"
        } : e.target === "openApi3" ? {
            type: t === "bigint" ? "integer" : t,
            enum: [n.value]
        } : {
            type: t === "bigint" ? "integer" : t,
            const: n.value
        }
    }
    let nE;
    const lo = {
        cuid: /^[cC][^\s-]{8,}$/,
        cuid2: /^[0-9a-z]+$/,
        ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
        email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
        emoji: () => (nE === void 0 && (nE = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")),
        nE),
        uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
        ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
        ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
        nanoid: /^[a-zA-Z0-9_-]{21}$/
    };
    function mO(n, e) {
        const t = {
            type: "string"
        };
        function r(s) {
            return e.patternStrategy === "escape" ? XH(s) : s
        }
        if (n.checks)
            for (const s of n.checks)
                switch (s.kind) {
                case "min":
                    ct(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, s.value) : s.value, s.message, e);
                    break;
                case "max":
                    ct(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, s.value) : s.value, s.message, e);
                    break;
                case "email":
                    switch (e.emailStrategy) {
                    case "format:email":
                        Hn(t, "email", s.message, e);
                        break;
                    case "format:idn-email":
                        Hn(t, "idn-email", s.message, e);
                        break;
                    case "pattern:zod":
                        Wn(t, lo.email, s.message, e);
                        break
                    }
                    break;
                case "url":
                    Hn(t, "uri", s.message, e);
                    break;
                case "uuid":
                    Hn(t, "uuid", s.message, e);
                    break;
                case "regex":
                    Wn(t, s.regex, s.message, e);
                    break;
                case "cuid":
                    Wn(t, lo.cuid, s.message, e);
                    break;
                case "cuid2":
                    Wn(t, lo.cuid2, s.message, e);
                    break;
                case "startsWith":
                    Wn(t, RegExp(`^${r(s.value)}`), s.message, e);
                    break;
                case "endsWith":
                    Wn(t, RegExp(`${r(s.value)}$`), s.message, e);
                    break;
                case "datetime":
                    Hn(t, "date-time", s.message, e);
                    break;
                case "date":
                    Hn(t, "date", s.message, e);
                    break;
                case "time":
                    Hn(t, "time", s.message, e);
                    break;
                case "duration":
                    Hn(t, "duration", s.message, e);
                    break;
                case "length":
                    ct(t, "minLength", typeof t.minLength == "number" ? Math.max(t.minLength, s.value) : s.value, s.message, e),
                    ct(t, "maxLength", typeof t.maxLength == "number" ? Math.min(t.maxLength, s.value) : s.value, s.message, e);
                    break;
                case "includes":
                    {
                        Wn(t, RegExp(r(s.value)), s.message, e);
                        break
                    }
                case "ip":
                    {
                        s.version !== "v6" && Hn(t, "ipv4", s.message, e),
                        s.version !== "v4" && Hn(t, "ipv6", s.message, e);
                        break
                    }
                case "emoji":
                    Wn(t, lo.emoji, s.message, e);
                    break;
                case "ulid":
                    {
                        Wn(t, lo.ulid, s.message, e);
                        break
                    }
                case "base64":
                    {
                        switch (e.base64Strategy) {
                        case "format:binary":
                            {
                                Hn(t, "binary", s.message, e);
                                break
                            }
                        case "contentEncoding:base64":
                            {
                                ct(t, "contentEncoding", "base64", s.message, e);
                                break
                            }
                        case "pattern:zod":
                            {
                                Wn(t, lo.base64, s.message, e);
                                break
                            }
                        }
                        break
                    }
                case "nanoid":
                    Wn(t, lo.nanoid, s.message, e)
                }
        return t
    }
    const XH = n => Array.from(n).map(e => /[a-zA-Z0-9]/.test(e) ? e : `\\${e}`).join("")
      , Hn = (n, e, t, r) => {
        var s;
        n.format || (s = n.anyOf) != null && s.some(i => i.format) ? (n.anyOf || (n.anyOf = []),
        n.format && (n.anyOf.push({
            format: n.format,
            ...n.errorMessage && r.errorMessages && {
                errorMessage: {
                    format: n.errorMessage.format
                }
            }
        }),
        delete n.format,
        n.errorMessage && (delete n.errorMessage.format,
        Object.keys(n.errorMessage).length === 0 && delete n.errorMessage)),
        n.anyOf.push({
            format: e,
            ...t && r.errorMessages && {
                errorMessage: {
                    format: t
                }
            }
        })) : ct(n, "format", e, t, r)
    }
      , Wn = (n, e, t, r) => {
        var s;
        n.pattern || (s = n.allOf) != null && s.some(i => i.pattern) ? (n.allOf || (n.allOf = []),
        n.pattern && (n.allOf.push({
            pattern: n.pattern,
            ...n.errorMessage && r.errorMessages && {
                errorMessage: {
                    pattern: n.errorMessage.pattern
                }
            }
        }),
        delete n.pattern,
        n.errorMessage && (delete n.errorMessage.pattern,
        Object.keys(n.errorMessage).length === 0 && delete n.errorMessage)),
        n.allOf.push({
            pattern: gO(e, r),
            ...t && r.errorMessages && {
                errorMessage: {
                    pattern: t
                }
            }
        })) : ct(n, "pattern", gO(e, r), t, r)
    }
      , gO = (n, e) => {
        var l;
        const t = typeof n == "function" ? n() : n;
        if (!e.applyRegexFlags || !t.flags)
            return t.source;
        const r = {
            i: t.flags.includes("i"),
            m: t.flags.includes("m"),
            s: t.flags.includes("s")
        }
          , s = r.i ? t.source.toLowerCase() : t.source;
        let i = ""
          , a = !1
          , c = !1
          , u = !1;
        for (let d = 0; d < s.length; d++) {
            if (a) {
                i += s[d],
                a = !1;
                continue
            }
            if (r.i) {
                if (c) {
                    if (s[d].match(/[a-z]/)) {
                        u ? (i += s[d],
                        i += `${s[d - 2]}-${s[d]}`.toUpperCase(),
                        u = !1) : s[d + 1] === "-" && ((l = s[d + 2]) != null && l.match(/[a-z]/)) ? (i += s[d],
                        u = !0) : i += `${s[d]}${s[d].toUpperCase()}`;
                        continue
                    }
                } else if (s[d].match(/[a-z]/)) {
                    i += `[${s[d]}${s[d].toUpperCase()}]`;
                    continue
                }
            }
            if (r.m) {
                if (s[d] === "^") {
                    i += `(^|(?<=[\r
]))`;
                    continue
                } else if (s[d] === "$") {
                    i += `($|(?=[\r
]))`;
                    continue
                }
            }
            if (r.s && s[d] === ".") {
                i += c ? `${s[d]}\r
` : `[${s[d]}\r
]`;
                continue
            }
            i += s[d],
            s[d] === "\\" ? a = !0 : c && s[d] === "]" ? c = !1 : !c && s[d] === "[" && (c = !0)
        }
        try {
            const d = new RegExp(i)
        } catch {
            return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`),
            t.source
        }
        return i
    }
    ;
    function yO(n, e) {
        var r, s, i, a;
        if (e.target === "openApi3" && ((r = n.keyType) == null ? void 0 : r._def.typeName) === Y.ZodEnum)
            return {
                type: "object",
                required: n.keyType._def.values,
                properties: n.keyType._def.values.reduce( (c, u) => ({
                    ...c,
                    [u]: et(n.valueType._def, {
                        ...e,
                        currentPath: [...e.currentPath, "properties", u]
                    }) ?? {}
                }), {}),
                additionalProperties: !1
            };
        const t = {
            type: "object",
            additionalProperties: et(n.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalProperties"]
            }) ?? {}
        };
        if (e.target === "openApi3")
            return t;
        if (((s = n.keyType) == null ? void 0 : s._def.typeName) === Y.ZodString && ((i = n.keyType._def.checks) != null && i.length)) {
            const c = Object.entries(mO(n.keyType._def, e)).reduce( (u, [l,d]) => l === "type" ? u : {
                ...u,
                [l]: d
            }, {});
            return {
                ...t,
                propertyNames: c
            }
        } else if (((a = n.keyType) == null ? void 0 : a._def.typeName) === Y.ZodEnum)
            return {
                ...t,
                propertyNames: {
                    enum: n.keyType._def.values
                }
            };
        return t
    }
    function YH(n, e) {
        if (e.mapStrategy === "record")
            return yO(n, e);
        const t = et(n.keyType._def, {
            ...e,
            currentPath: [...e.currentPath, "items", "items", "0"]
        }) || {}
          , r = et(n.valueType._def, {
            ...e,
            currentPath: [...e.currentPath, "items", "items", "1"]
        }) || {};
        return {
            type: "array",
            maxItems: 125,
            items: {
                type: "array",
                items: [t, r],
                minItems: 2,
                maxItems: 2
            }
        }
    }
    function QH(n) {
        const e = n.values
          , r = Object.keys(n.values).filter(i => typeof e[e[i]] != "number").map(i => e[i])
          , s = Array.from(new Set(r.map(i => typeof i)));
        return {
            type: s.length === 1 ? s[0] === "string" ? "string" : "number" : ["string", "number"],
            enum: r
        }
    }
    function e6() {
        return {
            not: {}
        }
    }
    function t6(n) {
        return n.target === "openApi3" ? {
            enum: ["null"],
            nullable: !0
        } : {
            type: "null"
        }
    }
    const Mw = {
        ZodString: "string",
        ZodNumber: "number",
        ZodBigInt: "integer",
        ZodBoolean: "boolean",
        ZodNull: "null"
    };
    function r6(n, e) {
        if (e.target === "openApi3")
            return wO(n, e);
        const t = n.options instanceof Map ? Array.from(n.options.values()) : n.options;
        if (t.every(r => r._def.typeName in Mw && (!r._def.checks || !r._def.checks.length))) {
            const r = t.reduce( (s, i) => {
                const a = Mw[i._def.typeName];
                return a && !s.includes(a) ? [...s, a] : s
            }
            , []);
            return {
                type: r.length > 1 ? r : r[0]
            }
        } else if (t.every(r => r._def.typeName === "ZodLiteral" && !r.description)) {
            const r = t.reduce( (s, i) => {
                const a = typeof i._def.value;
                switch (a) {
                case "string":
                case "number":
                case "boolean":
                    return [...s, a];
                case "bigint":
                    return [...s, "integer"];
                case "object":
                    if (i._def.value === null)
                        return [...s, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return s
                }
            }
            , []);
            if (r.length === t.length) {
                const s = r.filter( (i, a, c) => c.indexOf(i) === a);
                return {
                    type: s.length > 1 ? s : s[0],
                    enum: t.reduce( (i, a) => i.includes(a._def.value) ? i : [...i, a._def.value], [])
                }
            }
        } else if (t.every(r => r._def.typeName === "ZodEnum"))
            return {
                type: "string",
                enum: t.reduce( (r, s) => [...r, ...s._def.values.filter(i => !r.includes(i))], [])
            };
        return wO(n, e)
    }
    const wO = (n, e) => {
        const t = (n.options instanceof Map ? Array.from(n.options.values()) : n.options).map( (r, s) => et(r._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", `${s}`]
        })).filter(r => !!r && (!e.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
        return t.length ? {
            anyOf: t
        } : void 0
    }
    ;
    function n6(n, e) {
        if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(n.innerType._def.typeName) && (!n.innerType._def.checks || !n.innerType._def.checks.length))
            return e.target === "openApi3" || e.nullableStrategy === "property" ? {
                type: Mw[n.innerType._def.typeName],
                nullable: !0
            } : {
                type: [Mw[n.innerType._def.typeName], "null"]
            };
        if (e.target === "openApi3") {
            const r = et(n.innerType._def, {
                ...e,
                currentPath: [...e.currentPath]
            });
            return r && "$ref"in r ? {
                allOf: [r],
                nullable: !0
            } : r && {
                ...r,
                nullable: !0
            }
        }
        const t = et(n.innerType._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", "0"]
        });
        return t && {
            anyOf: [t, {
                type: "null"
            }]
        }
    }
    function s6(n, e) {
        const t = {
            type: "number"
        };
        if (!n.checks)
            return t;
        for (const r of n.checks)
            switch (r.kind) {
            case "int":
                t.type = "integer",
                fO(t, "type", r.message, e);
                break;
            case "min":
                e.target === "jsonSchema7" ? r.inclusive ? ct(t, "minimum", r.value, r.message, e) : ct(t, "exclusiveMinimum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMinimum = !0),
                ct(t, "minimum", r.value, r.message, e));
                break;
            case "max":
                e.target === "jsonSchema7" ? r.inclusive ? ct(t, "maximum", r.value, r.message, e) : ct(t, "exclusiveMaximum", r.value, r.message, e) : (r.inclusive || (t.exclusiveMaximum = !0),
                ct(t, "maximum", r.value, r.message, e));
                break;
            case "multipleOf":
                ct(t, "multipleOf", r.value, r.message, e);
                break
            }
        return t
    }
    function i6(n, e) {
        return e.removeAdditionalStrategy === "strict" ? n.catchall._def.typeName === "ZodNever" ? n.unknownKeys !== "strict" : et(n.catchall._def, {
            ...e,
            currentPath: [...e.currentPath, "additionalProperties"]
        }) ?? !0 : n.catchall._def.typeName === "ZodNever" ? n.unknownKeys === "passthrough" : et(n.catchall._def, {
            ...e,
            currentPath: [...e.currentPath, "additionalProperties"]
        }) ?? !0
    }
    function a6(n, e) {
        const t = {
            type: "object",
            ...Object.entries(n.shape()).reduce( (r, [s,i]) => {
                if (i === void 0 || i._def === void 0)
                    return r;
                const a = et(i._def, {
                    ...e,
                    currentPath: [...e.currentPath, "properties", s],
                    propertyPath: [...e.currentPath, "properties", s]
                });
                return a === void 0 ? r : {
                    properties: {
                        ...r.properties,
                        [s]: a
                    },
                    required: i.isOptional() && !e.openaiStrictMode ? r.required : [...r.required, s]
                }
            }
            , {
                properties: {},
                required: []
            }),
            additionalProperties: i6(n, e)
        };
        return t.required.length || delete t.required,
        t
    }
    const o6 = (n, e) => {
        var r;
        if (e.currentPath.toString() === ((r = e.propertyPath) == null ? void 0 : r.toString()))
            return et(n.innerType._def, e);
        const t = et(n.innerType._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", "1"]
        });
        return t ? {
            anyOf: [{
                not: {}
            }, t]
        } : {}
    }
      , c6 = (n, e) => {
        if (e.pipeStrategy === "input")
            return et(n.in._def, e);
        if (e.pipeStrategy === "output")
            return et(n.out._def, e);
        const t = et(n.in._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "0"]
        })
          , r = et(n.out._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", t ? "1" : "0"]
        });
        return {
            allOf: [t, r].filter(s => s !== void 0)
        }
    }
    ;
    function u6(n, e) {
        return et(n.type._def, e)
    }
    function l6(n, e) {
        const r = {
            type: "array",
            uniqueItems: !0,
            items: et(n.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "items"]
            })
        };
        return n.minSize && ct(r, "minItems", n.minSize.value, n.minSize.message, e),
        n.maxSize && ct(r, "maxItems", n.maxSize.value, n.maxSize.message, e),
        r
    }
    function d6(n, e) {
        return n.rest ? {
            type: "array",
            minItems: n.items.length,
            items: n.items.map( (t, r) => et(t._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${r}`]
            })).reduce( (t, r) => r === void 0 ? t : [...t, r], []),
            additionalItems: et(n.rest._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalItems"]
            })
        } : {
            type: "array",
            minItems: n.items.length,
            maxItems: n.items.length,
            items: n.items.map( (t, r) => et(t._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${r}`]
            })).reduce( (t, r) => r === void 0 ? t : [...t, r], [])
        }
    }
    function h6() {
        return {
            not: {}
        }
    }
    function f6() {
        return {}
    }
    const p6 = (n, e) => et(n.innerType._def, e);
    function et(n, e, t=!1) {
        var a;
        const r = e.seen.get(n);
        if (e.override) {
            const c = (a = e.override) == null ? void 0 : a.call(e, n, e, r, t);
            if (c !== NH)
                return c
        }
        if (r && !t) {
            const c = m6(r, e);
            if (c !== void 0)
                return "$ref"in c && e.seenRefs.add(c.$ref),
                c
        }
        const s = {
            def: n,
            path: e.currentPath,
            jsonSchema: void 0
        };
        e.seen.set(n, s);
        const i = y6(n, n.typeName, e, t);
        return i && w6(n, e, i),
        s.jsonSchema = i,
        i
    }
    const m6 = (n, e) => {
        switch (e.$refStrategy) {
        case "root":
            return {
                $ref: n.path.join("/")
            };
        case "extract-to-root":
            const t = n.path.slice(e.basePath.length + 1).join("_");
            return t !== e.name && e.nameStrategy === "duplicate-ref" && (e.definitions[t] = n.def),
            {
                $ref: [...e.basePath, e.definitionPath, t].join("/")
            };
        case "relative":
            return {
                $ref: g6(e.currentPath, n.path)
            };
        case "none":
        case "seen":
            return n.path.length < e.currentPath.length && n.path.every( (r, s) => e.currentPath[s] === r) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`),
            {}) : e.$refStrategy === "seen" ? {} : void 0
        }
    }
      , g6 = (n, e) => {
        let t = 0;
        for (; t < n.length && t < e.length && n[t] === e[t]; t++)
            ;
        return [(n.length - t).toString(), ...e.slice(t)].join("/")
    }
      , y6 = (n, e, t, r) => {
        switch (e) {
        case Y.ZodString:
            return mO(n, t);
        case Y.ZodNumber:
            return s6(n, t);
        case Y.ZodObject:
            return a6(n, t);
        case Y.ZodBigInt:
            return BH(n, t);
        case Y.ZodBoolean:
            return qH();
        case Y.ZodDate:
            return pO(n, t);
        case Y.ZodUndefined:
            return h6();
        case Y.ZodNull:
            return t6(t);
        case Y.ZodArray:
            return DH(n, t);
        case Y.ZodUnion:
        case Y.ZodDiscriminatedUnion:
            return r6(n, t);
        case Y.ZodIntersection:
            return JH(n, t);
        case Y.ZodTuple:
            return d6(n, t);
        case Y.ZodRecord:
            return yO(n, t);
        case Y.ZodLiteral:
            return ZH(n, t);
        case Y.ZodEnum:
            return VH(n);
        case Y.ZodNativeEnum:
            return QH(n);
        case Y.ZodNullable:
            return n6(n, t);
        case Y.ZodOptional:
            return o6(n, t);
        case Y.ZodMap:
            return YH(n, t);
        case Y.ZodSet:
            return l6(n, t);
        case Y.ZodLazy:
            return et(n.getter()._def, t);
        case Y.ZodPromise:
            return u6(n, t);
        case Y.ZodNaN:
        case Y.ZodNever:
            return e6();
        case Y.ZodEffects:
            return zH(n, t, r);
        case Y.ZodAny:
            return jH();
        case Y.ZodUnknown:
            return f6();
        case Y.ZodDefault:
            return WH(n, t);
        case Y.ZodBranded:
            return UH(n, t);
        case Y.ZodReadonly:
            return p6(n, t);
        case Y.ZodCatch:
            return KH(n, t);
        case Y.ZodPipeline:
            return c6(n, t);
        case Y.ZodFunction:
        case Y.ZodVoid:
        case Y.ZodSymbol:
            return;
        default:
            return (s => {}
            )()
        }
    }
      , w6 = (n, e, t) => (n.description && (t.description = n.description,
    e.markdownDescription && (t.markdownDescription = n.description)),
    t)
      , b6 = (n, e) => {
        const t = FH(e)
          , r = typeof e == "string" ? e : (e == null ? void 0 : e.nameStrategy) === "title" || e == null ? void 0 : e.name
          , s = et(n._def, r === void 0 ? t : {
            ...t,
            currentPath: [...t.basePath, t.definitionPath, r]
        }, !1) ?? {}
          , i = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
        i !== void 0 && (s.title = i);
        const a = ( () => {
            if (LH(t.definitions))
                return;
            const u = {}
              , l = new Set;
            for (let d = 0; d < 500; d++) {
                const h = Object.entries(t.definitions).filter( ([f]) => !l.has(f));
                if (h.length === 0)
                    break;
                for (const [f,p] of h)
                    u[f] = et(rE(p), {
                        ...t,
                        currentPath: [...t.basePath, t.definitionPath, f]
                    }, !0) ?? {},
                    l.add(f)
            }
            return u
        }
        )()
          , c = r === void 0 ? a ? {
            ...s,
            [t.definitionPath]: a
        } : s : t.nameStrategy === "duplicate-ref" ? {
            ...s,
            ...a || t.seenRefs.size ? {
                [t.definitionPath]: {
                    ...a,
                    ...t.seenRefs.size ? {
                        [r]: s
                    } : void 0
                }
            } : void 0
        } : {
            $ref: [...t.$refStrategy === "relative" ? [] : t.basePath, t.definitionPath, r].join("/"),
            [t.definitionPath]: {
                ...a,
                [r]: s
            }
        };
        return t.target === "jsonSchema7" ? c.$schema = "http://json-schema.org/draft-07/schema#" : t.target === "jsonSchema2019-09" && (c.$schema = "https://json-schema.org/draft/2019-09/schema#"),
        c
    }
    ;
    function bO(n, e) {
        return b6(n, {
            openaiStrictMode: !0,
            name: e.name,
            nameStrategy: "duplicate-ref",
            $refStrategy: "extract-to-root",
            nullableStrategy: "property"
        })
    }
    function v6(n, e, t) {
        return GK({
            type: "json_schema",
            json_schema: {
                ...t,
                name: e,
                strict: !0,
                schema: bO(n, {
                    name: e
                })
            }
        }, r => n.parse(JSON.parse(r)))
    }
    function _6(n) {
        return JK({
            type: "function",
            function: {
                name: n.name,
                parameters: bO(n.parameters, {
                    name: n.name
                }),
                strict: !0,
                ...n.description ? {
                    description: n.description
                } : void 0
            }
        }, {
            callback: n.function,
            parser: e => n.parameters.parse(JSON.parse(e))
        })
    }
    function S6(n) {
        const {azureOpenAIApiDeploymentName: e, azureOpenAIApiInstanceName: t, azureOpenAIApiKey: r, azureOpenAIBasePath: s, baseURL: i, azureADTokenProvider: a, azureOpenAIEndpoint: c} = n;
        if ((r || a) && s && e)
            return `${s}/${e}`;
        if ((r || a) && c && e)
            return `${c}/openai/deployments/${e}`;
        if (r || a) {
            if (!t)
                throw new Error("azureOpenAIApiInstanceName is required when using azureOpenAIApiKey");
            if (!e)
                throw new Error("azureOpenAIApiDeploymentName is a required parameter when using azureOpenAIApiKey");
            return `https://${t}.openai.azure.com/openai/deployments/${e}`
        }
        return i
    }
    function E6(n, e) {
        const t = typeof e == "number" ? void 0 : e;
        return {
            name: n.name,
            description: n.description,
            parameters: Ui(n.schema),
            ...(t == null ? void 0 : t.strict) !== void 0 ? {
                strict: t.strict
            } : {}
        }
    }
    function x6(n) {
        return n !== void 0 && Array.isArray(n.lc_namespace)
    }
    function C6(n) {
        return n !== void 0 && jt.isRunnable(n) && "lc_name"in n.constructor && typeof n.constructor.lc_name == "function" && n.constructor.lc_name() === "RunnableToolLike"
    }
    function k6(n) {
        return !!n && typeof n == "object" && "name"in n && "schema"in n && Rw(n.schema)
    }
    function Nw(n) {
        return k6(n) || C6(n) || x6(n)
    }
    function $w(n, e) {
        return n.lc_error_code = e,
        n.message = `${n.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`,
        n
    }
    function vO(n) {
        let e;
        return n.constructor.name === dw.name ? (e = new Error(n.message),
        e.name = "TimeoutError") : n.constructor.name === yn.name ? (e = new Error(n.message),
        e.name = "AbortError") : n.status === 400 && n.message.includes("tool_calls") ? e = $w(n, "INVALID_TOOL_RESULTS") : n.status === 401 ? e = $w(n, "MODEL_AUTHENTICATION") : n.status === 429 ? e = $w(n, "MODEL_RATE_LIMIT") : n.status === 404 ? e = $w(n, "MODEL_NOT_FOUND") : e = n,
        e
    }
    function P6(n) {
        if (n)
            return n === "any" || n === "required" ? "required" : n === "auto" ? "auto" : n === "none" ? "none" : typeof n == "string" ? {
                type: "function",
                function: {
                    name: n
                }
            } : n
    }
    function T6(n) {
        return n.anyOf !== void 0 && Array.isArray(n.anyOf)
    }
    function A6(n) {
        const e = ["namespace functions {", ""];
        for (const t of n)
            t.description && e.push(`// ${t.description}`),
            Object.keys(t.parameters.properties ?? {}).length > 0 ? (e.push(`type ${t.name} = (_: {`),
            e.push(_O(t.parameters, 0)),
            e.push("}) => any;")) : e.push(`type ${t.name} = () => any;`),
            e.push("");
        return e.push("} // namespace functions"),
        e.join(`
`)
    }
    function _O(n, e) {
        var r;
        const t = [];
        for (const [s,i] of Object.entries(n.properties ?? {}))
            i.description && e < 2 && t.push(`// ${i.description}`),
            (r = n.required) != null && r.includes(s) ? t.push(`${s}: ${Lw(i, e)},`) : t.push(`${s}?: ${Lw(i, e)},`);
        return t.map(s => " ".repeat(e) + s).join(`
`)
    }
    function Lw(n, e) {
        if (T6(n))
            return n.anyOf.map(t => Lw(t, e)).join(" | ");
        switch (n.type) {
        case "string":
            return n.enum ? n.enum.map(t => `"${t}"`).join(" | ") : "string";
        case "number":
            return n.enum ? n.enum.map(t => `${t}`).join(" | ") : "number";
        case "integer":
            return n.enum ? n.enum.map(t => `${t}`).join(" | ") : "number";
        case "boolean":
            return "boolean";
        case "null":
            return "null";
        case "object":
            return ["{", _O(n, e + 2), "}"].join(`
`);
        case "array":
            return n.items ? `${Lw(n.items, e)}[]` : "any[]";
        default:
            return ""
        }
    }
    function I6(n, e) {
        let t;
        if (Nw(n)) {
            const r = _6({
                name: n.name,
                parameters: n.schema,
                description: n.description
            });
            r.function.parameters ? t = {
                type: r.type,
                function: {
                    name: r.function.name,
                    description: r.function.description,
                    parameters: r.function.parameters,
                    ...(e == null ? void 0 : e.strict) !== void 0 ? {
                        strict: e.strict
                    } : {}
                }
            } : t = {
                type: "function",
                function: E6(n, e)
            }
        } else
            t = n;
        return (e == null ? void 0 : e.strict) !== void 0 && (t.function.strict = e.strict),
        t
    }
    function O6(n) {
        return n.role !== "system" && n.role !== "developer" && n.role !== "assistant" && n.role !== "user" && n.role !== "function" && n.role !== "tool" && console.warn(`Unknown message role: ${n.role}`),
        n.role
    }
    function SO(n) {
        const e = n._getType();
        switch (e) {
        case "system":
            return "system";
        case "ai":
            return "assistant";
        case "human":
            return "user";
        case "function":
            return "function";
        case "tool":
            return "tool";
        case "generic":
            {
                if (!su.isInstance(n))
                    throw new Error("Invalid generic chat message");
                return O6(n)
            }
        default:
            throw new Error(`Unknown message type: ${e}`)
        }
    }
    function EO(n, e) {
        return n.flatMap(t => {
            var i;
            let r = SO(t);
            r === "system" && (e != null && e.startsWith("o1")) && (r = "developer");
            const s = {
                role: r,
                content: t.content
            };
            if (t.name != null && (s.name = t.name),
            t.additional_kwargs.function_call != null && (s.function_call = t.additional_kwargs.function_call,
            s.content = null),
            ah(t) && ((i = t.tool_calls) != null && i.length) ? (s.tool_calls = t.tool_calls.map(OH),
            s.content = null) : (t.additional_kwargs.tool_calls != null && (s.tool_calls = t.additional_kwargs.tool_calls),
            t.tool_call_id != null && (s.tool_call_id = t.tool_call_id)),
            t.additional_kwargs.audio && typeof t.additional_kwargs.audio == "object" && "id"in t.additional_kwargs.audio) {
                const a = {
                    role: "assistant",
                    audio: {
                        id: t.additional_kwargs.audio.id
                    }
                };
                return [s, a]
            }
            return s
        }
        )
    }
    function xO(n, e) {
        return Ow(n) ? (e == null ? void 0 : e.strict) !== void 0 ? {
            ...n,
            function: {
                ...n.function,
                strict: e.strict
            }
        } : n : I6(n, e)
    }
    class R6 extends bs {
        static lc_name() {
            return "ChatOpenAI"
        }
        get callKeys() {
            return [...super.callKeys, "options", "function_call", "functions", "tools", "tool_choice", "promptIndex", "response_format", "seed", "reasoning_effort"]
        }
        get lc_secrets() {
            return {
                openAIApiKey: "OPENAI_API_KEY",
                apiKey: "OPENAI_API_KEY",
                organization: "OPENAI_ORGANIZATION"
            }
        }
        get lc_aliases() {
            return {
                modelName: "model",
                openAIApiKey: "openai_api_key",
                apiKey: "openai_api_key"
            }
        }
        constructor(e) {
            var t, r;
            super(e ?? {}),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "temperature", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "topP", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "frequencyPenalty", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "presencePenalty", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "n", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 1
            }),
            Object.defineProperty(this, "logitBias", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "modelName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "model", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "gpt-3.5-turbo"
            }),
            Object.defineProperty(this, "modelKwargs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "stop", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "stopSequences", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "user", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "timeout", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "streaming", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "streamUsage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "maxTokens", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "logprobs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "topLogprobs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "openAIApiKey", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "apiKey", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "organization", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "__includeRawResponse", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "client", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "clientConfig", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "supportsStrictToolCalling", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "audio", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "modalities", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "reasoningEffort", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.openAIApiKey = (e == null ? void 0 : e.apiKey) ?? (e == null ? void 0 : e.openAIApiKey) ?? ((t = e == null ? void 0 : e.configuration) == null ? void 0 : t.apiKey) ?? mn("OPENAI_API_KEY"),
            this.apiKey = this.openAIApiKey,
            this.organization = ((r = e == null ? void 0 : e.configuration) == null ? void 0 : r.organization) ?? mn("OPENAI_ORGANIZATION"),
            this.model = (e == null ? void 0 : e.model) ?? (e == null ? void 0 : e.modelName) ?? this.model,
            this.modelName = this.model,
            this.modelKwargs = (e == null ? void 0 : e.modelKwargs) ?? {},
            this.timeout = e == null ? void 0 : e.timeout,
            this.temperature = (e == null ? void 0 : e.temperature) ?? this.temperature,
            this.topP = (e == null ? void 0 : e.topP) ?? this.topP,
            this.frequencyPenalty = (e == null ? void 0 : e.frequencyPenalty) ?? this.frequencyPenalty,
            this.presencePenalty = (e == null ? void 0 : e.presencePenalty) ?? this.presencePenalty,
            this.maxTokens = e == null ? void 0 : e.maxTokens,
            this.logprobs = e == null ? void 0 : e.logprobs,
            this.topLogprobs = e == null ? void 0 : e.topLogprobs,
            this.n = (e == null ? void 0 : e.n) ?? this.n,
            this.logitBias = e == null ? void 0 : e.logitBias,
            this.stop = (e == null ? void 0 : e.stopSequences) ?? (e == null ? void 0 : e.stop),
            this.stopSequences = this == null ? void 0 : this.stop,
            this.user = e == null ? void 0 : e.user,
            this.__includeRawResponse = e == null ? void 0 : e.__includeRawResponse,
            this.audio = e == null ? void 0 : e.audio,
            this.modalities = e == null ? void 0 : e.modalities,
            this.reasoningEffort = e == null ? void 0 : e.reasoningEffort,
            this.model === "o1" && (this.disableStreaming = !0),
            this.streaming = (e == null ? void 0 : e.streaming) ?? !1,
            this.streamUsage = (e == null ? void 0 : e.streamUsage) ?? this.streamUsage,
            this.clientConfig = {
                apiKey: this.apiKey,
                organization: this.organization,
                dangerouslyAllowBrowser: !0,
                ...e == null ? void 0 : e.configuration
            },
            (e == null ? void 0 : e.supportsStrictToolCalling) !== void 0 && (this.supportsStrictToolCalling = e.supportsStrictToolCalling)
        }
        getLsParams(e) {
            const t = this.invocationParams(e);
            return {
                ls_provider: "openai",
                ls_model_name: this.model,
                ls_model_type: "chat",
                ls_temperature: t.temperature ?? void 0,
                ls_max_tokens: t.max_tokens ?? void 0,
                ls_stop: e.stop
            }
        }
        bindTools(e, t) {
            let r;
            return (t == null ? void 0 : t.strict) !== void 0 ? r = t.strict : this.supportsStrictToolCalling !== void 0 && (r = this.supportsStrictToolCalling),
            this.bind({
                tools: e.map(s => xO(s, {
                    strict: r
                })),
                ...t
            })
        }
        createResponseFormat(e) {
            return e && e.type === "json_schema" && e.json_schema.schema && Fw(e.json_schema.schema) ? v6(e.json_schema.schema, e.json_schema.name, {
                description: e.json_schema.description
            }) : e
        }
        invocationParams(e, t) {
            var c;
            let r;
            (e == null ? void 0 : e.strict) !== void 0 ? r = e.strict : this.supportsStrictToolCalling !== void 0 && (r = this.supportsStrictToolCalling);
            let s = {};
            (e == null ? void 0 : e.stream_options) !== void 0 ? s = {
                stream_options: e.stream_options
            } : this.streamUsage && (this.streaming || t != null && t.streaming) && (s = {
                stream_options: {
                    include_usage: !0
                }
            });
            const i = {
                model: this.model,
                temperature: this.temperature,
                top_p: this.topP,
                frequency_penalty: this.frequencyPenalty,
                presence_penalty: this.presencePenalty,
                max_tokens: this.maxTokens === -1 ? void 0 : this.maxTokens,
                logprobs: this.logprobs,
                top_logprobs: this.topLogprobs,
                n: this.n,
                logit_bias: this.logitBias,
                stop: (e == null ? void 0 : e.stop) ?? this.stopSequences,
                user: this.user,
                stream: this.streaming,
                functions: e == null ? void 0 : e.functions,
                function_call: e == null ? void 0 : e.function_call,
                tools: (c = e == null ? void 0 : e.tools) != null && c.length ? e.tools.map(u => xO(u, {
                    strict: r
                })) : void 0,
                tool_choice: P6(e == null ? void 0 : e.tool_choice),
                response_format: this.createResponseFormat(e == null ? void 0 : e.response_format),
                seed: e == null ? void 0 : e.seed,
                ...s,
                parallel_tool_calls: e == null ? void 0 : e.parallel_tool_calls,
                ...this.audio || e != null && e.audio ? {
                    audio: this.audio || (e == null ? void 0 : e.audio)
                } : {},
                ...this.modalities || e != null && e.modalities ? {
                    modalities: this.modalities || (e == null ? void 0 : e.modalities)
                } : {},
                ...this.modelKwargs
            };
            (e == null ? void 0 : e.prediction) !== void 0 && (i.prediction = e.prediction);
            const a = (e == null ? void 0 : e.reasoning_effort) ?? this.reasoningEffort;
            return a !== void 0 && (i.reasoning_effort = a),
            i
        }
        _convertOpenAIChatCompletionMessageToBaseMessage(e, t) {
            const r = e.tool_calls;
            switch (e.role) {
            case "assistant":
                {
                    const s = []
                      , i = [];
                    for (const u of r ?? [])
                        try {
                            s.push(lO(u, {
                                returnId: !0
                            }))
                        } catch (l) {
                            i.push(RH(u, l.message))
                        }
                    const a = {
                        function_call: e.function_call,
                        tool_calls: r
                    };
                    this.__includeRawResponse !== void 0 && (a.__raw_response = t);
                    const c = {
                        model_name: t.model,
                        ...t.system_fingerprint ? {
                            usage: {
                                ...t.usage
                            },
                            system_fingerprint: t.system_fingerprint
                        } : {}
                    };
                    return e.audio && (a.audio = e.audio),
                    new pn({
                        content: e.content || "",
                        tool_calls: s,
                        invalid_tool_calls: i,
                        additional_kwargs: a,
                        response_metadata: c,
                        id: t.id
                    })
                }
            default:
                return new su(e.content || "",e.role ?? "unknown")
            }
        }
        _convertOpenAIDeltaToBaseMessageChunk(e, t, r) {
            var u, l;
            const s = e.role ?? r
              , i = e.content ?? "";
            let a;
            e.function_call ? a = {
                function_call: e.function_call
            } : e.tool_calls ? a = {
                tool_calls: e.tool_calls
            } : a = {},
            this.__includeRawResponse && (a.__raw_response = t),
            e.audio && (a.audio = {
                ...e.audio,
                index: t.choices[0].index
            });
            const c = {
                usage: {
                    ...t.usage
                }
            };
            if (s === "user")
                return new jy({
                    content: i,
                    response_metadata: c
                });
            if (s === "assistant") {
                const d = [];
                if (Array.isArray(e.tool_calls))
                    for (const h of e.tool_calls)
                        d.push({
                            name: (u = h.function) == null ? void 0 : u.name,
                            args: (l = h.function) == null ? void 0 : l.arguments,
                            id: h.id,
                            index: h.index,
                            type: "tool_call_chunk"
                        });
                return new _r({
                    content: i,
                    tool_call_chunks: d,
                    additional_kwargs: a,
                    id: t.id,
                    response_metadata: c
                })
            } else
                return s === "system" ? new oh({
                    content: i,
                    response_metadata: c
                }) : s === "developer" ? new oh({
                    content: i,
                    response_metadata: c,
                    additional_kwargs: {
                        __openai_role__: "developer"
                    }
                }) : s === "function" ? new Fy({
                    content: i,
                    additional_kwargs: a,
                    name: e.name,
                    response_metadata: c
                }) : s === "tool" ? new __({
                    content: i,
                    additional_kwargs: a,
                    tool_call_id: e.tool_call_id,
                    response_metadata: c
                }) : new Ly({
                    content: i,
                    role: s,
                    response_metadata: c
                })
        }
        _identifyingParams() {
            return {
                model_name: this.model,
                ...this.invocationParams(),
                ...this.clientConfig
            }
        }
        async*_streamResponseChunks(e, t, r) {
            var l, d, h, f, p, g, y, m, w, E;
            const s = EO(e, this.model)
              , i = {
                ...this.invocationParams(t, {
                    streaming: !0
                }),
                messages: s,
                stream: !0
            };
            let a;
            const c = await this.completionWithRetry(i, t);
            let u;
            for await(const v of c) {
                const _ = (l = v == null ? void 0 : v.choices) == null ? void 0 : l[0];
                if (v.usage && (u = v.usage),
                !_)
                    continue;
                const {delta: A} = _;
                if (!A)
                    continue;
                const C = this._convertOpenAIDeltaToBaseMessageChunk(A, v, a);
                a = A.role ?? a;
                const k = {
                    prompt: t.promptIndex ?? 0,
                    completion: _.index ?? 0
                };
                if (typeof C.content != "string") {
                    console.log("[WARNING]: Received non-string content from OpenAI. This is currently not supported.");
                    continue
                }
                const x = {
                    ...k
                };
                _.finish_reason != null && (x.finish_reason = _.finish_reason,
                x.system_fingerprint = v.system_fingerprint,
                x.model_name = v.model),
                this.logprobs && (x.logprobs = _.logprobs);
                const N = new qi({
                    message: C,
                    text: C.content,
                    generationInfo: x
                });
                yield N,
                await (r == null ? void 0 : r.handleLLMNewToken(N.text ?? "", k, void 0, void 0, void 0, {
                    chunk: N
                }))
            }
            if (u) {
                const v = {
                    ...((d = u.prompt_tokens_details) == null ? void 0 : d.audio_tokens) !== null && {
                        audio: (h = u.prompt_tokens_details) == null ? void 0 : h.audio_tokens
                    },
                    ...((f = u.prompt_tokens_details) == null ? void 0 : f.cached_tokens) !== null && {
                        cache_read: (p = u.prompt_tokens_details) == null ? void 0 : p.cached_tokens
                    }
                }
                  , _ = {
                    ...((g = u.completion_tokens_details) == null ? void 0 : g.audio_tokens) !== null && {
                        audio: (y = u.completion_tokens_details) == null ? void 0 : y.audio_tokens
                    },
                    ...((m = u.completion_tokens_details) == null ? void 0 : m.reasoning_tokens) !== null && {
                        reasoning: (w = u.completion_tokens_details) == null ? void 0 : w.reasoning_tokens
                    }
                };
                yield new qi({
                    message: new _r({
                        content: "",
                        response_metadata: {
                            usage: {
                                ...u
                            }
                        },
                        usage_metadata: {
                            input_tokens: u.prompt_tokens,
                            output_tokens: u.completion_tokens,
                            total_tokens: u.total_tokens,
                            ...Object.keys(v).length > 0 && {
                                input_token_details: v
                            },
                            ...Object.keys(_).length > 0 && {
                                output_token_details: _
                            }
                        }
                    }),
                    text: ""
                })
            }
            if ((E = t.signal) != null && E.aborted)
                throw new Error("AbortError")
        }
        identifyingParams() {
            return this._identifyingParams()
        }
        async _generate(e, t, r) {
            var c, u;
            const s = {}
              , i = this.invocationParams(t)
              , a = EO(e, this.model);
            if (i.stream) {
                const l = this._streamResponseChunks(e, t, r)
                  , d = {};
                for await(const m of l) {
                    m.message.response_metadata = {
                        ...m.generationInfo,
                        ...m.message.response_metadata
                    };
                    const w = ((c = m.generationInfo) == null ? void 0 : c.completion) ?? 0;
                    d[w] === void 0 ? d[w] = m : d[w] = d[w].concat(m)
                }
                const h = Object.entries(d).sort( ([m], [w]) => parseInt(m, 10) - parseInt(w, 10)).map( ([m,w]) => w)
                  , {functions: f, function_call: p} = this.invocationParams(t)
                  , g = await this.getEstimatedTokenCountFromPrompt(e, f, p)
                  , y = await this.getNumTokensFromGenerations(h);
                return s.input_tokens = g,
                s.output_tokens = y,
                s.total_tokens = g + y,
                {
                    generations: h,
                    llmOutput: {
                        estimatedTokenUsage: {
                            promptTokens: s.input_tokens,
                            completionTokens: s.output_tokens,
                            totalTokens: s.total_tokens
                        }
                    }
                }
            } else {
                let l;
                t.response_format && t.response_format.type === "json_schema" ? l = await this.betaParsedCompletionWithRetry({
                    ...i,
                    stream: !1,
                    messages: a
                }, {
                    signal: t == null ? void 0 : t.signal,
                    ...t == null ? void 0 : t.options
                }) : l = await this.completionWithRetry({
                    ...i,
                    stream: !1,
                    messages: a
                }, {
                    signal: t == null ? void 0 : t.signal,
                    ...t == null ? void 0 : t.options
                });
                const {completion_tokens: d, prompt_tokens: h, total_tokens: f, prompt_tokens_details: p, completion_tokens_details: g} = (l == null ? void 0 : l.usage) ?? {};
                d && (s.output_tokens = (s.output_tokens ?? 0) + d),
                h && (s.input_tokens = (s.input_tokens ?? 0) + h),
                f && (s.total_tokens = (s.total_tokens ?? 0) + f),
                ((p == null ? void 0 : p.audio_tokens) !== null || (p == null ? void 0 : p.cached_tokens) !== null) && (s.input_token_details = {
                    ...(p == null ? void 0 : p.audio_tokens) !== null && {
                        audio: p == null ? void 0 : p.audio_tokens
                    },
                    ...(p == null ? void 0 : p.cached_tokens) !== null && {
                        cache_read: p == null ? void 0 : p.cached_tokens
                    }
                }),
                ((g == null ? void 0 : g.audio_tokens) !== null || (g == null ? void 0 : g.reasoning_tokens) !== null) && (s.output_token_details = {
                    ...(g == null ? void 0 : g.audio_tokens) !== null && {
                        audio: g == null ? void 0 : g.audio_tokens
                    },
                    ...(g == null ? void 0 : g.reasoning_tokens) !== null && {
                        reasoning: g == null ? void 0 : g.reasoning_tokens
                    }
                });
                const y = [];
                for (const m of (l == null ? void 0 : l.choices) ?? []) {
                    const E = {
                        text: ((u = m.message) == null ? void 0 : u.content) ?? "",
                        message: this._convertOpenAIChatCompletionMessageToBaseMessage(m.message ?? {
                            role: "assistant"
                        }, l)
                    };
                    E.generationInfo = {
                        ...m.finish_reason ? {
                            finish_reason: m.finish_reason
                        } : {},
                        ...m.logprobs ? {
                            logprobs: m.logprobs
                        } : {}
                    },
                    ah(E.message) && (E.message.usage_metadata = s),
                    E.message = new pn(Object.fromEntries(Object.entries(E.message).filter( ([v]) => !v.startsWith("lc_")))),
                    y.push(E)
                }
                return {
                    generations: y,
                    llmOutput: {
                        tokenUsage: {
                            promptTokens: s.input_tokens,
                            completionTokens: s.output_tokens,
                            totalTokens: s.total_tokens
                        }
                    }
                }
            }
        }
        async getEstimatedTokenCountFromPrompt(e, t, r) {
            let s = (await this.getNumTokensFromMessages(e)).totalCount;
            if (t && r !== "auto") {
                const i = A6(t);
                s += await this.getNumTokens(i),
                s += 9
            }
            return t && e.find(i => i._getType() === "system") && (s -= 4),
            r === "none" ? s += 1 : typeof r == "object" && (s += await this.getNumTokens(r.name) + 4),
            s
        }
        async getNumTokensFromGenerations(e) {
            return (await Promise.all(e.map(async r => {
                var s;
                return (s = r.message.additional_kwargs) != null && s.function_call ? (await this.getNumTokensFromMessages([r.message])).countPerMessage[0] : await this.getNumTokens(r.message.content)
            }
            ))).reduce( (r, s) => r + s, 0)
        }
        async getNumTokensFromMessages(e) {
            let t = 0
              , r = 0
              , s = 0;
            this.model === "gpt-3.5-turbo-0301" ? (r = 4,
            s = -1) : (r = 3,
            s = 1);
            const i = await Promise.all(e.map(async a => {
                var f, p, g, y, m, w;
                const c = await this.getNumTokens(a.content)
                  , u = await this.getNumTokens(SO(a))
                  , l = a.name !== void 0 ? s + await this.getNumTokens(a.name) : 0;
                let d = c + r + u + l;
                const h = a;
                if (h._getType() === "function" && (d -= 2),
                (f = h.additional_kwargs) != null && f.function_call && (d += 3),
                (p = h == null ? void 0 : h.additional_kwargs.function_call) != null && p.name && (d += await this.getNumTokens((g = h.additional_kwargs.function_call) == null ? void 0 : g.name)),
                (y = h.additional_kwargs.function_call) != null && y.arguments)
                    try {
                        d += await this.getNumTokens(JSON.stringify(JSON.parse((m = h.additional_kwargs.function_call) == null ? void 0 : m.arguments)))
                    } catch (E) {
                        console.error("Error parsing function arguments", E, JSON.stringify(h.additional_kwargs.function_call)),
                        d += await this.getNumTokens((w = h.additional_kwargs.function_call) == null ? void 0 : w.arguments)
                    }
                return t += d,
                d
            }
            ));
            return t += 3,
            {
                totalCount: t,
                countPerMessage: i
            }
        }
        async completionWithRetry(e, t) {
            const r = this._getClientOptions(t);
            return this.caller.call(async () => {
                try {
                    return await this.client.chat.completions.create(e, r)
                } catch (s) {
                    throw vO(s)
                }
            }
            )
        }
        async betaParsedCompletionWithRetry(e, t) {
            const r = this._getClientOptions(t);
            return this.caller.call(async () => {
                try {
                    return await this.client.beta.chat.completions.parse(e, r)
                } catch (s) {
                    throw vO(s)
                }
            }
            )
        }
        _getClientOptions(e) {
            if (!this.client) {
                const r = {
                    baseURL: this.clientConfig.baseURL
                }
                  , s = S6(r)
                  , i = {
                    ...this.clientConfig,
                    baseURL: s,
                    timeout: this.timeout,
                    maxRetries: 0
                };
                i.baseURL || delete i.baseURL,
                this.client = new Ge(i)
            }
            return {
                ...this.clientConfig,
                ...e
            }
        }
        _llmType() {
            return "openai"
        }
        _combineLLMOutput(...e) {
            return e.reduce( (t, r) => (r && r.tokenUsage && (t.tokenUsage.completionTokens += r.tokenUsage.completionTokens ?? 0,
            t.tokenUsage.promptTokens += r.tokenUsage.promptTokens ?? 0,
            t.tokenUsage.totalTokens += r.tokenUsage.totalTokens ?? 0),
            t), {
                tokenUsage: {
                    completionTokens: 0,
                    promptTokens: 0,
                    totalTokens: 0
                }
            })
        }
        withStructuredOutput(e, t) {
            let r, s, i, a;
            M6(e) ? (r = e.schema,
            s = e.name,
            i = e.method,
            a = e.includeRaw) : (r = e,
            s = t == null ? void 0 : t.name,
            i = t == null ? void 0 : t.method,
            a = t == null ? void 0 : t.includeRaw);
            let c, u;
            if ((t == null ? void 0 : t.strict) !== void 0 && i === "jsonMode")
                throw new Error("Argument `strict` is only supported for `method` = 'function_calling'");
            if (!this.model.startsWith("gpt-3") && !this.model.startsWith("gpt-4-") && this.model !== "gpt-4" ? i === void 0 && (i = "jsonSchema") : i === "jsonSchema" && console.warn(`[WARNING]: JSON Schema is not supported for model "${this.model}". Falling back to tool calling.`),
            i === "jsonMode")
                c = this.bind({
                    response_format: {
                        type: "json_object"
                    }
                }),
                Fw(r) ? u = cO.fromZodSchema(r) : u = new uO;
            else if (i === "jsonSchema")
                c = this.bind({
                    response_format: {
                        type: "json_schema",
                        json_schema: {
                            name: s ?? "extract",
                            description: r.description,
                            schema: r,
                            strict: t == null ? void 0 : t.strict
                        }
                    }
                }),
                Fw(r) ? u = cO.fromZodSchema(r) : u = new uO;
            else {
                let f = s ?? "extract";
                if (Fw(r)) {
                    const p = Ui(r);
                    c = this.bind({
                        tools: [{
                            type: "function",
                            function: {
                                name: f,
                                description: p.description,
                                parameters: p
                            }
                        }],
                        tool_choice: {
                            type: "function",
                            function: {
                                name: f
                            }
                        },
                        ...(t == null ? void 0 : t.strict) !== void 0 ? {
                            strict: t.strict
                        } : {}
                    }),
                    u = new dO({
                        returnSingle: !0,
                        keyName: f,
                        zodSchema: r
                    })
                } else {
                    let p;
                    typeof r.name == "string" && typeof r.parameters == "object" && r.parameters != null ? (p = r,
                    f = r.name) : (f = r.title ?? f,
                    p = {
                        name: f,
                        description: r.description ?? "",
                        parameters: r
                    }),
                    c = this.bind({
                        tools: [{
                            type: "function",
                            function: p
                        }],
                        tool_choice: {
                            type: "function",
                            function: {
                                name: f
                            }
                        },
                        ...(t == null ? void 0 : t.strict) !== void 0 ? {
                            strict: t.strict
                        } : {}
                    }),
                    u = new dO({
                        returnSingle: !0,
                        keyName: f
                    })
                }
            }
            if (!a)
                return c.pipe(u);
            const l = Vi.assign({
                parsed: (f, p) => u.invoke(f.raw, p)
            })
              , d = Vi.assign({
                parsed: () => null
            })
              , h = l.withFallbacks({
                fallbacks: [d]
            });
            return Fn.from([{
                raw: c
            }, h])
        }
    }
    function Fw(n) {
        return typeof (n == null ? void 0 : n.parse) == "function"
    }
    function M6(n) {
        return n !== void 0 && typeof n.schema == "object"
    }
    const Ou = "0.32.1";
    let CO = !1, Kh, kO, sE, PO, TO, AO;
    function N6(n, e={
        auto: !1
    }) {
        if (CO)
            throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${n.kind}'\` before importing anything else from @anthropic-ai/sdk`);
        if (Kh)
            throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${n.kind}'\` after \`import '@anthropic-ai/sdk/shims/${Kh}'\``);
        CO = e.auto,
        Kh = n.kind,
        kO = n.fetch,
        sE = n.File,
        PO = n.ReadableStream,
        TO = n.getDefaultAgent,
        AO = n.fileFromPath
    }
    class $6 {
        constructor(e) {
            this.body = e
        }
        get[Symbol.toStringTag]() {
            return "MultipartBody"
        }
    }
    function L6({manuallyImported: n}={}) {
        const e = n ? "You may need to use polyfills" : "Add one of these imports before your first `import  from '@anthropic-ai/sdk'`:\n- `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)\n- `import '@anthropic-ai/sdk/shims/web'` (otherwise)\n";
        let t, r, s, i;
        try {
            t = fetch,
            r = Request,
            s = Response,
            i = Headers
        } catch (a) {
            throw new Error(`this environment is missing the following Web Fetch API type: ${a.message}. ${e}`)
        }
        return {
            kind: "web",
            fetch: t,
            Request: r,
            Response: s,
            Headers: i,
            FormData: typeof FormData < "u" ? FormData : class {
                constructor() {
                    throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${e}`)
                }
            }
            ,
            Blob: typeof Blob < "u" ? Blob : class {
                constructor() {
                    throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${e}`)
                }
            }
            ,
            File: typeof File < "u" ? File : class {
                constructor() {
                    throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${e}`)
                }
            }
            ,
            ReadableStream: typeof ReadableStream < "u" ? ReadableStream : class {
                constructor() {
                    throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${e}`)
                }
            }
            ,
            getMultipartRequestOptions: async (a, c) => ({
                ...c,
                body: new $6(a)
            }),
            getDefaultAgent: a => {}
            ,
            fileFromPath: () => {
                throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads")
            }
            ,
            isFsReadStream: a => !1
        }
    }
    Kh || N6(L6(), {
        auto: !0
    });
    class Ye extends Error {
    }
    class fr extends Ye {
        constructor(e, t, r, s) {
            super(`${fr.makeMessage(e, t, r)}`),
            this.status = e,
            this.headers = s,
            this.request_id = s == null ? void 0 : s["request-id"],
            this.error = t
        }
        static makeMessage(e, t, r) {
            const s = t != null && t.message ? typeof t.message == "string" ? t.message : JSON.stringify(t.message) : t ? JSON.stringify(t) : r;
            return e && s ? `${e} ${s}` : e ? `${e} status code (no body)` : s || "(no status code or body)"
        }
        static generate(e, t, r, s) {
            if (!e)
                return new jw({
                    message: r,
                    cause: cE(t)
                });
            const i = t;
            return e === 400 ? new OO(e,i,r,s) : e === 401 ? new RO(e,i,r,s) : e === 403 ? new MO(e,i,r,s) : e === 404 ? new NO(e,i,r,s) : e === 409 ? new $O(e,i,r,s) : e === 422 ? new LO(e,i,r,s) : e === 429 ? new FO(e,i,r,s) : e >= 500 ? new jO(e,i,r,s) : new fr(e,i,r,s)
        }
    }
    class zn extends fr {
        constructor({message: e}={}) {
            super(void 0, void 0, e || "Request was aborted.", void 0),
            this.status = void 0
        }
    }
    class jw extends fr {
        constructor({message: e, cause: t}) {
            super(void 0, void 0, e || "Connection error.", void 0),
            this.status = void 0,
            t && (this.cause = t)
        }
    }
    class IO extends jw {
        constructor({message: e}={}) {
            super({
                message: e ?? "Request timed out."
            })
        }
    }
    class OO extends fr {
        constructor() {
            super(...arguments),
            this.status = 400
        }
    }
    class RO extends fr {
        constructor() {
            super(...arguments),
            this.status = 401
        }
    }
    class MO extends fr {
        constructor() {
            super(...arguments),
            this.status = 403
        }
    }
    class NO extends fr {
        constructor() {
            super(...arguments),
            this.status = 404
        }
    }
    class $O extends fr {
        constructor() {
            super(...arguments),
            this.status = 409
        }
    }
    class LO extends fr {
        constructor() {
            super(...arguments),
            this.status = 422
        }
    }
    class FO extends fr {
        constructor() {
            super(...arguments),
            this.status = 429
        }
    }
    class jO extends fr {
    }
    class Gi {
        constructor() {
            this.buffer = [],
            this.trailingCR = !1
        }
        decode(e) {
            let t = this.decodeText(e);
            if (this.trailingCR && (t = "\r" + t,
            this.trailingCR = !1),
            t.endsWith("\r") && (this.trailingCR = !0,
            t = t.slice(0, -1)),
            !t)
                return [];
            const r = Gi.NEWLINE_CHARS.has(t[t.length - 1] || "");
            let s = t.split(Gi.NEWLINE_REGEXP);
            return r && s.pop(),
            s.length === 1 && !r ? (this.buffer.push(s[0]),
            []) : (this.buffer.length > 0 && (s = [this.buffer.join("") + s[0], ...s.slice(1)],
            this.buffer = []),
            r || (this.buffer = [s.pop() || ""]),
            s)
        }
        decodeText(e) {
            if (e == null)
                return "";
            if (typeof e == "string")
                return e;
            if (typeof Buffer < "u") {
                if (e instanceof Buffer)
                    return e.toString();
                if (e instanceof Uint8Array)
                    return Buffer.from(e).toString();
                throw new Ye(`Unexpected: received non-Uint8Array (${e.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`)
            }
            if (typeof TextDecoder < "u") {
                if (e instanceof Uint8Array || e instanceof ArrayBuffer)
                    return this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8")),
                    this.textDecoder.decode(e);
                throw new Ye(`Unexpected: received non-Uint8Array/ArrayBuffer (${e.constructor.name}) in a web platform. Please report this error.`)
            }
            throw new Ye("Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.")
        }
        flush() {
            if (!this.buffer.length && !this.trailingCR)
                return [];
            const e = [this.buffer.join("")];
            return this.buffer = [],
            this.trailingCR = !1,
            e
        }
    }
    Gi.NEWLINE_CHARS = new Set([`
`, "\r"]),
    Gi.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
    class vs {
        constructor(e, t) {
            this.iterator = e,
            this.controller = t
        }
        static fromSSEResponse(e, t) {
            let r = !1;
            async function *s() {
                if (r)
                    throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
                r = !0;
                let i = !1;
                try {
                    for await(const a of F6(e, t)) {
                        if (a.event === "completion")
                            try {
                                yield JSON.parse(a.data)
                            } catch (c) {
                                throw console.error("Could not parse message into JSON:", a.data),
                                console.error("From chunk:", a.raw),
                                c
                            }
                        if (a.event === "message_start" || a.event === "message_delta" || a.event === "message_stop" || a.event === "content_block_start" || a.event === "content_block_delta" || a.event === "content_block_stop")
                            try {
                                yield JSON.parse(a.data)
                            } catch (c) {
                                throw console.error("Could not parse message into JSON:", a.data),
                                console.error("From chunk:", a.raw),
                                c
                            }
                        if (a.event !== "ping" && a.event === "error")
                            throw fr.generate(void 0, `SSE Error: ${a.data}`, a.data, qO(e.headers))
                    }
                    i = !0
                } catch (a) {
                    if (a instanceof Error && a.name === "AbortError")
                        return;
                    throw a
                } finally {
                    i || t.abort()
                }
            }
            return new vs(s,t)
        }
        static fromReadableStream(e, t) {
            let r = !1;
            async function *s() {
                const a = new Gi
                  , c = iE(e);
                for await(const u of c)
                    for (const l of a.decode(u))
                        yield l;
                for (const u of a.flush())
                    yield u
            }
            async function *i() {
                if (r)
                    throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
                r = !0;
                let a = !1;
                try {
                    for await(const c of s())
                        a || c && (yield JSON.parse(c));
                    a = !0
                } catch (c) {
                    if (c instanceof Error && c.name === "AbortError")
                        return;
                    throw c
                } finally {
                    a || t.abort()
                }
            }
            return new vs(i,t)
        }
        [Symbol.asyncIterator]() {
            return this.iterator()
        }
        tee() {
            const e = []
              , t = []
              , r = this.iterator()
              , s = i => ({
                next: () => {
                    if (i.length === 0) {
                        const a = r.next();
                        e.push(a),
                        t.push(a)
                    }
                    return i.shift()
                }
            });
            return [new vs( () => s(e),this.controller), new vs( () => s(t),this.controller)]
        }
        toReadableStream() {
            const e = this;
            let t;
            const r = new TextEncoder;
            return new PO({
                async start() {
                    t = e[Symbol.asyncIterator]()
                },
                async pull(s) {
                    try {
                        const {value: i, done: a} = await t.next();
                        if (a)
                            return s.close();
                        const c = r.encode(JSON.stringify(i) + `
`);
                        s.enqueue(c)
                    } catch (i) {
                        s.error(i)
                    }
                },
                async cancel() {
                    var s;
                    await ((s = t.return) == null ? void 0 : s.call(t))
                }
            })
        }
    }
    async function *F6(n, e) {
        if (!n.body)
            throw e.abort(),
            new Ye("Attempted to iterate over a response with no body");
        const t = new B6
          , r = new Gi
          , s = iE(n.body);
        for await(const i of j6(s))
            for (const a of r.decode(i)) {
                const c = t.decode(a);
                c && (yield c)
            }
        for (const i of r.flush()) {
            const a = t.decode(i);
            a && (yield a)
        }
    }
    async function *j6(n) {
        let e = new Uint8Array;
        for await(const t of n) {
            if (t == null)
                continue;
            const r = t instanceof ArrayBuffer ? new Uint8Array(t) : typeof t == "string" ? new TextEncoder().encode(t) : t;
            let s = new Uint8Array(e.length + r.length);
            s.set(e),
            s.set(r, e.length),
            e = s;
            let i;
            for (; (i = D6(e)) !== -1; )
                yield e.slice(0, i),
                e = e.slice(i)
        }
        e.length > 0 && (yield e)
    }
    function D6(n) {
        for (let r = 0; r < n.length - 2; r++) {
            if (n[r] === 10 && n[r + 1] === 10 || n[r] === 13 && n[r + 1] === 13)
                return r + 2;
            if (n[r] === 13 && n[r + 1] === 10 && r + 3 < n.length && n[r + 2] === 13 && n[r + 3] === 10)
                return r + 4
        }
        return -1
    }
    class B6 {
        constructor() {
            this.event = null,
            this.data = [],
            this.chunks = []
        }
        decode(e) {
            if (e.endsWith("\r") && (e = e.substring(0, e.length - 1)),
            !e) {
                if (!this.event && !this.data.length)
                    return null;
                const i = {
                    event: this.event,
                    data: this.data.join(`
`),
                    raw: this.chunks
                };
                return this.event = null,
                this.data = [],
                this.chunks = [],
                i
            }
            if (this.chunks.push(e),
            e.startsWith(":"))
                return null;
            let[t,r,s] = q6(e, ":");
            return s.startsWith(" ") && (s = s.substring(1)),
            t === "event" ? this.event = s : t === "data" && this.data.push(s),
            null
        }
    }
    function q6(n, e) {
        const t = n.indexOf(e);
        return t !== -1 ? [n.substring(0, t), e, n.substring(t + e.length)] : [n, "", ""]
    }
    function iE(n) {
        if (n[Symbol.asyncIterator])
            return n;
        const e = n.getReader();
        return {
            async next() {
                try {
                    const t = await e.read();
                    return t != null && t.done && e.releaseLock(),
                    t
                } catch (t) {
                    throw e.releaseLock(),
                    t
                }
            },
            async return() {
                const t = e.cancel();
                return e.releaseLock(),
                await t,
                {
                    done: !0,
                    value: void 0
                }
            },
            [Symbol.asyncIterator]() {
                return this
            }
        }
    }
    const U6 = n => n != null && typeof n == "object" && typeof n.url == "string" && typeof n.blob == "function"
      , K6 = n => n != null && typeof n == "object" && typeof n.name == "string" && typeof n.lastModified == "number" && Dw(n)
      , Dw = n => n != null && typeof n == "object" && typeof n.size == "number" && typeof n.type == "string" && typeof n.text == "function" && typeof n.slice == "function" && typeof n.arrayBuffer == "function";
    async function H6(n, e, t) {
        var s;
        if (n = await n,
        K6(n))
            return n;
        if (U6(n)) {
            const i = await n.blob();
            e || (e = new URL(n.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
            const a = Dw(i) ? [await i.arrayBuffer()] : [i];
            return new sE(a,e,t)
        }
        const r = await W6(n);
        if (e || (e = V6(n) ?? "unknown_file"),
        !(t != null && t.type)) {
            const i = (s = r[0]) == null ? void 0 : s.type;
            typeof i == "string" && (t = {
                ...t,
                type: i
            })
        }
        return new sE(r,e,t)
    }
    async function W6(n) {
        var t;
        let e = [];
        if (typeof n == "string" || ArrayBuffer.isView(n) || n instanceof ArrayBuffer)
            e.push(n);
        else if (Dw(n))
            e.push(await n.arrayBuffer());
        else if (G6(n))
            for await(const r of n)
                e.push(r);
        else
            throw new Error(`Unexpected data type: ${typeof n}; constructor: ${(t = n == null ? void 0 : n.constructor) == null ? void 0 : t.name}; props: ${z6(n)}`);
        return e
    }
    function z6(n) {
        return `[${Object.getOwnPropertyNames(n).map(t => `"${t}"`).join(", ")}]`
    }
    function V6(n) {
        var e;
        return aE(n.name) || aE(n.filename) || ((e = aE(n.path)) == null ? void 0 : e.split(/[\\/]/).pop())
    }
    const aE = n => {
        if (typeof n == "string")
            return n;
        if (typeof Buffer < "u" && n instanceof Buffer)
            return String(n)
    }
      , G6 = n => n != null && typeof n == "object" && typeof n[Symbol.asyncIterator] == "function"
      , DO = n => n && typeof n == "object" && n.body && n[Symbol.toStringTag] === "MultipartBody";
    var J6 = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, Z6 = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, Bw;
    async function BO(n) {
        const {response: e} = n;
        if (n.options.stream)
            return Ru("response", e.status, e.url, e.headers, e.body),
            n.options.__streamClass ? n.options.__streamClass.fromSSEResponse(e, n.controller) : vs.fromSSEResponse(e, n.controller);
        if (e.status === 204)
            return null;
        if (n.options.__binaryResponse)
            return e;
        const t = e.headers.get("content-type");
        if ((t == null ? void 0 : t.includes("application/json")) || (t == null ? void 0 : t.includes("application/vnd.api+json"))) {
            const i = await e.json();
            return Ru("response", e.status, e.url, e.headers, i),
            i
        }
        const s = await e.text();
        return Ru("response", e.status, e.url, e.headers, s),
        s
    }
    class qw extends Promise {
        constructor(e, t=BO) {
            super(r => {
                r(null)
            }
            ),
            this.responsePromise = e,
            this.parseResponse = t
        }
        _thenUnwrap(e) {
            return new qw(this.responsePromise,async t => e(await this.parseResponse(t), t))
        }
        asResponse() {
            return this.responsePromise.then(e => e.response)
        }
        async withResponse() {
            const [e,t] = await Promise.all([this.parse(), this.asResponse()]);
            return {
                data: e,
                response: t
            }
        }
        parse() {
            return this.parsedPromise || (this.parsedPromise = this.responsePromise.then(this.parseResponse)),
            this.parsedPromise
        }
        then(e, t) {
            return this.parse().then(e, t)
        }
        catch(e) {
            return this.parse().catch(e)
        }
        finally(e) {
            return this.parse().finally(e)
        }
    }
    class X6 {
        constructor({baseURL: e, maxRetries: t=2, timeout: r=6e5, httpAgent: s, fetch: i}) {
            this.baseURL = e,
            this.maxRetries = oE("maxRetries", t),
            this.timeout = oE("timeout", r),
            this.httpAgent = s,
            this.fetch = i ?? kO
        }
        authHeaders(e) {
            return {}
        }
        defaultHeaders(e) {
            return {
                Accept: "application/json",
                "Content-Type": "application/json",
                "User-Agent": this.getUserAgent(),
                ...nW(),
                ...this.authHeaders(e)
            }
        }
        validateHeaders(e, t) {}
        defaultIdempotencyKey() {
            return `stainless-node-retry-${cW()}`
        }
        get(e, t) {
            return this.methodRequest("get", e, t)
        }
        post(e, t) {
            return this.methodRequest("post", e, t)
        }
        patch(e, t) {
            return this.methodRequest("patch", e, t)
        }
        put(e, t) {
            return this.methodRequest("put", e, t)
        }
        delete(e, t) {
            return this.methodRequest("delete", e, t)
        }
        methodRequest(e, t, r) {
            return this.request(Promise.resolve(r).then(async s => {
                const i = s && Dw(s == null ? void 0 : s.body) ? new DataView(await s.body.arrayBuffer()) : (s == null ? void 0 : s.body)instanceof DataView ? s.body : (s == null ? void 0 : s.body)instanceof ArrayBuffer ? new DataView(s.body) : s && ArrayBuffer.isView(s == null ? void 0 : s.body) ? new DataView(s.body.buffer) : s == null ? void 0 : s.body;
                return {
                    method: e,
                    path: t,
                    ...s,
                    body: i
                }
            }
            ))
        }
        getAPIList(e, t, r) {
            return this.requestAPIList(t, {
                method: "get",
                path: e,
                ...r
            })
        }
        calculateContentLength(e) {
            if (typeof e == "string") {
                if (typeof Buffer < "u")
                    return Buffer.byteLength(e, "utf8").toString();
                if (typeof TextEncoder < "u")
                    return new TextEncoder().encode(e).length.toString()
            } else if (ArrayBuffer.isView(e))
                return e.byteLength.toString();
            return null
        }
        buildRequest(e, {retryCount: t=0}={}) {
            var y;
            const {method: r, path: s, query: i, headers: a={}} = e
              , c = ArrayBuffer.isView(e.body) || e.__binaryRequest && typeof e.body == "string" ? e.body : DO(e.body) ? e.body.body : e.body ? JSON.stringify(e.body, null, 2) : null
              , u = this.calculateContentLength(c)
              , l = this.buildURL(s, i);
            "timeout"in e && oE("timeout", e.timeout);
            const d = e.timeout ?? this.timeout
              , h = e.httpAgent ?? this.httpAgent ?? TO(l)
              , f = d + 1e3;
            typeof ((y = h == null ? void 0 : h.options) == null ? void 0 : y.timeout) == "number" && f > (h.options.timeout ?? 0) && (h.options.timeout = f),
            this.idempotencyHeader && r !== "get" && (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()),
            a[this.idempotencyHeader] = e.idempotencyKey);
            const p = this.buildHeaders({
                options: e,
                headers: a,
                contentLength: u,
                retryCount: t
            });
            return {
                req: {
                    method: r,
                    ...c && {
                        body: c
                    },
                    headers: p,
                    ...h && {
                        agent: h
                    },
                    signal: e.signal ?? null
                },
                url: l,
                timeout: d
            }
        }
        buildHeaders({options: e, headers: t, contentLength: r, retryCount: s}) {
            const i = {};
            r && (i["content-length"] = r);
            const a = this.defaultHeaders(e);
            return zO(i, a),
            zO(i, t),
            DO(e.body) && Kh !== "node" && delete i["content-type"],
            VO(a, "x-stainless-retry-count") === void 0 && VO(t, "x-stainless-retry-count") === void 0 && (i["x-stainless-retry-count"] = String(s)),
            this.validateHeaders(i, t),
            i
        }
        async prepareOptions(e) {}
        async prepareRequest(e, {url: t, options: r}) {}
        parseHeaders(e) {
            return e ? Symbol.iterator in e ? Object.fromEntries(Array.from(e).map(t => [...t])) : {
                ...e
            } : {}
        }
        makeStatusError(e, t, r, s) {
            return fr.generate(e, t, r, s)
        }
        request(e, t=null) {
            return new qw(this.makeRequest(e, t))
        }
        async makeRequest(e, t) {
            var h, f;
            const r = await e
              , s = r.maxRetries ?? this.maxRetries;
            t == null && (t = s),
            await this.prepareOptions(r);
            const {req: i, url: a, timeout: c} = this.buildRequest(r, {
                retryCount: s - t
            });
            if (await this.prepareRequest(i, {
                url: a,
                options: r
            }),
            Ru("request", a, r, i.headers),
            (h = r.signal) != null && h.aborted)
                throw new zn;
            const u = new AbortController
              , l = await this.fetchWithTimeout(a, i, c, u).catch(cE);
            if (l instanceof Error) {
                if ((f = r.signal) != null && f.aborted)
                    throw new zn;
                if (t)
                    return this.retryRequest(r, t);
                throw l.name === "AbortError" ? new IO : new jw({
                    cause: l
                })
            }
            const d = qO(l.headers);
            if (!l.ok) {
                if (t && this.shouldRetry(l)) {
                    const E = `retrying, ${t} attempts remaining`;
                    return Ru(`response (error; ${E})`, l.status, a, d),
                    this.retryRequest(r, t, d)
                }
                const p = await l.text().catch(E => cE(E).message)
                  , g = sW(p)
                  , y = g ? void 0 : p;
                throw Ru(`response (error; ${t ? "(error; no more retries left)" : "(error; not retryable)"})`, l.status, a, d, y),
                this.makeStatusError(l.status, g, y, d)
            }
            return {
                response: l,
                options: r,
                controller: u
            }
        }
        requestAPIList(e, t) {
            const r = this.makeRequest(t, null);
            return new Q6(this,r,e)
        }
        buildURL(e, t) {
            const r = aW(e) ? new URL(e) : new URL(this.baseURL + (this.baseURL.endsWith("/") && e.startsWith("/") ? e.slice(1) : e))
              , s = this.defaultQuery();
            return Kw(s) || (t = {
                ...s,
                ...t
            }),
            typeof t == "object" && t && !Array.isArray(t) && (r.search = this.stringifyQuery(t)),
            r.toString()
        }
        stringifyQuery(e) {
            return Object.entries(e).filter( ([t,r]) => typeof r < "u").map( ([t,r]) => {
                if (typeof r == "string" || typeof r == "number" || typeof r == "boolean")
                    return `${encodeURIComponent(t)}=${encodeURIComponent(r)}`;
                if (r === null)
                    return `${encodeURIComponent(t)}=`;
                throw new Ye(`Cannot stringify type ${typeof r}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`)
            }
            ).join("&")
        }
        async fetchWithTimeout(e, t, r, s) {
            const {signal: i, ...a} = t || {};
            i && i.addEventListener("abort", () => s.abort());
            const c = setTimeout( () => s.abort(), r);
            return this.getRequestClient().fetch.call(void 0, e, {
                signal: s.signal,
                ...a
            }).finally( () => {
                clearTimeout(c)
            }
            )
        }
        getRequestClient() {
            return {
                fetch: this.fetch
            }
        }
        shouldRetry(e) {
            const t = e.headers.get("x-should-retry");
            return t === "true" ? !0 : t === "false" ? !1 : e.status === 408 || e.status === 409 || e.status === 429 || e.status >= 500
        }
        async retryRequest(e, t, r) {
            let s;
            const i = r == null ? void 0 : r["retry-after-ms"];
            if (i) {
                const c = parseFloat(i);
                Number.isNaN(c) || (s = c)
            }
            const a = r == null ? void 0 : r["retry-after"];
            if (a && !s) {
                const c = parseFloat(a);
                Number.isNaN(c) ? s = Date.parse(a) - Date.now() : s = c * 1e3
            }
            if (!(s && 0 <= s && s < 60 * 1e3)) {
                const c = e.maxRetries ?? this.maxRetries;
                s = this.calculateDefaultRetryTimeoutMillis(t, c)
            }
            return await oW(s),
            this.makeRequest(e, t - 1)
        }
        calculateDefaultRetryTimeoutMillis(e, t) {
            const i = t - e
              , a = Math.min(.5 * Math.pow(2, i), 8)
              , c = 1 - Math.random() * .25;
            return a * c * 1e3
        }
        getUserAgent() {
            return `${this.constructor.name}/JS ${Ou}`
        }
    }
    class Y6 {
        constructor(e, t, r, s) {
            Bw.set(this, void 0),
            J6(this, Bw, e, "f"),
            this.options = s,
            this.response = t,
            this.body = r
        }
        hasNextPage() {
            return this.getPaginatedItems().length ? this.nextPageInfo() != null : !1
        }
        async getNextPage() {
            const e = this.nextPageInfo();
            if (!e)
                throw new Ye("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
            const t = {
                ...this.options
            };
            if ("params"in e && typeof t.query == "object")
                t.query = {
                    ...t.query,
                    ...e.params
                };
            else if ("url"in e) {
                const r = [...Object.entries(t.query || {}), ...e.url.searchParams.entries()];
                for (const [s,i] of r)
                    e.url.searchParams.set(s, i);
                t.query = void 0,
                t.path = e.url.toString()
            }
            return await Z6(this, Bw, "f").requestAPIList(this.constructor, t)
        }
        async*iterPages() {
            let e = this;
            for (yield e; e.hasNextPage(); )
                e = await e.getNextPage(),
                yield e
        }
        async*[(Bw = new WeakMap,
        Symbol.asyncIterator)]() {
            for await(const e of this.iterPages())
                for (const t of e.getPaginatedItems())
                    yield t
        }
    }
    class Q6 extends qw {
        constructor(e, t, r) {
            super(t, async s => new r(e,s.response,await BO(s),s.options))
        }
        async*[Symbol.asyncIterator]() {
            const e = await this;
            for await(const t of e)
                yield t
        }
    }
    const qO = n => new Proxy(Object.fromEntries(n.entries()),{
        get(e, t) {
            const r = t.toString();
            return e[r.toLowerCase()] || e[r]
        }
    })
      , eW = {
        method: !0,
        path: !0,
        query: !0,
        body: !0,
        headers: !0,
        maxRetries: !0,
        stream: !0,
        timeout: !0,
        httpAgent: !0,
        signal: !0,
        idempotencyKey: !0,
        __binaryRequest: !0,
        __binaryResponse: !0,
        __streamClass: !0
    }
      , Uw = n => typeof n == "object" && n !== null && !Kw(n) && Object.keys(n).every(e => WO(eW, e))
      , tW = () => {
        var e;
        if (typeof Deno < "u" && Deno.build != null)
            return {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": Ou,
                "X-Stainless-OS": KO(Deno.build.os),
                "X-Stainless-Arch": UO(Deno.build.arch),
                "X-Stainless-Runtime": "deno",
                "X-Stainless-Runtime-Version": typeof Deno.version == "string" ? Deno.version : ((e = Deno.version) == null ? void 0 : e.deno) ?? "unknown"
            };
        if (typeof EdgeRuntime < "u")
            return {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": Ou,
                "X-Stainless-OS": "Unknown",
                "X-Stainless-Arch": `other:${EdgeRuntime}`,
                "X-Stainless-Runtime": "edge",
                "X-Stainless-Runtime-Version": process.version
            };
        if (Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]")
            return {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": Ou,
                "X-Stainless-OS": KO(process.platform),
                "X-Stainless-Arch": UO(process.arch),
                "X-Stainless-Runtime": "node",
                "X-Stainless-Runtime-Version": process.version
            };
        const n = rW();
        return n ? {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": Ou,
            "X-Stainless-OS": "Unknown",
            "X-Stainless-Arch": "unknown",
            "X-Stainless-Runtime": `browser:${n.browser}`,
            "X-Stainless-Runtime-Version": n.version
        } : {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": Ou,
            "X-Stainless-OS": "Unknown",
            "X-Stainless-Arch": "unknown",
            "X-Stainless-Runtime": "unknown",
            "X-Stainless-Runtime-Version": "unknown"
        }
    }
    ;
    function rW() {
        if (typeof navigator > "u" || !navigator)
            return null;
        const n = [{
            key: "edge",
            pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "ie",
            pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "ie",
            pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "chrome",
            pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "firefox",
            pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/
        }, {
            key: "safari",
            pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/
        }];
        for (const {key: e, pattern: t} of n) {
            const r = t.exec(navigator.userAgent);
            if (r) {
                const s = r[1] || 0
                  , i = r[2] || 0
                  , a = r[3] || 0;
                return {
                    browser: e,
                    version: `${s}.${i}.${a}`
                }
            }
        }
        return null
    }
    const UO = n => n === "x32" ? "x32" : n === "x86_64" || n === "x64" ? "x64" : n === "arm" ? "arm" : n === "aarch64" || n === "arm64" ? "arm64" : n ? `other:${n}` : "unknown"
      , KO = n => (n = n.toLowerCase(),
    n.includes("ios") ? "iOS" : n === "android" ? "Android" : n === "darwin" ? "MacOS" : n === "win32" ? "Windows" : n === "freebsd" ? "FreeBSD" : n === "openbsd" ? "OpenBSD" : n === "linux" ? "Linux" : n ? `Other:${n}` : "Unknown");
    let HO;
    const nW = () => HO ?? (HO = tW())
      , sW = n => {
        try {
            return JSON.parse(n)
        } catch {
            return
        }
    }
      , iW = new RegExp("^(?:[a-z]+:)?//","i")
      , aW = n => iW.test(n)
      , oW = n => new Promise(e => setTimeout(e, n))
      , oE = (n, e) => {
        if (typeof e != "number" || !Number.isInteger(e))
            throw new Ye(`${n} must be an integer`);
        if (e < 0)
            throw new Ye(`${n} must be a positive integer`);
        return e
    }
      , cE = n => {
        if (n instanceof Error)
            return n;
        if (typeof n == "object" && n !== null)
            try {
                return new Error(JSON.stringify(n))
            } catch {}
        return new Error(String(n))
    }
      , uE = n => {
        var e, t, r, s, i;
        if (typeof process < "u")
            return ((t = (e = process.env) == null ? void 0 : e[n]) == null ? void 0 : t.trim()) ?? void 0;
        if (typeof Deno < "u")
            return (i = (s = (r = Deno.env) == null ? void 0 : r.get) == null ? void 0 : s.call(r, n)) == null ? void 0 : i.trim()
    }
    ;
    function Kw(n) {
        if (!n)
            return !0;
        for (const e in n)
            return !1;
        return !0
    }
    function WO(n, e) {
        return Object.prototype.hasOwnProperty.call(n, e)
    }
    function zO(n, e) {
        for (const t in e) {
            if (!WO(e, t))
                continue;
            const r = t.toLowerCase();
            if (!r)
                continue;
            const s = e[t];
            s === null ? delete n[r] : s !== void 0 && (n[r] = s)
        }
    }
    function Ru(n, ...e) {
        var t;
        typeof process < "u" && ((t = process == null ? void 0 : process.env) == null ? void 0 : t.DEBUG) === "true" && console.log(`Anthropic:DEBUG:${n}`, ...e)
    }
    const cW = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, n => {
        const e = Math.random() * 16 | 0;
        return (n === "x" ? e : e & 3 | 8).toString(16)
    }
    )
      , uW = () => typeof window < "u" && typeof window.document < "u" && typeof navigator < "u"
      , lW = n => typeof (n == null ? void 0 : n.get) == "function"
      , VO = (n, e) => {
        var r;
        const t = e.toLowerCase();
        if (lW(n)) {
            const s = ((r = e[0]) == null ? void 0 : r.toUpperCase()) + e.substring(1).replace(/([^\w])(\w)/g, (i, a, c) => a + c.toUpperCase());
            for (const i of [e, t, e.toUpperCase(), s]) {
                const a = n.get(i);
                if (a)
                    return a
            }
        }
        for (const [s,i] of Object.entries(n))
            if (s.toLowerCase() === t)
                return Array.isArray(i) ? (i.length <= 1 || console.warn(`Received ${i.length} entries for the ${e} header, using the first entry.`),
                i[0]) : i
    }
    ;
    class dW extends Y6 {
        constructor(e, t, r, s) {
            super(e, t, r, s),
            this.data = r.data || [],
            this.has_more = r.has_more || !1,
            this.first_id = r.first_id || null,
            this.last_id = r.last_id || null
        }
        getPaginatedItems() {
            return this.data ?? []
        }
        nextPageParams() {
            const e = this.nextPageInfo();
            if (!e)
                return null;
            if ("params"in e)
                return e.params;
            const t = Object.fromEntries(e.url.searchParams);
            return Object.keys(t).length ? t : null
        }
        nextPageInfo() {
            var t;
            if ((t = this.options.query) != null && t.before_id) {
                const r = this.first_id;
                return r ? {
                    params: {
                        before_id: r
                    }
                } : null
            }
            const e = this.last_id;
            return e ? {
                params: {
                    after_id: e
                }
            } : null
        }
    }
    class ho {
        constructor(e) {
            this._client = e
        }
    }
    class lE {
        constructor(e, t) {
            this.iterator = e,
            this.controller = t
        }
        async*decoder() {
            const e = new Gi;
            for await(const t of this.iterator)
                for (const r of e.decode(t))
                    yield JSON.parse(r);
            for (const t of e.flush())
                yield JSON.parse(t)
        }
        [Symbol.asyncIterator]() {
            return this.decoder()
        }
        static fromResponse(e, t) {
            if (!e.body)
                throw t.abort(),
                new Ye("Attempted to iterate over a response with no body");
            return new lE(iE(e.body),t)
        }
    }
    class dE extends ho {
        create(e, t) {
            const {betas: r, ...s} = e;
            return this._client.post("/v1/messages/batches?beta=true", {
                body: s,
                ...t,
                headers: {
                    "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        retrieve(e, t={}, r) {
            if (Uw(t))
                return this.retrieve(e, {}, t);
            const {betas: s} = t;
            return this._client.get(`/v1/messages/batches/${e}?beta=true`, {
                ...r,
                headers: {
                    "anthropic-beta": [...s ?? [], "message-batches-2024-09-24"].toString(),
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        list(e={}, t) {
            if (Uw(e))
                return this.list({}, e);
            const {betas: r, ...s} = e;
            return this._client.getAPIList("/v1/messages/batches?beta=true", hE, {
                query: s,
                ...t,
                headers: {
                    "anthropic-beta": [...r ?? [], "message-batches-2024-09-24"].toString(),
                    ...t == null ? void 0 : t.headers
                }
            })
        }
        cancel(e, t={}, r) {
            if (Uw(t))
                return this.cancel(e, {}, t);
            const {betas: s} = t;
            return this._client.post(`/v1/messages/batches/${e}/cancel?beta=true`, {
                ...r,
                headers: {
                    "anthropic-beta": [...s ?? [], "message-batches-2024-09-24"].toString(),
                    ...r == null ? void 0 : r.headers
                }
            })
        }
        async results(e, t={}, r) {
            if (Uw(t))
                return this.results(e, {}, t);
            const s = await this.retrieve(e);
            if (!s.results_url)
                throw new Ye(`No batch \`results_url\`; Has it finished processing? ${s.processing_status} - ${s.id}`);
            const {betas: i} = t;
            return this._client.get(s.results_url, {
                ...r,
                headers: {
                    "anthropic-beta": [...i ?? [], "message-batches-2024-09-24"].toString(),
                    ...r == null ? void 0 : r.headers
                },
                __binaryResponse: !0
            })._thenUnwrap( (a, c) => lE.fromResponse(c.response, c.controller))
        }
    }
    class hE extends dW {
    }
    dE.BetaMessageBatchesPage = hE;
    let Hw = class extends ho {
        constructor() {
            super(...arguments),
            this.batches = new dE(this._client)
        }
        create(e, t) {
            const {betas: r, ...s} = e;
            return this._client.post("/v1/messages?beta=true", {
                body: s,
                timeout: this._client._options.timeout ?? 6e5,
                ...t,
                headers: {
                    ...(r == null ? void 0 : r.toString()) != null ? {
                        "anthropic-beta": r == null ? void 0 : r.toString()
                    } : void 0,
                    ...t == null ? void 0 : t.headers
                },
                stream: e.stream ?? !1
            })
        }
        countTokens(e, t) {
            const {betas: r, ...s} = e;
            return this._client.post("/v1/messages/count_tokens?beta=true", {
                body: s,
                ...t,
                headers: {
                    "anthropic-beta": [...r ?? [], "token-counting-2024-11-01"].toString(),
                    ...t == null ? void 0 : t.headers
                }
            })
        }
    }
    ;
    Hw.Batches = dE,
    Hw.BetaMessageBatchesPage = hE;
    const hW = n => {
        let e = 0
          , t = [];
        for (; e < n.length; ) {
            let r = n[e];
            if (r === "\\") {
                e++;
                continue
            }
            if (r === "{") {
                t.push({
                    type: "brace",
                    value: "{"
                }),
                e++;
                continue
            }
            if (r === "}") {
                t.push({
                    type: "brace",
                    value: "}"
                }),
                e++;
                continue
            }
            if (r === "[") {
                t.push({
                    type: "paren",
                    value: "["
                }),
                e++;
                continue
            }
            if (r === "]") {
                t.push({
                    type: "paren",
                    value: "]"
                }),
                e++;
                continue
            }
            if (r === ":") {
                t.push({
                    type: "separator",
                    value: ":"
                }),
                e++;
                continue
            }
            if (r === ",") {
                t.push({
                    type: "delimiter",
                    value: ","
                }),
                e++;
                continue
            }
            if (r === '"') {
                let c = ""
                  , u = !1;
                for (r = n[++e]; r !== '"'; ) {
                    if (e === n.length) {
                        u = !0;
                        break
                    }
                    if (r === "\\") {
                        if (e++,
                        e === n.length) {
                            u = !0;
                            break
                        }
                        c += r + n[e],
                        r = n[++e]
                    } else
                        c += r,
                        r = n[++e]
                }
                r = n[++e],
                u || t.push({
                    type: "string",
                    value: c
                });
                continue
            }
            if (r && /\s/.test(r)) {
                e++;
                continue
            }
            let i = /[0-9]/;
            if (r && i.test(r) || r === "-" || r === ".") {
                let c = "";
                for (r === "-" && (c += r,
                r = n[++e]); r && i.test(r) || r === "."; )
                    c += r,
                    r = n[++e];
                t.push({
                    type: "number",
                    value: c
                });
                continue
            }
            let a = /[a-z]/i;
            if (r && a.test(r)) {
                let c = "";
                for (; r && a.test(r) && e !== n.length; )
                    c += r,
                    r = n[++e];
                if (c == "true" || c == "false" || c === "null")
                    t.push({
                        type: "name",
                        value: c
                    });
                else {
                    e++;
                    continue
                }
                continue
            }
            e++
        }
        return t
    }
      , Mu = n => {
        if (n.length === 0)
            return n;
        let e = n[n.length - 1];
        switch (e.type) {
        case "separator":
            return n = n.slice(0, n.length - 1),
            Mu(n);
        case "number":
            let t = e.value[e.value.length - 1];
            if (t === "." || t === "-")
                return n = n.slice(0, n.length - 1),
                Mu(n);
        case "string":
            let r = n[n.length - 2];
            if ((r == null ? void 0 : r.type) === "delimiter")
                return n = n.slice(0, n.length - 1),
                Mu(n);
            if ((r == null ? void 0 : r.type) === "brace" && r.value === "{")
                return n = n.slice(0, n.length - 1),
                Mu(n);
            break;
        case "delimiter":
            return n = n.slice(0, n.length - 1),
            Mu(n)
        }
        return n
    }
      , fW = n => {
        let e = [];
        return n.map(t => {
            t.type === "brace" && (t.value === "{" ? e.push("}") : e.splice(e.lastIndexOf("}"), 1)),
            t.type === "paren" && (t.value === "[" ? e.push("]") : e.splice(e.lastIndexOf("]"), 1))
        }
        ),
        e.length > 0 && e.reverse().map(t => {
            t === "}" ? n.push({
                type: "brace",
                value: "}"
            }) : t === "]" && n.push({
                type: "paren",
                value: "]"
            })
        }
        ),
        n
    }
      , pW = n => {
        let e = "";
        return n.map(t => {
            switch (t.type) {
            case "string":
                e += '"' + t.value + '"';
                break;
            default:
                e += t.value;
                break
            }
        }
        ),
        e
    }
      , GO = n => JSON.parse(pW(fW(Mu(hW(n)))));
    var Br = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, Ue = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, wn, Ji, Ww, zw, Hh, Wh, Vw, zh, Gs, Vh, Gw, Jw, Nu, fE, JO, pE, mE, gE, yE, ZO;
    const XO = "__json_buf";
    class Zw {
        constructor() {
            wn.add(this),
            this.messages = [],
            this.receivedMessages = [],
            Ji.set(this, void 0),
            this.controller = new AbortController,
            Ww.set(this, void 0),
            zw.set(this, () => {}
            ),
            Hh.set(this, () => {}
            ),
            Wh.set(this, void 0),
            Vw.set(this, () => {}
            ),
            zh.set(this, () => {}
            ),
            Gs.set(this, {}),
            Vh.set(this, !1),
            Gw.set(this, !1),
            Jw.set(this, !1),
            Nu.set(this, !1),
            pE.set(this, e => {
                if (Br(this, Gw, !0, "f"),
                e instanceof Error && e.name === "AbortError" && (e = new zn),
                e instanceof zn)
                    return Br(this, Jw, !0, "f"),
                    this._emit("abort", e);
                if (e instanceof Ye)
                    return this._emit("error", e);
                if (e instanceof Error) {
                    const t = new Ye(e.message);
                    return t.cause = e,
                    this._emit("error", t)
                }
                return this._emit("error", new Ye(String(e)))
            }
            ),
            Br(this, Ww, new Promise( (e, t) => {
                Br(this, zw, e, "f"),
                Br(this, Hh, t, "f")
            }
            ), "f"),
            Br(this, Wh, new Promise( (e, t) => {
                Br(this, Vw, e, "f"),
                Br(this, zh, t, "f")
            }
            ), "f"),
            Ue(this, Ww, "f").catch( () => {}
            ),
            Ue(this, Wh, "f").catch( () => {}
            )
        }
        static fromReadableStream(e) {
            const t = new Zw;
            return t._run( () => t._fromReadableStream(e)),
            t
        }
        static createMessage(e, t, r) {
            const s = new Zw;
            for (const i of t.messages)
                s._addPromptCachingBetaMessageParam(i);
            return s._run( () => s._createPromptCachingBetaMessage(e, {
                ...t,
                stream: !0
            }, {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "stream"
                }
            })),
            s
        }
        _run(e) {
            e().then( () => {
                this._emitFinal(),
                this._emit("end")
            }
            , Ue(this, pE, "f"))
        }
        _addPromptCachingBetaMessageParam(e) {
            this.messages.push(e)
        }
        _addPromptCachingBetaMessage(e, t=!0) {
            this.receivedMessages.push(e),
            t && this._emit("message", e)
        }
        async _createPromptCachingBetaMessage(e, t, r) {
            var a;
            const s = r == null ? void 0 : r.signal;
            s && (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort())),
            Ue(this, wn, "m", mE).call(this);
            const i = await e.create({
                ...t,
                stream: !0
            }, {
                ...r,
                signal: this.controller.signal
            });
            this._connected();
            for await(const c of i)
                Ue(this, wn, "m", gE).call(this, c);
            if ((a = i.controller.signal) != null && a.aborted)
                throw new zn;
            Ue(this, wn, "m", yE).call(this)
        }
        _connected() {
            this.ended || (Ue(this, zw, "f").call(this),
            this._emit("connect"))
        }
        get ended() {
            return Ue(this, Vh, "f")
        }
        get errored() {
            return Ue(this, Gw, "f")
        }
        get aborted() {
            return Ue(this, Jw, "f")
        }
        abort() {
            this.controller.abort()
        }
        on(e, t) {
            return (Ue(this, Gs, "f")[e] || (Ue(this, Gs, "f")[e] = [])).push({
                listener: t
            }),
            this
        }
        off(e, t) {
            const r = Ue(this, Gs, "f")[e];
            if (!r)
                return this;
            const s = r.findIndex(i => i.listener === t);
            return s >= 0 && r.splice(s, 1),
            this
        }
        once(e, t) {
            return (Ue(this, Gs, "f")[e] || (Ue(this, Gs, "f")[e] = [])).push({
                listener: t,
                once: !0
            }),
            this
        }
        emitted(e) {
            return new Promise( (t, r) => {
                Br(this, Nu, !0, "f"),
                e !== "error" && this.once("error", r),
                this.once(e, t)
            }
            )
        }
        async done() {
            Br(this, Nu, !0, "f"),
            await Ue(this, Wh, "f")
        }
        get currentMessage() {
            return Ue(this, Ji, "f")
        }
        async finalMessage() {
            return await this.done(),
            Ue(this, wn, "m", fE).call(this)
        }
        async finalText() {
            return await this.done(),
            Ue(this, wn, "m", JO).call(this)
        }
        _emit(e, ...t) {
            if (Ue(this, Vh, "f"))
                return;
            e === "end" && (Br(this, Vh, !0, "f"),
            Ue(this, Vw, "f").call(this));
            const r = Ue(this, Gs, "f")[e];
            if (r && (Ue(this, Gs, "f")[e] = r.filter(s => !s.once),
            r.forEach( ({listener: s}) => s(...t))),
            e === "abort") {
                const s = t[0];
                !Ue(this, Nu, "f") && !(r != null && r.length) && Promise.reject(s),
                Ue(this, Hh, "f").call(this, s),
                Ue(this, zh, "f").call(this, s),
                this._emit("end");
                return
            }
            if (e === "error") {
                const s = t[0];
                !Ue(this, Nu, "f") && !(r != null && r.length) && Promise.reject(s),
                Ue(this, Hh, "f").call(this, s),
                Ue(this, zh, "f").call(this, s),
                this._emit("end")
            }
        }
        _emitFinal() {
            this.receivedMessages.at(-1) && this._emit("finalPromptCachingBetaMessage", Ue(this, wn, "m", fE).call(this))
        }
        async _fromReadableStream(e, t) {
            var i;
            const r = t == null ? void 0 : t.signal;
            r && (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            Ue(this, wn, "m", mE).call(this),
            this._connected();
            const s = vs.fromReadableStream(e, this.controller);
            for await(const a of s)
                Ue(this, wn, "m", gE).call(this, a);
            if ((i = s.controller.signal) != null && i.aborted)
                throw new zn;
            Ue(this, wn, "m", yE).call(this)
        }
        [(Ji = new WeakMap,
        Ww = new WeakMap,
        zw = new WeakMap,
        Hh = new WeakMap,
        Wh = new WeakMap,
        Vw = new WeakMap,
        zh = new WeakMap,
        Gs = new WeakMap,
        Vh = new WeakMap,
        Gw = new WeakMap,
        Jw = new WeakMap,
        Nu = new WeakMap,
        pE = new WeakMap,
        wn = new WeakSet,
        fE = function() {
            if (this.receivedMessages.length === 0)
                throw new Ye("stream ended without producing a PromptCachingBetaMessage with role=assistant");
            return this.receivedMessages.at(-1)
        }
        ,
        JO = function() {
            if (this.receivedMessages.length === 0)
                throw new Ye("stream ended without producing a PromptCachingBetaMessage with role=assistant");
            const t = this.receivedMessages.at(-1).content.filter(r => r.type === "text").map(r => r.text);
            if (t.length === 0)
                throw new Ye("stream ended without producing a content block with type=text");
            return t.join(" ")
        }
        ,
        mE = function() {
            this.ended || Br(this, Ji, void 0, "f")
        }
        ,
        gE = function(t) {
            if (this.ended)
                return;
            const r = Ue(this, wn, "m", ZO).call(this, t);
            switch (this._emit("streamEvent", t, r),
            t.type) {
            case "content_block_delta":
                {
                    const s = r.content.at(-1);
                    t.delta.type === "text_delta" && s.type === "text" ? this._emit("text", t.delta.text, s.text || "") : t.delta.type === "input_json_delta" && s.type === "tool_use" && s.input && this._emit("inputJson", t.delta.partial_json, s.input);
                    break
                }
            case "message_stop":
                {
                    this._addPromptCachingBetaMessageParam(r),
                    this._addPromptCachingBetaMessage(r, !0);
                    break
                }
            case "content_block_stop":
                {
                    this._emit("contentBlock", r.content.at(-1));
                    break
                }
            case "message_start":
                {
                    Br(this, Ji, r, "f");
                    break
                }
            }
        }
        ,
        yE = function() {
            if (this.ended)
                throw new Ye("stream has ended, this shouldn't happen");
            const t = Ue(this, Ji, "f");
            if (!t)
                throw new Ye("request ended without sending any chunks");
            return Br(this, Ji, void 0, "f"),
            t
        }
        ,
        ZO = function(t) {
            let r = Ue(this, Ji, "f");
            if (t.type === "message_start") {
                if (r)
                    throw new Ye(`Unexpected event order, got ${t.type} before receiving "message_stop"`);
                return t.message
            }
            if (!r)
                throw new Ye(`Unexpected event order, got ${t.type} before "message_start"`);
            switch (t.type) {
            case "message_stop":
                return r;
            case "message_delta":
                return r.stop_reason = t.delta.stop_reason,
                r.stop_sequence = t.delta.stop_sequence,
                r.usage.output_tokens = t.usage.output_tokens,
                r;
            case "content_block_start":
                return r.content.push(t.content_block),
                r;
            case "content_block_delta":
                {
                    const s = r.content.at(t.index);
                    if ((s == null ? void 0 : s.type) === "text" && t.delta.type === "text_delta")
                        s.text += t.delta.text;
                    else if ((s == null ? void 0 : s.type) === "tool_use" && t.delta.type === "input_json_delta") {
                        let i = s[XO] || "";
                        i += t.delta.partial_json,
                        Object.defineProperty(s, XO, {
                            value: i,
                            enumerable: !1,
                            writable: !0
                        }),
                        i && (s.input = GO(i))
                    }
                    return r
                }
            case "content_block_stop":
                return r
            }
        }
        ,
        Symbol.asyncIterator)]() {
            const e = []
              , t = [];
            let r = !1;
            return this.on("streamEvent", s => {
                const i = t.shift();
                i ? i.resolve(s) : e.push(s)
            }
            ),
            this.on("end", () => {
                r = !0;
                for (const s of t)
                    s.resolve(void 0);
                t.length = 0
            }
            ),
            this.on("abort", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            this.on("error", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            {
                next: async () => e.length ? {
                    value: e.shift(),
                    done: !1
                } : r ? {
                    value: void 0,
                    done: !0
                } : new Promise( (i, a) => t.push({
                    resolve: i,
                    reject: a
                })).then(i => i ? {
                    value: i,
                    done: !1
                } : {
                    value: void 0,
                    done: !0
                }),
                return: async () => (this.abort(),
                {
                    value: void 0,
                    done: !0
                })
            }
        }
        toReadableStream() {
            return new vs(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()
        }
    }
    let YO = class extends ho {
        create(e, t) {
            const {betas: r, ...s} = e;
            return this._client.post("/v1/messages?beta=prompt_caching", {
                body: s,
                timeout: this._client._options.timeout ?? 6e5,
                ...t,
                headers: {
                    "anthropic-beta": [...r ?? [], "prompt-caching-2024-07-31"].toString(),
                    ...t == null ? void 0 : t.headers
                },
                stream: e.stream ?? !1
            })
        }
        stream(e, t) {
            return Zw.createMessage(this, e, t)
        }
    }
    ;
    class wE extends ho {
        constructor() {
            super(...arguments),
            this.messages = new YO(this._client)
        }
    }
    wE.Messages = YO;
    class Xw extends ho {
        constructor() {
            super(...arguments),
            this.messages = new Hw(this._client),
            this.promptCaching = new wE(this._client)
        }
    }
    Xw.Messages = Hw,
    Xw.PromptCaching = wE;
    class QO extends ho {
        create(e, t) {
            return this._client.post("/v1/complete", {
                body: e,
                timeout: this._client._options.timeout ?? 6e5,
                ...t,
                stream: e.stream ?? !1
            })
        }
    }
    var qr = function(n, e, t, r, s) {
        if (r === "m")
            throw new TypeError("Private method is not writable");
        if (r === "a" && !s)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? n !== e || !s : !e.has(n))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return r === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t),
        t
    }, Ke = function(n, e, t, r) {
        if (t === "a" && !r)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? n !== e || !r : !e.has(n))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n)
    }, bn, Zi, Yw, Qw, Gh, Jh, eb, Zh, Js, Xh, tb, rb, $u, bE, eR, vE, _E, SE, EE, tR;
    const rR = "__json_buf";
    class nb {
        constructor() {
            bn.add(this),
            this.messages = [],
            this.receivedMessages = [],
            Zi.set(this, void 0),
            this.controller = new AbortController,
            Yw.set(this, void 0),
            Qw.set(this, () => {}
            ),
            Gh.set(this, () => {}
            ),
            Jh.set(this, void 0),
            eb.set(this, () => {}
            ),
            Zh.set(this, () => {}
            ),
            Js.set(this, {}),
            Xh.set(this, !1),
            tb.set(this, !1),
            rb.set(this, !1),
            $u.set(this, !1),
            vE.set(this, e => {
                if (qr(this, tb, !0, "f"),
                e instanceof Error && e.name === "AbortError" && (e = new zn),
                e instanceof zn)
                    return qr(this, rb, !0, "f"),
                    this._emit("abort", e);
                if (e instanceof Ye)
                    return this._emit("error", e);
                if (e instanceof Error) {
                    const t = new Ye(e.message);
                    return t.cause = e,
                    this._emit("error", t)
                }
                return this._emit("error", new Ye(String(e)))
            }
            ),
            qr(this, Yw, new Promise( (e, t) => {
                qr(this, Qw, e, "f"),
                qr(this, Gh, t, "f")
            }
            ), "f"),
            qr(this, Jh, new Promise( (e, t) => {
                qr(this, eb, e, "f"),
                qr(this, Zh, t, "f")
            }
            ), "f"),
            Ke(this, Yw, "f").catch( () => {}
            ),
            Ke(this, Jh, "f").catch( () => {}
            )
        }
        static fromReadableStream(e) {
            const t = new nb;
            return t._run( () => t._fromReadableStream(e)),
            t
        }
        static createMessage(e, t, r) {
            const s = new nb;
            for (const i of t.messages)
                s._addMessageParam(i);
            return s._run( () => s._createMessage(e, {
                ...t,
                stream: !0
            }, {
                ...r,
                headers: {
                    ...r == null ? void 0 : r.headers,
                    "X-Stainless-Helper-Method": "stream"
                }
            })),
            s
        }
        _run(e) {
            e().then( () => {
                this._emitFinal(),
                this._emit("end")
            }
            , Ke(this, vE, "f"))
        }
        _addMessageParam(e) {
            this.messages.push(e)
        }
        _addMessage(e, t=!0) {
            this.receivedMessages.push(e),
            t && this._emit("message", e)
        }
        async _createMessage(e, t, r) {
            var a;
            const s = r == null ? void 0 : r.signal;
            s && (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort())),
            Ke(this, bn, "m", _E).call(this);
            const i = await e.create({
                ...t,
                stream: !0
            }, {
                ...r,
                signal: this.controller.signal
            });
            this._connected();
            for await(const c of i)
                Ke(this, bn, "m", SE).call(this, c);
            if ((a = i.controller.signal) != null && a.aborted)
                throw new zn;
            Ke(this, bn, "m", EE).call(this)
        }
        _connected() {
            this.ended || (Ke(this, Qw, "f").call(this),
            this._emit("connect"))
        }
        get ended() {
            return Ke(this, Xh, "f")
        }
        get errored() {
            return Ke(this, tb, "f")
        }
        get aborted() {
            return Ke(this, rb, "f")
        }
        abort() {
            this.controller.abort()
        }
        on(e, t) {
            return (Ke(this, Js, "f")[e] || (Ke(this, Js, "f")[e] = [])).push({
                listener: t
            }),
            this
        }
        off(e, t) {
            const r = Ke(this, Js, "f")[e];
            if (!r)
                return this;
            const s = r.findIndex(i => i.listener === t);
            return s >= 0 && r.splice(s, 1),
            this
        }
        once(e, t) {
            return (Ke(this, Js, "f")[e] || (Ke(this, Js, "f")[e] = [])).push({
                listener: t,
                once: !0
            }),
            this
        }
        emitted(e) {
            return new Promise( (t, r) => {
                qr(this, $u, !0, "f"),
                e !== "error" && this.once("error", r),
                this.once(e, t)
            }
            )
        }
        async done() {
            qr(this, $u, !0, "f"),
            await Ke(this, Jh, "f")
        }
        get currentMessage() {
            return Ke(this, Zi, "f")
        }
        async finalMessage() {
            return await this.done(),
            Ke(this, bn, "m", bE).call(this)
        }
        async finalText() {
            return await this.done(),
            Ke(this, bn, "m", eR).call(this)
        }
        _emit(e, ...t) {
            if (Ke(this, Xh, "f"))
                return;
            e === "end" && (qr(this, Xh, !0, "f"),
            Ke(this, eb, "f").call(this));
            const r = Ke(this, Js, "f")[e];
            if (r && (Ke(this, Js, "f")[e] = r.filter(s => !s.once),
            r.forEach( ({listener: s}) => s(...t))),
            e === "abort") {
                const s = t[0];
                !Ke(this, $u, "f") && !(r != null && r.length) && Promise.reject(s),
                Ke(this, Gh, "f").call(this, s),
                Ke(this, Zh, "f").call(this, s),
                this._emit("end");
                return
            }
            if (e === "error") {
                const s = t[0];
                !Ke(this, $u, "f") && !(r != null && r.length) && Promise.reject(s),
                Ke(this, Gh, "f").call(this, s),
                Ke(this, Zh, "f").call(this, s),
                this._emit("end")
            }
        }
        _emitFinal() {
            this.receivedMessages.at(-1) && this._emit("finalMessage", Ke(this, bn, "m", bE).call(this))
        }
        async _fromReadableStream(e, t) {
            var i;
            const r = t == null ? void 0 : t.signal;
            r && (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            Ke(this, bn, "m", _E).call(this),
            this._connected();
            const s = vs.fromReadableStream(e, this.controller);
            for await(const a of s)
                Ke(this, bn, "m", SE).call(this, a);
            if ((i = s.controller.signal) != null && i.aborted)
                throw new zn;
            Ke(this, bn, "m", EE).call(this)
        }
        [(Zi = new WeakMap,
        Yw = new WeakMap,
        Qw = new WeakMap,
        Gh = new WeakMap,
        Jh = new WeakMap,
        eb = new WeakMap,
        Zh = new WeakMap,
        Js = new WeakMap,
        Xh = new WeakMap,
        tb = new WeakMap,
        rb = new WeakMap,
        $u = new WeakMap,
        vE = new WeakMap,
        bn = new WeakSet,
        bE = function() {
            if (this.receivedMessages.length === 0)
                throw new Ye("stream ended without producing a Message with role=assistant");
            return this.receivedMessages.at(-1)
        }
        ,
        eR = function() {
            if (this.receivedMessages.length === 0)
                throw new Ye("stream ended without producing a Message with role=assistant");
            const t = this.receivedMessages.at(-1).content.filter(r => r.type === "text").map(r => r.text);
            if (t.length === 0)
                throw new Ye("stream ended without producing a content block with type=text");
            return t.join(" ")
        }
        ,
        _E = function() {
            this.ended || qr(this, Zi, void 0, "f")
        }
        ,
        SE = function(t) {
            if (this.ended)
                return;
            const r = Ke(this, bn, "m", tR).call(this, t);
            switch (this._emit("streamEvent", t, r),
            t.type) {
            case "content_block_delta":
                {
                    const s = r.content.at(-1);
                    t.delta.type === "text_delta" && s.type === "text" ? this._emit("text", t.delta.text, s.text || "") : t.delta.type === "input_json_delta" && s.type === "tool_use" && s.input && this._emit("inputJson", t.delta.partial_json, s.input);
                    break
                }
            case "message_stop":
                {
                    this._addMessageParam(r),
                    this._addMessage(r, !0);
                    break
                }
            case "content_block_stop":
                {
                    this._emit("contentBlock", r.content.at(-1));
                    break
                }
            case "message_start":
                {
                    qr(this, Zi, r, "f");
                    break
                }
            }
        }
        ,
        EE = function() {
            if (this.ended)
                throw new Ye("stream has ended, this shouldn't happen");
            const t = Ke(this, Zi, "f");
            if (!t)
                throw new Ye("request ended without sending any chunks");
            return qr(this, Zi, void 0, "f"),
            t
        }
        ,
        tR = function(t) {
            let r = Ke(this, Zi, "f");
            if (t.type === "message_start") {
                if (r)
                    throw new Ye(`Unexpected event order, got ${t.type} before receiving "message_stop"`);
                return t.message
            }
            if (!r)
                throw new Ye(`Unexpected event order, got ${t.type} before "message_start"`);
            switch (t.type) {
            case "message_stop":
                return r;
            case "message_delta":
                return r.stop_reason = t.delta.stop_reason,
                r.stop_sequence = t.delta.stop_sequence,
                r.usage.output_tokens = t.usage.output_tokens,
                r;
            case "content_block_start":
                return r.content.push(t.content_block),
                r;
            case "content_block_delta":
                {
                    const s = r.content.at(t.index);
                    if ((s == null ? void 0 : s.type) === "text" && t.delta.type === "text_delta")
                        s.text += t.delta.text;
                    else if ((s == null ? void 0 : s.type) === "tool_use" && t.delta.type === "input_json_delta") {
                        let i = s[rR] || "";
                        i += t.delta.partial_json,
                        Object.defineProperty(s, rR, {
                            value: i,
                            enumerable: !1,
                            writable: !0
                        }),
                        i && (s.input = GO(i))
                    }
                    return r
                }
            case "content_block_stop":
                return r
            }
        }
        ,
        Symbol.asyncIterator)]() {
            const e = []
              , t = [];
            let r = !1;
            return this.on("streamEvent", s => {
                const i = t.shift();
                i ? i.resolve(s) : e.push(s)
            }
            ),
            this.on("end", () => {
                r = !0;
                for (const s of t)
                    s.resolve(void 0);
                t.length = 0
            }
            ),
            this.on("abort", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            this.on("error", s => {
                r = !0;
                for (const i of t)
                    i.reject(s);
                t.length = 0
            }
            ),
            {
                next: async () => e.length ? {
                    value: e.shift(),
                    done: !1
                } : r ? {
                    value: void 0,
                    done: !0
                } : new Promise( (i, a) => t.push({
                    resolve: i,
                    reject: a
                })).then(i => i ? {
                    value: i,
                    done: !1
                } : {
                    value: void 0,
                    done: !0
                }),
                return: async () => (this.abort(),
                {
                    value: void 0,
                    done: !0
                })
            }
        }
        toReadableStream() {
            return new vs(this[Symbol.asyncIterator].bind(this),this.controller).toReadableStream()
        }
    }
    class nR extends ho {
        create(e, t) {
            return e.model in sR && console.warn(`The model '${e.model}' is deprecated and will reach end-of-life on ${sR[e.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`),
            this._client.post("/v1/messages", {
                body: e,
                timeout: this._client._options.timeout ?? 6e5,
                ...t,
                stream: e.stream ?? !1
            })
        }
        stream(e, t) {
            return nb.createMessage(this, e, t)
        }
    }
    const sR = {
        "claude-1.3": "November 6th, 2024",
        "claude-1.3-100k": "November 6th, 2024",
        "claude-instant-1.1": "November 6th, 2024",
        "claude-instant-1.1-100k": "November 6th, 2024",
        "claude-instant-1.2": "November 6th, 2024"
    };
    var iR;
    class _t extends X6 {
        constructor({baseURL: e=uE("ANTHROPIC_BASE_URL"), apiKey: t=uE("ANTHROPIC_API_KEY") ?? null, authToken: r=uE("ANTHROPIC_AUTH_TOKEN") ?? null, ...s}={}) {
            const i = {
                apiKey: t,
                authToken: r,
                ...s,
                baseURL: e || "https://api.anthropic.com"
            };
            if (!i.dangerouslyAllowBrowser && uW())
                throw new Ye(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new Anthropic({ apiKey, dangerouslyAllowBrowser: true });

TODO: link!
`);
            super({
                baseURL: i.baseURL,
                timeout: i.timeout ?? 6e5,
                httpAgent: i.httpAgent,
                maxRetries: i.maxRetries,
                fetch: i.fetch
            }),
            this.completions = new QO(this),
            this.messages = new nR(this),
            this.beta = new Xw(this),
            this._options = i,
            this.apiKey = t,
            this.authToken = r
        }
        defaultQuery() {
            return this._options.defaultQuery
        }
        defaultHeaders(e) {
            return {
                ...super.defaultHeaders(e),
                ...this._options.dangerouslyAllowBrowser ? {
                    "anthropic-dangerous-direct-browser-access": "true"
                } : void 0,
                "anthropic-version": "2023-06-01",
                ...this._options.defaultHeaders
            }
        }
        validateHeaders(e, t) {
            if (!(this.apiKey && e["x-api-key"]) && t["x-api-key"] !== null && !(this.authToken && e.authorization) && t.authorization !== null)
                throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted')
        }
        authHeaders(e) {
            const t = this.apiKeyAuth(e)
              , r = this.bearerAuth(e);
            return t != null && !Kw(t) ? t : r != null && !Kw(r) ? r : {}
        }
        apiKeyAuth(e) {
            return this.apiKey == null ? {} : {
                "X-Api-Key": this.apiKey
            }
        }
        bearerAuth(e) {
            return this.authToken == null ? {} : {
                Authorization: `Bearer ${this.authToken}`
            }
        }
    }
    iR = _t,
    _t.Anthropic = iR,
    _t.HUMAN_PROMPT = `

Human:`,
    _t.AI_PROMPT = `

Assistant:`,
    _t.DEFAULT_TIMEOUT = 6e5,
    _t.AnthropicError = Ye,
    _t.APIError = fr,
    _t.APIConnectionError = jw,
    _t.APIConnectionTimeoutError = IO,
    _t.APIUserAbortError = zn,
    _t.NotFoundError = NO,
    _t.ConflictError = $O,
    _t.RateLimitError = FO,
    _t.BadRequestError = OO,
    _t.AuthenticationError = RO,
    _t.InternalServerError = jO,
    _t.PermissionDeniedError = MO,
    _t.UnprocessableEntityError = LO,
    _t.toFile = H6,
    _t.fileFromPath = AO,
    _t.Completions = QO,
    _t.Messages = nR,
    _t.Beta = Xw;
    class aR extends eE {
        static lc_name() {
            return "AnthropicToolsOutputParser"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "anthropic", "output_parsers"]
            }),
            Object.defineProperty(this, "returnId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "keyName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "returnSingle", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "zodSchema", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.keyName = e.keyName,
            this.returnSingle = e.returnSingle ?? this.returnSingle,
            this.zodSchema = e.zodSchema
        }
        async _validateResult(e) {
            let t = e;
            if (typeof e == "string")
                try {
                    t = JSON.parse(e)
                } catch (s) {
                    throw new Iu(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(s.message)}`,e)
                }
            else
                t = e;
            if (this.zodSchema === void 0)
                return t;
            const r = await this.zodSchema.safeParseAsync(t);
            if (r.success)
                return r.data;
            throw new Iu(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(r.error.errors)}`,JSON.stringify(t, null, 2))
        }
        async parseResult(e) {
            const t = e.flatMap(i => {
                const {message: a} = i;
                return Array.isArray(a.content) ? oR(a.content)[0] : []
            }
            );
            if (t[0] === void 0)
                throw new Error("No parseable tool calls provided to AnthropicToolsOutputParser.");
            const [r] = t;
            return await this._validateResult(r.args)
        }
    }
    function oR(n) {
        const e = [];
        for (const t of n)
            t.type === "tool_use" && e.push({
                name: t.name,
                args: t.input,
                id: t.id,
                type: "tool_call"
            });
        return e
    }
    function mW(n) {
        if (n)
            return n === "any" ? {
                type: "any"
            } : n === "auto" ? {
                type: "auto"
            } : typeof n == "string" ? {
                type: "tool",
                name: n
            } : n
    }
    function cR(n) {
        const e = /^data:(image\/.+);base64,(.+)$/
          , t = n.match(e);
        if (t === null)
            throw new Error(["Anthropic only supports base64-encoded images currently.", "Example: data:image/png;base64,/9j/4AAQSk..."].join(`

`));
        return {
            type: "base64",
            media_type: t[1] ?? "",
            data: t[2] ?? ""
        }
    }
    function gW(n) {
        const e = [];
        for (const t of n)
            if (t._getType() === "tool")
                if (typeof t.content == "string") {
                    const r = e[e.length - 1];
                    (r == null ? void 0 : r._getType()) === "human" && Array.isArray(r.content) && "type"in r.content[0] && r.content[0].type === "tool_result" ? r.content.push({
                        type: "tool_result",
                        content: t.content,
                        tool_use_id: t.tool_call_id
                    }) : e.push(new Ct({
                        content: [{
                            type: "tool_result",
                            content: t.content,
                            tool_use_id: t.tool_call_id
                        }]
                    }))
                } else
                    e.push(new Ct({
                        content: [{
                            type: "tool_result",
                            content: xE(t.content),
                            tool_use_id: t.tool_call_id
                        }]
                    }));
            else
                e.push(t);
        return e
    }
    function uR(n) {
        if (n.id === void 0)
            throw new Error('Anthropic requires all tool calls to have an "id".');
        return {
            type: "tool_use",
            id: n.id,
            name: n.name,
            input: n.args
        }
    }
    function xE(n) {
        const e = ["tool_use", "tool_result", "input_json_delta"]
          , t = ["text", "text_delta"];
        return typeof n == "string" ? n : n.map(s => {
            const i = "cache_control"in s ? s.cache_control : void 0;
            if (s.type === "image_url") {
                let a;
                return typeof s.image_url == "string" ? a = cR(s.image_url) : a = cR(s.image_url.url),
                {
                    type: "image",
                    source: a,
                    ...i ? {
                        cache_control: i
                    } : {}
                }
            } else {
                if (s.type === "document")
                    return {
                        type: "document",
                        source: s.source,
                        ...i ? {
                            cache_control: i
                        } : {}
                    };
                if (t.find(a => a === s.type) && "text"in s)
                    return {
                        type: "text",
                        text: s.text,
                        ...i ? {
                            cache_control: i
                        } : {}
                    };
                if (e.find(a => a === s.type)) {
                    const a = {
                        ...s
                    };
                    if ("index"in a && delete a.index,
                    a.type === "input_json_delta" && (a.type = "tool_use"),
                    "input"in a)
                        try {
                            a.input = JSON.parse(a.input)
                        } catch {}
                    return {
                        ...a,
                        ...i ? {
                            cache_control: i
                        } : {}
                    }
                } else
                    throw new Error("Unsupported message content format")
            }
        }
        )
    }
    function lR(n) {
        const e = gW(n);
        let t;
        e.length > 0 && e[0]._getType() === "system" && (t = n[0].content);
        const s = (t !== void 0 ? e.slice(1) : e).map(i => {
            var c;
            let a;
            if (i._getType() === "human")
                a = "user";
            else if (i._getType() === "ai")
                a = "assistant";
            else if (i._getType() === "tool")
                a = "user";
            else
                throw i._getType() === "system" ? new Error("System messages are only permitted as the first passed message.") : new Error(`Message type "${i._getType()}" is not supported.`);
            if (ah(i) && ((c = i.tool_calls) != null && c.length)) {
                if (typeof i.content == "string")
                    return i.content === "" ? {
                        role: a,
                        content: i.tool_calls.map(uR)
                    } : {
                        role: a,
                        content: [{
                            type: "text",
                            text: i.content
                        }, ...i.tool_calls.map(uR)]
                    };
                {
                    const {content: u} = i;
                    return !i.tool_calls.every(d => u.find(h => (h.type === "tool_use" || h.type === "input_json_delta") && h.id === d.id)) && console.warn('The "tool_calls" field on a message is only respected if content is a string.'),
                    {
                        role: a,
                        content: xE(i.content)
                    }
                }
            } else
                return {
                    role: a,
                    content: xE(i.content)
                }
        }
        );
        return {
            messages: yW(s),
            system: t
        }
    }
    function yW(n) {
        if (!n || n.length <= 1)
            return n;
        const e = [];
        let t = n[0];
        const r = i => typeof i == "string" ? [{
            type: "text",
            text: i
        }] : i
          , s = i => i.role !== "user" || typeof i.content == "string" ? !1 : Array.isArray(i.content) && i.content.every(a => a.type === "tool_result");
        for (let i = 1; i < n.length; i += 1) {
            const a = n[i];
            s(t) && s(a) ? t = {
                ...t,
                content: [...r(t.content), ...r(a.content)]
            } : (e.push(t),
            t = a)
        }
        return e.push(t),
        e
    }
    function wW(n, e) {
        var t, r;
        if (n.type === "message_start") {
            const {content: s, usage: i, ...a} = n.message
              , c = {};
            for (const [f,p] of Object.entries(a))
                p != null && (c[f] = p);
            const {input_tokens: u, output_tokens: l, ...d} = i ?? {}
              , h = {
                input_tokens: u,
                output_tokens: l,
                total_tokens: u + l,
                input_token_details: {
                    cache_creation: d.cache_creation_input_tokens,
                    cache_read: d.cache_read_input_tokens
                }
            };
            return {
                chunk: new _r({
                    content: e.coerceContentToString ? "" : [],
                    additional_kwargs: c,
                    usage_metadata: e.streamUsage ? h : void 0,
                    response_metadata: {
                        usage: {
                            ...d
                        }
                    },
                    id: n.message.id
                })
            }
        } else if (n.type === "message_delta") {
            const s = {
                input_tokens: 0,
                output_tokens: n.usage.output_tokens,
                total_tokens: n.usage.output_tokens,
                input_token_details: {
                    cache_creation: n.usage.cache_creation_input_tokens,
                    cache_read: n.usage.cache_read_input_tokens
                }
            };
            return {
                chunk: new _r({
                    content: e.coerceContentToString ? "" : [],
                    additional_kwargs: {
                        ...n.delta
                    },
                    usage_metadata: e.streamUsage ? s : void 0
                })
            }
        } else if (n.type === "content_block_start" && n.content_block.type === "tool_use") {
            const s = n.content_block;
            return {
                chunk: new _r({
                    content: e.coerceContentToString ? "" : [{
                        index: n.index,
                        ...n.content_block,
                        input: ""
                    }],
                    additional_kwargs: {},
                    tool_call_chunks: [{
                        id: s.id,
                        index: n.index,
                        name: s.name,
                        args: ""
                    }]
                })
            }
        } else if (n.type === "content_block_delta" && n.delta.type === "text_delta") {
            const s = (t = n.delta) == null ? void 0 : t.text;
            if (s !== void 0)
                return {
                    chunk: new _r({
                        content: e.coerceContentToString ? s : [{
                            index: n.index,
                            ...n.delta
                        }],
                        additional_kwargs: {}
                    })
                }
        } else {
            if (n.type === "content_block_delta" && n.delta.type === "input_json_delta")
                return {
                    chunk: new _r({
                        content: e.coerceContentToString ? "" : [{
                            index: n.index,
                            input: n.delta.partial_json,
                            type: n.delta.type
                        }],
                        additional_kwargs: {},
                        tool_call_chunks: [{
                            index: n.index,
                            args: n.delta.partial_json
                        }]
                    })
                };
            if (n.type === "content_block_start" && n.content_block.type === "text") {
                const s = (r = n.content_block) == null ? void 0 : r.text;
                if (s !== void 0)
                    return {
                        chunk: new _r({
                            content: e.coerceContentToString ? s : [{
                                index: n.index,
                                ...n.content_block
                            }],
                            additional_kwargs: {}
                        })
                    }
            }
        }
        return null
    }
    function bW(n, e) {
        const t = e.usage
          , r = t != null ? {
            input_tokens: t.input_tokens ?? 0,
            output_tokens: t.output_tokens ?? 0,
            total_tokens: (t.input_tokens ?? 0) + (t.output_tokens ?? 0),
            input_token_details: {
                cache_creation: t.cache_creation_input_tokens,
                cache_read: t.cache_read_input_tokens
            }
        } : void 0;
        if (n.length === 1 && n[0].type === "text")
            return [{
                text: n[0].text,
                message: new pn({
                    content: n[0].text,
                    additional_kwargs: e,
                    usage_metadata: r,
                    response_metadata: e,
                    id: e.id
                })
            }];
        {
            const s = oR(n);
            return [{
                text: "",
                message: new pn({
                    content: n,
                    additional_kwargs: e,
                    tool_calls: s,
                    usage_metadata: r,
                    response_metadata: e,
                    id: e.id
                })
            }]
        }
    }
    function sb(n, e) {
        return n.lc_error_code = e,
        n.message = `${n.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`,
        n
    }
    function dR(n) {
        let e;
        return n.status === 400 && n.message.includes("tool") ? e = sb(n, "INVALID_TOOL_RESULTS") : n.status === 401 ? e = sb(n, "MODEL_AUTHENTICATION") : n.status === 404 ? e = sb(n, "MODEL_NOT_FOUND") : n.status === 429 ? e = sb(n, "MODEL_RATE_LIMIT") : e = n,
        e
    }
    function vW(n) {
        return !!(n.tools && n.tools.length > 0)
    }
    function _W(n) {
        return "input_schema"in n
    }
    function SW(n) {
        if (typeof n.content == "string")
            return n.content;
        if (Array.isArray(n.content) && n.content.length >= 1 && "input"in n.content[0])
            return typeof n.content[0].input == "string" ? n.content[0].input : JSON.stringify(n.content[0].input);
        if (Array.isArray(n.content) && n.content.length >= 1 && "text"in n.content[0])
            return n.content[0].text
    }
    class EW extends bs {
        static lc_name() {
            return "ChatAnthropic"
        }
        get lc_secrets() {
            return {
                anthropicApiKey: "ANTHROPIC_API_KEY",
                apiKey: "ANTHROPIC_API_KEY"
            }
        }
        get lc_aliases() {
            return {
                modelName: "model"
            }
        }
        constructor(e) {
            if (super(e ?? {}),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "anthropicApiKey", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "apiKey", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "apiUrl", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "temperature", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 1
            }),
            Object.defineProperty(this, "topK", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -1
            }),
            Object.defineProperty(this, "topP", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: -1
            }),
            Object.defineProperty(this, "maxTokens", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: 2048
            }),
            Object.defineProperty(this, "modelName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "claude-2.1"
            }),
            Object.defineProperty(this, "model", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "claude-2.1"
            }),
            Object.defineProperty(this, "invocationKwargs", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "stopSequences", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "streaming", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "clientOptions", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "batchClient", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "streamingClient", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "streamUsage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "createClient", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.anthropicApiKey = (e == null ? void 0 : e.apiKey) ?? (e == null ? void 0 : e.anthropicApiKey) ?? mn("ANTHROPIC_API_KEY"),
            !this.anthropicApiKey && !(e != null && e.createClient))
                throw new Error("Anthropic API key not found");
            this.clientOptions = (e == null ? void 0 : e.clientOptions) ?? {},
            this.apiKey = this.anthropicApiKey,
            this.apiUrl = e == null ? void 0 : e.anthropicApiUrl,
            this.modelName = (e == null ? void 0 : e.model) ?? (e == null ? void 0 : e.modelName) ?? this.model,
            this.model = this.modelName,
            this.invocationKwargs = (e == null ? void 0 : e.invocationKwargs) ?? {},
            this.temperature = (e == null ? void 0 : e.temperature) ?? this.temperature,
            this.topK = (e == null ? void 0 : e.topK) ?? this.topK,
            this.topP = (e == null ? void 0 : e.topP) ?? this.topP,
            this.maxTokens = (e == null ? void 0 : e.maxTokensToSample) ?? (e == null ? void 0 : e.maxTokens) ?? this.maxTokens,
            this.stopSequences = (e == null ? void 0 : e.stopSequences) ?? this.stopSequences,
            this.streaming = (e == null ? void 0 : e.streaming) ?? !1,
            this.streamUsage = (e == null ? void 0 : e.streamUsage) ?? this.streamUsage,
            this.createClient = (e == null ? void 0 : e.createClient) ?? (t => new _t(t))
        }
        getLsParams(e) {
            const t = this.invocationParams(e);
            return {
                ls_provider: "anthropic",
                ls_model_name: this.model,
                ls_model_type: "chat",
                ls_temperature: t.temperature ?? void 0,
                ls_max_tokens: t.max_tokens ?? void 0,
                ls_stop: e.stop
            }
        }
        formatStructuredToolToAnthropic(e) {
            if (!(!e || !e.length))
                return e.map(t => {
                    if (_W(t))
                        return t;
                    if (Ow(t))
                        return {
                            name: t.function.name,
                            description: t.function.description,
                            input_schema: t.function.parameters
                        };
                    if (Nw(t))
                        return {
                            name: t.name,
                            description: t.description,
                            input_schema: Ui(t.schema)
                        };
                    throw new Error(`Unknown tool type passed to ChatAnthropic: ${JSON.stringify(t, null, 2)}`)
                }
                )
        }
        bindTools(e, t) {
            return this.bind({
                tools: this.formatStructuredToolToAnthropic(e),
                ...t
            })
        }
        invocationParams(e) {
            const t = mW(e == null ? void 0 : e.tool_choice);
            return {
                model: this.model,
                temperature: this.temperature,
                top_k: this.topK,
                top_p: this.topP,
                stop_sequences: (e == null ? void 0 : e.stop) ?? this.stopSequences,
                stream: this.streaming,
                max_tokens: this.maxTokens,
                tools: this.formatStructuredToolToAnthropic(e == null ? void 0 : e.tools),
                tool_choice: t,
                ...this.invocationKwargs
            }
        }
        _identifyingParams() {
            return {
                model_name: this.model,
                ...this.invocationParams()
            }
        }
        identifyingParams() {
            return {
                model_name: this.model,
                ...this.invocationParams()
            }
        }
        async*_streamResponseChunks(e, t, r) {
            var u;
            const s = this.invocationParams(t)
              , i = lR(e)
              , a = !vW({
                ...s,
                ...i,
                stream: !1
            })
              , c = await this.createStreamWithRetry({
                ...s,
                ...i,
                stream: !0
            }, {
                headers: t.headers
            });
            for await(const l of c) {
                if ((u = t.signal) != null && u.aborted)
                    throw c.controller.abort(),
                    new Error("AbortError: User aborted the request.");
                const d = this.streamUsage ?? t.streamUsage
                  , h = wW(l, {
                    streamUsage: d,
                    coerceContentToString: a
                });
                if (!h)
                    continue;
                const {chunk: f} = h
                  , p = SW(f)
                  , g = new qi({
                    message: new _r({
                        content: f.content,
                        additional_kwargs: f.additional_kwargs,
                        tool_call_chunks: f.tool_call_chunks,
                        usage_metadata: d ? f.usage_metadata : void 0,
                        response_metadata: f.response_metadata,
                        id: f.id
                    }),
                    text: p ?? ""
                });
                yield g,
                await (r == null ? void 0 : r.handleLLMNewToken(p ?? "", void 0, void 0, void 0, void 0, {
                    chunk: g
                }))
            }
        }
        async _generateNonStreaming(e, t, r) {
            const s = await this.completionWithRetry({
                ...t,
                stream: !1,
                ...lR(e)
            }, r)
              , {content: i, ...a} = s
              , c = bW(i, a)
              , {role: u, type: l, ...d} = a;
            return {
                generations: c,
                llmOutput: d
            }
        }
        async _generate(e, t, r) {
            if (this.stopSequences && t.stop)
                throw new Error('"stopSequence" parameter found in input and default params');
            const s = this.invocationParams(t);
            if (s.stream) {
                let i;
                const a = this._streamResponseChunks(e, t, r);
                for await(const c of a)
                    i === void 0 ? i = c : i = i.concat(c);
                if (i === void 0)
                    throw new Error("No chunks returned from Anthropic API.");
                return {
                    generations: [{
                        text: i.text,
                        message: i.message
                    }]
                }
            } else
                return this._generateNonStreaming(e, s, {
                    signal: t.signal,
                    headers: t.headers
                })
        }
        async createStreamWithRetry(e, t) {
            if (!this.streamingClient) {
                const s = this.apiUrl ? {
                    baseURL: this.apiUrl
                } : void 0;
                this.streamingClient = this.createClient({
                    dangerouslyAllowBrowser: !0,
                    ...this.clientOptions,
                    ...s,
                    apiKey: this.apiKey,
                    maxRetries: 0
                })
            }
            const r = async () => {
                try {
                    return await this.streamingClient.messages.create({
                        ...e,
                        ...this.invocationKwargs,
                        stream: !0
                    }, t)
                } catch (s) {
                    throw dR(s)
                }
            }
            ;
            return this.caller.call(r)
        }
        async completionWithRetry(e, t) {
            if (!this.batchClient) {
                const s = this.apiUrl ? {
                    baseURL: this.apiUrl
                } : void 0;
                this.batchClient = this.createClient({
                    dangerouslyAllowBrowser: !0,
                    ...this.clientOptions,
                    ...s,
                    apiKey: this.apiKey,
                    maxRetries: 0
                })
            }
            const r = async () => {
                try {
                    return await this.batchClient.messages.create({
                        ...e,
                        ...this.invocationKwargs
                    }, t)
                } catch (s) {
                    throw dR(s)
                }
            }
            ;
            return this.caller.callWithOptions({
                signal: t.signal ?? void 0
            }, r)
        }
        _llmType() {
            return "anthropic"
        }
        withStructuredOutput(e, t) {
            const r = e
              , s = t == null ? void 0 : t.name
              , i = t == null ? void 0 : t.method
              , a = t == null ? void 0 : t.includeRaw;
            if (i === "jsonMode")
                throw new Error('Anthropic only supports "functionCalling" as a method.');
            let c = s ?? "extract", u, l;
            if (Rw(r)) {
                const g = Ui(r);
                l = [{
                    name: c,
                    description: g.description ?? "A function available to call.",
                    input_schema: g
                }],
                u = new aR({
                    returnSingle: !0,
                    keyName: c,
                    zodSchema: r
                })
            } else {
                let g;
                typeof r.name == "string" && typeof r.description == "string" && typeof r.input_schema == "object" && r.input_schema != null ? (g = r,
                c = r.name) : g = {
                    name: c,
                    description: r.description ?? "",
                    input_schema: r
                },
                l = [g],
                u = new aR({
                    returnSingle: !0,
                    keyName: c
                })
            }
            const d = this.bind({
                tools: l,
                tool_choice: {
                    type: "tool",
                    name: c
                }
            });
            if (!a)
                return d.pipe(u).withConfig({
                    runName: "ChatAnthropicStructuredOutput"
                });
            const h = Vi.assign({
                parsed: (g, y) => u.invoke(g.raw, y)
            })
              , f = Vi.assign({
                parsed: () => null
            })
              , p = h.withFallbacks({
                fallbacks: [f]
            });
            return Fn.from([{
                raw: d
            }, p]).withConfig({
                runName: "StructuredOutputRunnable"
            })
        }
    }
    class xW extends EW {
    }
    var hR;
    (function(n) {
        n.STRING = "string",
        n.NUMBER = "number",
        n.INTEGER = "integer",
        n.BOOLEAN = "boolean",
        n.ARRAY = "array",
        n.OBJECT = "object"
    }
    )(hR || (hR = {}));
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    var fR;
    (function(n) {
        n.LANGUAGE_UNSPECIFIED = "language_unspecified",
        n.PYTHON = "python"
    }
    )(fR || (fR = {}));
    var pR;
    (function(n) {
        n.OUTCOME_UNSPECIFIED = "outcome_unspecified",
        n.OUTCOME_OK = "outcome_ok",
        n.OUTCOME_FAILED = "outcome_failed",
        n.OUTCOME_DEADLINE_EXCEEDED = "outcome_deadline_exceeded"
    }
    )(pR || (pR = {}));
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const mR = ["user", "model", "function", "system"];
    var gR;
    (function(n) {
        n.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED",
        n.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH",
        n.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        n.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT",
        n.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT"
    }
    )(gR || (gR = {}));
    var yR;
    (function(n) {
        n.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
        n.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE",
        n.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE",
        n.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH",
        n.BLOCK_NONE = "BLOCK_NONE"
    }
    )(yR || (yR = {}));
    var wR;
    (function(n) {
        n.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED",
        n.NEGLIGIBLE = "NEGLIGIBLE",
        n.LOW = "LOW",
        n.MEDIUM = "MEDIUM",
        n.HIGH = "HIGH"
    }
    )(wR || (wR = {}));
    var bR;
    (function(n) {
        n.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED",
        n.SAFETY = "SAFETY",
        n.OTHER = "OTHER"
    }
    )(bR || (bR = {}));
    var Yh;
    (function(n) {
        n.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED",
        n.STOP = "STOP",
        n.MAX_TOKENS = "MAX_TOKENS",
        n.SAFETY = "SAFETY",
        n.RECITATION = "RECITATION",
        n.LANGUAGE = "LANGUAGE",
        n.OTHER = "OTHER"
    }
    )(Yh || (Yh = {}));
    var vR;
    (function(n) {
        n.TASK_TYPE_UNSPECIFIED = "TASK_TYPE_UNSPECIFIED",
        n.RETRIEVAL_QUERY = "RETRIEVAL_QUERY",
        n.RETRIEVAL_DOCUMENT = "RETRIEVAL_DOCUMENT",
        n.SEMANTIC_SIMILARITY = "SEMANTIC_SIMILARITY",
        n.CLASSIFICATION = "CLASSIFICATION",
        n.CLUSTERING = "CLUSTERING"
    }
    )(vR || (vR = {}));
    var Lu;
    (function(n) {
        n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
        n.AUTO = "AUTO",
        n.ANY = "ANY",
        n.NONE = "NONE"
    }
    )(Lu || (Lu = {}));
    var _R;
    (function(n) {
        n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED",
        n.MODE_DYNAMIC = "MODE_DYNAMIC"
    }
    )(_R || (_R = {}));
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class Ur extends Error {
        constructor(e) {
            super(`[GoogleGenerativeAI Error]: ${e}`)
        }
    }
    class Fu extends Ur {
        constructor(e, t) {
            super(e),
            this.response = t
        }
    }
    class SR extends Ur {
        constructor(e, t, r, s) {
            super(e),
            this.status = t,
            this.statusText = r,
            this.errorDetails = s
        }
    }
    class Xi extends Ur {
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const CW = "https://generativelanguage.googleapis.com"
      , kW = "v1beta"
      , PW = "0.21.0"
      , TW = "genai-js";
    var fo;
    (function(n) {
        n.GENERATE_CONTENT = "generateContent",
        n.STREAM_GENERATE_CONTENT = "streamGenerateContent",
        n.COUNT_TOKENS = "countTokens",
        n.EMBED_CONTENT = "embedContent",
        n.BATCH_EMBED_CONTENTS = "batchEmbedContents"
    }
    )(fo || (fo = {}));
    class AW {
        constructor(e, t, r, s, i) {
            this.model = e,
            this.task = t,
            this.apiKey = r,
            this.stream = s,
            this.requestOptions = i
        }
        toString() {
            var e, t;
            const r = ((e = this.requestOptions) === null || e === void 0 ? void 0 : e.apiVersion) || kW;
            let i = `${((t = this.requestOptions) === null || t === void 0 ? void 0 : t.baseUrl) || CW}/${r}/${this.model}:${this.task}`;
            return this.stream && (i += "?alt=sse"),
            i
        }
    }
    function IW(n) {
        const e = [];
        return n != null && n.apiClient && e.push(n.apiClient),
        e.push(`${TW}/${PW}`),
        e.join(" ")
    }
    async function OW(n) {
        var e;
        const t = new Headers;
        t.append("Content-Type", "application/json"),
        t.append("x-goog-api-client", IW(n.requestOptions)),
        t.append("x-goog-api-key", n.apiKey);
        let r = (e = n.requestOptions) === null || e === void 0 ? void 0 : e.customHeaders;
        if (r) {
            if (!(r instanceof Headers))
                try {
                    r = new Headers(r)
                } catch (s) {
                    throw new Xi(`unable to convert customHeaders value ${JSON.stringify(r)} to Headers: ${s.message}`)
                }
            for (const [s,i] of r.entries()) {
                if (s === "x-goog-api-key")
                    throw new Xi(`Cannot set reserved header name ${s}`);
                if (s === "x-goog-api-client")
                    throw new Xi(`Header name ${s} can only be set using the apiClient field`);
                t.append(s, i)
            }
        }
        return t
    }
    async function RW(n, e, t, r, s, i) {
        const a = new AW(n,e,t,r,i);
        return {
            url: a.toString(),
            fetchOptions: Object.assign(Object.assign({}, LW(i)), {
                method: "POST",
                headers: await OW(a),
                body: s
            })
        }
    }
    async function Qh(n, e, t, r, s, i={}, a=fetch) {
        const {url: c, fetchOptions: u} = await RW(n, e, t, r, s, i);
        return MW(c, u, a)
    }
    async function MW(n, e, t=fetch) {
        let r;
        try {
            r = await t(n, e)
        } catch (s) {
            NW(s, n)
        }
        return r.ok || await $W(r, n),
        r
    }
    function NW(n, e) {
        let t = n;
        throw n instanceof SR || n instanceof Xi || (t = new Ur(`Error fetching from ${e.toString()}: ${n.message}`),
        t.stack = n.stack),
        t
    }
    async function $W(n, e) {
        let t = "", r;
        try {
            const s = await n.json();
            t = s.error.message,
            s.error.details && (t += ` ${JSON.stringify(s.error.details)}`,
            r = s.error.details)
        } catch {}
        throw new SR(`Error fetching from ${e.toString()}: [${n.status} ${n.statusText}] ${t}`,n.status,n.statusText,r)
    }
    function LW(n) {
        const e = {};
        if ((n == null ? void 0 : n.signal) !== void 0 || (n == null ? void 0 : n.timeout) >= 0) {
            const t = new AbortController;
            (n == null ? void 0 : n.timeout) >= 0 && setTimeout( () => t.abort(), n.timeout),
            n != null && n.signal && n.signal.addEventListener("abort", () => {
                t.abort()
            }
            ),
            e.signal = t.signal
        }
        return e
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function CE(n) {
        return n.text = () => {
            if (n.candidates && n.candidates.length > 0) {
                if (n.candidates.length > 1 && console.warn(`This response had ${n.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`),
                ib(n.candidates[0]))
                    throw new Fu(`${Yi(n)}`,n);
                return FW(n)
            } else if (n.promptFeedback)
                throw new Fu(`Text not available. ${Yi(n)}`,n);
            return ""
        }
        ,
        n.functionCall = () => {
            if (n.candidates && n.candidates.length > 0) {
                if (n.candidates.length > 1 && console.warn(`This response had ${n.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`),
                ib(n.candidates[0]))
                    throw new Fu(`${Yi(n)}`,n);
                return console.warn("response.functionCall() is deprecated. Use response.functionCalls() instead."),
                ER(n)[0]
            } else if (n.promptFeedback)
                throw new Fu(`Function call not available. ${Yi(n)}`,n)
        }
        ,
        n.functionCalls = () => {
            if (n.candidates && n.candidates.length > 0) {
                if (n.candidates.length > 1 && console.warn(`This response had ${n.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`),
                ib(n.candidates[0]))
                    throw new Fu(`${Yi(n)}`,n);
                return ER(n)
            } else if (n.promptFeedback)
                throw new Fu(`Function call not available. ${Yi(n)}`,n)
        }
        ,
        n
    }
    function FW(n) {
        var e, t, r, s;
        const i = [];
        if (!((t = (e = n.candidates) === null || e === void 0 ? void 0 : e[0].content) === null || t === void 0) && t.parts)
            for (const a of (s = (r = n.candidates) === null || r === void 0 ? void 0 : r[0].content) === null || s === void 0 ? void 0 : s.parts)
                a.text && i.push(a.text),
                a.executableCode && i.push("\n```" + a.executableCode.language + `
` + a.executableCode.code + "\n```\n"),
                a.codeExecutionResult && i.push("\n```\n" + a.codeExecutionResult.output + "\n```\n");
        return i.length > 0 ? i.join("") : ""
    }
    function ER(n) {
        var e, t, r, s;
        const i = [];
        if (!((t = (e = n.candidates) === null || e === void 0 ? void 0 : e[0].content) === null || t === void 0) && t.parts)
            for (const a of (s = (r = n.candidates) === null || r === void 0 ? void 0 : r[0].content) === null || s === void 0 ? void 0 : s.parts)
                a.functionCall && i.push(a.functionCall);
        if (i.length > 0)
            return i
    }
    const jW = [Yh.RECITATION, Yh.SAFETY, Yh.LANGUAGE];
    function ib(n) {
        return !!n.finishReason && jW.includes(n.finishReason)
    }
    function Yi(n) {
        var e, t, r;
        let s = "";
        if ((!n.candidates || n.candidates.length === 0) && n.promptFeedback)
            s += "Response was blocked",
            !((e = n.promptFeedback) === null || e === void 0) && e.blockReason && (s += ` due to ${n.promptFeedback.blockReason}`),
            !((t = n.promptFeedback) === null || t === void 0) && t.blockReasonMessage && (s += `: ${n.promptFeedback.blockReasonMessage}`);
        else if (!((r = n.candidates) === null || r === void 0) && r[0]) {
            const i = n.candidates[0];
            ib(i) && (s += `Candidate was blocked due to ${i.finishReason}`,
            i.finishMessage && (s += `: ${i.finishMessage}`))
        }
        return s
    }
    function ef(n) {
        return this instanceof ef ? (this.v = n,
        this) : new ef(n)
    }
    function DW(n, e, t) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var r = t.apply(n, e || []), s, i = [];
        return s = {},
        a("next"),
        a("throw"),
        a("return"),
        s[Symbol.asyncIterator] = function() {
            return this
        }
        ,
        s;
        function a(f) {
            r[f] && (s[f] = function(p) {
                return new Promise(function(g, y) {
                    i.push([f, p, g, y]) > 1 || c(f, p)
                }
                )
            }
            )
        }
        function c(f, p) {
            try {
                u(r[f](p))
            } catch (g) {
                h(i[0][3], g)
            }
        }
        function u(f) {
            f.value instanceof ef ? Promise.resolve(f.value.v).then(l, d) : h(i[0][2], f)
        }
        function l(f) {
            c("next", f)
        }
        function d(f) {
            c("throw", f)
        }
        function h(f, p) {
            f(p),
            i.shift(),
            i.length && c(i[0][0], i[0][1])
        }
    }
    typeof SuppressedError == "function" && SuppressedError;
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const xR = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
    function BW(n) {
        const e = n.body.pipeThrough(new TextDecoderStream("utf8",{
            fatal: !0
        }))
          , t = KW(e)
          , [r,s] = t.tee();
        return {
            stream: UW(r),
            response: qW(s)
        }
    }
    async function qW(n) {
        const e = []
          , t = n.getReader();
        for (; ; ) {
            const {done: r, value: s} = await t.read();
            if (r)
                return CE(HW(e));
            e.push(s)
        }
    }
    function UW(n) {
        return DW(this, arguments, function*() {
            const t = n.getReader();
            for (; ; ) {
                const {value: r, done: s} = yield ef(t.read());
                if (s)
                    break;
                yield yield ef(CE(r))
            }
        })
    }
    function KW(n) {
        const e = n.getReader();
        return new ReadableStream({
            start(r) {
                let s = "";
                return i();
                function i() {
                    return e.read().then( ({value: a, done: c}) => {
                        if (c) {
                            if (s.trim()) {
                                r.error(new Ur("Failed to parse stream"));
                                return
                            }
                            r.close();
                            return
                        }
                        s += a;
                        let u = s.match(xR), l;
                        for (; u; ) {
                            try {
                                l = JSON.parse(u[1])
                            } catch {
                                r.error(new Ur(`Error parsing JSON response: "${u[1]}"`));
                                return
                            }
                            r.enqueue(l),
                            s = s.substring(u[0].length),
                            u = s.match(xR)
                        }
                        return i()
                    }
                    )
                }
            }
        })
    }
    function HW(n) {
        const e = n[n.length - 1]
          , t = {
            promptFeedback: e == null ? void 0 : e.promptFeedback
        };
        for (const r of n) {
            if (r.candidates)
                for (const s of r.candidates) {
                    const i = s.index;
                    if (t.candidates || (t.candidates = []),
                    t.candidates[i] || (t.candidates[i] = {
                        index: s.index
                    }),
                    t.candidates[i].citationMetadata = s.citationMetadata,
                    t.candidates[i].groundingMetadata = s.groundingMetadata,
                    t.candidates[i].finishReason = s.finishReason,
                    t.candidates[i].finishMessage = s.finishMessage,
                    t.candidates[i].safetyRatings = s.safetyRatings,
                    s.content && s.content.parts) {
                        t.candidates[i].content || (t.candidates[i].content = {
                            role: s.content.role || "user",
                            parts: []
                        });
                        const a = {};
                        for (const c of s.content.parts)
                            c.text && (a.text = c.text),
                            c.functionCall && (a.functionCall = c.functionCall),
                            c.executableCode && (a.executableCode = c.executableCode),
                            c.codeExecutionResult && (a.codeExecutionResult = c.codeExecutionResult),
                            Object.keys(a).length === 0 && (a.text = ""),
                            t.candidates[i].content.parts.push(a)
                    }
                }
            r.usageMetadata && (t.usageMetadata = r.usageMetadata)
        }
        return t
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    async function CR(n, e, t, r) {
        const s = await Qh(e, fo.STREAM_GENERATE_CONTENT, n, !0, JSON.stringify(t), r);
        return BW(s)
    }
    async function kR(n, e, t, r) {
        const i = await (await Qh(e, fo.GENERATE_CONTENT, n, !1, JSON.stringify(t), r)).json();
        return {
            response: CE(i)
        }
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    function PR(n) {
        if (n != null) {
            if (typeof n == "string")
                return {
                    role: "system",
                    parts: [{
                        text: n
                    }]
                };
            if (n.text)
                return {
                    role: "system",
                    parts: [n]
                };
            if (n.parts)
                return n.role ? n : {
                    role: "system",
                    parts: n.parts
                }
        }
    }
    function tf(n) {
        let e = [];
        if (typeof n == "string")
            e = [{
                text: n
            }];
        else
            for (const t of n)
                typeof t == "string" ? e.push({
                    text: t
                }) : e.push(t);
        return WW(e)
    }
    function WW(n) {
        const e = {
            role: "user",
            parts: []
        }
          , t = {
            role: "function",
            parts: []
        };
        let r = !1
          , s = !1;
        for (const i of n)
            "functionResponse"in i ? (t.parts.push(i),
            s = !0) : (e.parts.push(i),
            r = !0);
        if (r && s)
            throw new Ur("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
        if (!r && !s)
            throw new Ur("No content is provided for sending chat message.");
        return r ? e : t
    }
    function zW(n, e) {
        var t;
        let r = {
            model: e == null ? void 0 : e.model,
            generationConfig: e == null ? void 0 : e.generationConfig,
            safetySettings: e == null ? void 0 : e.safetySettings,
            tools: e == null ? void 0 : e.tools,
            toolConfig: e == null ? void 0 : e.toolConfig,
            systemInstruction: e == null ? void 0 : e.systemInstruction,
            cachedContent: (t = e == null ? void 0 : e.cachedContent) === null || t === void 0 ? void 0 : t.name,
            contents: []
        };
        const s = n.generateContentRequest != null;
        if (n.contents) {
            if (s)
                throw new Xi("CountTokensRequest must have one of contents or generateContentRequest, not both.");
            r.contents = n.contents
        } else if (s)
            r = Object.assign(Object.assign({}, r), n.generateContentRequest);
        else {
            const i = tf(n);
            r.contents = [i]
        }
        return {
            generateContentRequest: r
        }
    }
    function TR(n) {
        let e;
        return n.contents ? e = n : e = {
            contents: [tf(n)]
        },
        n.systemInstruction && (e.systemInstruction = PR(n.systemInstruction)),
        e
    }
    function VW(n) {
        return typeof n == "string" || Array.isArray(n) ? {
            content: tf(n)
        } : n
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const AR = ["text", "inlineData", "functionCall", "functionResponse", "executableCode", "codeExecutionResult"]
      , GW = {
        user: ["text", "inlineData"],
        function: ["functionResponse"],
        model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
        system: ["text"]
    };
    function JW(n) {
        let e = !1;
        for (const t of n) {
            const {role: r, parts: s} = t;
            if (!e && r !== "user")
                throw new Ur(`First content should be with role 'user', got ${r}`);
            if (!mR.includes(r))
                throw new Ur(`Each item should include role field. Got ${r} but valid roles are: ${JSON.stringify(mR)}`);
            if (!Array.isArray(s))
                throw new Ur("Content should have 'parts' property with an array of Parts");
            if (s.length === 0)
                throw new Ur("Each Content should have at least one part");
            const i = {
                text: 0,
                inlineData: 0,
                functionCall: 0,
                functionResponse: 0,
                fileData: 0,
                executableCode: 0,
                codeExecutionResult: 0
            };
            for (const c of s)
                for (const u of AR)
                    u in c && (i[u] += 1);
            const a = GW[r];
            for (const c of AR)
                if (!a.includes(c) && i[c] > 0)
                    throw new Ur(`Content with role '${r}' can't contain '${c}' part`);
            e = !0
        }
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    const IR = "SILENT_ERROR";
    class ZW {
        constructor(e, t, r, s={}) {
            this.model = t,
            this.params = r,
            this._requestOptions = s,
            this._history = [],
            this._sendPromise = Promise.resolve(),
            this._apiKey = e,
            r != null && r.history && (JW(r.history),
            this._history = r.history)
        }
        async getHistory() {
            return await this._sendPromise,
            this._history
        }
        async sendMessage(e, t={}) {
            var r, s, i, a, c, u;
            await this._sendPromise;
            const l = tf(e)
              , d = {
                safetySettings: (r = this.params) === null || r === void 0 ? void 0 : r.safetySettings,
                generationConfig: (s = this.params) === null || s === void 0 ? void 0 : s.generationConfig,
                tools: (i = this.params) === null || i === void 0 ? void 0 : i.tools,
                toolConfig: (a = this.params) === null || a === void 0 ? void 0 : a.toolConfig,
                systemInstruction: (c = this.params) === null || c === void 0 ? void 0 : c.systemInstruction,
                cachedContent: (u = this.params) === null || u === void 0 ? void 0 : u.cachedContent,
                contents: [...this._history, l]
            }
              , h = Object.assign(Object.assign({}, this._requestOptions), t);
            let f;
            return this._sendPromise = this._sendPromise.then( () => kR(this._apiKey, this.model, d, h)).then(p => {
                var g;
                if (p.response.candidates && p.response.candidates.length > 0) {
                    this._history.push(l);
                    const y = Object.assign({
                        parts: [],
                        role: "model"
                    }, (g = p.response.candidates) === null || g === void 0 ? void 0 : g[0].content);
                    this._history.push(y)
                } else {
                    const y = Yi(p.response);
                    y && console.warn(`sendMessage() was unsuccessful. ${y}. Inspect response object for details.`)
                }
                f = p
            }
            ),
            await this._sendPromise,
            f
        }
        async sendMessageStream(e, t={}) {
            var r, s, i, a, c, u;
            await this._sendPromise;
            const l = tf(e)
              , d = {
                safetySettings: (r = this.params) === null || r === void 0 ? void 0 : r.safetySettings,
                generationConfig: (s = this.params) === null || s === void 0 ? void 0 : s.generationConfig,
                tools: (i = this.params) === null || i === void 0 ? void 0 : i.tools,
                toolConfig: (a = this.params) === null || a === void 0 ? void 0 : a.toolConfig,
                systemInstruction: (c = this.params) === null || c === void 0 ? void 0 : c.systemInstruction,
                cachedContent: (u = this.params) === null || u === void 0 ? void 0 : u.cachedContent,
                contents: [...this._history, l]
            }
              , h = Object.assign(Object.assign({}, this._requestOptions), t)
              , f = CR(this._apiKey, this.model, d, h);
            return this._sendPromise = this._sendPromise.then( () => f).catch(p => {
                throw new Error(IR)
            }
            ).then(p => p.response).then(p => {
                if (p.candidates && p.candidates.length > 0) {
                    this._history.push(l);
                    const g = Object.assign({}, p.candidates[0].content);
                    g.role || (g.role = "model"),
                    this._history.push(g)
                } else {
                    const g = Yi(p);
                    g && console.warn(`sendMessageStream() was unsuccessful. ${g}. Inspect response object for details.`)
                }
            }
            ).catch(p => {
                p.message !== IR && console.error(p)
            }
            ),
            f
        }
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    async function XW(n, e, t, r) {
        return (await Qh(e, fo.COUNT_TOKENS, n, !1, JSON.stringify(t), r)).json()
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    async function YW(n, e, t, r) {
        return (await Qh(e, fo.EMBED_CONTENT, n, !1, JSON.stringify(t), r)).json()
    }
    async function QW(n, e, t, r) {
        const s = t.requests.map(a => Object.assign(Object.assign({}, a), {
            model: e
        }));
        return (await Qh(e, fo.BATCH_EMBED_CONTENTS, n, !1, JSON.stringify({
            requests: s
        }), r)).json()
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class OR {
        constructor(e, t, r={}) {
            this.apiKey = e,
            this._requestOptions = r,
            t.model.includes("/") ? this.model = t.model : this.model = `models/${t.model}`,
            this.generationConfig = t.generationConfig || {},
            this.safetySettings = t.safetySettings || [],
            this.tools = t.tools,
            this.toolConfig = t.toolConfig,
            this.systemInstruction = PR(t.systemInstruction),
            this.cachedContent = t.cachedContent
        }
        async generateContent(e, t={}) {
            var r;
            const s = TR(e)
              , i = Object.assign(Object.assign({}, this._requestOptions), t);
            return kR(this.apiKey, this.model, Object.assign({
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent: (r = this.cachedContent) === null || r === void 0 ? void 0 : r.name
            }, s), i)
        }
        async generateContentStream(e, t={}) {
            var r;
            const s = TR(e)
              , i = Object.assign(Object.assign({}, this._requestOptions), t);
            return CR(this.apiKey, this.model, Object.assign({
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent: (r = this.cachedContent) === null || r === void 0 ? void 0 : r.name
            }, s), i)
        }
        startChat(e) {
            var t;
            return new ZW(this.apiKey,this.model,Object.assign({
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent: (t = this.cachedContent) === null || t === void 0 ? void 0 : t.name
            }, e),this._requestOptions)
        }
        async countTokens(e, t={}) {
            const r = zW(e, {
                model: this.model,
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent: this.cachedContent
            })
              , s = Object.assign(Object.assign({}, this._requestOptions), t);
            return XW(this.apiKey, this.model, r, s)
        }
        async embedContent(e, t={}) {
            const r = VW(e)
              , s = Object.assign(Object.assign({}, this._requestOptions), t);
            return YW(this.apiKey, this.model, r, s)
        }
        async batchEmbedContents(e, t={}) {
            const r = Object.assign(Object.assign({}, this._requestOptions), t);
            return QW(this.apiKey, this.model, e, r)
        }
    }
    /**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
    class RR {
        constructor(e) {
            this.apiKey = e
        }
        getGenerativeModel(e, t) {
            if (!e.model)
                throw new Ur("Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })");
            return new OR(this.apiKey,e,t)
        }
        getGenerativeModelFromCachedContent(e, t, r) {
            if (!e.name)
                throw new Xi("Cached content must contain a `name` field.");
            if (!e.model)
                throw new Xi("Cached content must contain a `model` field.");
            const s = ["model", "systemInstruction"];
            for (const a of s)
                if (t != null && t[a] && e[a] && (t == null ? void 0 : t[a]) !== e[a]) {
                    if (a === "model") {
                        const c = t.model.startsWith("models/") ? t.model.replace("models/", "") : t.model
                          , u = e.model.startsWith("models/") ? e.model.replace("models/", "") : e.model;
                        if (c === u)
                            continue
                    }
                    throw new Xi(`Different value for "${a}" specified in modelParams (${t[a]}) and cachedContent (${e[a]})`)
                }
            const i = Object.assign(Object.assign({}, t), {
                model: e.model,
                tools: e.tools,
                toolConfig: e.toolConfig,
                systemInstruction: e.systemInstruction,
                cachedContent: e
            });
            return new OR(this.apiKey,i,r)
        }
    }
    function rf(n) {
        if (typeof n == "object" && n !== null) {
            const e = {
                ...n
            };
            "additionalProperties"in e && delete e.additionalProperties,
            "$schema"in e && delete e.$schema;
            for (const t in e)
                t in e && (Array.isArray(e[t]) ? e[t] = e[t].map(rf) : typeof e[t] == "object" && e[t] !== null && (e[t] = rf(e[t])));
            return e
        }
        return n
    }
    function MR(n) {
        const e = rf(Ui(n))
          , {$schema: t, ...r} = e;
        return r
    }
    function ez(n) {
        const e = rf(n)
          , {$schema: t, ...r} = e;
        return r
    }
    function tz(n) {
        const e = n._getType();
        return su.isInstance(n) ? n.role : e === "tool" ? e : n.name ?? e
    }
    function rz(n) {
        switch (n) {
        case "ai":
        case "model":
            return "model";
        case "system":
            return "system";
        case "human":
            return "user";
        case "tool":
        case "function":
            return "function";
        default:
            throw new Error(`Unknown / unsupported author: ${n}`)
        }
    }
    function nz(n) {
        if ("mimeType"in n && "data"in n)
            return {
                inlineData: {
                    mimeType: n.mimeType,
                    data: n.data
                }
            };
        if ("mimeType"in n && "fileUri"in n)
            return {
                fileData: {
                    mimeType: n.mimeType,
                    fileUri: n.fileUri
                }
            };
        throw new Error("Invalid media content")
    }
    function sz(n, e) {
        if (typeof n.content == "string" && n.content !== "")
            return [{
                text: n.content
            }];
        let t = []
          , r = []
          , s = [];
        return "tool_calls"in n && Array.isArray(n.tool_calls) && n.tool_calls.length > 0 ? t = n.tool_calls.map(i => ({
            functionCall: {
                name: i.name,
                args: i.args
            }
        })) : n.getType() === "tool" && n.name && n.content ? r = [{
            functionResponse: {
                name: n.name,
                response: n.content
            }
        }] : Array.isArray(n.content) && (s = n.content.map(i => {
            var a;
            if (i.type === "text")
                return {
                    text: i.text
                };
            if (i.type === "executableCode")
                return {
                    executableCode: i.executableCode
                };
            if (i.type === "codeExecutionResult")
                return {
                    codeExecutionResult: i.codeExecutionResult
                };
            if (i.type === "image_url") {
                if (!e)
                    throw new Error("This model does not support images");
                let c;
                if (typeof i.image_url == "string")
                    c = i.image_url;
                else if (typeof i.image_url == "object" && "url"in i.image_url)
                    c = i.image_url.url;
                else
                    throw new Error("Please provide image as base64 encoded data URL");
                const [u,l] = c.split(",");
                if (!u.startsWith("data:"))
                    throw new Error("Please provide image as base64 encoded data URL");
                const [d,h] = u.replace(/^data:/, "").split(";");
                if (h !== "base64")
                    throw new Error("Please provide image as base64 encoded data URL");
                return {
                    inlineData: {
                        data: l,
                        mimeType: d
                    }
                }
            } else {
                if (i.type === "media")
                    return nz(i);
                if (i.type === "tool_use")
                    return {
                        functionCall: {
                            name: i.name,
                            args: i.input
                        }
                    };
                if ((a = i.type) != null && a.includes("/") && i.type.split("/").length === 2 && "data"in i && typeof i.data == "string")
                    return {
                        inlineData: {
                            mimeType: i.type,
                            data: i.data
                        }
                    }
            }
            throw new Error(`Unknown content type ${i.type}`)
        }
        )),
        [...s, ...t, ...r]
    }
    function NR(n, e, t=!1) {
        return n.reduce( (r, s, i) => {
            if (!ih(s))
                throw new Error("Unsupported message input");
            const a = tz(s);
            if (a === "system" && i !== 0)
                throw new Error("System message should be the first one");
            const c = rz(a)
              , u = r.content[r.content.length];
            if (!r.mergeWithPreviousContent && u && u.role === c)
                throw new Error("Google Generative AI requires alternate messages between authors");
            const l = sz(s, e);
            if (r.mergeWithPreviousContent) {
                const f = r.content[r.content.length - 1];
                if (!f)
                    throw new Error("There was a problem parsing your system message. Please try a prompt without one.");
                return f.parts.push(...l),
                {
                    mergeWithPreviousContent: !1,
                    content: r.content
                }
            }
            let d = c;
            (d === "function" || d === "system" && !t) && (d = "user");
            const h = {
                role: d,
                parts: l
            };
            return {
                mergeWithPreviousContent: a === "system" && !t,
                content: [...r.content, h]
            }
        }
        , {
            content: [],
            mergeWithPreviousContent: !1
        }).content
    }
    function iz(n, e) {
        if (!n.candidates || n.candidates.length === 0 || !n.candidates[0])
            return {
                generations: [],
                llmOutput: {
                    filters: n.promptFeedback
                }
            };
        const t = n.functionCalls()
          , [r] = n.candidates
          , {content: s, ...i} = r;
        let a;
        (s == null ? void 0 : s.parts.length) === 1 && s.parts[0].text ? a = s.parts[0].text : a = s.parts.map(l => "text"in l ? {
            type: "text",
            text: l.text
        } : "executableCode"in l ? {
            type: "executableCode",
            executableCode: l.executableCode
        } : "codeExecutionResult"in l ? {
            type: "codeExecutionResult",
            codeExecutionResult: l.codeExecutionResult
        } : l);
        let c = "";
        return typeof a == "string" ? c = a : "text"in a[0] && (c = a[0].text),
        {
            generations: [{
                text: c,
                message: new pn({
                    content: a,
                    tool_calls: t == null ? void 0 : t.map(l => ({
                        ...l,
                        type: "tool_call"
                    })),
                    additional_kwargs: {
                        ...i
                    },
                    usage_metadata: e == null ? void 0 : e.usageMetadata
                }),
                generationInfo: i
            }]
        }
    }
    function az(n, e) {
        if (!n.candidates || n.candidates.length === 0)
            return null;
        const t = n.functionCalls()
          , [r] = n.candidates
          , {content: s, ...i} = r;
        let a;
        s != null && s.parts && s.parts.every(l => "text"in l) ? a = s.parts.map(l => l.text).join("") : s.parts && (a = s.parts.map(l => "text"in l ? {
            type: "text",
            text: l.text
        } : "executableCode"in l ? {
            type: "executableCode",
            executableCode: l.executableCode
        } : "codeExecutionResult"in l ? {
            type: "codeExecutionResult",
            codeExecutionResult: l.codeExecutionResult
        } : l));
        let c = "";
        a && typeof a == "string" ? c = a : a && typeof a == "object" && "text"in a[0] && (c = a[0].text);
        const u = [];
        return t && u.push(...t.map(l => ({
            ...l,
            args: JSON.stringify(l.args),
            index: e.index,
            type: "tool_call_chunk"
        }))),
        new qi({
            text: c,
            message: new _r({
                content: a || "",
                name: s ? s.role : void 0,
                tool_call_chunks: u,
                additional_kwargs: {},
                usage_metadata: e.usageMetadata
            }),
            generationInfo: i
        })
    }
    function oz(n) {
        return n.every(e => "functionDeclarations"in e && Array.isArray(e.functionDeclarations)) ? n : [{
            functionDeclarations: n.map(e => {
                if (Nw(e)) {
                    const t = MR(e.schema);
                    return {
                        name: e.name,
                        description: e.description,
                        parameters: t
                    }
                }
                return Ow(e) ? {
                    name: e.function.name,
                    description: e.function.description ?? "A function available to call.",
                    parameters: ez(e.function.parameters)
                } : e
            }
            )
        }]
    }
    class $R extends eE {
        static lc_name() {
            return "GoogleGenerativeAIToolsOutputParser"
        }
        constructor(e) {
            super(e),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "google_genai", "output_parsers"]
            }),
            Object.defineProperty(this, "returnId", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "keyName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "returnSingle", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "zodSchema", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.keyName = e.keyName,
            this.returnSingle = e.returnSingle ?? this.returnSingle,
            this.zodSchema = e.zodSchema
        }
        async _validateResult(e) {
            if (this.zodSchema === void 0)
                return e;
            const t = await this.zodSchema.safeParseAsync(e);
            if (t.success)
                return t.data;
            throw new Iu(`Failed to parse. Text: "${JSON.stringify(e, null, 2)}". Error: ${JSON.stringify(t.error.errors)}`,JSON.stringify(e, null, 2))
        }
        async parseResult(e) {
            const t = e.flatMap(i => {
                const {message: a} = i;
                return !("tool_calls"in a) || !Array.isArray(a.tool_calls) ? [] : a.tool_calls
            }
            );
            if (t[0] === void 0)
                throw new Error("No parseable tool calls provided to GoogleGenerativeAIToolsOutputParser.");
            const [r] = t;
            return await this._validateResult(r.args)
        }
    }
    function LR(n, e) {
        const t = cz(n)
          , r = lz(t, e);
        return {
            tools: t,
            toolConfig: r
        }
    }
    function cz(n) {
        let e = [];
        const t = [];
        return n.forEach(s => {
            if (Nw(s)) {
                const [i] = oz([s]);
                i.functionDeclarations && e.push(...i.functionDeclarations)
            } else if (Ow(s)) {
                const {functionDeclarations: i} = uz(s);
                if (i)
                    e.push(...i);
                else
                    throw new Error("Failed to convert OpenAI structured tool to GenerativeAI tool")
            } else
                t.push(s)
        }
        ),
        t.find(s => "functionDeclarations"in s) ? t.map(s => {
            if ((e == null ? void 0 : e.length) > 0 && "functionDeclarations"in s) {
                const i = {
                    functionDeclarations: [...s.functionDeclarations || [], ...e]
                };
                return e = [],
                i
            }
            return s
        }
        ) : [...t, ...e.length > 0 ? [{
            functionDeclarations: e
        }] : []]
    }
    function uz(n) {
        return {
            functionDeclarations: [{
                name: n.function.name,
                description: n.function.description,
                parameters: rf(n.function.parameters)
            }]
        }
    }
    function lz(n, e) {
        if (!n.length || !e)
            return;
        const {toolChoice: t, allowedFunctionNames: r} = e
          , s = {
            any: Lu.ANY,
            auto: Lu.AUTO,
            none: Lu.NONE
        };
        if (t && ["any", "auto", "none"].includes(t))
            return {
                functionCallingConfig: {
                    mode: s[t] ?? "MODE_UNSPECIFIED",
                    allowedFunctionNames: r
                }
            };
        if (typeof t == "string" || r)
            return {
                functionCallingConfig: {
                    mode: Lu.ANY,
                    allowedFunctionNames: [...r ?? [], ...t && typeof t == "string" ? [t] : []]
                }
            }
    }
    class dz extends bs {
        static lc_name() {
            return "ChatGoogleGenerativeAI"
        }
        get lc_secrets() {
            return {
                apiKey: "GOOGLE_API_KEY"
            }
        }
        get lc_aliases() {
            return {
                apiKey: "google_api_key"
            }
        }
        get _isMultimodalModel() {
            return this.model.includes("vision") || this.model.startsWith("gemini-1.5") || this.model.startsWith("gemini-2")
        }
        constructor(e) {
            var t, r;
            if (super(e ?? {}),
            Object.defineProperty(this, "lc_serializable", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "lc_namespace", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: ["langchain", "chat_models", "google_genai"]
            }),
            Object.defineProperty(this, "modelName", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "gemini-pro"
            }),
            Object.defineProperty(this, "model", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: "gemini-pro"
            }),
            Object.defineProperty(this, "temperature", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "maxOutputTokens", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "topP", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "topK", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "stopSequences", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: []
            }),
            Object.defineProperty(this, "safetySettings", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "apiKey", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "streaming", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !1
            }),
            Object.defineProperty(this, "streamUsage", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: !0
            }),
            Object.defineProperty(this, "convertSystemMessageToHumanContent", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            Object.defineProperty(this, "client", {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            }),
            this.modelName = ((t = e == null ? void 0 : e.model) == null ? void 0 : t.replace(/^models\//, "")) ?? ((r = e == null ? void 0 : e.modelName) == null ? void 0 : r.replace(/^models\//, "")) ?? this.model,
            this.model = this.modelName,
            this.maxOutputTokens = (e == null ? void 0 : e.maxOutputTokens) ?? this.maxOutputTokens,
            this.maxOutputTokens && this.maxOutputTokens < 0)
                throw new Error("`maxOutputTokens` must be a positive integer");
            if (this.temperature = (e == null ? void 0 : e.temperature) ?? this.temperature,
            this.temperature && (this.temperature < 0 || this.temperature > 2))
                throw new Error("`temperature` must be in the range of [0.0,2.0]");
            if (this.topP = (e == null ? void 0 : e.topP) ?? this.topP,
            this.topP && this.topP < 0)
                throw new Error("`topP` must be a positive integer");
            if (this.topP && this.topP > 1)
                throw new Error("`topP` must be below 1.");
            if (this.topK = (e == null ? void 0 : e.topK) ?? this.topK,
            this.topK && this.topK < 0)
                throw new Error("`topK` must be a positive integer");
            if (this.stopSequences = (e == null ? void 0 : e.stopSequences) ?? this.stopSequences,
            this.apiKey = (e == null ? void 0 : e.apiKey) ?? mn("GOOGLE_API_KEY"),
            !this.apiKey)
                throw new Error("Please set an API key for Google GenerativeAI in the environment variable GOOGLE_API_KEY or in the `apiKey` field of the ChatGoogleGenerativeAI constructor");
            if (this.safetySettings = (e == null ? void 0 : e.safetySettings) ?? this.safetySettings,
            this.safetySettings && this.safetySettings.length > 0 && new Set(this.safetySettings.map(i => i.category)).size !== this.safetySettings.length)
                throw new Error("The categories in `safetySettings` array must be unique");
            this.streaming = (e == null ? void 0 : e.streaming) ?? this.streaming,
            this.client = new RR(this.apiKey).getGenerativeModel({
                model: this.model,
                safetySettings: this.safetySettings,
                generationConfig: {
                    candidateCount: 1,
                    stopSequences: this.stopSequences,
                    maxOutputTokens: this.maxOutputTokens,
                    temperature: this.temperature,
                    topP: this.topP,
                    topK: this.topK,
                    ...e != null && e.json ? {
                        responseMimeType: "application/json"
                    } : {}
                }
            }, {
                apiVersion: e == null ? void 0 : e.apiVersion,
                baseUrl: e == null ? void 0 : e.baseUrl
            }),
            this.streamUsage = (e == null ? void 0 : e.streamUsage) ?? this.streamUsage
        }
        useCachedContent(e, t, r) {
            this.apiKey && (this.client = new RR(this.apiKey).getGenerativeModelFromCachedContent(e, t, r))
        }
        get useSystemInstruction() {
            return typeof this.convertSystemMessageToHumanContent == "boolean" ? !this.convertSystemMessageToHumanContent : this.computeUseSystemInstruction
        }
        get computeUseSystemInstruction() {
            return this.modelName === "gemini-1.0-pro-001" || this.modelName.startsWith("gemini-pro-vision") || this.modelName.startsWith("gemini-1.0-pro-vision") ? !1 : this.modelName !== "gemini-pro"
        }
        getLsParams(e) {
            return {
                ls_provider: "google_genai",
                ls_model_name: this.model,
                ls_model_type: "chat",
                ls_temperature: this.client.generationConfig.temperature,
                ls_max_tokens: this.client.generationConfig.maxOutputTokens,
                ls_stop: e.stop
            }
        }
        _combineLLMOutput() {
            return []
        }
        _llmType() {
            return "googlegenerativeai"
        }
        bindTools(e, t) {
            var r;
            return this.bind({
                tools: (r = LR(e)) == null ? void 0 : r.tools,
                ...t
            })
        }
        invocationParams(e) {
            var r;
            const t = (r = e == null ? void 0 : e.tools) != null && r.length ? LR(e.tools, {
                toolChoice: e.tool_choice,
                allowedFunctionNames: e.allowedFunctionNames
            }) : void 0;
            return {
                ...t != null && t.tools ? {
                    tools: t.tools
                } : {},
                ...t != null && t.toolConfig ? {
                    toolConfig: t.toolConfig
                } : {}
            }
        }
        async _generate(e, t, r) {
            var d;
            const s = NR(e, this._isMultimodalModel, this.useSystemInstruction);
            let i = s;
            if (s[0].role === "system") {
                const [h] = s;
                this.client.systemInstruction = h,
                i = s.slice(1)
            }
            const a = this.invocationParams(t);
            if (this.streaming) {
                const h = {}
                  , f = this._streamResponseChunks(e, t, r)
                  , p = {};
                for await(const y of f) {
                    const m = ((d = y.generationInfo) == null ? void 0 : d.completion) ?? 0;
                    p[m] === void 0 ? p[m] = y : p[m] = p[m].concat(y)
                }
                return {
                    generations: Object.entries(p).sort( ([y], [m]) => parseInt(y, 10) - parseInt(m, 10)).map( ([y,m]) => m),
                    llmOutput: {
                        estimatedTokenUsage: h
                    }
                }
            }
            const c = await this.completionWithRetry({
                ...a,
                contents: i
            });
            let u;
            if ("usageMetadata"in c.response) {
                const h = c.response.usageMetadata;
                u = {
                    input_tokens: h.promptTokenCount ?? 0,
                    output_tokens: h.candidatesTokenCount ?? 0,
                    total_tokens: h.totalTokenCount ?? 0
                }
            }
            const l = iz(c.response, {
                usageMetadata: u
            });
            return await (r == null ? void 0 : r.handleLLMNewToken(l.generations[0].text ?? "")),
            l
        }
        async*_streamResponseChunks(e, t, r) {
            const s = NR(e, this._isMultimodalModel, this.useSystemInstruction);
            let i = s;
            if (s[0].role === "system") {
                const [h] = s;
                this.client.systemInstruction = h,
                i = s.slice(1)
            }
            const c = {
                ...this.invocationParams(t),
                contents: i
            }
              , u = await this.caller.callWithOptions({
                signal: t == null ? void 0 : t.signal
            }, async () => {
                const {stream: h} = await this.client.generateContentStream(c);
                return h
            }
            );
            let l, d = 0;
            for await(const h of u) {
                if ("usageMetadata"in h && this.streamUsage !== !1 && t.streamUsage !== !1) {
                    const p = h.usageMetadata;
                    if (!l)
                        l = {
                            input_tokens: p.promptTokenCount ?? 0,
                            output_tokens: p.candidatesTokenCount ?? 0,
                            total_tokens: p.totalTokenCount ?? 0
                        };
                    else {
                        const g = (p.candidatesTokenCount ?? 0) - l.output_tokens;
                        l = {
                            input_tokens: 0,
                            output_tokens: g,
                            total_tokens: g
                        }
                    }
                }
                const f = az(h, {
                    usageMetadata: l,
                    index: d
                });
                d += 1,
                f && (yield f,
                await (r == null ? void 0 : r.handleLLMNewToken(f.text ?? "")))
            }
        }
        async completionWithRetry(e, t) {
            return this.caller.callWithOptions({
                signal: t == null ? void 0 : t.signal
            }, async () => {
                var r;
                try {
                    return await this.client.generateContent(e)
                } catch (s) {
                    throw (r = s.message) != null && r.includes("400 Bad Request") && (s.status = 400),
                    s
                }
            }
            )
        }
        withStructuredOutput(e, t) {
            const r = e
              , s = t == null ? void 0 : t.name
              , i = t == null ? void 0 : t.method
              , a = t == null ? void 0 : t.includeRaw;
            if (i === "jsonMode")
                throw new Error('ChatGoogleGenerativeAI only supports "functionCalling" as a method.');
            let c = s ?? "extract", u, l;
            if (Rw(r)) {
                const g = MR(r);
                l = [{
                    functionDeclarations: [{
                        name: c,
                        description: g.description ?? "A function available to call.",
                        parameters: g
                    }]
                }],
                u = new $R({
                    returnSingle: !0,
                    keyName: c,
                    zodSchema: r
                })
            } else {
                let g;
                typeof r.name == "string" && typeof r.parameters == "object" && r.parameters != null ? (g = r,
                c = r.name) : g = {
                    name: c,
                    description: r.description ?? "",
                    parameters: r
                },
                l = [{
                    functionDeclarations: [g]
                }],
                u = new $R({
                    returnSingle: !0,
                    keyName: c
                })
            }
            const d = this.bind({
                tools: l,
                tool_choice: c
            });
            if (!a)
                return d.pipe(u).withConfig({
                    runName: "ChatGoogleGenerativeAIStructuredOutput"
                });
            const h = Vi.assign({
                parsed: (g, y) => u.invoke(g.raw, y)
            })
              , f = Vi.assign({
                parsed: () => null
            })
              , p = h.withFallbacks({
                fallbacks: [f]
            });
            return Fn.from([{
                raw: d
            }, p]).withConfig({
                runName: "StructuredOutputRunnable"
            })
        }
    }
    function kE(n, e, t, r) {
        let a = 0
          , c = .001;
        switch (e) {
        case jg.OpenAI:
            {
                n === Ci.Planner && (a = .02);
                const u = {
                    model: r,
                    apiKey: t.apiKey,
                    configuration: {}
                };
                return t.baseUrl && (u.configuration = {
                    baseURL: t.baseUrl
                }),
                r.startsWith("o") ? u.modelKwargs = {
                    max_completion_tokens: 5e3
                } : (u.topP = c,
                u.temperature = a,
                u.maxTokens = 2e3),
                new R6(u)
            }
        case jg.Anthropic:
            {
                a = .1,
                c = .1;
                const u = {
                    model: r,
                    apiKey: t.apiKey,
                    maxTokens: 2e3,
                    temperature: a,
                    topP: c,
                    clientOptions: {}
                };
                return t.baseUrl && (u.clientOptions = {
                    baseURL: t.baseUrl
                }),
                new xW(u)
            }
        case jg.Gemini:
            {
                a = .5,
                c = .8;
                const u = {
                    model: r,
                    apiKey: t.apiKey,
                    temperature: a,
                    topP: c
                };
                return new dz(u)
            }
        default:
            throw new Error(`Provider ${e} not supported yet`)
        }
    }
    const Qi = kn("background")
      , ab = new Iq({});
    let pr = null
      , ob = null;
    chrome.sidePanel.setPanelBehavior({
        openPanelOnActionClick: !0
    }).catch(n => console.error(n));
    async function hz(n) {
        var e;
        try {
            return ((e = (await chrome.scripting.executeScript({
                target: {
                    tabId: n
                },
                func: () => Object.prototype.hasOwnProperty.call(window, "buildDomTree")
            }))[0]) == null ? void 0 : e.result) || !1
        } catch (t) {
            return console.error("Failed to check script injection status:", t),
            !1
        }
    }
    async function fz(n) {
        try {
            if (await hz(n)) {
                console.log("Scripts already injected, skipping...");
                return
            }
            await chrome.scripting.executeScript({
                target: {
                    tabId: n
                },
                files: ["buildDomTree.js"]
            }),
            console.log("Scripts successfully injected")
        } catch (e) {
            console.error("Failed to inject scripts:", e)
        }
    }
    chrome.tabs.onUpdated.addListener(async (n, e, t) => {
        var r;
        n && e.status === "complete" && ((r = t.url) != null && r.startsWith("http")) && await fz(n)
    }
    ),
    chrome.debugger.onDetach.addListener(async (n, e) => {
        console.log("Debugger detached:", n, e),
        e === "canceled_by_user" && n.tabId && await ab.cleanup()
    }
    ),
    chrome.tabs.onRemoved.addListener(n => {
        ab.removeAttachedPage(n)
    }
    ),
    Qi.info("background loaded"),
    chrome.runtime.onConnect.addListener(n => {
        n.name === "side-panel-connection" && (ob = n,
        n.onMessage.addListener(async e => {
            try {
                switch (e.type) {
                case "heartbeat":
                    n.postMessage({
                        type: "heartbeat_ack"
                    });
                    break;
                case "new_task":
                    {
                        if (!e.task)
                            return n.postMessage({
                                type: "error",
                                error: "No task provided"
                            });
                        if (!e.tabId)
                            return n.postMessage({
                                type: "error",
                                error: "No tab ID provided"
                            });
                        Qi.info("new_task", e.tabId, e.task),
                        pr = await pz(e.taskId, e.task, ab),
                        FR(pr);
                        const t = await pr.execute();
                        Qi.info("new_task execution result", e.tabId, t);
                        break
                    }
                case "follow_up_task":
                    {
                        if (!e.task)
                            return n.postMessage({
                                type: "error",
                                error: "No follow up task provided"
                            });
                        if (!e.tabId)
                            return n.postMessage({
                                type: "error",
                                error: "No tab ID provided"
                            });
                        if (Qi.info("follow_up_task", e.tabId, e.task),
                        pr) {
                            pr.addFollowUpTask(e.task),
                            FR(pr);
                            const t = await pr.execute();
                            Qi.info("follow_up_task execution result", e.tabId, t)
                        } else
                            return Qi.info("follow_up_task: executor was cleaned up, can not add follow-up task"),
                            n.postMessage({
                                type: "error",
                                error: "Executor was cleaned up, can not add follow-up task"
                            });
                        break
                    }
                case "cancel_task":
                    {
                        if (!pr)
                            return n.postMessage({
                                type: "error",
                                error: "No task to cancel"
                            });
                        await pr.cancel();
                        break
                    }
                case "screenshot":
                    {
                        if (!e.tabId)
                            return n.postMessage({
                                type: "error",
                                error: "No tab ID provided"
                            });
                        const r = await (await ab.switchTab(e.tabId)).takeScreenshot();
                        return Qi.info("screenshot", e.tabId, r),
                        n.postMessage({
                            type: "success",
                            screenshot: r
                        })
                    }
                case "resume_task":
                    return pr ? (await pr.resume(),
                    n.postMessage({
                        type: "success"
                    })) : n.postMessage({
                        type: "error",
                        error: "No task to resume"
                    });
                case "pause_task":
                    return pr ? (await pr.pause(),
                    n.postMessage({
                        type: "success"
                    })) : n.postMessage({
                        type: "error",
                        error: "No task to pause"
                    });
                default:
                    return n.postMessage({
                        type: "error",
                        error: "Unknown message type"
                    })
                }
            } catch (t) {
                console.error("Error handling port message:", t),
                n.postMessage({
                    type: "error",
                    error: t instanceof Error ? t.message : "Unknown error"
                })
            }
        }
        ),
        n.onDisconnect.addListener( () => {
            console.log("Side panel disconnected"),
            ob = null
        }
        ))
    }
    );
    async function pz(n, e, t) {
        const r = await tj.getAllProviders();
        if (Object.keys(r).length === 0)
            throw new Error("Please configure API keys in the settings first");
        const s = await cj.getAllAgentModels();
        for (const p of Object.values(s))
            if (!r[p.provider])
                throw new Error(`Provider ${p.provider} not found in the settings`);
        const i = s[Ci.Navigator];
        if (!i)
            throw new Error("Please choose a model for the navigator in the settings first");
        const a = kE(Ci.Navigator, i.provider, r[i.provider], i.modelName);
        let c = null;
        const u = s[Ci.Planner];
        u && (c = kE(Ci.Planner, u.provider, r[u.provider], u.modelName));
        let l = null;
        const d = s[Ci.Validator];
        d && (l = kE(Ci.Validator, d.provider, r[d.provider], d.modelName));
        const h = await mj.getSettings();
        return new oK(e,n,t,a,{
            plannerLLM: c ?? a,
            validatorLLM: l ?? a,
            agentOptions: {
                maxSteps: h.maxSteps,
                maxFailures: h.maxFailures,
                maxActionsPerStep: h.maxActionsPerStep,
                useVision: h.useVision,
                useVisionForPlanner: h.useVisionForPlanner,
                planningInterval: h.planningInterval
            }
        })
    }
    async function FR(n) {
        n.clearExecutionEvents(),
        n.subscribeExecutionEvents(async e => {
            try {
                ob && ob.postMessage(e)
            } catch (t) {
                Qi.error("Failed to send message to side panel:", t)
            }
            (e.state === ke.TASK_OK || e.state === ke.TASK_FAIL || e.state === ke.TASK_CANCEL) && await (pr == null ? void 0 : pr.cleanup())
        }
        )
    }
    var cb = {
        exports: {}
    }, PE, jR;
    function mz() {
        if (jR)
            return PE;
        jR = 1;
        var n = 1e3
          , e = n * 60
          , t = e * 60
          , r = t * 24
          , s = r * 7
          , i = r * 365.25;
        PE = function(d, h) {
            h = h || {};
            var f = typeof d;
            if (f === "string" && d.length > 0)
                return a(d);
            if (f === "number" && isFinite(d))
                return h.long ? u(d) : c(d);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(d))
        }
        ;
        function a(d) {
            if (d = String(d),
            !(d.length > 100)) {
                var h = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(d);
                if (h) {
                    var f = parseFloat(h[1])
                      , p = (h[2] || "ms").toLowerCase();
                    switch (p) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return f * i;
                    case "weeks":
                    case "week":
                    case "w":
                        return f * s;
                    case "days":
                    case "day":
                    case "d":
                        return f * r;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return f * t;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return f * e;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return f * n;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return f;
                    default:
                        return
                    }
                }
            }
        }
        function c(d) {
            var h = Math.abs(d);
            return h >= r ? Math.round(d / r) + "d" : h >= t ? Math.round(d / t) + "h" : h >= e ? Math.round(d / e) + "m" : h >= n ? Math.round(d / n) + "s" : d + "ms"
        }
        function u(d) {
            var h = Math.abs(d);
            return h >= r ? l(d, h, r, "day") : h >= t ? l(d, h, t, "hour") : h >= e ? l(d, h, e, "minute") : h >= n ? l(d, h, n, "second") : d + " ms"
        }
        function l(d, h, f, p) {
            var g = h >= f * 1.5;
            return Math.round(d / f) + " " + p + (g ? "s" : "")
        }
        return PE
    }
    var TE, DR;
    function gz() {
        if (DR)
            return TE;
        DR = 1;
        function n(e) {
            r.debug = r,
            r.default = r,
            r.coerce = l,
            r.disable = c,
            r.enable = i,
            r.enabled = u,
            r.humanize = mz(),
            r.destroy = d,
            Object.keys(e).forEach(h => {
                r[h] = e[h]
            }
            ),
            r.names = [],
            r.skips = [],
            r.formatters = {};
            function t(h) {
                let f = 0;
                for (let p = 0; p < h.length; p++)
                    f = (f << 5) - f + h.charCodeAt(p),
                    f |= 0;
                return r.colors[Math.abs(f) % r.colors.length]
            }
            r.selectColor = t;
            function r(h) {
                let f, p = null, g, y;
                function m(...w) {
                    if (!m.enabled)
                        return;
                    const E = m
                      , v = Number(new Date)
                      , _ = v - (f || v);
                    E.diff = _,
                    E.prev = f,
                    E.curr = v,
                    f = v,
                    w[0] = r.coerce(w[0]),
                    typeof w[0] != "string" && w.unshift("%O");
                    let A = 0;
                    w[0] = w[0].replace(/%([a-zA-Z%])/g, (k, x) => {
                        if (k === "%%")
                            return "%";
                        A++;
                        const N = r.formatters[x];
                        if (typeof N == "function") {
                            const R = w[A];
                            k = N.call(E, R),
                            w.splice(A, 1),
                            A--
                        }
                        return k
                    }
                    ),
                    r.formatArgs.call(E, w),
                    (E.log || r.log).apply(E, w)
                }
                return m.namespace = h,
                m.useColors = r.useColors(),
                m.color = r.selectColor(h),
                m.extend = s,
                m.destroy = r.destroy,
                Object.defineProperty(m, "enabled", {
                    enumerable: !0,
                    configurable: !1,
                    get: () => p !== null ? p : (g !== r.namespaces && (g = r.namespaces,
                    y = r.enabled(h)),
                    y),
                    set: w => {
                        p = w
                    }
                }),
                typeof r.init == "function" && r.init(m),
                m
            }
            function s(h, f) {
                const p = r(this.namespace + (typeof f > "u" ? ":" : f) + h);
                return p.log = this.log,
                p
            }
            function i(h) {
                r.save(h),
                r.namespaces = h,
                r.names = [],
                r.skips = [];
                const f = (typeof h == "string" ? h : "").trim().replace(" ", ",").split(",").filter(Boolean);
                for (const p of f)
                    p[0] === "-" ? r.skips.push(p.slice(1)) : r.names.push(p)
            }
            function a(h, f) {
                let p = 0
                  , g = 0
                  , y = -1
                  , m = 0;
                for (; p < h.length; )
                    if (g < f.length && (f[g] === h[p] || f[g] === "*"))
                        f[g] === "*" ? (y = g,
                        m = p,
                        g++) : (p++,
                        g++);
                    else if (y !== -1)
                        g = y + 1,
                        m++,
                        p = m;
                    else
                        return !1;
                for (; g < f.length && f[g] === "*"; )
                    g++;
                return g === f.length
            }
            function c() {
                const h = [...r.names, ...r.skips.map(f => "-" + f)].join(",");
                return r.enable(""),
                h
            }
            function u(h) {
                for (const f of r.skips)
                    if (a(h, f))
                        return !1;
                for (const f of r.names)
                    if (a(h, f))
                        return !0;
                return !1
            }
            function l(h) {
                return h instanceof Error ? h.stack || h.message : h
            }
            function d() {
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
            }
            return r.enable(r.load()),
            r
        }
        return TE = n,
        TE
    }
    var BR;
    function yz() {
        return BR || (BR = 1,
        function(n, e) {
            e.formatArgs = r,
            e.save = s,
            e.load = i,
            e.useColors = t,
            e.storage = a(),
            e.destroy = ( () => {
                let u = !1;
                return () => {
                    u || (u = !0,
                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
                }
            }
            )(),
            e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
            function t() {
                if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
                    return !0;
                if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
                    return !1;
                let u;
                return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
            }
            function r(u) {
                if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + n.exports.humanize(this.diff),
                !this.useColors)
                    return;
                const l = "color: " + this.color;
                u.splice(1, 0, l, "color: inherit");
                let d = 0
                  , h = 0;
                u[0].replace(/%[a-zA-Z%]/g, f => {
                    f !== "%%" && (d++,
                    f === "%c" && (h = d))
                }
                ),
                u.splice(h, 0, l)
            }
            e.log = console.debug || console.log || ( () => {}
            );
            function s(u) {
                try {
                    u ? e.storage.setItem("debug", u) : e.storage.removeItem("debug")
                } catch {}
            }
            function i() {
                let u;
                try {
                    u = e.storage.getItem("debug")
                } catch {}
                return !u && typeof process < "u" && "env"in process && (u = process.env.DEBUG),
                u
            }
            function a() {
                try {
                    return localStorage
                } catch {}
            }
            n.exports = gz()(e);
            const {formatters: c} = n.exports;
            c.j = function(u) {
                try {
                    return JSON.stringify(u)
                } catch (l) {
                    return "[UnexpectedJSONParseError]: " + l.message
                }
            }
        }(cb, cb.exports)),
        cb.exports
    }
    var wz = yz();
    const bz = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: De(wz)
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var AE = {}
      , nf = {}
      , po = {};
    function vz(n) {
        return {
            all: n = n || new Map,
            on: function(e, t) {
                var r = n.get(e);
                r ? r.push(t) : n.set(e, [t])
            },
            off: function(e, t) {
                var r = n.get(e);
                r && (t ? r.splice(r.indexOf(t) >>> 0, 1) : n.set(e, []))
            },
            emit: function(e, t) {
                var r = n.get(e);
                r && r.slice().map(function(s) {
                    s(t)
                }),
                (r = n.get("*")) && r.slice().map(function(s) {
                    s(e, t)
                })
            }
        }
    }
    const _z = We(Object.freeze(Object.defineProperty({
        __proto__: null,
        default: vz
    }, Symbol.toStringTag, {
        value: "Module"
    })));
    var qR;
    function ju() {
        var r, s;
        if (qR)
            return po;
        qR = 1;
        var n = po && po.__importDefault || function(i) {
            return i && i.__esModule ? i : {
                default: i
            }
        }
        ;
        Object.defineProperty(po, "__esModule", {
            value: !0
        }),
        po.EventEmitter = void 0;
        const e = n(_z);
        let t = (s = class {
            constructor() {
                b(this, r, (0,
                e.default)())
            }
            on(a, c) {
                return o(this, r).on(a, c),
                this
            }
            once(a, c) {
                const u = l => {
                    c(l),
                    this.off(a, u)
                }
                ;
                return this.on(a, u)
            }
            off(a, c) {
                return o(this, r).off(a, c),
                this
            }
            emit(a, c) {
                o(this, r).emit(a, c)
            }
            removeAllListeners(a) {
                return a ? o(this, r).all.delete(a) : o(this, r).all.clear(),
                this
            }
        }
        ,
        r = new WeakMap,
        s);
        return po.EventEmitter = t,
        po
    }
    var sf = {}, UR;
    function vn() {
        if (UR)
            return sf;
        UR = 1,
        Object.defineProperty(sf, "__esModule", {
            value: !0
        }),
        sf.LogType = void 0;
        var n;
        return function(e) {
            e.bidi = "bidi",
            e.cdp = "cdp",
            e.debug = "debug",
            e.debugError = "debug:error",
            e.debugInfo = "debug:info"
        }(n || (sf.LogType = n = {})),
        sf
    }
    var af = {}, KR;
    function Sz() {
        var r, s, i, a, c, u, oL;
        if (KR)
            return af;
        KR = 1;
        var n;
        Object.defineProperty(af, "__esModule", {
            value: !0
        }),
        af.ProcessingQueue = void 0;
        const e = vn();
        let t = (r = class {
            constructor(h, f) {
                b(this, u);
                b(this, s);
                b(this, i);
                b(this, a, []);
                b(this, c, !1);
                S(this, i, h),
                S(this, s, f)
            }
            add(h, f) {
                o(this, a).push([h, f]),
                P(this, u, oL).call(this)
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakSet,
        oL = async function() {
            var h;
            if (!o(this, c)) {
                for (S(this, c, !0); o(this, a).length > 0; ) {
                    const f = o(this, a).shift();
                    if (!f)
                        continue;
                    const [p,g] = f;
                    (h = o(this, s)) == null || h.call(this, n.LOGGER_PREFIX, "Processing event:", g),
                    await p.then(y => {
                        var m;
                        if (y.kind === "error") {
                            (m = o(this, s)) == null || m.call(this, e.LogType.debugError, "Event threw before sending:", y.error.message, y.error.stack);
                            return
                        }
                        return o(this, i).call(this, y.value)
                    }
                    ).catch(y => {
                        var m;
                        (m = o(this, s)) == null || m.call(this, e.LogType.debugError, "Event was not processed:", y == null ? void 0 : y.message)
                    }
                    )
                }
                S(this, c, !1)
            }
        }
        ,
        J(r, "LOGGER_PREFIX", `${e.LogType.debug}:queue`),
        r);
        return af.ProcessingQueue = t,
        n = t,
        af
    }
    var of = {}, Vn = {}, IE = {}, HR;
    function Ez() {
        return HR || (HR = 1,
        Object.defineProperty(IE, "__esModule", {
            value: !0
        })),
        IE
    }
    var ur = {}, WR;
    function zR() {
        if (WR)
            return ur;
        WR = 1,
        Object.defineProperty(ur, "__esModule", {
            value: !0
        }),
        ur.EVENT_NAMES = ur.Bluetooth = ur.Network = ur.BrowsingContext = ur.Log = ur.Script = ur.BiDiModule = void 0;
        var n;
        (function(a) {
            a.Bluetooth = "bluetooth",
            a.Browser = "browser",
            a.BrowsingContext = "browsingContext",
            a.Cdp = "goog:cdp",
            a.DeprecatedCdp = "cdp",
            a.Input = "input",
            a.Log = "log",
            a.Network = "network",
            a.Script = "script",
            a.Session = "session"
        }
        )(n || (ur.BiDiModule = n = {}));
        var e;
        (function(a) {
            (function(c) {
                c.Message = "script.message",
                c.RealmCreated = "script.realmCreated",
                c.RealmDestroyed = "script.realmDestroyed"
            }
            )(a.EventNames || (a.EventNames = {}))
        }
        )(e || (ur.Script = e = {}));
        var t;
        (function(a) {
            (function(c) {
                c.LogEntryAdded = "log.entryAdded"
            }
            )(a.EventNames || (a.EventNames = {}))
        }
        )(t || (ur.Log = t = {}));
        var r;
        (function(a) {
            (function(c) {
                c.ContextCreated = "browsingContext.contextCreated",
                c.ContextDestroyed = "browsingContext.contextDestroyed",
                c.DomContentLoaded = "browsingContext.domContentLoaded",
                c.DownloadWillBegin = "browsingContext.downloadWillBegin",
                c.FragmentNavigated = "browsingContext.fragmentNavigated",
                c.HistoryUpdated = "browsingContext.historyUpdated",
                c.Load = "browsingContext.load",
                c.NavigationAborted = "browsingContext.navigationAborted",
                c.NavigationFailed = "browsingContext.navigationFailed",
                c.NavigationStarted = "browsingContext.navigationStarted",
                c.UserPromptClosed = "browsingContext.userPromptClosed",
                c.UserPromptOpened = "browsingContext.userPromptOpened"
            }
            )(a.EventNames || (a.EventNames = {}))
        }
        )(r || (ur.BrowsingContext = r = {}));
        var s;
        (function(a) {
            (function(c) {
                c.AuthRequired = "network.authRequired",
                c.BeforeRequestSent = "network.beforeRequestSent",
                c.FetchError = "network.fetchError",
                c.ResponseCompleted = "network.responseCompleted",
                c.ResponseStarted = "network.responseStarted"
            }
            )(a.EventNames || (a.EventNames = {}))
        }
        )(s || (ur.Network = s = {}));
        var i;
        return function(a) {
            (function(c) {
                c.RequestDevicePromptUpdated = "bluetooth.requestDevicePromptUpdated"
            }
            )(a.EventNames || (a.EventNames = {}))
        }(i || (ur.Bluetooth = i = {})),
        ur.EVENT_NAMES = new Set([...Object.values(n), ...Object.values(r.EventNames), ...Object.values(t.EventNames), ...Object.values(s.EventNames), ...Object.values(e.EventNames)]),
        ur
    }
    var OE = {}, VR;
    function xz() {
        return VR || (VR = 1,
        Object.defineProperty(OE, "__esModule", {
            value: !0
        })),
        OE
    }
    var Se = {}, GR;
    function JR() {
        if (GR)
            return Se;
        GR = 1,
        Object.defineProperty(Se, "__esModule", {
            value: !0
        }),
        Se.NoSuchWebExtensionException = Se.InvalidWebExtensionException = Se.UnderspecifiedStoragePartitionException = Se.UnableToSetFileInputException = Se.UnableToSetCookieException = Se.NoSuchStoragePartitionException = Se.UnsupportedOperationException = Se.UnableToCloseBrowserException = Se.UnableToCaptureScreenException = Se.UnknownErrorException = Se.UnknownCommandException = Se.SessionNotCreatedException = Se.NoSuchUserContextException = Se.NoSuchScriptException = Se.NoSuchRequestException = Se.NoSuchNodeException = Se.NoSuchInterceptException = Se.NoSuchHistoryEntryException = Se.NoSuchHandleException = Se.NoSuchFrameException = Se.NoSuchElementException = Se.NoSuchAlertException = Se.MoveTargetOutOfBoundsException = Se.InvalidSessionIdException = Se.InvalidSelectorException = Se.InvalidArgumentException = Se.Exception = void 0;
        class n extends Error {
            constructor(T, L, q) {
                super();
                J(this, "error");
                J(this, "message");
                J(this, "stacktrace");
                this.error = T,
                this.message = L,
                this.stacktrace = q
            }
            toErrorResponse(T) {
                return {
                    type: "error",
                    id: T,
                    error: this.error,
                    message: this.message,
                    stacktrace: this.stacktrace
                }
            }
        }
        Se.Exception = n;
        class e extends n {
            constructor(O, T) {
                super("invalid argument", O, T)
            }
        }
        Se.InvalidArgumentException = e;
        class t extends n {
            constructor(O, T) {
                super("invalid selector", O, T)
            }
        }
        Se.InvalidSelectorException = t;
        class r extends n {
            constructor(O, T) {
                super("invalid session id", O, T)
            }
        }
        Se.InvalidSessionIdException = r;
        class s extends n {
            constructor(O, T) {
                super("move target out of bounds", O, T)
            }
        }
        Se.MoveTargetOutOfBoundsException = s;
        class i extends n {
            constructor(O, T) {
                super("no such alert", O, T)
            }
        }
        Se.NoSuchAlertException = i;
        class a extends n {
            constructor(O, T) {
                super("no such element", O, T)
            }
        }
        Se.NoSuchElementException = a;
        class c extends n {
            constructor(O, T) {
                super("no such frame", O, T)
            }
        }
        Se.NoSuchFrameException = c;
        class u extends n {
            constructor(O, T) {
                super("no such handle", O, T)
            }
        }
        Se.NoSuchHandleException = u;
        class l extends n {
            constructor(O, T) {
                super("no such history entry", O, T)
            }
        }
        Se.NoSuchHistoryEntryException = l;
        class d extends n {
            constructor(O, T) {
                super("no such intercept", O, T)
            }
        }
        Se.NoSuchInterceptException = d;
        class h extends n {
            constructor(O, T) {
                super("no such node", O, T)
            }
        }
        Se.NoSuchNodeException = h;
        class f extends n {
            constructor(O, T) {
                super("no such request", O, T)
            }
        }
        Se.NoSuchRequestException = f;
        class p extends n {
            constructor(O, T) {
                super("no such script", O, T)
            }
        }
        Se.NoSuchScriptException = p;
        class g extends n {
            constructor(O, T) {
                super("no such user context", O, T)
            }
        }
        Se.NoSuchUserContextException = g;
        class y extends n {
            constructor(O, T) {
                super("session not created", O, T)
            }
        }
        Se.SessionNotCreatedException = y;
        class m extends n {
            constructor(O, T) {
                super("unknown command", O, T)
            }
        }
        Se.UnknownCommandException = m;
        class w extends n {
            constructor(O, T=new Error().stack) {
                super("unknown error", O, T)
            }
        }
        Se.UnknownErrorException = w;
        class E extends n {
            constructor(O, T) {
                super("unable to capture screen", O, T)
            }
        }
        Se.UnableToCaptureScreenException = E;
        class v extends n {
            constructor(O, T) {
                super("unable to close browser", O, T)
            }
        }
        Se.UnableToCloseBrowserException = v;
        class _ extends n {
            constructor(O, T) {
                super("unsupported operation", O, T)
            }
        }
        Se.UnsupportedOperationException = _;
        class A extends n {
            constructor(O, T) {
                super("no such storage partition", O, T)
            }
        }
        Se.NoSuchStoragePartitionException = A;
        class C extends n {
            constructor(O, T) {
                super("unable to set cookie", O, T)
            }
        }
        Se.UnableToSetCookieException = C;
        class k extends n {
            constructor(O, T) {
                super("unable to set file input", O, T)
            }
        }
        Se.UnableToSetFileInputException = k;
        class x extends n {
            constructor(O, T) {
                super("underspecified storage partition", O, T)
            }
        }
        Se.UnderspecifiedStoragePartitionException = x;
        class N extends n {
            constructor(O, T) {
                super("invalid web extension", O, T)
            }
        }
        Se.InvalidWebExtensionException = N;
        class R extends n {
            constructor(O, T) {
                super("no such web extension", O, T)
            }
        }
        return Se.NoSuchWebExtensionException = R,
        Se
    }
    var RE = {}, ZR;
    function Cz() {
        return ZR || (ZR = 1,
        Object.defineProperty(RE, "__esModule", {
            value: !0
        })),
        RE
    }
    var ME = {}, XR;
    function kz() {
        return XR || (XR = 1,
        Object.defineProperty(ME, "__esModule", {
            value: !0
        })),
        ME
    }
    var YR;
    function mt() {
        return YR || (YR = 1,
        function(n) {
            var e = Vn && Vn.__createBinding || (Object.create ? function(i, a, c, u) {
                u === void 0 && (u = c);
                var l = Object.getOwnPropertyDescriptor(a, c);
                (!l || ("get"in l ? !a.__esModule : l.writable || l.configurable)) && (l = {
                    enumerable: !0,
                    get: function() {
                        return a[c]
                    }
                }),
                Object.defineProperty(i, u, l)
            }
            : function(i, a, c, u) {
                u === void 0 && (u = c),
                i[u] = a[c]
            }
            )
              , t = Vn && Vn.__setModuleDefault || (Object.create ? function(i, a) {
                Object.defineProperty(i, "default", {
                    enumerable: !0,
                    value: a
                })
            }
            : function(i, a) {
                i.default = a
            }
            )
              , r = Vn && Vn.__importStar || function() {
                var i = function(a) {
                    return i = Object.getOwnPropertyNames || function(c) {
                        var u = [];
                        for (var l in c)
                            Object.prototype.hasOwnProperty.call(c, l) && (u[u.length] = l);
                        return u
                    }
                    ,
                    i(a)
                };
                return function(a) {
                    if (a && a.__esModule)
                        return a;
                    var c = {};
                    if (a != null)
                        for (var u = i(a), l = 0; l < u.length; l++)
                            u[l] !== "default" && e(c, a, u[l]);
                    return t(c, a),
                    c
                }
            }()
              , s = Vn && Vn.__exportStar || function(i, a) {
                for (var c in i)
                    c !== "default" && !Object.prototype.hasOwnProperty.call(a, c) && e(a, i, c)
            }
            ;
            Object.defineProperty(n, "__esModule", {
                value: !0
            }),
            n.ChromiumBidi = n.Cdp = void 0,
            n.Cdp = r(Ez()),
            n.ChromiumBidi = r(zR()),
            s(xz(), n),
            s(JR(), n),
            s(Cz(), n),
            s(kz(), n)
        }(Vn)),
        Vn
    }
    var cf = {}, QR;
    function Pz() {
        if (QR)
            return cf;
        QR = 1,
        Object.defineProperty(cf, "__esModule", {
            value: !0
        }),
        cf.BidiNoOpParser = void 0;
        let n = class {
            parseHandleRequestDevicePromptParams(t) {
                return t
            }
            parseSimulateAdapterParameters(t) {
                return t
            }
            parseSimulateAdvertisementParameters(t) {
                return t
            }
            parseSimulatePreconnectedPeripheralParameters(t) {
                return t
            }
            parseRemoveUserContextParams(t) {
                return t
            }
            parseActivateParams(t) {
                return t
            }
            parseCaptureScreenshotParams(t) {
                return t
            }
            parseCloseParams(t) {
                return t
            }
            parseCreateParams(t) {
                return t
            }
            parseGetTreeParams(t) {
                return t
            }
            parseHandleUserPromptParams(t) {
                return t
            }
            parseLocateNodesParams(t) {
                return t
            }
            parseNavigateParams(t) {
                return t
            }
            parsePrintParams(t) {
                return t
            }
            parseReloadParams(t) {
                return t
            }
            parseSetViewportParams(t) {
                return t
            }
            parseTraverseHistoryParams(t) {
                return t
            }
            parseGetSessionParams(t) {
                return t
            }
            parseResolveRealmParams(t) {
                return t
            }
            parseSendCommandParams(t) {
                return t
            }
            parseAddPreloadScriptParams(t) {
                return t
            }
            parseCallFunctionParams(t) {
                return t
            }
            parseDisownParams(t) {
                return t
            }
            parseEvaluateParams(t) {
                return t
            }
            parseGetRealmsParams(t) {
                return t
            }
            parseRemovePreloadScriptParams(t) {
                return t
            }
            parsePerformActionsParams(t) {
                return t
            }
            parseReleaseActionsParams(t) {
                return t
            }
            parseSetFilesParams(t) {
                return t
            }
            parseAddInterceptParams(t) {
                return t
            }
            parseContinueRequestParams(t) {
                return t
            }
            parseContinueResponseParams(t) {
                return t
            }
            parseContinueWithAuthParams(t) {
                return t
            }
            parseFailRequestParams(t) {
                return t
            }
            parseProvideResponseParams(t) {
                return t
            }
            parseRemoveInterceptParams(t) {
                return t
            }
            parseSetCacheBehavior(t) {
                return t
            }
            parseSetPermissionsParams(t) {
                return t
            }
            parseSubscribeParams(t) {
                return t
            }
            parseDeleteCookiesParams(t) {
                return t
            }
            parseGetCookiesParams(t) {
                return t
            }
            parseSetCookieParams(t) {
                return t
            }
        }
        ;
        return cf.BidiNoOpParser = n,
        cf
    }
    var uf = {}, eM;
    function Tz() {
        var t, r, s, cL, a;
        if (eM)
            return uf;
        eM = 1,
        Object.defineProperty(uf, "__esModule", {
            value: !0
        }),
        uf.BrowserProcessor = void 0;
        const n = mt();
        let e = (a = class {
            constructor(u, l) {
                b(this, s);
                b(this, t);
                b(this, r);
                S(this, t, u),
                S(this, r, l)
            }
            close() {
                return setTimeout( () => o(this, t).sendCommand("Browser.close"), 0),
                {}
            }
            async createUserContext(u) {
                const l = {
                    proxyServer: u["goog:proxyServer"] ?? void 0
                }
                  , d = u["goog:proxyBypassList"] ?? void 0;
                return d && (l.proxyBypassList = d.join(",")),
                {
                    userContext: (await o(this, t).sendCommand("Target.createBrowserContext", l)).browserContextId
                }
            }
            async removeUserContext(u) {
                const l = u.userContext;
                if (l === "default")
                    throw new n.InvalidArgumentException("`default` user context cannot be removed");
                try {
                    await o(this, t).sendCommand("Target.disposeBrowserContext", {
                        browserContextId: l
                    })
                } catch (d) {
                    throw d.message.startsWith("Failed to find context with id") ? new n.NoSuchUserContextException(d.message) : d
                }
                return {}
            }
            async getUserContexts() {
                const u = await o(this, t).sendCommand("Target.getBrowserContexts");
                return {
                    userContexts: [{
                        userContext: "default"
                    }, ...u.browserContextIds.map(l => ({
                        userContext: l
                    }))]
                }
            }
            async getClientWindows() {
                const u = o(this, r).getTopLevelContexts().map(f => f.cdpTarget.id)
                  , l = await Promise.all(u.map(async f => await P(this, s, cL).call(this, f)))
                  , d = new Set
                  , h = new Array;
                for (const f of l)
                    d.has(f.clientWindow) || (d.add(f.clientWindow),
                    h.push(f));
                return {
                    clientWindows: h
                }
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        s = new WeakSet,
        cL = async function(u) {
            const l = await o(this, t).sendCommand("Browser.getWindowForTarget", {
                targetId: u
            });
            return {
                active: !1,
                clientWindow: `${l.windowId}`,
                state: l.bounds.windowState ?? "normal",
                height: l.bounds.height ?? 0,
                width: l.bounds.width ?? 0,
                x: l.bounds.left ?? 0,
                y: l.bounds.top ?? 0
            }
        }
        ,
        a);
        return uf.BrowserProcessor = e,
        uf
    }
    var lf = {}, tM;
    function Az() {
        var t, r, s, i, a;
        if (tM)
            return lf;
        tM = 1,
        Object.defineProperty(lf, "__esModule", {
            value: !0
        }),
        lf.CdpProcessor = void 0;
        const n = mt();
        let e = (a = class {
            constructor(u, l, d, h) {
                b(this, t);
                b(this, r);
                b(this, s);
                b(this, i);
                S(this, t, u),
                S(this, r, l),
                S(this, s, d),
                S(this, i, h)
            }
            getSession(u) {
                const l = u.context
                  , d = o(this, t).getContext(l).cdpTarget.cdpSessionId;
                return d === void 0 ? {} : {
                    session: d
                }
            }
            resolveRealm(u) {
                const l = u.realm
                  , d = o(this, r).getRealm({
                    realmId: l
                });
                if (d === void 0)
                    throw new n.UnknownErrorException(`Could not find realm ${u.realm}`);
                return {
                    executionContextId: d.executionContextId
                }
            }
            async sendCommand(u) {
                return {
                    result: await (u.session ? o(this, s).getCdpClient(u.session) : o(this, i)).sendCommand(u.method, u.params),
                    session: u.session
                }
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a);
        return lf.CdpProcessor = e,
        lf
    }
    var df = {}, rM;
    function Iz() {
        var t, r, s, i, uL, c;
        if (rM)
            return df;
        rM = 1,
        Object.defineProperty(df, "__esModule", {
            value: !0
        }),
        df.BrowsingContextProcessor = void 0;
        const n = mt();
        let e = (c = class {
            constructor(l, d, h) {
                b(this, i);
                b(this, t);
                b(this, r);
                b(this, s);
                S(this, t, l),
                S(this, r, d),
                S(this, s, h),
                o(this, s).addSubscribeHook(n.ChromiumBidi.BrowsingContext.EventNames.ContextCreated, P(this, i, uL).bind(this))
            }
            getTree(l) {
                return {
                    contexts: (l.root === void 0 ? o(this, r).getTopLevelContexts() : [o(this, r).getContext(l.root)]).map(h => h.serializeToBidiValue(l.maxDepth ?? Number.MAX_VALUE))
                }
            }
            async create(l) {
                let d, h = "default";
                if (l.referenceContext !== void 0) {
                    if (d = o(this, r).getContext(l.referenceContext),
                    !d.isTopLevelContext())
                        throw new n.InvalidArgumentException("referenceContext should be a top-level context");
                    h = d.userContext
                }
                l.userContext !== void 0 && (h = l.userContext);
                const f = o(this, r).getAllContexts().filter(m => m.userContext === h);
                let p = !1;
                switch (l.type) {
                case "tab":
                    p = !1;
                    break;
                case "window":
                    p = !0;
                    break
                }
                f.length || (p = !0);
                let g;
                try {
                    g = await o(this, t).sendCommand("Target.createTarget", {
                        url: "about:blank",
                        newWindow: p,
                        browserContextId: h === "default" ? void 0 : h,
                        background: l.background === !0
                    })
                } catch (m) {
                    throw m.message.startsWith("Failed to find browser context with id") || m.message === "browserContextId" ? new n.NoSuchUserContextException(`The context ${h} was not found`) : m
                }
                const y = await o(this, r).waitForContext(g.targetId);
                return await y.lifecycleLoaded(),
                {
                    context: y.id
                }
            }
            navigate(l) {
                return o(this, r).getContext(l.context).navigate(l.url, l.wait ?? "none")
            }
            reload(l) {
                return o(this, r).getContext(l.context).reload(l.ignoreCache ?? !1, l.wait ?? "none")
            }
            async activate(l) {
                const d = o(this, r).getContext(l.context);
                if (!d.isTopLevelContext())
                    throw new n.InvalidArgumentException("Activation is only supported on the top-level context");
                return await d.activate(),
                {}
            }
            async captureScreenshot(l) {
                return await o(this, r).getContext(l.context).captureScreenshot(l)
            }
            async print(l) {
                return await o(this, r).getContext(l.context).print(l)
            }
            async setViewport(l) {
                const d = o(this, r).getContext(l.context);
                if (!d.isTopLevelContext())
                    throw new n.InvalidArgumentException("Emulating viewport is only supported on the top-level context");
                return await d.setViewport(l.viewport, l.devicePixelRatio),
                {}
            }
            async traverseHistory(l) {
                const d = o(this, r).getContext(l.context);
                if (!d)
                    throw new n.InvalidArgumentException(`No browsing context with id ${l.context}`);
                if (!d.isTopLevelContext())
                    throw new n.InvalidArgumentException("Traversing history is only supported on the top-level context");
                return await d.traverseHistory(l.delta),
                {}
            }
            async handleUserPrompt(l) {
                var h;
                const d = o(this, r).getContext(l.context);
                try {
                    await d.handleUserPrompt(l.accept, l.userText)
                } catch (f) {
                    throw (h = f.message) != null && h.includes("No dialog is showing") ? new n.NoSuchAlertException("No dialog is showing") : f
                }
                return {}
            }
            async close(l) {
                const d = o(this, r).getContext(l.context);
                if (!d.isTopLevelContext())
                    throw new n.InvalidArgumentException(`Non top-level browsing context ${d.id} cannot be closed.`);
                const h = d.cdpTarget.parentCdpClient;
                try {
                    const f = new Promise(p => {
                        const g = y => {
                            y.targetId === l.context && (h.off("Target.detachedFromTarget", g),
                            p())
                        }
                        ;
                        h.on("Target.detachedFromTarget", g)
                    }
                    );
                    try {
                        l.promptUnload ? await d.close() : await h.sendCommand("Target.closeTarget", {
                            targetId: l.context
                        })
                    } catch (p) {
                        if (!h.isCloseError(p))
                            throw p
                    }
                    await f
                } catch (f) {
                    if (!(f.code === -32e3 && f.message === "Not attached to an active page"))
                        throw f
                }
                return {}
            }
            async locateNodes(l) {
                return await o(this, r).getContext(l.context).locateNodes(l)
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakSet,
        uL = function(l) {
            return [o(this, r).getContext(l), ...o(this, r).getContext(l).allChildren].forEach(f => {
                o(this, s).registerEvent({
                    type: "event",
                    method: n.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
                    params: f.serializeToBidiValue()
                }, f.id)
            }
            ),
            Promise.resolve()
        }
        ,
        c);
        return df.BrowsingContextProcessor = e,
        df
    }
    var hf = {}, ub = {}, nM;
    function mo() {
        if (nM)
            return ub;
        nM = 1,
        Object.defineProperty(ub, "__esModule", {
            value: !0
        }),
        ub.assert = n;
        function n(e, t) {
            if (!e)
                throw new Error(t ?? "Internal assertion failed.")
        }
        return ub
    }
    var ff = {}, pf = {}, sM;
    function Oz() {
        if (sM)
            return pf;
        sM = 1,
        Object.defineProperty(pf, "__esModule", {
            value: !0
        }),
        pf.isSingleComplexGrapheme = n,
        pf.isSingleGrapheme = e;
        function n(t) {
            return e(t) && t.length > 1
        }
        function e(t) {
            return [...new Intl.Segmenter("en",{
                granularity: "grapheme"
            }).segment(t)].length === 1
        }
        return pf
    }
    var Gn = {}, iM;
    function aM() {
        var s, i, Og, c, u, l, d, h, f, p;
        if (iM)
            return Gn;
        iM = 1,
        Object.defineProperty(Gn, "__esModule", {
            value: !0
        }),
        Gn.WheelSource = Gn.PointerSource = Gn.KeySource = Gn.NoneSource = void 0;
        class n {
            constructor() {
                J(this, "type", "none")
            }
        }
        Gn.NoneSource = n;
        class e {
            constructor() {
                b(this, i);
                J(this, "type", "key");
                J(this, "pressed", new Set);
                b(this, s, 0)
            }
            get modifiers() {
                return o(this, s)
            }
            get alt() {
                return (o(this, s) & 1) === 1
            }
            set alt(y) {
                P(this, i, Og).call(this, y, 1)
            }
            get ctrl() {
                return (o(this, s) & 2) === 2
            }
            set ctrl(y) {
                P(this, i, Og).call(this, y, 2)
            }
            get meta() {
                return (o(this, s) & 4) === 4
            }
            set meta(y) {
                P(this, i, Og).call(this, y, 4)
            }
            get shift() {
                return (o(this, s) & 8) === 8
            }
            set shift(y) {
                P(this, i, Og).call(this, y, 8)
            }
        }
        s = new WeakMap,
        i = new WeakSet,
        Og = function(y, m) {
            y ? S(this, s, o(this, s) | m) : S(this, s, o(this, s) & ~m)
        }
        ,
        Gn.KeySource = e;
        class t {
            constructor(y, m) {
                J(this, "type", "pointer");
                J(this, "subtype");
                J(this, "pointerId");
                J(this, "pressed", new Set);
                J(this, "x", 0);
                J(this, "y", 0);
                J(this, "radiusX");
                J(this, "radiusY");
                J(this, "force");
                b(this, p, new Map);
                this.pointerId = y,
                this.subtype = m
            }
            get buttons() {
                let y = 0;
                for (const m of this.pressed)
                    switch (m) {
                    case 0:
                        y |= 1;
                        break;
                    case 1:
                        y |= 4;
                        break;
                    case 2:
                        y |= 2;
                        break;
                    case 3:
                        y |= 8;
                        break;
                    case 4:
                        y |= 16;
                        break
                    }
                return y
            }
            setClickCount(y, m) {
                let w = o(this, p).get(y);
                return (!w || w.compare(m)) && (w = m),
                ++w.count,
                o(this, p).set(y, w),
                w.count
            }
            getClickCount(y) {
                var m;
                return ((m = o(this, p).get(y)) == null ? void 0 : m.count) ?? 0
            }
        }
        p = new WeakMap,
        J(t, "ClickContext", (c = class {
            constructor(m, w, E) {
                J(this, "count", 0);
                b(this, d);
                b(this, h);
                b(this, f);
                S(this, d, m),
                S(this, h, w),
                S(this, f, E)
            }
            compare(m) {
                return o(m, f) - o(this, f) > o(c, u) || Math.abs(o(m, d) - o(this, d)) > o(c, l) || Math.abs(o(m, h) - o(this, h)) > o(c, l)
            }
        }
        ,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        b(c, u, 500),
        b(c, l, 2),
        c)),
        Gn.PointerSource = t;
        class r {
            constructor() {
                J(this, "type", "wheel")
            }
        }
        return Gn.WheelSource = r,
        Gn
    }
    var Du = {}, oM;
    function Rz() {
        if (oM)
            return Du;
        oM = 1,
        Object.defineProperty(Du, "__esModule", {
            value: !0
        }),
        Du.getNormalizedKey = n,
        Du.getKeyCode = e,
        Du.getKeyLocation = t;
        function n(r) {
            switch (r) {
            case "":
                return "Unidentified";
            case "":
                return "Cancel";
            case "":
                return "Help";
            case "":
                return "Backspace";
            case "":
                return "Tab";
            case "":
                return "Clear";
            case "":
            case "":
                return "Enter";
            case "":
                return "Shift";
            case "":
                return "Control";
            case "":
                return "Alt";
            case "":
                return "Pause";
            case "":
                return "Escape";
            case "":
                return " ";
            case "":
                return "PageUp";
            case "":
                return "PageDown";
            case "":
                return "End";
            case "":
                return "Home";
            case "":
                return "ArrowLeft";
            case "":
                return "ArrowUp";
            case "":
                return "ArrowRight";
            case "":
                return "ArrowDown";
            case "":
                return "Insert";
            case "":
                return "Delete";
            case "":
                return ";";
            case "":
                return "=";
            case "":
                return "0";
            case "":
                return "1";
            case "":
                return "2";
            case "":
                return "3";
            case "":
                return "4";
            case "":
                return "5";
            case "":
                return "6";
            case "":
                return "7";
            case "":
                return "8";
            case "":
                return "9";
            case "":
                return "*";
            case "":
                return "+";
            case "":
                return ",";
            case "":
                return "-";
            case "":
                return ".";
            case "":
                return "/";
            case "":
                return "F1";
            case "":
                return "F2";
            case "":
                return "F3";
            case "":
                return "F4";
            case "":
                return "F5";
            case "":
                return "F6";
            case "":
                return "F7";
            case "":
                return "F8";
            case "":
                return "F9";
            case "":
                return "F10";
            case "":
                return "F11";
            case "":
                return "F12";
            case "":
                return "Meta";
            case "":
                return "ZenkakuHankaku";
            case "":
                return "Shift";
            case "":
                return "Control";
            case "":
                return "Alt";
            case "":
                return "Meta";
            case "":
                return "PageUp";
            case "":
                return "PageDown";
            case "":
                return "End";
            case "":
                return "Home";
            case "":
                return "ArrowLeft";
            case "":
                return "ArrowUp";
            case "":
                return "ArrowRight";
            case "":
                return "ArrowDown";
            case "":
                return "Insert";
            case "":
                return "Delete";
            default:
                return r
            }
        }
        function e(r) {
            switch (r) {
            case "`":
            case "~":
                return "Backquote";
            case "\\":
            case "|":
                return "Backslash";
            case "":
                return "Backspace";
            case "[":
            case "{":
                return "BracketLeft";
            case "]":
            case "}":
                return "BracketRight";
            case ",":
            case "<":
                return "Comma";
            case "0":
            case ")":
                return "Digit0";
            case "1":
            case "!":
                return "Digit1";
            case "2":
            case "@":
                return "Digit2";
            case "3":
            case "#":
                return "Digit3";
            case "4":
            case "$":
                return "Digit4";
            case "5":
            case "%":
                return "Digit5";
            case "6":
            case "^":
                return "Digit6";
            case "7":
            case "&":
                return "Digit7";
            case "8":
            case "*":
                return "Digit8";
            case "9":
            case "(":
                return "Digit9";
            case "=":
            case "+":
                return "Equal";
            case ">":
                return "IntlBackslash";
            case "a":
            case "A":
                return "KeyA";
            case "b":
            case "B":
                return "KeyB";
            case "c":
            case "C":
                return "KeyC";
            case "d":
            case "D":
                return "KeyD";
            case "e":
            case "E":
                return "KeyE";
            case "f":
            case "F":
                return "KeyF";
            case "g":
            case "G":
                return "KeyG";
            case "h":
            case "H":
                return "KeyH";
            case "i":
            case "I":
                return "KeyI";
            case "j":
            case "J":
                return "KeyJ";
            case "k":
            case "K":
                return "KeyK";
            case "l":
            case "L":
                return "KeyL";
            case "m":
            case "M":
                return "KeyM";
            case "n":
            case "N":
                return "KeyN";
            case "o":
            case "O":
                return "KeyO";
            case "p":
            case "P":
                return "KeyP";
            case "q":
            case "Q":
                return "KeyQ";
            case "r":
            case "R":
                return "KeyR";
            case "s":
            case "S":
                return "KeyS";
            case "t":
            case "T":
                return "KeyT";
            case "u":
            case "U":
                return "KeyU";
            case "v":
            case "V":
                return "KeyV";
            case "w":
            case "W":
                return "KeyW";
            case "x":
            case "X":
                return "KeyX";
            case "y":
            case "Y":
                return "KeyY";
            case "z":
            case "Z":
                return "KeyZ";
            case "-":
            case "_":
                return "Minus";
            case ".":
                return "Period";
            case "'":
            case '"':
                return "Quote";
            case ";":
            case ":":
                return "Semicolon";
            case "/":
            case "?":
                return "Slash";
            case "":
                return "AltLeft";
            case "":
                return "AltRight";
            case "":
                return "ControlLeft";
            case "":
                return "ControlRight";
            case "":
                return "Enter";
            case "":
                return "Pause";
            case "":
                return "MetaLeft";
            case "":
                return "MetaRight";
            case "":
                return "ShiftLeft";
            case "":
                return "ShiftRight";
            case " ":
            case "":
                return "Space";
            case "":
                return "Tab";
            case "":
                return "Delete";
            case "":
                return "End";
            case "":
                return "Help";
            case "":
                return "Home";
            case "":
                return "Insert";
            case "":
                return "PageDown";
            case "":
                return "PageUp";
            case "":
                return "ArrowDown";
            case "":
                return "ArrowLeft";
            case "":
                return "ArrowRight";
            case "":
                return "ArrowUp";
            case "":
                return "Escape";
            case "":
                return "F1";
            case "":
                return "F2";
            case "":
                return "F3";
            case "":
                return "F4";
            case "":
                return "F5";
            case "":
                return "F6";
            case "":
                return "F7";
            case "":
                return "F8";
            case "":
                return "F9";
            case "":
                return "F10";
            case "":
                return "F11";
            case "":
                return "F12";
            case "":
                return "NumpadEqual";
            case "":
            case "":
                return "Numpad0";
            case "":
            case "":
                return "Numpad1";
            case "":
            case "":
                return "Numpad2";
            case "":
            case "":
                return "Numpad3";
            case "":
            case "":
                return "Numpad4";
            case "":
                return "Numpad5";
            case "":
            case "":
                return "Numpad6";
            case "":
            case "":
                return "Numpad7";
            case "":
            case "":
                return "Numpad8";
            case "":
            case "":
                return "Numpad9";
            case "":
                return "NumpadAdd";
            case "":
                return "NumpadComma";
            case "":
            case "":
                return "NumpadDecimal";
            case "":
                return "NumpadDivide";
            case "":
                return "NumpadEnter";
            case "":
                return "NumpadMultiply";
            case "":
                return "NumpadSubtract";
            default:
                return
            }
        }
        function t(r) {
            switch (r) {
            case "":
            case "":
            case "":
            case "":
            case "":
                return 1;
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
            case "":
                return 3;
            case "":
            case "":
            case "":
            case "":
                return 2;
            default:
                return 0
            }
        }
        return Du
    }
    var mf = {}, cM;
    function Mz() {
        return cM || (cM = 1,
        Object.defineProperty(mf, "__esModule", {
            value: !0
        }),
        mf.KeyToKeyCode = void 0,
        mf.KeyToKeyCode = {
            0: 48,
            1: 49,
            2: 50,
            3: 51,
            4: 52,
            5: 53,
            6: 54,
            7: 55,
            8: 56,
            9: 57,
            Abort: 3,
            Help: 6,
            Backspace: 8,
            Tab: 9,
            Numpad5: 12,
            NumpadEnter: 13,
            Enter: 13,
            "\\r": 13,
            "\\n": 13,
            ShiftLeft: 16,
            ShiftRight: 16,
            ControlLeft: 17,
            ControlRight: 17,
            AltLeft: 18,
            AltRight: 18,
            Pause: 19,
            CapsLock: 20,
            Escape: 27,
            Convert: 28,
            NonConvert: 29,
            Space: 32,
            Numpad9: 33,
            PageUp: 33,
            Numpad3: 34,
            PageDown: 34,
            End: 35,
            Numpad1: 35,
            Home: 36,
            Numpad7: 36,
            ArrowLeft: 37,
            Numpad4: 37,
            Numpad8: 38,
            ArrowUp: 38,
            ArrowRight: 39,
            Numpad6: 39,
            Numpad2: 40,
            ArrowDown: 40,
            Select: 41,
            Open: 43,
            PrintScreen: 44,
            Insert: 45,
            Numpad0: 45,
            Delete: 46,
            NumpadDecimal: 46,
            Digit0: 48,
            Digit1: 49,
            Digit2: 50,
            Digit3: 51,
            Digit4: 52,
            Digit5: 53,
            Digit6: 54,
            Digit7: 55,
            Digit8: 56,
            Digit9: 57,
            KeyA: 65,
            KeyB: 66,
            KeyC: 67,
            KeyD: 68,
            KeyE: 69,
            KeyF: 70,
            KeyG: 71,
            KeyH: 72,
            KeyI: 73,
            KeyJ: 74,
            KeyK: 75,
            KeyL: 76,
            KeyM: 77,
            KeyN: 78,
            KeyO: 79,
            KeyP: 80,
            KeyQ: 81,
            KeyR: 82,
            KeyS: 83,
            KeyT: 84,
            KeyU: 85,
            KeyV: 86,
            KeyW: 87,
            KeyX: 88,
            KeyY: 89,
            KeyZ: 90,
            MetaLeft: 91,
            MetaRight: 92,
            ContextMenu: 93,
            NumpadMultiply: 106,
            NumpadAdd: 107,
            NumpadSubtract: 109,
            NumpadDivide: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            F13: 124,
            F14: 125,
            F15: 126,
            F16: 127,
            F17: 128,
            F18: 129,
            F19: 130,
            F20: 131,
            F21: 132,
            F22: 133,
            F23: 134,
            F24: 135,
            NumLock: 144,
            ScrollLock: 145,
            AudioVolumeMute: 173,
            AudioVolumeDown: 174,
            AudioVolumeUp: 175,
            MediaTrackNext: 176,
            MediaTrackPrevious: 177,
            MediaStop: 178,
            MediaPlayPause: 179,
            Semicolon: 186,
            Equal: 187,
            NumpadEqual: 187,
            Comma: 188,
            Minus: 189,
            Period: 190,
            Slash: 191,
            Backquote: 192,
            BracketLeft: 219,
            Backslash: 220,
            BracketRight: 221,
            Quote: 222,
            AltGraph: 225,
            Props: 247,
            Cancel: 3,
            Clear: 12,
            Shift: 16,
            Control: 17,
            Alt: 18,
            Accept: 30,
            ModeChange: 31,
            " ": 32,
            Print: 42,
            Execute: 43,
            "\\u0000": 46,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90,
            Meta: 91,
            "*": 106,
            "+": 107,
            "-": 109,
            "/": 111,
            ";": 186,
            "=": 187,
            ",": 188,
            ".": 190,
            "`": 192,
            "[": 219,
            "\\\\": 220,
            "]": 221,
            "'": 222,
            Attn: 246,
            CrSel: 247,
            ExSel: 248,
            EraseEof: 249,
            Play: 250,
            ZoomOut: 251,
            ")": 48,
            "!": 49,
            "@": 50,
            "#": 51,
            $: 52,
            "%": 53,
            "^": 54,
            "&": 55,
            "(": 57,
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 90,
            ":": 186,
            "<": 188,
            _: 189,
            ">": 190,
            "?": 191,
            "~": 192,
            "{": 219,
            "|": 220,
            "}": 221,
            '"': 222,
            Camera: 44,
            EndCall: 95,
            VolumeDown: 182,
            VolumeUp: 183
        }),
        mf
    }
    var uM;
    function Nz() {
        var y, m, w, E, v, _, A, C, rr, lL, dL, hL, fL, pL, fC, mL, gL, yL;
        if (uM)
            return ff;
        uM = 1,
        Object.defineProperty(ff, "__esModule", {
            value: !0
        }),
        ff.ActionDispatcher = void 0;
        const n = mt()
          , e = mo()
          , t = Oz()
          , r = aM()
          , s = Rz()
          , i = Mz()
          , a = (j => {
            const $ = j.getClientRects()[0]
              , B = Math.max(0, Math.min($.x, $.x + $.width))
              , D = Math.min(window.innerWidth, Math.max($.x, $.x + $.width))
              , z = Math.max(0, Math.min($.y, $.y + $.height))
              , G = Math.min(window.innerHeight, Math.max($.y, $.y + $.height));
            return [B + (D - B >> 1), z + (G - z >> 1)]
        }
        ).toString()
          , c = ( () => navigator.platform.toLowerCase().includes("mac")).toString();
        async function u(j, $) {
            var ee, V, K, se;
            const D = await (await j.getOrCreateSandbox(void 0)).callFunction(a, !1, {
                type: "undefined"
            }, [$]);
            if (D.type === "exception")
                throw new n.NoSuchElementException(`Origin element ${$.sharedId} was not found`);
            (0,
            e.assert)(D.result.type === "array"),
            (0,
            e.assert)(((V = (ee = D.result.value) == null ? void 0 : ee[0]) == null ? void 0 : V.type) === "number"),
            (0,
            e.assert)(((se = (K = D.result.value) == null ? void 0 : K[1]) == null ? void 0 : se.type) === "number");
            const {result: {value: [{value: z},{value: G}]}} = D;
            return {
                x: z,
                y: G
            }
        }
        let l = (y = class {
            constructor($, B, D, z) {
                b(this, C);
                b(this, m);
                b(this, w, 0);
                b(this, E, 0);
                b(this, v);
                b(this, _);
                b(this, A);
                S(this, m, B),
                S(this, v, $),
                S(this, _, D),
                S(this, A, z)
            }
            async dispatchActions($) {
                await o(this, v).queue.run(async () => {
                    for (const B of $)
                        await this.dispatchTickActions(B)
                }
                )
            }
            async dispatchTickActions($) {
                S(this, w, performance.now()),
                S(this, E, 0);
                for (const {action: D} of $)
                    "duration"in D && D.duration !== void 0 && S(this, E, Math.max(o(this, E), D.duration));
                const B = [new Promise(D => setTimeout(D, o(this, E)))];
                for (const D of $)
                    B.push(P(this, C, lL).call(this, D));
                await Promise.all(B)
            }
        }
        ,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakSet,
        rr = function() {
            return o(this, m).getContext(o(this, _))
        }
        ,
        lL = async function({id: $, action: B}) {
            const D = o(this, v).get($)
              , z = o(this, v).getGlobalKeyState();
            switch (B.type) {
            case "keyDown":
                {
                    await P(this, C, gL).call(this, D, B),
                    o(this, v).cancelList.push({
                        id: $,
                        action: {
                            ...B,
                            type: "keyUp"
                        }
                    });
                    break
                }
            case "keyUp":
                {
                    await P(this, C, yL).call(this, D, B);
                    break
                }
            case "pause":
                break;
            case "pointerDown":
                {
                    await P(this, C, dL).call(this, D, z, B),
                    o(this, v).cancelList.push({
                        id: $,
                        action: {
                            ...B,
                            type: "pointerUp"
                        }
                    });
                    break
                }
            case "pointerMove":
                {
                    await P(this, C, fL).call(this, D, z, B);
                    break
                }
            case "pointerUp":
                {
                    await P(this, C, hL).call(this, D, z, B);
                    break
                }
            case "scroll":
                {
                    await P(this, C, mL).call(this, D, z, B);
                    break
                }
            }
        }
        ,
        dL = async function($, B, D) {
            const {button: z} = D;
            if ($.pressed.has(z))
                return;
            $.pressed.add(z);
            const {x: G, y: ee, subtype: V} = $
              , {width: K, height: se, pressure: ye, twist: ue, tangentialPressure: He} = D
              , {tiltX: pe, tiltY: I} = p(D)
              , {modifiers: M} = B
              , {radiusX: U, radiusY: W} = g(K ?? 1, se ?? 1);
            switch (V) {
            case "mouse":
            case "pen":
                await o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                    type: "mousePressed",
                    x: G,
                    y: ee,
                    modifiers: M,
                    button: f(z),
                    buttons: $.buttons,
                    clickCount: $.setClickCount(z, new r.PointerSource.ClickContext(G,ee,performance.now())),
                    pointerType: V,
                    tangentialPressure: He,
                    tiltX: pe,
                    tiltY: I,
                    twist: ue,
                    force: ye
                });
                break;
            case "touch":
                await o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                    type: "touchStart",
                    touchPoints: [{
                        x: G,
                        y: ee,
                        radiusX: U,
                        radiusY: W,
                        tangentialPressure: He,
                        tiltX: pe,
                        tiltY: I,
                        twist: ue,
                        force: ye,
                        id: $.pointerId
                    }],
                    modifiers: M
                });
                break
            }
            $.radiusX = U,
            $.radiusY = W,
            $.force = ye
        }
        ,
        hL = function($, B, D) {
            const {button: z} = D;
            if (!$.pressed.has(z))
                return;
            $.pressed.delete(z);
            const {x: G, y: ee, force: V, radiusX: K, radiusY: se, subtype: ye} = $
              , {modifiers: ue} = B;
            switch (ye) {
            case "mouse":
            case "pen":
                return o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                    type: "mouseReleased",
                    x: G,
                    y: ee,
                    modifiers: ue,
                    button: f(z),
                    buttons: $.buttons,
                    clickCount: $.getClickCount(z),
                    pointerType: ye
                });
            case "touch":
                return o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                    type: "touchEnd",
                    touchPoints: [{
                        x: G,
                        y: ee,
                        id: $.pointerId,
                        force: V,
                        radiusX: K,
                        radiusY: se
                    }],
                    modifiers: ue
                })
            }
        }
        ,
        fL = async function($, B, D) {
            const {x: z, y: G, subtype: ee} = $
              , {width: V, height: K, pressure: se, twist: ye, tangentialPressure: ue, x: He, y: pe, origin: I="viewport", duration: M=o(this, E)} = D
              , {tiltX: U, tiltY: W} = p(D)
              , {radiusX: X, radiusY: te} = g(V ?? 1, K ?? 1)
              , {targetX: ae, targetY: xe} = await P(this, C, fC).call(this, I, He, pe, z, G);
            if (ae < 0 || xe < 0)
                throw new n.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${ae}, y: ${xe})`);
            let ce;
            do {
                const Pe = M > 0 ? (performance.now() - o(this, w)) / M : 1;
                ce = Pe >= 1;
                let we, H;
                if (ce ? (we = ae,
                H = xe) : (we = Math.round(Pe * (ae - z) + z),
                H = Math.round(Pe * (xe - G) + G)),
                $.x !== we || $.y !== H) {
                    const {modifiers: Q} = B;
                    switch (ee) {
                    case "mouse":
                        await o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                            type: "mouseMoved",
                            x: we,
                            y: H,
                            modifiers: Q,
                            clickCount: 0,
                            button: f($.pressed.values().next().value ?? 5),
                            buttons: $.buttons,
                            pointerType: ee,
                            tangentialPressure: ue,
                            tiltX: U,
                            tiltY: W,
                            twist: ye,
                            force: se
                        });
                        break;
                    case "pen":
                        $.pressed.size !== 0 && await o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                            type: "mouseMoved",
                            x: we,
                            y: H,
                            modifiers: Q,
                            clickCount: 0,
                            button: f($.pressed.values().next().value ?? 5),
                            buttons: $.buttons,
                            pointerType: ee,
                            tangentialPressure: ue,
                            tiltX: U,
                            tiltY: W,
                            twist: ye,
                            force: se ?? .5
                        });
                        break;
                    case "touch":
                        $.pressed.size !== 0 && await o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                            type: "touchMove",
                            touchPoints: [{
                                x: we,
                                y: H,
                                radiusX: X,
                                radiusY: te,
                                tangentialPressure: ue,
                                tiltX: U,
                                tiltY: W,
                                twist: ye,
                                force: se,
                                id: $.pointerId
                            }],
                            modifiers: Q
                        });
                        break
                    }
                    $.x = we,
                    $.y = H,
                    $.radiusX = X,
                    $.radiusY = te,
                    $.force = se
                }
            } while (!ce)
        }
        ,
        pL = async function() {
            if (o(this, C, rr).id === o(this, C, rr).cdpTarget.id)
                return {
                    x: 0,
                    y: 0
                };
            const {backendNodeId: $} = await o(this, C, rr).cdpTarget.cdpClient.sendCommand("DOM.getFrameOwner", {
                frameId: o(this, C, rr).id
            })
              , {model: B} = await o(this, C, rr).cdpTarget.cdpClient.sendCommand("DOM.getBoxModel", {
                backendNodeId: $
            });
            return {
                x: B.content[0],
                y: B.content[1]
            }
        }
        ,
        fC = async function($, B, D, z, G) {
            let ee, V;
            const K = await P(this, C, pL).call(this);
            switch ($) {
            case "viewport":
                ee = B + K.x,
                V = D + K.y;
                break;
            case "pointer":
                ee = z + B + K.x,
                V = G + D + K.y;
                break;
            default:
                {
                    const {x: se, y: ye} = await u(o(this, C, rr), $.element);
                    ee = se + B + K.x,
                    V = ye + D + K.y;
                    break
                }
            }
            return {
                targetX: ee,
                targetY: V
            }
        }
        ,
        mL = async function($, B, D) {
            const {deltaX: z, deltaY: G, x: ee, y: V, origin: K="viewport", duration: se=o(this, E)} = D;
            if (K === "pointer")
                throw new n.InvalidArgumentException('"pointer" origin is invalid for scrolling.');
            const {targetX: ye, targetY: ue} = await P(this, C, fC).call(this, K, ee, V, 0, 0);
            if (ye < 0 || ue < 0)
                throw new n.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${ye}, y: ${ue})`);
            let He = 0, pe = 0, I;
            do {
                const M = se > 0 ? (performance.now() - o(this, w)) / se : 1;
                I = M >= 1;
                let U, W;
                if (I ? (U = z - He,
                W = G - pe) : (U = Math.round(M * z - He),
                W = Math.round(M * G - pe)),
                U !== 0 || W !== 0) {
                    const {modifiers: X} = B;
                    await o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                        type: "mouseWheel",
                        deltaX: U,
                        deltaY: W,
                        x: ye,
                        y: ue,
                        modifiers: X
                    }),
                    He += U,
                    pe += W
                }
            } while (!I)
        }
        ,
        gL = async function($, B) {
            const D = B.value;
            if (!(0,
            t.isSingleGrapheme)(D))
                throw new n.InvalidArgumentException(`Invalid key value: ${D}`);
            const z = (0,
            t.isSingleComplexGrapheme)(D)
              , G = (0,
            s.getNormalizedKey)(D)
              , ee = $.pressed.has(G)
              , V = (0,
            s.getKeyCode)(D)
              , K = (0,
            s.getKeyLocation)(D);
            switch (G) {
            case "Alt":
                $.alt = !0;
                break;
            case "Shift":
                $.shift = !0;
                break;
            case "Control":
                $.ctrl = !0;
                break;
            case "Meta":
                $.meta = !0;
                break
            }
            $.pressed.add(G);
            const {modifiers: se} = $
              , ye = d(G, $, z)
              , ue = h(V ?? "", $) ?? ye;
            let He;
            if (o(this, A) && $.meta)
                switch (V) {
                case "KeyA":
                    He = "SelectAll";
                    break;
                case "KeyC":
                    He = "Copy";
                    break;
                case "KeyV":
                    He = $.shift ? "PasteAndMatchStyle" : "Paste";
                    break;
                case "KeyX":
                    He = "Cut";
                    break;
                case "KeyZ":
                    He = $.shift ? "Redo" : "Undo";
                    break
                }
            const pe = [o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
                type: ue ? "keyDown" : "rawKeyDown",
                windowsVirtualKeyCode: i.KeyToKeyCode[G],
                key: G,
                code: V,
                text: ue,
                unmodifiedText: ye,
                autoRepeat: ee,
                isSystemKey: $.alt || void 0,
                location: K < 3 ? K : void 0,
                isKeypad: K === 3,
                modifiers: se,
                commands: He ? [He] : void 0
            })];
            G === "Escape" && !$.alt && (o(this, A) && !$.ctrl && !$.meta || !o(this, A)) && pe.push(o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.cancelDragging")),
            await Promise.all(pe)
        }
        ,
        yL = function($, B) {
            const D = B.value;
            if (!(0,
            t.isSingleGrapheme)(D))
                throw new n.InvalidArgumentException(`Invalid key value: ${D}`);
            const z = (0,
            t.isSingleComplexGrapheme)(D)
              , G = (0,
            s.getNormalizedKey)(D);
            if (!$.pressed.has(G))
                return;
            const ee = (0,
            s.getKeyCode)(D)
              , V = (0,
            s.getKeyLocation)(D);
            switch (G) {
            case "Alt":
                $.alt = !1;
                break;
            case "Shift":
                $.shift = !1;
                break;
            case "Control":
                $.ctrl = !1;
                break;
            case "Meta":
                $.meta = !1;
                break
            }
            $.pressed.delete(G);
            const {modifiers: K} = $
              , se = d(G, $, z)
              , ye = h(ee ?? "", $) ?? se;
            return o(this, C, rr).cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
                type: "keyUp",
                windowsVirtualKeyCode: i.KeyToKeyCode[G],
                key: G,
                code: ee,
                text: ye,
                unmodifiedText: se,
                location: V < 3 ? V : void 0,
                isSystemKey: $.alt || void 0,
                isKeypad: V === 3,
                modifiers: K
            })
        }
        ,
        J(y, "isMacOS", async $ => {
            const B = await (await $.getOrCreateSandbox(void 0)).callFunction(c, !1);
            return (0,
            e.assert)(B.type !== "exception"),
            (0,
            e.assert)(B.result.type === "boolean"),
            B.result.value
        }
        ),
        y);
        ff.ActionDispatcher = l;
        const d = (j, $, B) => B ? j : j === "Enter" ? "\r" : [...j].length === 1 ? $.shift ? j.toLocaleUpperCase("en-US") : j : void 0
          , h = (j, $) => {
            if ($.ctrl) {
                switch (j) {
                case "Digit2":
                    if ($.shift)
                        return "\0";
                    break;
                case "KeyA":
                    return "";
                case "KeyB":
                    return "";
                case "KeyC":
                    return "";
                case "KeyD":
                    return "";
                case "KeyE":
                    return "";
                case "KeyF":
                    return "";
                case "KeyG":
                    return "\x07";
                case "KeyH":
                    return "\b";
                case "KeyI":
                    return "	";
                case "KeyJ":
                    return `
`;
                case "KeyK":
                    return "\v";
                case "KeyL":
                    return "\f";
                case "KeyM":
                    return "\r";
                case "KeyN":
                    return "";
                case "KeyO":
                    return "";
                case "KeyP":
                    return "";
                case "KeyQ":
                    return "";
                case "KeyR":
                    return "";
                case "KeyS":
                    return "";
                case "KeyT":
                    return "";
                case "KeyU":
                    return "";
                case "KeyV":
                    return "";
                case "KeyW":
                    return "";
                case "KeyX":
                    return "";
                case "KeyY":
                    return "";
                case "KeyZ":
                    return "";
                case "BracketLeft":
                    return "\x1B";
                case "Backslash":
                    return "";
                case "BracketRight":
                    return "";
                case "Digit6":
                    if ($.shift)
                        return "";
                    break;
                case "Minus":
                    return ""
                }
                return ""
            }
            if ($.alt)
                return ""
        }
        ;
        function f(j) {
            switch (j) {
            case 0:
                return "left";
            case 1:
                return "middle";
            case 2:
                return "right";
            case 3:
                return "back";
            case 4:
                return "forward";
            default:
                return "none"
            }
        }
        function p(j) {
            const $ = j.altitudeAngle ?? Math.PI / 2
              , B = j.azimuthAngle ?? 0;
            let D = 0
              , z = 0;
            if ($ === 0 && ((B === 0 || B === 2 * Math.PI) && (D = Math.PI / 2),
            B === Math.PI / 2 && (z = Math.PI / 2),
            B === Math.PI && (D = -Math.PI / 2),
            B === 3 * Math.PI / 2 && (z = -Math.PI / 2),
            B > 0 && B < Math.PI / 2 && (D = Math.PI / 2,
            z = Math.PI / 2),
            B > Math.PI / 2 && B < Math.PI && (D = -Math.PI / 2,
            z = Math.PI / 2),
            B > Math.PI && B < 3 * Math.PI / 2 && (D = -Math.PI / 2,
            z = -Math.PI / 2),
            B > 3 * Math.PI / 2 && B < 2 * Math.PI && (D = Math.PI / 2,
            z = -Math.PI / 2)),
            $ !== 0) {
                const ee = Math.tan($);
                D = Math.atan(Math.cos(B) / ee),
                z = Math.atan(Math.sin(B) / ee)
            }
            const G = 180 / Math.PI;
            return {
                tiltX: Math.round(D * G),
                tiltY: Math.round(z * G)
            }
        }
        function g(j, $) {
            return {
                radiusX: j ? j / 2 : .5,
                radiusY: $ ? $ / 2 : .5
            }
        }
        return ff
    }
    var gf = {}, yf = {}, wf = {}, lM;
    function $z() {
        var e, t, r, pC, i;
        if (lM)
            return wf;
        lM = 1,
        Object.defineProperty(wf, "__esModule", {
            value: !0
        }),
        wf.Mutex = void 0;
        let n = (i = class {
            constructor() {
                b(this, r);
                b(this, e, !1);
                b(this, t, [])
            }
            acquire() {
                const c = {
                    resolved: !1
                };
                return o(this, e) ? new Promise(u => {
                    o(this, t).push( () => u(P(this, r, pC).bind(this, c)))
                }
                ) : (S(this, e, !0),
                Promise.resolve(P(this, r, pC).bind(this, c)))
            }
            async run(c) {
                const u = await this.acquire();
                try {
                    return await c()
                } finally {
                    u()
                }
            }
        }
        ,
        e = new WeakMap,
        t = new WeakMap,
        r = new WeakSet,
        pC = function(c) {
            if (c.resolved)
                throw new Error("Cannot release more than once.");
            c.resolved = !0;
            const u = o(this, t).shift();
            if (!u) {
                S(this, e, !1);
                return
            }
            u()
        }
        ,
        i);
        return wf.Mutex = n,
        wf
    }
    var dM;
    function Lz() {
        var s, i, a;
        if (dM)
            return yf;
        dM = 1,
        Object.defineProperty(yf, "__esModule", {
            value: !0
        }),
        yf.InputState = void 0;
        const n = mt()
          , e = $z()
          , t = aM();
        let r = (a = class {
            constructor() {
                J(this, "cancelList", []);
                b(this, s, new Map);
                b(this, i, new e.Mutex)
            }
            getOrCreate(u, l, d) {
                let h = o(this, s).get(u);
                if (!h) {
                    switch (l) {
                    case "none":
                        h = new t.NoneSource;
                        break;
                    case "key":
                        h = new t.KeySource;
                        break;
                    case "pointer":
                        {
                            let f = d === "mouse" ? 0 : 2;
                            const p = new Set;
                            for (const [,g] of o(this, s))
                                g.type === "pointer" && p.add(g.pointerId);
                            for (; p.has(f); )
                                ++f;
                            h = new t.PointerSource(f,d);
                            break
                        }
                    case "wheel":
                        h = new t.WheelSource;
                        break;
                    default:
                        throw new n.InvalidArgumentException(`Expected "none", "key", "pointer", or "wheel". Found unknown source type ${l}.`)
                    }
                    return o(this, s).set(u, h),
                    h
                }
                if (h.type !== l)
                    throw new n.InvalidArgumentException(`Input source type of ${u} is ${h.type}, but received ${l}.`);
                return h
            }
            get(u) {
                const l = o(this, s).get(u);
                if (!l)
                    throw new n.UnknownErrorException("Internal error.");
                return l
            }
            getGlobalKeyState() {
                const u = new t.KeySource;
                for (const [,l] of o(this, s))
                    if (l.type === "key") {
                        for (const d of l.pressed)
                            u.pressed.add(d);
                        u.alt || (u.alt = l.alt),
                        u.ctrl || (u.ctrl = l.ctrl),
                        u.meta || (u.meta = l.meta),
                        u.shift || (u.shift = l.shift)
                    }
                return u
            }
            get queue() {
                return o(this, i)
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a);
        return yf.InputState = r,
        yf
    }
    var hM;
    function Fz() {
        if (hM)
            return gf;
        hM = 1,
        Object.defineProperty(gf, "__esModule", {
            value: !0
        }),
        gf.InputStateManager = void 0;
        const n = mo()
          , e = Lz();
        let t = class extends WeakMap {
            get(s) {
                return (0,
                n.assert)(s.isTopLevelContext()),
                this.has(s) || this.set(s, new e.InputState),
                super.get(s)
            }
        }
        ;
        return gf.InputStateManager = t,
        gf
    }
    var fM;
    function jz() {
        var i, a, c, wL, l;
        if (fM)
            return hf;
        fM = 1,
        Object.defineProperty(hf, "__esModule", {
            value: !0
        }),
        hf.InputProcessor = void 0;
        const n = mt()
          , e = mo()
          , t = Nz()
          , r = Fz();
        let s = (l = class {
            constructor(h) {
                b(this, c);
                b(this, i);
                b(this, a, new r.InputStateManager);
                S(this, i, h)
            }
            async performActions(h) {
                const f = o(this, i).getContext(h.context)
                  , p = o(this, a).get(f.top)
                  , g = P(this, c, wL).call(this, h, p);
                return await new t.ActionDispatcher(p,o(this, i),h.context,await t.ActionDispatcher.isMacOS(f).catch( () => !1)).dispatchActions(g),
                {}
            }
            async releaseActions(h) {
                const f = o(this, i).getContext(h.context)
                  , p = f.top
                  , g = o(this, a).get(p);
                return await new t.ActionDispatcher(g,o(this, i),h.context,await t.ActionDispatcher.isMacOS(f).catch( () => !1)).dispatchTickActions(g.cancelList.reverse()),
                o(this, a).delete(p),
                {}
            }
            async setFiles(h) {
                const p = await o(this, i).getContext(h.context).getOrCreateSandbox(void 0);
                let g;
                try {
                    g = await p.callFunction(String(function(E) {
                        if (!(this instanceof HTMLInputElement))
                            return this instanceof Element ? 1 : 0;
                        if (this.type !== "file")
                            return 2;
                        if (this.disabled)
                            return 3;
                        if (E > 1 && !this.multiple)
                            return 4
                    }), !1, h.element, [{
                        type: "number",
                        value: h.files.length
                    }])
                } catch {
                    throw new n.NoSuchNodeException(`Could not find element ${h.element.sharedId}`)
                }
                if ((0,
                e.assert)(g.type === "success"),
                g.result.type === "number")
                    switch (g.result.value) {
                    case 0:
                        throw new n.NoSuchElementException(`Could not find element ${h.element.sharedId}`);
                    case 1:
                        throw new n.UnableToSetFileInputException(`Element ${h.element.sharedId} is not a input`);
                    case 2:
                        throw new n.UnableToSetFileInputException(`Input element ${h.element.sharedId} is not a file type`);
                    case 3:
                        throw new n.UnableToSetFileInputException(`Input element ${h.element.sharedId} is disabled`);
                    case 4:
                        throw new n.UnableToSetFileInputException("Cannot set multiple files on a non-multiple input element")
                    }
                if (h.files.length === 0)
                    return await p.callFunction(String(function() {
                        var E;
                        if (((E = this.files) == null ? void 0 : E.length) === 0) {
                            this.dispatchEvent(new Event("cancel",{
                                bubbles: !0
                            }));
                            return
                        }
                        this.files = new DataTransfer().files,
                        this.dispatchEvent(new Event("input",{
                            bubbles: !0,
                            composed: !0
                        })),
                        this.dispatchEvent(new Event("change",{
                            bubbles: !0
                        }))
                    }), !1, h.element),
                    {};
                const y = [];
                for (let w = 0; w < h.files.length; ++w) {
                    const E = await p.callFunction(String(function(C) {
                        var k;
                        return (k = this.files) == null ? void 0 : k.item(C)
                    }), !1, h.element, [{
                        type: "number",
                        value: 0
                    }], "root");
                    if ((0,
                    e.assert)(E.type === "success"),
                    E.result.type !== "object")
                        break;
                    const {handle: v} = E.result;
                    (0,
                    e.assert)(v !== void 0);
                    const {path: _} = await p.cdpClient.sendCommand("DOM.getFileInfo", {
                        objectId: v
                    });
                    y.push(_),
                    p.disown(v).catch(void 0)
                }
                y.sort();
                const m = [...h.files].sort();
                if (y.length !== h.files.length || m.some( (w, E) => y[E] !== w)) {
                    const {objectId: w} = await p.deserializeForCdp(h.element);
                    (0,
                    e.assert)(w !== void 0),
                    await p.cdpClient.sendCommand("DOM.setFileInputFiles", {
                        files: h.files,
                        objectId: w
                    })
                } else
                    await p.callFunction(String(function() {
                        this.dispatchEvent(new Event("cancel",{
                            bubbles: !0
                        }))
                    }), !1, h.element);
                return {}
            }
        }
        ,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakSet,
        wL = function(h, f) {
            var g;
            const p = [];
            for (const y of h.actions) {
                switch (y.type) {
                case "pointer":
                    {
                        y.parameters ?? (y.parameters = {
                            pointerType: "mouse"
                        }),
                        (g = y.parameters).pointerType ?? (g.pointerType = "mouse");
                        const w = f.getOrCreate(y.id, "pointer", y.parameters.pointerType);
                        if (w.subtype !== y.parameters.pointerType)
                            throw new n.InvalidArgumentException(`Expected input source ${y.id} to be ${w.subtype}; got ${y.parameters.pointerType}.`);
                        break
                    }
                default:
                    f.getOrCreate(y.id, y.type)
                }
                const m = y.actions.map(w => ({
                    id: y.id,
                    action: w
                }));
                for (let w = 0; w < m.length; w++)
                    p.length === w && p.push([]),
                    p[w].push(m[w])
            }
            return p
        }
        ,
        l);
        return hf.InputProcessor = s,
        hf
    }
    var bf = {}, qt = {}, lb = {}, pM;
    function Dz() {
        if (pM)
            return lb;
        pM = 1,
        Object.defineProperty(lb, "__esModule", {
            value: !0
        }),
        lb.base64ToString = n;
        function n(e) {
            return "atob"in globalThis ? globalThis.atob(e) : Buffer.from(e, "base64").toString("ascii")
        }
        return lb
    }
    var mM;
    function db() {
        if (mM)
            return qt;
        mM = 1,
        Object.defineProperty(qt, "__esModule", {
            value: !0
        }),
        qt.computeHeadersSize = t,
        qt.bidiNetworkHeadersFromCdpNetworkHeaders = r,
        qt.bidiNetworkHeadersFromCdpNetworkHeadersEntries = s,
        qt.cdpNetworkHeadersFromBidiNetworkHeaders = i,
        qt.bidiNetworkHeadersFromCdpFetchHeaders = a,
        qt.cdpFetchHeadersFromBidiNetworkHeaders = c,
        qt.networkHeaderFromCookieHeaders = u,
        qt.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = l,
        qt.cdpToBiDiCookie = d,
        qt.deserializeByteValue = h,
        qt.bidiToCdpCookie = f,
        qt.sameSiteBiDiToCdp = g,
        qt.isSpecialScheme = y,
        qt.matchUrlPattern = w,
        qt.bidiBodySizeFromCdpPostDataEntries = E,
        qt.getTiming = v;
        const n = JR()
          , e = Dz();
        function t(_) {
            const A = _.reduce( (C, k) => `${C}${k.name}: ${k.value.value}\r
`, "");
            return new TextEncoder().encode(A).length
        }
        function r(_) {
            return _ ? Object.entries(_).map( ([A,C]) => ({
                name: A,
                value: {
                    type: "string",
                    value: C
                }
            })) : []
        }
        function s(_) {
            return _ ? _.map( ({name: A, value: C}) => ({
                name: A,
                value: {
                    type: "string",
                    value: C
                }
            })) : []
        }
        function i(_) {
            if (_ !== void 0)
                return _.reduce( (A, C) => (A[C.name] = C.value.value,
                A), {})
        }
        function a(_) {
            return _ ? _.map( ({name: A, value: C}) => ({
                name: A,
                value: {
                    type: "string",
                    value: C
                }
            })) : []
        }
        function c(_) {
            if (_ !== void 0)
                return _.map( ({name: A, value: C}) => ({
                    name: A,
                    value: C.value
                }))
        }
        function u(_) {
            return _ === void 0 ? void 0 : {
                name: "Cookie",
                value: {
                    type: "string",
                    value: _.reduce( (C, k, x) => {
                        x > 0 && (C += ";");
                        const N = k.value.type === "base64" ? btoa(k.value.value) : k.value.value;
                        return C += `${k.name}=${N}`,
                        C
                    }
                    , "")
                }
            }
        }
        function l(_) {
            switch (_) {
            case "default":
                return "Default";
            case "cancel":
                return "CancelAuth";
            case "provideCredentials":
                return "ProvideCredentials"
            }
        }
        function d(_) {
            const A = {
                name: _.name,
                value: {
                    type: "string",
                    value: _.value
                },
                domain: _.domain,
                path: _.path,
                size: _.size,
                httpOnly: _.httpOnly,
                secure: _.secure,
                sameSite: _.sameSite === void 0 ? "none" : p(_.sameSite),
                ..._.expires >= 0 ? {
                    expiry: _.expires
                } : void 0
            };
            return A["goog:session"] = _.session,
            A["goog:priority"] = _.priority,
            A["goog:sameParty"] = _.sameParty,
            A["goog:sourceScheme"] = _.sourceScheme,
            A["goog:sourcePort"] = _.sourcePort,
            _.partitionKey !== void 0 && (A["goog:partitionKey"] = _.partitionKey),
            _.partitionKeyOpaque !== void 0 && (A["goog:partitionKeyOpaque"] = _.partitionKeyOpaque),
            A
        }
        function h(_) {
            return _.type === "base64" ? (0,
            e.base64ToString)(_.value) : _.value
        }
        function f(_, A) {
            const C = h(_.cookie.value)
              , k = {
                name: _.cookie.name,
                value: C,
                domain: _.cookie.domain,
                path: _.cookie.path ?? "/",
                secure: _.cookie.secure ?? !1,
                httpOnly: _.cookie.httpOnly ?? !1,
                ...A.sourceOrigin !== void 0 && {
                    partitionKey: {
                        hasCrossSiteAncestor: !1,
                        topLevelSite: A.sourceOrigin
                    }
                },
                ..._.cookie.expiry !== void 0 && {
                    expires: _.cookie.expiry
                },
                ..._.cookie.sameSite !== void 0 && {
                    sameSite: g(_.cookie.sameSite)
                }
            };
            return _.cookie["goog:url"] !== void 0 && (k.url = _.cookie["goog:url"]),
            _.cookie["goog:priority"] !== void 0 && (k.priority = _.cookie["goog:priority"]),
            _.cookie["goog:sameParty"] !== void 0 && (k.sameParty = _.cookie["goog:sameParty"]),
            _.cookie["goog:sourceScheme"] !== void 0 && (k.sourceScheme = _.cookie["goog:sourceScheme"]),
            _.cookie["goog:sourcePort"] !== void 0 && (k.sourcePort = _.cookie["goog:sourcePort"]),
            k
        }
        function p(_) {
            switch (_) {
            case "Strict":
                return "strict";
            case "None":
                return "none";
            case "Lax":
                return "lax";
            default:
                return "lax"
            }
        }
        function g(_) {
            switch (_) {
            case "strict":
                return "Strict";
            case "lax":
                return "Lax";
            case "none":
                return "None"
            }
            throw new n.InvalidArgumentException(`Unknown 'sameSite' value ${_}`)
        }
        function y(_) {
            return ["ftp", "file", "http", "https", "ws", "wss"].includes(_.replace(/:$/, ""))
        }
        function m(_) {
            return _.protocol.replace(/:$/, "")
        }
        function w(_, A) {
            const C = new URL(A);
            return !(_.protocol !== void 0 && _.protocol !== m(C) || _.hostname !== void 0 && _.hostname !== C.hostname || _.port !== void 0 && _.port !== C.port || _.pathname !== void 0 && _.pathname !== C.pathname || _.search !== void 0 && _.search !== C.search)
        }
        function E(_) {
            let A = 0;
            for (const C of _)
                A += atob(C.bytes ?? "").length;
            return A
        }
        function v(_, A=0) {
            return !_ || _ <= 0 || _ + A <= 0 ? 0 : _ + A
        }
        return qt
    }
    var gM;
    function yM() {
        var s, i, a, mC, Rg, l;
        if (gM)
            return bf;
        gM = 1,
        Object.defineProperty(bf, "__esModule", {
            value: !0
        }),
        bf.NetworkProcessor = void 0;
        const n = mt()
          , e = db();
        let t = (l = class {
            constructor(h, f) {
                b(this, a);
                b(this, s);
                b(this, i);
                S(this, s, h),
                S(this, i, f)
            }
            async addIntercept(h) {
                o(this, s).verifyTopLevelContextsList(h.contexts);
                const f = h.urlPatterns ?? []
                  , p = l.parseUrlPatterns(f)
                  , g = o(this, i).addIntercept({
                    urlPatterns: p,
                    phases: h.phases,
                    contexts: h.contexts
                });
                return await Promise.all(o(this, s).getAllContexts().map(y => y.cdpTarget.toggleNetwork())),
                {
                    intercept: g
                }
            }
            async continueRequest(h) {
                if (h.url !== void 0 && l.parseUrlString(h.url),
                h.method !== void 0 && !l.isMethodValid(h.method))
                    throw new n.InvalidArgumentException(`Method '${h.method}' is invalid.`);
                h.headers && l.validateHeaders(h.headers);
                const f = P(this, a, Rg).call(this, h.request, ["beforeRequestSent"]);
                try {
                    await f.continueRequest(h)
                } catch (p) {
                    throw l.wrapInterceptionError(p)
                }
                return {}
            }
            async continueResponse(h) {
                h.headers && l.validateHeaders(h.headers);
                const f = P(this, a, Rg).call(this, h.request, ["authRequired", "responseStarted"]);
                try {
                    await f.continueResponse(h)
                } catch (p) {
                    throw l.wrapInterceptionError(p)
                }
                return {}
            }
            async continueWithAuth(h) {
                const f = h.request;
                return await P(this, a, Rg).call(this, f, ["authRequired"]).continueWithAuth(h),
                {}
            }
            async failRequest({request: h}) {
                const f = P(this, a, mC).call(this, h);
                if (f.interceptPhase === "authRequired")
                    throw new n.InvalidArgumentException(`Request '${h}' in 'authRequired' phase cannot be failed`);
                if (!f.interceptPhase)
                    throw new n.NoSuchRequestException(`No blocked request found for network id '${h}'`);
                return await f.failRequest("Failed"),
                {}
            }
            async provideResponse(h) {
                h.headers && l.validateHeaders(h.headers);
                const f = P(this, a, Rg).call(this, h.request, ["beforeRequestSent", "responseStarted", "authRequired"]);
                try {
                    await f.provideResponse(h)
                } catch (p) {
                    throw l.wrapInterceptionError(p)
                }
                return {}
            }
            async removeIntercept(h) {
                return o(this, i).removeIntercept(h.intercept),
                await Promise.all(o(this, s).getAllContexts().map(f => f.cdpTarget.toggleNetwork())),
                {}
            }
            async setCacheBehavior(h) {
                const f = o(this, s).verifyTopLevelContextsList(h.contexts);
                if (f.size === 0)
                    return o(this, i).defaultCacheBehavior = h.cacheBehavior,
                    await Promise.all(o(this, s).getAllContexts().map(g => g.cdpTarget.toggleSetCacheDisabled())),
                    {};
                const p = h.cacheBehavior === "bypass";
                return await Promise.all([...f.values()].map(g => g.cdpTarget.toggleSetCacheDisabled(p))),
                {}
            }
            static validateHeaders(h) {
                for (const f of h) {
                    let p;
                    if (f.value.type === "string" ? p = f.value.value : p = atob(f.value.value),
                    p !== p.trim() || p.includes(`
`) || p.includes("\0"))
                        throw new n.InvalidArgumentException(`Header value '${p}' is not acceptable value`)
                }
            }
            static isMethodValid(h) {
                return /^[!#$%&'*+\-.^_`|~a-zA-Z\d]+$/.test(h)
            }
            static parseUrlString(h) {
                try {
                    return new URL(h)
                } catch (f) {
                    throw new n.InvalidArgumentException(`Invalid URL '${h}': ${f}`)
                }
            }
            static parseUrlPatterns(h) {
                return h.map(f => {
                    let p = ""
                      , g = !0
                      , y = !0
                      , m = !0
                      , w = !0
                      , E = !0;
                    switch (f.type) {
                    case "string":
                        {
                            p = r(f.pattern);
                            break
                        }
                    case "pattern":
                        {
                            if (f.protocol === void 0)
                                g = !1,
                                p += "http";
                            else {
                                if (f.protocol === "")
                                    throw new n.InvalidArgumentException("URL pattern must specify a protocol");
                                if (f.protocol = r(f.protocol),
                                !f.protocol.match(/^[a-zA-Z+-.]+$/))
                                    throw new n.InvalidArgumentException("Forbidden characters");
                                p += f.protocol
                            }
                            const _ = p.toLocaleLowerCase();
                            if (p += ":",
                            (0,
                            e.isSpecialScheme)(_) && (p += "//"),
                            f.hostname === void 0)
                                _ !== "file" && (p += "placeholder"),
                                y = !1;
                            else {
                                if (f.hostname === "")
                                    throw new n.InvalidArgumentException("URL pattern must specify a hostname");
                                if (f.protocol === "file")
                                    throw new n.InvalidArgumentException("URL pattern protocol cannot be 'file'");
                                f.hostname = r(f.hostname);
                                let A = !1;
                                for (const C of f.hostname) {
                                    if (C === "/" || C === "?" || C === "#")
                                        throw new n.InvalidArgumentException("'/', '?', '#' are forbidden in hostname");
                                    if (!A && C === ":")
                                        throw new n.InvalidArgumentException("':' is only allowed inside brackets in hostname");
                                    C === "[" && (A = !0),
                                    C === "]" && (A = !1)
                                }
                                p += f.hostname
                            }
                            if (f.port === void 0)
                                m = !1;
                            else {
                                if (f.port === "")
                                    throw new n.InvalidArgumentException("URL pattern must specify a port");
                                if (f.port = r(f.port),
                                p += ":",
                                !f.port.match(/^\d+$/))
                                    throw new n.InvalidArgumentException("Forbidden characters");
                                p += f.port
                            }
                            if (f.pathname === void 0)
                                w = !1;
                            else {
                                if (f.pathname = r(f.pathname),
                                f.pathname[0] !== "/" && (p += "/"),
                                f.pathname.includes("#") || f.pathname.includes("?"))
                                    throw new n.InvalidArgumentException("Forbidden characters");
                                p += f.pathname
                            }
                            if (f.search === void 0)
                                E = !1;
                            else {
                                if (f.search = r(f.search),
                                f.search[0] !== "?" && (p += "?"),
                                f.search.includes("#"))
                                    throw new n.InvalidArgumentException("Forbidden characters");
                                p += f.search
                            }
                            break
                        }
                    }
                    const v = _ => {
                        const A = {
                            "ftp:": 21,
                            "file:": null,
                            "http:": 80,
                            "https:": 443,
                            "ws:": 80,
                            "wss:": 443
                        };
                        if ((0,
                        e.isSpecialScheme)(_.protocol) && A[_.protocol] !== null && (!_.port || String(A[_.protocol]) === _.port))
                            return "";
                        if (_.port)
                            return _.port
                    }
                    ;
                    try {
                        const _ = new URL(p);
                        return {
                            protocol: g ? _.protocol.replace(/:$/, "") : void 0,
                            hostname: y ? _.hostname : void 0,
                            port: m ? v(_) : void 0,
                            pathname: w && _.pathname ? _.pathname : void 0,
                            search: E ? _.search : void 0
                        }
                    } catch (_) {
                        throw new n.InvalidArgumentException(`${_.message} '${p}'`)
                    }
                }
                )
            }
            static wrapInterceptionError(h) {
                return h != null && h.message.includes("Invalid header") ? new n.InvalidArgumentException("Invalid header") : h
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakSet,
        mC = function(h) {
            const f = o(this, i).getRequestById(h);
            if (!f)
                throw new n.NoSuchRequestException(`Network request with ID '${h}' doesn't exist`);
            return f
        }
        ,
        Rg = function(h, f) {
            const p = P(this, a, mC).call(this, h);
            if (!p.interceptPhase)
                throw new n.NoSuchRequestException(`No blocked request found for network id '${h}'`);
            if (p.interceptPhase && !f.includes(p.interceptPhase))
                throw new n.InvalidArgumentException(`Blocked request for network id '${h}' is in '${p.interceptPhase}' phase`);
            return p
        }
        ,
        l);
        bf.NetworkProcessor = t;
        function r(d) {
            const h = new Set(["(", ")", "*", "{", "}"]);
            let f = ""
              , p = !1;
            for (const g of d) {
                if (!p) {
                    if (h.has(g))
                        throw new n.InvalidArgumentException("Forbidden characters");
                    if (g === "\\") {
                        p = !0;
                        continue
                    }
                }
                f += g,
                p = !1
            }
            return f
        }
        return bf
    }
    var vf = {}, wM;
    function Bz() {
        var t, r;
        if (wM)
            return vf;
        wM = 1,
        Object.defineProperty(vf, "__esModule", {
            value: !0
        }),
        vf.PermissionsProcessor = void 0;
        const n = mt();
        let e = (r = class {
            constructor(i) {
                b(this, t);
                S(this, t, i)
            }
            async setPermissions(i) {
                try {
                    const a = i["goog:userContext"] || i.userContext;
                    await o(this, t).sendCommand("Browser.setPermission", {
                        origin: i.origin,
                        browserContextId: a && a !== "default" ? a : void 0,
                        permission: {
                            name: i.descriptor.name
                        },
                        setting: i.state
                    })
                } catch (a) {
                    if (a.message === "Permission can't be granted to opaque origins.")
                        return {};
                    throw new n.InvalidArgumentException(a.message)
                }
                return {}
            }
        }
        ,
        t = new WeakMap,
        r);
        return vf.PermissionsProcessor = e,
        vf
    }
    var _f = {}
      , Sf = {}
      , hb = {};
    const qz = We(Object.freeze(Object.defineProperty({
        __proto__: null,
        default: {}
    }, Symbol.toStringTag, {
        value: "Module"
    })));
    var bM;
    function Bu() {
        if (bM)
            return hb;
        bM = 1,
        Object.defineProperty(hb, "__esModule", {
            value: !0
        }),
        hb.uuidv4 = e;
        function n(t) {
            return t.reduce( (r, s) => r + s.toString(16).padStart(2, "0"), "")
        }
        function e() {
            if ("crypto"in globalThis && "randomUUID"in globalThis.crypto)
                return globalThis.crypto.randomUUID();
            const t = new Uint8Array(16);
            return "crypto"in globalThis && "getRandomValues"in globalThis.crypto ? globalThis.crypto.getRandomValues(t) : qz.webcrypto.getRandomValues(t),
            t[6] = t[6] & 15 | 64,
            t[8] = t[8] & 63 | 128,
            [n(t.subarray(0, 4)), n(t.subarray(4, 6)), n(t.subarray(6, 8)), n(t.subarray(8, 10)), n(t.subarray(10, 16))].join("-")
        }
        return hb
    }
    var Ef = {}, vM;
    function _M() {
        var s, i, a, c, u, gC, bL, vL, f, yC, _L;
        if (vM)
            return Ef;
        vM = 1,
        Object.defineProperty(Ef, "__esModule", {
            value: !0
        }),
        Ef.ChannelProxy = void 0;
        const n = mt()
          , e = vn()
          , t = Bu();
        let r = (u = class {
            constructor(m, w) {
                b(this, f);
                b(this, s);
                b(this, i, (0,
                t.uuidv4)());
                b(this, a);
                S(this, s, m),
                S(this, a, w)
            }
            async init(m, w) {
                var _, A;
                const E = await P(_ = u, c, bL).call(_, m)
                  , v = await P(A = u, c, vL).call(A, m, E);
                return P(this, f, yC).call(this, m, E, w),
                v
            }
            async startListenerFromWindow(m, w) {
                var E;
                try {
                    const v = await P(this, f, _L).call(this, m);
                    P(this, f, yC).call(this, m, v, w)
                } catch (v) {
                    (E = o(this, a)) == null || E.call(this, e.LogType.debugError, v)
                }
            }
            getEvalInWindowStr() {
                var E;
                const m = String( (v, _) => {
                    const A = window;
                    return A[v] === void 0 ? A[v] = _ : (A[v](_),
                    delete A[v]),
                    _.sendMessage
                }
                )
                  , w = P(E = u, c, gC).call(E);
                return `(${m})('${o(this, i)}',${w})`
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakSet,
        gC = function() {
            return `(${String( () => {
                const w = [];
                let E = null;
                return {
                    async getMessage() {
                        return await (w.length > 0 ? Promise.resolve() : new Promise(_ => {
                            E = _
                        }
                        )),
                        w.shift()
                    },
                    sendMessage(v) {
                        w.push(v),
                        E !== null && (E(),
                        E = null)
                    }
                }
            }
            )})()`
        }
        ,
        bL = async function(m) {
            const w = await m.cdpClient.sendCommand("Runtime.evaluate", {
                expression: P(this, c, gC).call(this),
                contextId: m.executionContextId,
                serializationOptions: {
                    serialization: "idOnly"
                }
            });
            if (w.exceptionDetails || w.result.objectId === void 0)
                throw new Error("Cannot create channel");
            return w.result.objectId
        }
        ,
        vL = async function(m, w) {
            return (await m.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String(v => v.sendMessage),
                arguments: [{
                    objectId: w
                }],
                executionContextId: m.executionContextId,
                serializationOptions: {
                    serialization: "idOnly"
                }
            })).result.objectId
        }
        ,
        f = new WeakSet,
        yC = async function(m, w, E) {
            var v, _;
            for (; ; )
                try {
                    const A = await m.cdpClient.sendCommand("Runtime.callFunctionOn", {
                        functionDeclaration: String(async C => await C.getMessage()),
                        arguments: [{
                            objectId: w
                        }],
                        awaitPromise: !0,
                        executionContextId: m.executionContextId,
                        serializationOptions: {
                            serialization: "deep",
                            maxDepth: ((v = o(this, s).serializationOptions) == null ? void 0 : v.maxObjectDepth) ?? void 0
                        }
                    });
                    if (A.exceptionDetails)
                        throw new Error("Runtime.callFunctionOn in ChannelProxy",{
                            cause: A.exceptionDetails
                        });
                    for (const C of m.associatedBrowsingContexts)
                        E.registerEvent({
                            type: "event",
                            method: n.ChromiumBidi.Script.EventNames.Message,
                            params: {
                                channel: o(this, s).channel,
                                data: m.cdpToBidiValue(A, o(this, s).ownership ?? "none"),
                                source: m.source
                            }
                        }, C.id)
                } catch (A) {
                    (_ = o(this, a)) == null || _.call(this, e.LogType.debugError, A);
                    break
                }
        }
        ,
        _L = async function(m) {
            const w = await m.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String(E => {
                    const v = window;
                    if (v[E] === void 0)
                        return new Promise(A => v[E] = A);
                    const _ = v[E];
                    return delete v[E],
                    _
                }
                ),
                arguments: [{
                    value: o(this, i)
                }],
                executionContextId: m.executionContextId,
                awaitPromise: !0,
                serializationOptions: {
                    serialization: "idOnly"
                }
            });
            if (w.exceptionDetails !== void 0 || w.result.objectId === void 0)
                throw new Error(`ChannelHandle not found in window["${o(this, i)}"]`);
            return w.result.objectId
        }
        ,
        b(u, c),
        u);
        return Ef.ChannelProxy = r,
        Ef
    }
    var SM;
    function Uz() {
        var r, s, i, a, c, u, l, d, SL, f;
        if (SM)
            return Sf;
        SM = 1,
        Object.defineProperty(Sf, "__esModule", {
            value: !0
        }),
        Sf.PreloadScript = void 0;
        const n = Bu()
          , e = _M();
        let t = (f = class {
            constructor(g, y) {
                b(this, d);
                b(this, r, (0,
                n.uuidv4)());
                b(this, s, []);
                b(this, i);
                b(this, a, new Set);
                b(this, c);
                b(this, u);
                b(this, l);
                var m;
                S(this, c, ((m = g.arguments) == null ? void 0 : m.map(w => new e.ChannelProxy(w.value,y))) ?? []),
                S(this, i, g.functionDeclaration),
                S(this, u, g.sandbox),
                S(this, l, g.contexts)
            }
            get id() {
                return o(this, r)
            }
            get targetIds() {
                return o(this, a)
            }
            get channels() {
                return o(this, c)
            }
            get contexts() {
                return o(this, l)
            }
            async initInTargets(g, y) {
                await Promise.all(Array.from(g).map(m => this.initInTarget(m, y)))
            }
            async initInTarget(g, y) {
                const m = await g.cdpClient.sendCommand("Page.addScriptToEvaluateOnNewDocument", {
                    source: P(this, d, SL).call(this),
                    worldName: o(this, u),
                    runImmediately: y
                });
                o(this, s).push({
                    target: g,
                    preloadScriptId: m.identifier
                }),
                o(this, a).add(g.id)
            }
            async remove() {
                await Promise.all([o(this, s).map(async g => {
                    const y = g.target
                      , m = g.preloadScriptId;
                    return await y.cdpClient.sendCommand("Page.removeScriptToEvaluateOnNewDocument", {
                        identifier: m
                    })
                }
                )])
            }
            dispose(g) {
                S(this, s, o(this, s).filter(y => {
                    var m;
                    return ((m = y.target) == null ? void 0 : m.id) !== g
                }
                )),
                o(this, a).delete(g)
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakSet,
        SL = function() {
            const g = `[${this.channels.map(y => y.getEvalInWindowStr()).join(", ")}]`;
            return `(()=>{(${o(this, i)})(...${g})})()`
        }
        ,
        f);
        return Sf.PreloadScript = t,
        Sf
    }
    var EM;
    function Kz() {
        var r, s, i, a, c, u, EL, Xb, h;
        if (EM)
            return _f;
        EM = 1,
        Object.defineProperty(_f, "__esModule", {
            value: !0
        }),
        _f.ScriptProcessor = void 0;
        const n = mt()
          , e = Uz();
        let t = (h = class {
            constructor(p, g, y, m, w) {
                b(this, u);
                b(this, r);
                b(this, s);
                b(this, i);
                b(this, a);
                b(this, c);
                S(this, s, g),
                S(this, i, y),
                S(this, a, m),
                S(this, c, w),
                S(this, r, p),
                o(this, r).addSubscribeHook(n.ChromiumBidi.Script.EventNames.RealmCreated, P(this, u, EL).bind(this))
            }
            async addPreloadScript(p) {
                const g = o(this, s).verifyTopLevelContextsList(p.contexts)
                  , y = new e.PreloadScript(p,o(this, c));
                o(this, a).add(y);
                const m = g.size === 0 ? new Set(o(this, s).getTopLevelContexts().map(w => w.cdpTarget)) : new Set([...g.values()].map(w => w.cdpTarget));
                return await y.initInTargets(m, !1),
                {
                    script: y.id
                }
            }
            async removePreloadScript(p) {
                const {script: g} = p
                  , y = o(this, a).find({
                    id: g
                });
                if (y.length === 0)
                    throw new n.NoSuchScriptException(`No preload script with id '${g}'`);
                return await Promise.all(y.map(m => m.remove())),
                o(this, a).remove({
                    id: g
                }),
                {}
            }
            async callFunction(p) {
                return await (await P(this, u, Xb).call(this, p.target)).callFunction(p.functionDeclaration, p.awaitPromise, p.this, p.arguments, p.resultOwnership, p.serializationOptions, p.userActivation)
            }
            async evaluate(p) {
                return await (await P(this, u, Xb).call(this, p.target)).evaluate(p.expression, p.awaitPromise, p.resultOwnership, p.serializationOptions, p.userActivation)
            }
            async disown(p) {
                const g = await P(this, u, Xb).call(this, p.target);
                return await Promise.all(p.handles.map(async y => await g.disown(y))),
                {}
            }
            getRealms(p) {
                return p.context !== void 0 && o(this, s).getContext(p.context),
                {
                    realms: o(this, i).findRealms({
                        browsingContextId: p.context,
                        type: p.type
                    }).map(y => y.realmInfo)
                }
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakSet,
        EL = function(p) {
            const g = o(this, s).getContext(p)
              , y = [g, ...o(this, s).getContext(p).allChildren]
              , m = new Set;
            for (const w of y) {
                const E = o(this, i).findRealms({
                    browsingContextId: w.id
                });
                for (const v of E)
                    m.add(v)
            }
            for (const w of m)
                o(this, r).registerEvent({
                    type: "event",
                    method: n.ChromiumBidi.Script.EventNames.RealmCreated,
                    params: w.realmInfo
                }, g.id);
            return Promise.resolve()
        }
        ,
        Xb = async function(p) {
            return "context"in p ? await o(this, s).getContext(p.context).getOrCreateSandbox(p.sandbox) : o(this, i).getRealm({
                realmId: p.realm
            })
        }
        ,
        h);
        return _f.ScriptProcessor = t,
        _f
    }
    var xf = {}, xM;
    function Hz() {
        var t, r, s, i, a, xL, CL, l;
        if (xM)
            return xf;
        xM = 1,
        Object.defineProperty(xf, "__esModule", {
            value: !0
        }),
        xf.SessionProcessor = void 0;
        const n = mt();
        let e = (l = class {
            constructor(h, f, p) {
                b(this, a);
                b(this, t);
                b(this, r);
                b(this, s);
                b(this, i, !1);
                S(this, t, h),
                S(this, r, f),
                S(this, s, p)
            }
            status() {
                return {
                    ready: !1,
                    message: "already connected"
                }
            }
            async new(h) {
                if (o(this, i))
                    throw new Error("Session has been already created.");
                S(this, i, !0);
                const f = P(this, a, xL).call(this, h.capabilities);
                await o(this, s).call(this, f);
                const p = await o(this, r).sendCommand("Browser.getVersion");
                return {
                    sessionId: "unknown",
                    capabilities: {
                        ...f,
                        acceptInsecureCerts: f.acceptInsecureCerts ?? !1,
                        browserName: p.product,
                        browserVersion: p.revision,
                        platformName: "",
                        setWindowRect: !1,
                        webSocketUrl: "",
                        userAgent: p.userAgent
                    }
                }
            }
            async subscribe(h, f={}) {
                return {
                    subscription: await o(this, t).subscribe(h.events, h.contexts ?? [], f)
                }
            }
            async unsubscribe(h, f={}) {
                return await o(this, t).unsubscribe(h.events, h.contexts ?? [], f),
                {}
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakSet,
        xL = function(h) {
            const f = [];
            for (const g of h.firstMatch ?? [{}]) {
                const y = {
                    ...h.alwaysMatch
                };
                for (const m of Object.keys(g)) {
                    if (y[m] !== void 0)
                        throw new n.InvalidArgumentException(`Capability ${m} in firstMatch is already defined in alwaysMatch`);
                    y[m] = g[m]
                }
                f.push(y)
            }
            const p = f.find(g => g.browserName === "chrome") ?? f[0] ?? {};
            return p.unhandledPromptBehavior = P(this, a, CL).call(this, p.unhandledPromptBehavior),
            p
        }
        ,
        CL = function(h) {
            if (h !== void 0) {
                if (typeof h == "object")
                    return h;
                if (typeof h != "string")
                    throw new n.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' type: ${typeof h}`);
                switch (h) {
                case "accept":
                case "accept and notify":
                    return {
                        default: "accept"
                    };
                case "dismiss":
                case "dismiss and notify":
                    return {
                        default: "dismiss"
                    };
                case "ignore":
                    return {
                        default: "ignore"
                    };
                default:
                    throw new n.InvalidArgumentException(`Unexpected 'unhandledPromptBehavior' value: ${h}`)
                }
            }
        }
        ,
        l);
        return xf.SessionProcessor = e,
        xf
    }
    var Cf = {}, CM;
    function Wz() {
        var a, c, u, l, Yb, Mg, kL, PL, Qb, wC, m;
        if (CM)
            return Cf;
        CM = 1,
        Object.defineProperty(Cf, "__esModule", {
            value: !0
        }),
        Cf.StorageProcessor = void 0;
        const n = mt()
          , e = mo()
          , t = vn()
          , r = yM()
          , s = db();
        let i = (m = class {
            constructor(E, v, _) {
                b(this, l);
                b(this, a);
                b(this, c);
                b(this, u);
                S(this, c, v),
                S(this, a, E),
                S(this, u, _)
            }
            async deleteCookies(E) {
                const v = P(this, l, Qb).call(this, E.partition);
                let _;
                try {
                    _ = await o(this, a).sendCommand("Storage.getCookies", {
                        browserContextId: P(this, l, Mg).call(this, v)
                    })
                } catch (C) {
                    throw P(this, l, Yb).call(this, C) ? new n.NoSuchUserContextException(C.message) : C
                }
                const A = _.cookies.filter(C => {
                    var k;
                    return v.sourceOrigin === void 0 || ((k = C.partitionKey) == null ? void 0 : k.topLevelSite) === v.sourceOrigin
                }
                ).filter(C => {
                    const k = (0,
                    s.cdpToBiDiCookie)(C);
                    return P(this, l, wC).call(this, k, E.filter)
                }
                ).map(C => ({
                    ...C,
                    expires: 1
                }));
                return await o(this, a).sendCommand("Storage.setCookies", {
                    cookies: A,
                    browserContextId: P(this, l, Mg).call(this, v)
                }),
                {
                    partitionKey: v
                }
            }
            async getCookies(E) {
                const v = P(this, l, Qb).call(this, E.partition);
                let _;
                try {
                    _ = await o(this, a).sendCommand("Storage.getCookies", {
                        browserContextId: P(this, l, Mg).call(this, v)
                    })
                } catch (C) {
                    throw P(this, l, Yb).call(this, C) ? new n.NoSuchUserContextException(C.message) : C
                }
                return {
                    cookies: _.cookies.filter(C => {
                        var k;
                        return v.sourceOrigin === void 0 || ((k = C.partitionKey) == null ? void 0 : k.topLevelSite) === v.sourceOrigin
                    }
                    ).map(C => (0,
                    s.cdpToBiDiCookie)(C)).filter(C => P(this, l, wC).call(this, C, E.filter)),
                    partitionKey: v
                }
            }
            async setCookie(E) {
                var A;
                const v = P(this, l, Qb).call(this, E.partition)
                  , _ = (0,
                s.bidiToCdpCookie)(E, v);
                try {
                    await o(this, a).sendCommand("Storage.setCookies", {
                        cookies: [_],
                        browserContextId: P(this, l, Mg).call(this, v)
                    })
                } catch (C) {
                    throw P(this, l, Yb).call(this, C) ? new n.NoSuchUserContextException(C.message) : ((A = o(this, u)) == null || A.call(this, t.LogType.debugError, C),
                    new n.UnableToSetCookieException(C.toString()))
                }
                return {
                    partitionKey: v
                }
            }
        }
        ,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakSet,
        Yb = function(E) {
            var v;
            return (v = E.message) == null ? void 0 : v.startsWith("Failed to find browser context for id")
        }
        ,
        Mg = function(E) {
            return E.userContext === "default" ? void 0 : E.userContext
        }
        ,
        kL = function(E) {
            const v = E.context;
            return {
                userContext: o(this, c).getContext(v).userContext
            }
        }
        ,
        PL = function(E) {
            var C;
            const v = new Map;
            let _ = E.sourceOrigin;
            if (_ !== void 0) {
                const k = r.NetworkProcessor.parseUrlString(_);
                k.origin === "null" ? _ = k.origin : _ = `${k.protocol}//${k.hostname}`
            }
            for (const [k,x] of Object.entries(E))
                k !== void 0 && x !== void 0 && !["type", "sourceOrigin", "userContext"].includes(k) && v.set(k, x);
            return v.size > 0 && ((C = o(this, u)) == null || C.call(this, t.LogType.debugInfo, `Unsupported partition keys: ${JSON.stringify(Object.fromEntries(v))}`)),
            {
                userContext: E.userContext ?? "default",
                ..._ === void 0 ? {} : {
                    sourceOrigin: _
                }
            }
        }
        ,
        Qb = function(E) {
            return E === void 0 ? {
                userContext: "default"
            } : E.type === "context" ? P(this, l, kL).call(this, E) : ((0,
            e.assert)(E.type === "storageKey", "Unknown partition type"),
            P(this, l, PL).call(this, E))
        }
        ,
        wC = function(E, v) {
            return v === void 0 ? !0 : (v.domain === void 0 || v.domain === E.domain) && (v.name === void 0 || v.name === E.name) && (v.value === void 0 || (0,
            s.deserializeByteValue)(v.value) === (0,
            s.deserializeByteValue)(E.value)) && (v.path === void 0 || v.path === E.path) && (v.size === void 0 || v.size === E.size) && (v.httpOnly === void 0 || v.httpOnly === E.httpOnly) && (v.secure === void 0 || v.secure === E.secure) && (v.sameSite === void 0 || v.sameSite === E.sameSite) && (v.expiry === void 0 || v.expiry === E.expiry)
        }
        ,
        m);
        return Cf.StorageProcessor = i,
        Cf
    }
    var kf = {}, kM;
    function NE() {
        var e, t, r;
        if (kM)
            return kf;
        kM = 1,
        Object.defineProperty(kf, "__esModule", {
            value: !0
        }),
        kf.OutgoingMessage = void 0;
        let n = (r = class {
            constructor(i, a) {
                b(this, e);
                b(this, t);
                S(this, e, i),
                S(this, t, a)
            }
            static createFromPromise(i, a) {
                return i.then(c => c.kind === "success" ? {
                    kind: "success",
                    value: new r(c.value,a)
                } : c)
            }
            static createResolved(i, a) {
                return Promise.resolve({
                    kind: "success",
                    value: new r(i,a)
                })
            }
            get message() {
                return o(this, e)
            }
            get channel() {
                return o(this, t)
            }
        }
        ,
        e = new WeakMap,
        t = new WeakMap,
        r);
        return kf.OutgoingMessage = n,
        kf
    }
    var PM;
    function zz() {
        var y, m, w, E, v, _, A, C, k, x, N, R, F, TL, ev, L;
        if (PM)
            return of;
        PM = 1,
        Object.defineProperty(of, "__esModule", {
            value: !0
        }),
        of.CommandProcessor = void 0;
        const n = mt()
          , e = ju()
          , t = vn()
          , r = Pz()
          , s = Tz()
          , i = Az()
          , a = Iz()
          , c = jz()
          , u = yM()
          , l = Bz()
          , d = Kz()
          , h = Hz()
          , f = Wz()
          , p = NE();
        let g = (L = class extends e.EventEmitter {
            constructor(j, $, B, D, z, G, ee, V, K=new r.BidiNoOpParser, se, ye) {
                super();
                b(this, F);
                b(this, y);
                b(this, m);
                b(this, w);
                b(this, E);
                b(this, v);
                b(this, _);
                b(this, A);
                b(this, C);
                b(this, k);
                b(this, x);
                b(this, N);
                b(this, R);
                S(this, N, K),
                S(this, R, ye),
                S(this, y, V),
                S(this, m, new s.BrowserProcessor($,D)),
                S(this, w, new a.BrowsingContextProcessor($,D,B)),
                S(this, E, new i.CdpProcessor(D,z,j,$)),
                S(this, v, new c.InputProcessor(D)),
                S(this, _, new u.NetworkProcessor(D,ee)),
                S(this, A, new l.PermissionsProcessor($)),
                S(this, C, new d.ScriptProcessor(B,D,z,G,ye)),
                S(this, k, new h.SessionProcessor(B,$,se)),
                S(this, x, new f.StorageProcessor($,D,ye))
            }
            async processCommand(j) {
                var $;
                try {
                    const B = await P(this, F, TL).call(this, j)
                      , D = {
                        type: "success",
                        id: j.id,
                        result: B
                    };
                    this.emit("response", {
                        message: p.OutgoingMessage.createResolved(D, j.channel),
                        event: j.method
                    })
                } catch (B) {
                    if (B instanceof n.Exception)
                        this.emit("response", {
                            message: p.OutgoingMessage.createResolved(B.toErrorResponse(j.id), j.channel),
                            event: j.method
                        });
                    else {
                        const D = B;
                        ($ = o(this, R)) == null || $.call(this, t.LogType.bidi, D),
                        this.emit("response", {
                            message: p.OutgoingMessage.createResolved(new n.UnknownErrorException(D.message,D.stack).toErrorResponse(j.id), j.channel),
                            event: j.method
                        })
                    }
                }
            }
        }
        ,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakMap,
        x = new WeakMap,
        N = new WeakMap,
        R = new WeakMap,
        F = new WeakSet,
        TL = async function(j) {
            switch (j.method) {
            case "bluetooth.handleRequestDevicePrompt":
                return await o(this, y).handleRequestDevicePrompt(o(this, N).parseHandleRequestDevicePromptParams(j.params));
            case "bluetooth.simulateAdapter":
                return await o(this, y).simulateAdapter(o(this, N).parseSimulateAdapterParameters(j.params));
            case "bluetooth.simulateAdvertisement":
                return await o(this, y).simulateAdvertisement(o(this, N).parseSimulateAdvertisementParameters(j.params));
            case "bluetooth.simulatePreconnectedPeripheral":
                return await o(this, y).simulatePreconnectedPeripheral(o(this, N).parseSimulatePreconnectedPeripheralParameters(j.params));
            case "browser.close":
                return o(this, m).close();
            case "browser.createUserContext":
                return await o(this, m).createUserContext(j.params);
            case "browser.getClientWindows":
                return await o(this, m).getClientWindows();
            case "browser.getUserContexts":
                return await o(this, m).getUserContexts();
            case "browser.removeUserContext":
                return await o(this, m).removeUserContext(o(this, N).parseRemoveUserContextParams(j.params));
            case "browser.setClientWindowState":
                throw new n.UnknownErrorException(`Method ${j.method} is not implemented.`);
            case "browsingContext.activate":
                return await o(this, w).activate(o(this, N).parseActivateParams(j.params));
            case "browsingContext.captureScreenshot":
                return await o(this, w).captureScreenshot(o(this, N).parseCaptureScreenshotParams(j.params));
            case "browsingContext.close":
                return await o(this, w).close(o(this, N).parseCloseParams(j.params));
            case "browsingContext.create":
                return await o(this, w).create(o(this, N).parseCreateParams(j.params));
            case "browsingContext.getTree":
                return o(this, w).getTree(o(this, N).parseGetTreeParams(j.params));
            case "browsingContext.handleUserPrompt":
                return await o(this, w).handleUserPrompt(o(this, N).parseHandleUserPromptParams(j.params));
            case "browsingContext.locateNodes":
                return await o(this, w).locateNodes(o(this, N).parseLocateNodesParams(j.params));
            case "browsingContext.navigate":
                return await o(this, w).navigate(o(this, N).parseNavigateParams(j.params));
            case "browsingContext.print":
                return await o(this, w).print(o(this, N).parsePrintParams(j.params));
            case "browsingContext.reload":
                return await o(this, w).reload(o(this, N).parseReloadParams(j.params));
            case "browsingContext.setViewport":
                return await o(this, w).setViewport(o(this, N).parseSetViewportParams(j.params));
            case "browsingContext.traverseHistory":
                return await o(this, w).traverseHistory(o(this, N).parseTraverseHistoryParams(j.params));
            case "goog:cdp.getSession":
                return o(this, E).getSession(o(this, N).parseGetSessionParams(j.params));
            case "goog:cdp.resolveRealm":
                return o(this, E).resolveRealm(o(this, N).parseResolveRealmParams(j.params));
            case "goog:cdp.sendCommand":
                return await o(this, E).sendCommand(o(this, N).parseSendCommandParams(j.params));
            case "cdp.getSession":
                return o(this, E).getSession(o(this, N).parseGetSessionParams(j.params));
            case "cdp.resolveRealm":
                return o(this, E).resolveRealm(o(this, N).parseResolveRealmParams(j.params));
            case "cdp.sendCommand":
                return await o(this, E).sendCommand(o(this, N).parseSendCommandParams(j.params));
            case "input.performActions":
                return await o(this, v).performActions(o(this, N).parsePerformActionsParams(j.params));
            case "input.releaseActions":
                return await o(this, v).releaseActions(o(this, N).parseReleaseActionsParams(j.params));
            case "input.setFiles":
                return await o(this, v).setFiles(o(this, N).parseSetFilesParams(j.params));
            case "network.addIntercept":
                return await o(this, _).addIntercept(o(this, N).parseAddInterceptParams(j.params));
            case "network.continueRequest":
                return await o(this, _).continueRequest(o(this, N).parseContinueRequestParams(j.params));
            case "network.continueResponse":
                return await o(this, _).continueResponse(o(this, N).parseContinueResponseParams(j.params));
            case "network.continueWithAuth":
                return await o(this, _).continueWithAuth(o(this, N).parseContinueWithAuthParams(j.params));
            case "network.failRequest":
                return await o(this, _).failRequest(o(this, N).parseFailRequestParams(j.params));
            case "network.provideResponse":
                return await o(this, _).provideResponse(o(this, N).parseProvideResponseParams(j.params));
            case "network.removeIntercept":
                return await o(this, _).removeIntercept(o(this, N).parseRemoveInterceptParams(j.params));
            case "network.setCacheBehavior":
                return await o(this, _).setCacheBehavior(o(this, N).parseSetCacheBehavior(j.params));
            case "permissions.setPermission":
                return await o(this, A).setPermissions(o(this, N).parseSetPermissionsParams(j.params));
            case "script.addPreloadScript":
                return await o(this, C).addPreloadScript(o(this, N).parseAddPreloadScriptParams(j.params));
            case "script.callFunction":
                return await o(this, C).callFunction(o(this, N).parseCallFunctionParams(P(this, F, ev).call(this, j.params)));
            case "script.disown":
                return await o(this, C).disown(o(this, N).parseDisownParams(P(this, F, ev).call(this, j.params)));
            case "script.evaluate":
                return await o(this, C).evaluate(o(this, N).parseEvaluateParams(P(this, F, ev).call(this, j.params)));
            case "script.getRealms":
                return o(this, C).getRealms(o(this, N).parseGetRealmsParams(j.params));
            case "script.removePreloadScript":
                return await o(this, C).removePreloadScript(o(this, N).parseRemovePreloadScriptParams(j.params));
            case "session.end":
                throw new n.UnknownErrorException(`Method ${j.method} is not implemented.`);
            case "session.new":
                return await o(this, k).new(j.params);
            case "session.status":
                return o(this, k).status();
            case "session.subscribe":
                return await o(this, k).subscribe(o(this, N).parseSubscribeParams(j.params), j.channel);
            case "session.unsubscribe":
                return await o(this, k).unsubscribe(o(this, N).parseSubscribeParams(j.params), j.channel);
            case "storage.deleteCookies":
                return await o(this, x).deleteCookies(o(this, N).parseDeleteCookiesParams(j.params));
            case "storage.getCookies":
                return await o(this, x).getCookies(o(this, N).parseGetCookiesParams(j.params));
            case "storage.setCookie":
                return await o(this, x).setCookie(o(this, N).parseSetCookieParams(j.params));
            case "webExtension.install":
                throw new n.UnknownErrorException(`Method ${j.method} is not implemented.`);
            case "webExtension.uninstall":
                throw new n.UnknownErrorException(`Method ${j.method} is not implemented.`)
            }
            throw new n.UnknownCommandException(`Unknown command '${j == null ? void 0 : j.method}'.`)
        }
        ,
        ev = function(j) {
            return typeof j == "object" && j && "target"in j && typeof j.target == "object" && j.target && "context"in j.target && delete j.target.realm,
            j
        }
        ,
        L);
        return of.CommandProcessor = g,
        of
    }
    var Pf = {}, TM;
    function Vz() {
        var e, t, r;
        if (TM)
            return Pf;
        TM = 1,
        Object.defineProperty(Pf, "__esModule", {
            value: !0
        }),
        Pf.BluetoothProcessor = void 0;
        let n = (r = class {
            constructor(i, a) {
                b(this, e);
                b(this, t);
                S(this, e, i),
                S(this, t, a)
            }
            async simulateAdapter(i) {
                const a = o(this, t).getContext(i.context);
                return await a.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.disable"),
                await a.cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.enable", {
                    state: i.state
                }),
                {}
            }
            async simulatePreconnectedPeripheral(i) {
                return await o(this, t).getContext(i.context).cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.simulatePreconnectedPeripheral", {
                    address: i.address,
                    name: i.name,
                    knownServiceUuids: i.knownServiceUuids,
                    manufacturerData: i.manufacturerData
                }),
                {}
            }
            async simulateAdvertisement(i) {
                return await o(this, t).getContext(i.context).cdpTarget.browserCdpClient.sendCommand("BluetoothEmulation.simulateAdvertisement", {
                    entry: i.scanEntry
                }),
                {}
            }
            onCdpTargetCreated(i) {
                i.cdpClient.on("DeviceAccess.deviceRequestPrompted", a => {
                    o(this, e).registerEvent({
                        type: "event",
                        method: "bluetooth.requestDevicePromptUpdated",
                        params: {
                            context: i.id,
                            prompt: a.id,
                            devices: a.devices
                        }
                    }, i.id)
                }
                )
            }
            async handleRequestDevicePrompt(i) {
                const a = o(this, t).getContext(i.context);
                return i.accept ? await a.cdpTarget.cdpClient.sendCommand("DeviceAccess.selectPrompt", {
                    id: i.prompt,
                    deviceId: i.device
                }) : await a.cdpTarget.cdpClient.sendCommand("DeviceAccess.cancelPrompt", {
                    id: i.prompt
                }),
                {}
            }
        }
        ,
        e = new WeakMap,
        t = new WeakMap,
        r);
        return Pf.BluetoothProcessor = n,
        Pf
    }
    var Tf = {}, qu = {}, Af = {}, AM;
    function fb() {
        var e, t, r, s, i, a, c;
        if (AM)
            return Af;
        AM = 1,
        Object.defineProperty(Af, "__esModule", {
            value: !0
        }),
        Af.Deferred = void 0;
        let n = (e = Symbol.toStringTag,
        c = class {
            constructor() {
                b(this, t, !1);
                b(this, r);
                b(this, s);
                b(this, i);
                b(this, a);
                J(this, e, "Promise");
                S(this, r, new Promise( (l, d) => {
                    S(this, i, l),
                    S(this, a, d)
                }
                )),
                o(this, r).catch(l => {}
                )
            }
            get isFinished() {
                return o(this, t)
            }
            get result() {
                if (!o(this, t))
                    throw new Error("Deferred is not finished yet");
                return o(this, s)
            }
            then(l, d) {
                return o(this, r).then(l, d)
            }
            catch(l) {
                return o(this, r).catch(l)
            }
            resolve(l) {
                S(this, s, l),
                o(this, t) || (S(this, t, !0),
                o(this, i).call(this, l))
            }
            reject(l) {
                o(this, t) || (S(this, t, !0),
                o(this, a).call(this, l))
            }
            finally(l) {
                return o(this, r).finally(l)
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c);
        return Af.Deferred = n,
        Af
    }
    var pb = {}, IM;
    function OM() {
        if (IM)
            return pb;
        IM = 1,
        Object.defineProperty(pb, "__esModule", {
            value: !0
        }),
        pb.getTimestamp = n;
        function n() {
            return new Date().getTime()
        }
        return pb
    }
    var mb = {}, RM;
    function Gz() {
        if (RM)
            return mb;
        RM = 1,
        Object.defineProperty(mb, "__esModule", {
            value: !0
        }),
        mb.inchesFromCm = n;
        function n(e) {
            return e / 2.54
        }
        return mb
    }
    var If = {}, Of = {}, MM;
    function NM() {
        var i, a, c, u, l, d, h, f, bC, g, AL, vC, _C, IL, SC, EC, OL, RL, xC;
        if (MM)
            return Of;
        MM = 1,
        Object.defineProperty(Of, "__esModule", {
            value: !0
        }),
        Of.Realm = void 0;
        const n = mt()
          , e = vn()
          , t = Bu()
          , r = _M()
          , x = class x {
            constructor(R, F, O, T, L, q, Z) {
                b(this, f);
                b(this, i);
                b(this, a);
                b(this, c);
                b(this, u);
                b(this, l);
                b(this, d);
                b(this, h);
                S(this, i, R),
                S(this, a, F),
                S(this, c, O),
                S(this, u, T),
                S(this, l, L),
                S(this, d, q),
                S(this, h, Z),
                o(this, h).addRealm(this)
            }
            cdpToBidiValue(R, F) {
                const O = this.serializeForBiDi(R.result.deepSerializedValue, new Map);
                if (R.result.objectId) {
                    const T = R.result.objectId;
                    F === "root" ? (O.handle = T,
                    o(this, h).knownHandlesToRealmMap.set(T, this.realmId)) : P(this, f, xC).call(this, T).catch(L => {
                        var q;
                        return (q = o(this, u)) == null ? void 0 : q.call(this, e.LogType.debugError, L)
                    }
                    )
                }
                return O
            }
            serializeForBiDi(R, F) {
                if (Object.hasOwn(R, "weakLocalObjectReference")) {
                    const T = R.weakLocalObjectReference;
                    F.has(T) || F.set(T, (0,
                    t.uuidv4)()),
                    R.internalId = F.get(T),
                    delete R.weakLocalObjectReference
                }
                if (R.type === "node" && R.value && Object.hasOwn(R.value, "frameId") && delete R.value.frameId,
                R.type === "platformobject")
                    return {
                        type: "object"
                    };
                const O = R.value;
                if (O === void 0)
                    return R;
                if (["array", "set", "htmlcollection", "nodelist"].includes(R.type))
                    for (const T in O)
                        O[T] = this.serializeForBiDi(O[T], F);
                if (["object", "map"].includes(R.type))
                    for (const T in O)
                        O[T] = [this.serializeForBiDi(O[T][0], F), this.serializeForBiDi(O[T][1], F)];
                return R
            }
            get realmId() {
                return o(this, d)
            }
            get executionContextId() {
                return o(this, c)
            }
            get origin() {
                return o(this, l)
            }
            get source() {
                return {
                    realm: this.realmId
                }
            }
            get cdpClient() {
                return o(this, i)
            }
            get baseInfo() {
                return {
                    realm: this.realmId,
                    origin: this.origin
                }
            }
            async evaluate(R, F, O="none", T={}, L=!1, q=!1) {
                var j;
                const Z = await this.cdpClient.sendCommand("Runtime.evaluate", {
                    contextId: this.executionContextId,
                    expression: R,
                    awaitPromise: F,
                    serializationOptions: P(j = x, g, EC).call(j, "deep", T),
                    userGesture: L,
                    includeCommandLineAPI: q
                });
                return Z.exceptionDetails ? await P(this, f, SC).call(this, Z.exceptionDetails, 0, O) : {
                    realm: this.realmId,
                    result: this.cdpToBidiValue(Z, O),
                    type: "success"
                }
            }
            initialize() {
                P(this, f, bC).call(this, {
                    type: "event",
                    method: n.ChromiumBidi.Script.EventNames.RealmCreated,
                    params: this.realmInfo
                })
            }
            async serializeCdpObject(R, F) {
                var L;
                const O = P(L = x, g, AL).call(L, R)
                  , T = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                    functionDeclaration: String(q => q),
                    awaitPromise: !1,
                    arguments: [O],
                    serializationOptions: {
                        serialization: "deep"
                    },
                    executionContextId: this.executionContextId
                });
                return this.cdpToBidiValue(T, F)
            }
            async stringifyObject(R) {
                const {result: F} = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                    functionDeclaration: String(O => String(O)),
                    awaitPromise: !1,
                    arguments: [R],
                    returnByValue: !0,
                    executionContextId: this.executionContextId
                });
                return F.value
            }
            async callFunction(R, F, O={
                type: "undefined"
            }, T=[], L="none", q={}, Z=!1) {
                var D;
                const j = `(...args) => {
      function callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }
      return callFunction((
        ${R}
      ), args);
    }`
                  , $ = [await this.deserializeForCdp(O), ...await Promise.all(T.map(async z => await this.deserializeForCdp(z)))];
                let B;
                try {
                    B = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                        functionDeclaration: j,
                        awaitPromise: F,
                        arguments: $,
                        serializationOptions: P(D = x, g, EC).call(D, "deep", q),
                        executionContextId: this.executionContextId,
                        userGesture: Z
                    })
                } catch (z) {
                    throw z.code === -32e3 && ["Could not find object with given id", "Argument should belong to the same JavaScript world as target object", "Invalid remote object id"].includes(z.message) ? new n.NoSuchHandleException("Handle was not found.") : z
                }
                return B.exceptionDetails ? await P(this, f, SC).call(this, B.exceptionDetails, 1, L) : {
                    type: "success",
                    result: this.cdpToBidiValue(B, L),
                    realm: this.realmId
                }
            }
            async deserializeForCdp(R) {
                if ("handle"in R && R.handle)
                    return {
                        objectId: R.handle
                    };
                if ("handle"in R || "sharedId"in R)
                    throw new n.NoSuchHandleException("Handle was not found.");
                switch (R.type) {
                case "undefined":
                    return {
                        unserializableValue: "undefined"
                    };
                case "null":
                    return {
                        unserializableValue: "null"
                    };
                case "string":
                    return {
                        value: R.value
                    };
                case "number":
                    return R.value === "NaN" ? {
                        unserializableValue: "NaN"
                    } : R.value === "-0" ? {
                        unserializableValue: "-0"
                    } : R.value === "Infinity" ? {
                        unserializableValue: "Infinity"
                    } : R.value === "-Infinity" ? {
                        unserializableValue: "-Infinity"
                    } : {
                        value: R.value
                    };
                case "boolean":
                    return {
                        value: !!R.value
                    };
                case "bigint":
                    return {
                        unserializableValue: `BigInt(${JSON.stringify(R.value)})`
                    };
                case "date":
                    return {
                        unserializableValue: `new Date(Date.parse(${JSON.stringify(R.value)}))`
                    };
                case "regexp":
                    return {
                        unserializableValue: `new RegExp(${JSON.stringify(R.value.pattern)}, ${JSON.stringify(R.value.flags)})`
                    };
                case "map":
                    {
                        const F = await P(this, f, vC).call(this, R.value)
                          , {result: O} = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                            functionDeclaration: String( (...T) => {
                                const L = new Map;
                                for (let q = 0; q < T.length; q += 2)
                                    L.set(T[q], T[q + 1]);
                                return L
                            }
                            ),
                            awaitPromise: !1,
                            arguments: F,
                            returnByValue: !1,
                            executionContextId: this.executionContextId
                        });
                        return {
                            objectId: O.objectId
                        }
                    }
                case "object":
                    {
                        const F = await P(this, f, vC).call(this, R.value)
                          , {result: O} = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                            functionDeclaration: String( (...T) => {
                                const L = {};
                                for (let q = 0; q < T.length; q += 2) {
                                    const Z = T[q];
                                    L[Z] = T[q + 1]
                                }
                                return L
                            }
                            ),
                            awaitPromise: !1,
                            arguments: F,
                            returnByValue: !1,
                            executionContextId: this.executionContextId
                        });
                        return {
                            objectId: O.objectId
                        }
                    }
                case "array":
                    {
                        const F = await P(this, f, _C).call(this, R.value)
                          , {result: O} = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                            functionDeclaration: String( (...T) => T),
                            awaitPromise: !1,
                            arguments: F,
                            returnByValue: !1,
                            executionContextId: this.executionContextId
                        });
                        return {
                            objectId: O.objectId
                        }
                    }
                case "set":
                    {
                        const F = await P(this, f, _C).call(this, R.value)
                          , {result: O} = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                            functionDeclaration: String( (...T) => new Set(T)),
                            awaitPromise: !1,
                            arguments: F,
                            returnByValue: !1,
                            executionContextId: this.executionContextId
                        });
                        return {
                            objectId: O.objectId
                        }
                    }
                case "channel":
                    return {
                        objectId: await new r.ChannelProxy(R.value,o(this, u)).init(this, o(this, a))
                    }
                }
                throw new Error(`Value ${JSON.stringify(R)} is not deserializable.`)
            }
            async disown(R) {
                o(this, h).knownHandlesToRealmMap.get(R) === this.realmId && (await P(this, f, xC).call(this, R),
                o(this, h).knownHandlesToRealmMap.delete(R))
            }
            dispose() {
                P(this, f, bC).call(this, {
                    type: "event",
                    method: n.ChromiumBidi.Script.EventNames.RealmDestroyed,
                    params: {
                        realm: this.realmId
                    }
                })
            }
        }
        ;
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakSet,
        bC = function(R) {
            if (this.associatedBrowsingContexts.length === 0)
                o(this, a).registerGlobalEvent(R);
            else
                for (const F of this.associatedBrowsingContexts)
                    o(this, a).registerEvent(R, F.id)
        }
        ,
        g = new WeakSet,
        AL = function(R) {
            return R.objectId !== void 0 ? {
                objectId: R.objectId
            } : R.unserializableValue !== void 0 ? {
                unserializableValue: R.unserializableValue
            } : {
                value: R.value
            }
        }
        ,
        vC = async function(R) {
            return (await Promise.all(R.map(async ([O,T]) => {
                let L;
                typeof O == "string" ? L = {
                    value: O
                } : L = await this.deserializeForCdp(O);
                const q = await this.deserializeForCdp(T);
                return [L, q]
            }
            ))).flat()
        }
        ,
        _C = async function(R) {
            return await Promise.all(R.map(F => this.deserializeForCdp(F)))
        }
        ,
        IL = async function(R, F, O) {
            var q;
            const T = ((q = R.stackTrace) == null ? void 0 : q.callFrames.map(Z => ({
                url: Z.url,
                functionName: Z.functionName,
                lineNumber: Z.lineNumber - F,
                columnNumber: Z.columnNumber
            }))) ?? []
              , L = R.exception;
            return {
                exception: await this.serializeCdpObject(L, O),
                columnNumber: R.columnNumber,
                lineNumber: R.lineNumber - F,
                stackTrace: {
                    callFrames: T
                },
                text: await this.stringifyObject(L) || R.text
            }
        }
        ,
        SC = async function(R, F, O) {
            return {
                exceptionDetails: await P(this, f, IL).call(this, R, F, O),
                realm: this.realmId,
                type: "exception"
            }
        }
        ,
        EC = function(R, F) {
            var O, T;
            return {
                serialization: R,
                additionalParameters: P(O = x, g, OL).call(O, F),
                ...P(T = x, g, RL).call(T, F)
            }
        }
        ,
        OL = function(R) {
            const F = {};
            return R.maxDomDepth !== void 0 && (F.maxNodeDepth = R.maxDomDepth === null ? 1e3 : R.maxDomDepth),
            R.includeShadowTree !== void 0 && (F.includeShadowTree = R.includeShadowTree),
            F
        }
        ,
        RL = function(R) {
            return R.maxObjectDepth === void 0 || R.maxObjectDepth === null ? {} : {
                maxDepth: R.maxObjectDepth
            }
        }
        ,
        xC = async function(R) {
            try {
                await this.cdpClient.sendCommand("Runtime.releaseObject", {
                    objectId: R
                })
            } catch (F) {
                if (!(F.code === -32e3 && F.message === "Invalid remote object id"))
                    throw F
            }
        }
        ,
        b(x, g);
        let s = x;
        return Of.Realm = s,
        Of
    }
    var Rf = {}, $M;
    function Jz() {
        if ($M)
            return Rf;
        $M = 1,
        Object.defineProperty(Rf, "__esModule", {
            value: !0
        }),
        Rf.getSharedId = e,
        Rf.parseSharedId = r;
        const n = "_element_";
        function e(s, i, a) {
            return `f.${s}.d.${i}.e.${a}`
        }
        function t(s) {
            const i = s.match(new RegExp(`(.*)${n}(.*)`));
            if (!i)
                return null;
            const a = i[1]
              , c = i[2];
            if (a === void 0 || c === void 0)
                return null;
            const u = parseInt(c ?? "");
            return isNaN(u) ? null : {
                documentId: a,
                backendNodeId: u
            }
        }
        function r(s) {
            const i = t(s);
            if (i !== null)
                return {
                    ...i,
                    frameId: void 0
                };
            const a = s.match(/f\.(.*)\.d\.(.*)\.e\.([0-9]*)/);
            if (!a)
                return null;
            const c = a[1]
              , u = a[2]
              , l = a[3];
            if (c === void 0 || u === void 0 || l === void 0)
                return null;
            const d = parseInt(l ?? "");
            return isNaN(d) ? null : {
                frameId: c,
                documentId: u,
                backendNodeId: d
            }
        }
        return Rf
    }
    var LM;
    function FM() {
        var s, i, a, ML;
        if (LM)
            return If;
        LM = 1,
        Object.defineProperty(If, "__esModule", {
            value: !0
        }),
        If.WindowRealm = void 0;
        const n = mt()
          , e = NM()
          , t = Jz();
        class r extends e.Realm {
            constructor(d, h, f, p, g, y, m, w, E, v) {
                super(f, p, g, y, m, w, E);
                b(this, a);
                b(this, s);
                b(this, i);
                J(this, "sandbox");
                S(this, s, d),
                S(this, i, h),
                this.sandbox = v,
                this.initialize()
            }
            get browsingContext() {
                return o(this, i).getContext(o(this, s))
            }
            get associatedBrowsingContexts() {
                return [this.browsingContext]
            }
            get realmType() {
                return "window"
            }
            get realmInfo() {
                return {
                    ...this.baseInfo,
                    type: this.realmType,
                    context: o(this, s),
                    sandbox: this.sandbox
                }
            }
            get source() {
                return {
                    realm: this.realmId,
                    context: this.browsingContext.id
                }
            }
            serializeForBiDi(d, h) {
                const f = d.value;
                if (d.type === "node" && f !== void 0) {
                    if (Object.hasOwn(f, "backendNodeId")) {
                        let p = this.browsingContext.navigableId ?? "UNKNOWN";
                        Object.hasOwn(f, "loaderId") && (p = f.loaderId,
                        delete f.loaderId),
                        d.sharedId = (0,
                        t.getSharedId)(P(this, a, ML).call(this, p), p, f.backendNodeId),
                        delete f.backendNodeId
                    }
                    if (Object.hasOwn(f, "children"))
                        for (const p in f.children)
                            f.children[p] = this.serializeForBiDi(f.children[p], h);
                    Object.hasOwn(f, "shadowRoot") && f.shadowRoot !== null && (f.shadowRoot = this.serializeForBiDi(f.shadowRoot, h)),
                    f.namespaceURI === "" && (f.namespaceURI = null)
                }
                return super.serializeForBiDi(d, h)
            }
            async deserializeForCdp(d) {
                if ("sharedId"in d && d.sharedId) {
                    const h = (0,
                    t.parseSharedId)(d.sharedId);
                    if (h === null)
                        throw new n.NoSuchNodeException(`SharedId "${d.sharedId}" was not found.`);
                    const {documentId: f, backendNodeId: p} = h;
                    if (this.browsingContext.navigableId !== f)
                        throw new n.NoSuchNodeException(`SharedId "${d.sharedId}" belongs to different document. Current document is ${this.browsingContext.navigableId}.`);
                    try {
                        const {object: g} = await this.cdpClient.sendCommand("DOM.resolveNode", {
                            backendNodeId: p,
                            executionContextId: this.executionContextId
                        });
                        return {
                            objectId: g.objectId
                        }
                    } catch (g) {
                        throw g.code === -32e3 && g.message === "No node with given id found" ? new n.NoSuchNodeException(`SharedId "${d.sharedId}" was not found.`) : new n.UnknownErrorException(g.message,g.stack)
                    }
                }
                return await super.deserializeForCdp(d)
            }
            async evaluate(d, h, f, p, g, y) {
                return await o(this, i).getContext(o(this, s)).targetUnblockedOrThrow(),
                await super.evaluate(d, h, f, p, g, y)
            }
            async callFunction(d, h, f, p, g, y, m) {
                return await o(this, i).getContext(o(this, s)).targetUnblockedOrThrow(),
                await super.callFunction(d, h, f, p, g, y, m)
            }
        }
        return s = new WeakMap,
        i = new WeakMap,
        a = new WeakSet,
        ML = function(d) {
            const h = o(this, i).getAllContexts().find(f => f.navigableId === d);
            return (h == null ? void 0 : h.id) ?? "UNKNOWN"
        }
        ,
        If.WindowRealm = r,
        If
    }
    var Zs = {}, gb = {}, jM;
    function Zz() {
        if (jM)
            return gb;
        jM = 1,
        Object.defineProperty(gb, "__esModule", {
            value: !0
        }),
        gb.urlMatchesAboutBlank = n;
        function n(e) {
            if (e === "")
                return !0;
            try {
                const t = new URL(e);
                return t.protocol.replace(/:$/, "").toLowerCase() === "about" && t.pathname.toLowerCase() === "blank" && t.username === "" && t.password === "" && t.host === ""
            } catch (t) {
                if (t instanceof TypeError)
                    return !1;
                throw t
            }
        }
        return gb
    }
    var DM;
    function Xz() {
        var l, d, h, f, p, g, y, tv, w, E, v, _, A, C, k, x, NL, R;
        if (DM)
            return Zs;
        DM = 1,
        Object.defineProperty(Zs, "__esModule", {
            value: !0
        }),
        Zs.NavigationTracker = Zs.NavigationState = Zs.NavigationResult = void 0;
        const n = mt()
          , e = fb()
          , t = vn()
          , r = OM()
          , s = Zz()
          , i = Bu();
        class a {
            constructor(O, T) {
                J(this, "eventName");
                J(this, "message");
                this.eventName = O,
                this.message = T
            }
        }
        Zs.NavigationResult = a;
        class c {
            constructor(O, T, L, q) {
                b(this, y);
                J(this, "navigationId", (0,
                i.uuidv4)());
                b(this, l);
                b(this, d, !1);
                b(this, h, new e.Deferred);
                J(this, "url");
                J(this, "loaderId");
                b(this, f);
                b(this, p);
                b(this, g, !1);
                J(this, "isFragmentNavigation");
                S(this, l, T),
                this.url = O,
                S(this, f, L),
                S(this, p, q)
            }
            get finished() {
                return o(this, h)
            }
            navigationInfo() {
                return {
                    context: o(this, l),
                    navigation: this.navigationId,
                    timestamp: (0,
                    r.getTimestamp)(),
                    url: this.url
                }
            }
            start() {
                !o(this, f) && !o(this, d) && o(this, p).registerEvent({
                    type: "event",
                    method: n.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted,
                    params: this.navigationInfo()
                }, o(this, l)),
                S(this, d, !0)
            }
            frameNavigated() {
                S(this, g, !0)
            }
            fragmentNavigated() {
                S(this, g, !0),
                P(this, y, tv).call(this, new a("browsingContext.fragmentNavigated"))
            }
            load() {
                P(this, y, tv).call(this, new a("browsingContext.load"))
            }
            fail(O) {
                P(this, y, tv).call(this, new a(o(this, g) ? "browsingContext.navigationAborted" : "browsingContext.navigationFailed",O))
            }
        }
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakSet,
        tv = function(O) {
            S(this, d, !0),
            !o(this, f) && !o(this, h).isFinished && O.eventName !== "browsingContext.load" && o(this, p).registerEvent({
                type: "event",
                method: O.eventName,
                params: this.navigationInfo()
            }, o(this, l)),
            o(this, h).resolve(O)
        }
        ,
        Zs.NavigationState = c;
        let u = (R = class {
            constructor(O, T, L, q) {
                b(this, x);
                b(this, w);
                b(this, E);
                b(this, v, new Map);
                b(this, _);
                b(this, A);
                b(this, C);
                b(this, k, !0);
                S(this, _, T),
                S(this, w, L),
                S(this, E, q),
                S(this, k, !0),
                S(this, A, new c(O,T,(0,
                s.urlMatchesAboutBlank)(O),o(this, w)))
            }
            get currentNavigationId() {
                var O;
                return ((O = o(this, C)) == null ? void 0 : O.loaderId) !== void 0 ? o(this, C).navigationId : o(this, A).navigationId
            }
            get isInitialNavigation() {
                return o(this, k)
            }
            get url() {
                return o(this, A).url
            }
            createPendingNavigation(O, T=!1) {
                var q, Z;
                (q = o(this, E)) == null || q.call(this, t.LogType.debug, "createCommandNavigation"),
                S(this, k, T && o(this, k) && (0,
                s.urlMatchesAboutBlank)(O)),
                (Z = o(this, C)) == null || Z.fail("navigation canceled by concurrent navigation");
                const L = new c(O,o(this, _),o(this, k),o(this, w));
                return S(this, C, L),
                L
            }
            dispose() {
                var O;
                (O = o(this, C)) == null || O.fail("navigation canceled by context disposal"),
                o(this, A).fail("navigation canceled by context disposal")
            }
            onTargetInfoChanged(O) {
                var T;
                (T = o(this, E)) == null || T.call(this, t.LogType.debug, `onTargetInfoChanged ${O}`),
                o(this, A).url = O
            }
            frameNavigated(O, T, L) {
                var Z;
                if ((Z = o(this, E)) == null || Z.call(this, t.LogType.debug, `frameNavigated ${O}`),
                L !== void 0 && !o(this, v).has(T)) {
                    const j = o(this, C) ?? this.createPendingNavigation(L, !0);
                    j.url = L,
                    j.start(),
                    j.fail("the requested url is unreachable");
                    return
                }
                const q = P(this, x, NL).call(this, O, T);
                q.frameNavigated(),
                q !== o(this, A) && o(this, A).fail("navigation canceled by concurrent navigation"),
                q.url = O,
                q.loaderId = T,
                o(this, v).set(T, q),
                q.start(),
                S(this, A, q),
                o(this, C) === q && S(this, C, void 0)
            }
            navigatedWithinDocument(O, T) {
                var q;
                if ((q = o(this, E)) == null || q.call(this, t.LogType.debug, `navigatedWithinDocument ${O}, ${T}`),
                o(this, A).url = O,
                T !== "fragment")
                    return;
                const L = o(this, C) !== void 0 && o(this, C).loaderId === void 0 ? o(this, C) : new c(O,o(this, _),!1,o(this, w));
                L.fragmentNavigated(),
                L === o(this, C) && S(this, C, void 0)
            }
            frameRequestedNavigation(O) {
                var T;
                (T = o(this, E)) == null || T.call(this, t.LogType.debug, `Page.frameRequestedNavigation ${O}`),
                this.createPendingNavigation(O, !0)
            }
            loadPageEvent(O) {
                var T, L;
                (T = o(this, E)) == null || T.call(this, t.LogType.debug, "loadPageEvent"),
                S(this, k, !1),
                (L = o(this, v).get(O)) == null || L.load()
            }
            failNavigation(O, T) {
                var L;
                (L = o(this, E)) == null || L.call(this, t.LogType.debug, "failCommandNavigation"),
                O.fail(T)
            }
            navigationCommandFinished(O, T) {
                var L;
                (L = o(this, E)) == null || L.call(this, t.LogType.debug, `finishCommandNavigation ${O.navigationId}, ${T}`),
                T !== void 0 && (O.loaderId = T,
                o(this, v).set(T, O)),
                O.isFragmentNavigation = T === void 0,
                !(T === void 0 || o(this, A) === O) && (o(this, A).fail("navigation canceled by concurrent navigation"),
                O.start(),
                S(this, A, O),
                o(this, C) === O && S(this, C, void 0))
            }
            frameStartedNavigating(O, T) {
                var q;
                if ((q = o(this, E)) == null || q.call(this, t.LogType.debug, `frameStartedNavigating ${O}, ${T}`),
                o(this, v).has(T))
                    return;
                const L = o(this, C) ?? this.createPendingNavigation(O, !0);
                L.url = O,
                L.start(),
                L.loaderId = T,
                o(this, v).set(T, L)
            }
            beforeunload() {
                var O, T;
                if ((O = o(this, E)) == null || O.call(this, t.LogType.debug, "beforeunload"),
                o(this, C) === void 0) {
                    (T = o(this, E)) == null || T.call(this, t.LogType.debugError, "Unexpectedly no pending navigation on beforeunload");
                    return
                }
                o(this, C).start()
            }
            networkLoadingFailed(O, T) {
                var L;
                (L = o(this, v).get(O)) == null || L.fail(T)
            }
        }
        ,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakMap,
        x = new WeakSet,
        NL = function(O, T) {
            var L;
            return o(this, v).has(T) ? o(this, v).get(T) : o(this, C) !== void 0 && ((L = o(this, C)) == null ? void 0 : L.loaderId) === void 0 ? o(this, C) : this.createPendingNavigation(O, !0)
        }
        ,
        R);
        return Zs.NavigationTracker = u,
        Zs
    }
    var BM;
    function qM() {
        var m, w, E, v, _, A, C, k, x, N, R, F, O, T, L, q, Z, j, rv, CC, D, $L, LL, nv, kC, FL, PC, jL, DL, BL;
        if (BM)
            return qu;
        BM = 1;
        var n;
        Object.defineProperty(qu, "__esModule", {
            value: !0
        }),
        qu.BrowsingContextImpl = void 0,
        qu.serializeOrigin = d;
        const e = mt()
          , t = mo()
          , r = fb()
          , s = vn()
          , i = OM()
          , a = Gz()
          , c = FM()
          , u = Xz();
        let l = (m = class {
            constructor(I, M, U, W, X, te, ae, xe, ce, Pe, we) {
                b(this, j);
                b(this, w, new Set);
                b(this, E);
                J(this, "userContext");
                b(this, v);
                b(this, _, null);
                b(this, A, {
                    width: 0,
                    height: 0
                });
                b(this, C);
                b(this, k, {
                    DOMContentLoaded: new r.Deferred,
                    load: new r.Deferred
                });
                b(this, x);
                b(this, N, new r.Deferred);
                b(this, R);
                b(this, F);
                b(this, O);
                b(this, T);
                b(this, L);
                b(this, q);
                b(this, Z);
                S(this, x, W),
                S(this, E, I),
                S(this, _, M),
                this.userContext = U,
                S(this, F, X),
                S(this, R, te),
                S(this, L, ae),
                S(this, q, Pe),
                S(this, O, we),
                S(this, C, ce),
                S(this, T, new u.NavigationTracker(xe,I,X,we))
            }
            static create(I, M, U, W, X, te, ae, xe, ce, Pe, we) {
                var Q;
                const H = new n(I,M,U,W,X,te,ae,xe,ce,Pe,we);
                return P(Q = H, j, CC).call(Q),
                te.addContext(H),
                H.isTopLevelContext() || H.parent.addChild(H.id),
                X.registerPromiseEvent(H.targetUnblockedOrThrow().then( () => ({
                    kind: "success",
                    value: {
                        type: "event",
                        method: e.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
                        params: {
                            ...H.serializeToBidiValue(),
                            url: xe
                        }
                    }
                }), ie => ({
                    kind: "error",
                    error: ie
                })), H.id, e.ChromiumBidi.BrowsingContext.EventNames.ContextCreated),
                H
            }
            get navigableId() {
                return o(this, v)
            }
            get navigationId() {
                return o(this, T).currentNavigationId
            }
            dispose(I) {
                o(this, T).dispose(),
                P(this, j, rv).call(this),
                o(this, L).deleteRealms({
                    browsingContextId: this.id
                }),
                this.isTopLevelContext() || o(this.parent, w).delete(this.id),
                P(this, j, FL).call(this),
                I && o(this, F).registerEvent({
                    type: "event",
                    method: e.ChromiumBidi.BrowsingContext.EventNames.ContextDestroyed,
                    params: this.serializeToBidiValue()
                }, this.id),
                o(this, F).clearBufferedEvents(this.id),
                o(this, R).deleteContextById(this.id)
            }
            get id() {
                return o(this, E)
            }
            get parentId() {
                return o(this, _)
            }
            set parentId(I) {
                var M;
                if (o(this, _) !== null) {
                    (M = o(this, O)) == null || M.call(this, s.LogType.debugError, "Parent context already set");
                    return
                }
                S(this, _, I),
                this.isTopLevelContext() || this.parent.addChild(this.id)
            }
            get parent() {
                return this.parentId === null ? null : o(this, R).getContext(this.parentId)
            }
            get directChildren() {
                return [...o(this, w)].map(I => o(this, R).getContext(I))
            }
            get allChildren() {
                const I = this.directChildren;
                return I.concat(...I.map(M => M.allChildren))
            }
            isTopLevelContext() {
                return o(this, _) === null
            }
            get top() {
                let I = this
                  , M = I.parent;
                for (; M; )
                    I = M,
                    M = I.parent;
                return I
            }
            addChild(I) {
                o(this, w).add(I)
            }
            get cdpTarget() {
                return o(this, x)
            }
            updateCdpTarget(I) {
                S(this, x, I),
                P(this, j, CC).call(this)
            }
            get url() {
                return o(this, T).url
            }
            async lifecycleLoaded() {
                await o(this, k).load
            }
            async targetUnblockedOrThrow() {
                const I = await o(this, x).unblocked;
                if (I.kind === "error")
                    throw I.error
            }
            async getOrCreateSandbox(I) {
                if (I === void 0 || I === "")
                    return await o(this, N);
                let M = o(this, L).findRealms({
                    browsingContextId: this.id,
                    sandbox: I
                });
                return M.length === 0 && (await o(this, x).cdpClient.sendCommand("Page.createIsolatedWorld", {
                    frameId: this.id,
                    worldName: I
                }),
                M = o(this, L).findRealms({
                    browsingContextId: this.id,
                    sandbox: I
                }),
                (0,
                t.assert)(M.length !== 0)),
                M[0]
            }
            serializeToBidiValue(I=0, M=!0) {
                return {
                    context: o(this, E),
                    url: this.url,
                    userContext: this.userContext,
                    originalOpener: o(this, C) ?? null,
                    clientWindow: "",
                    children: I > 0 ? this.directChildren.map(U => U.serializeToBidiValue(I - 1, !1)) : null,
                    ...M ? {
                        parent: o(this, _)
                    } : {}
                }
            }
            onTargetInfoChanged(I) {
                o(this, T).onTargetInfoChanged(I.targetInfo.url)
            }
            async navigate(I, M) {
                try {
                    new URL(I)
                } catch {
                    throw new e.InvalidArgumentException(`Invalid URL: ${I}`)
                }
                const U = o(this, T).createPendingNavigation(I)
                  , W = (async () => {
                    const te = await o(this, x).cdpClient.sendCommand("Page.navigate", {
                        url: I,
                        frameId: this.id
                    });
                    if (te.errorText)
                        throw o(this, T).failNavigation(U, te.errorText),
                        new e.UnknownErrorException(te.errorText);
                    o(this, T).navigationCommandFinished(U, te.loaderId),
                    P(this, j, nv).call(this, te.loaderId)
                }
                )()
                  , X = await Promise.race([P(this, j, PC).call(this, M, W, U), U.finished]);
                if (X instanceof u.NavigationResult && (X.eventName === "browsingContext.navigationAborted" || X.eventName === "browsingContext.navigationFailed"))
                    throw new e.UnknownErrorException(X.message ?? "unknown exception");
                return {
                    navigation: U.navigationId,
                    url: U.url
                }
            }
            async reload(I, M) {
                await this.targetUnblockedOrThrow(),
                P(this, j, kC).call(this);
                const U = o(this, T).createPendingNavigation(o(this, T).url)
                  , W = o(this, x).cdpClient.sendCommand("Page.reload", {
                    ignoreCache: I
                })
                  , X = await Promise.race([P(this, j, PC).call(this, M, W, U), U.finished]);
                if (X instanceof u.NavigationResult && (X.eventName === "browsingContext.navigationAborted" || X.eventName === "browsingContext.navigationFailed"))
                    throw new e.UnknownErrorException(X.message ?? "unknown exception");
                return {
                    navigation: U.navigationId,
                    url: U.url
                }
            }
            async setViewport(I, M) {
                if (I === null && M === null)
                    await o(this, x).cdpClient.sendCommand("Emulation.clearDeviceMetricsOverride");
                else
                    try {
                        let U;
                        I === void 0 ? U = o(this, A) : I === null ? U = {
                            width: 0,
                            height: 0
                        } : U = I,
                        S(this, A, U),
                        await o(this, x).cdpClient.sendCommand("Emulation.setDeviceMetricsOverride", {
                            width: o(this, A).width,
                            height: o(this, A).height,
                            deviceScaleFactor: M || 0,
                            mobile: !1,
                            dontSetVisibleSize: !0
                        })
                    } catch (U) {
                        throw U.message.startsWith("Width and height values must be positive") ? new e.UnsupportedOperationException("Provided viewport dimensions are not supported") : U
                    }
            }
            async handleUserPrompt(I, M) {
                await o(this, x).cdpClient.sendCommand("Page.handleJavaScriptDialog", {
                    accept: I ?? !0,
                    promptText: M
                })
            }
            async activate() {
                await o(this, x).cdpClient.sendCommand("Page.bringToFront")
            }
            async captureScreenshot(I) {
                if (!this.isTopLevelContext())
                    throw new e.UnsupportedOperationException(`Non-top-level 'context' (${I.context}) is currently not supported`);
                const M = h(I);
                let U = !1, W;
                switch (I.origin ?? (I.origin = "viewport"),
                I.origin) {
                case "document":
                    {
                        W = String( () => {
                            const ce = document.documentElement;
                            return {
                                x: 0,
                                y: 0,
                                width: ce.scrollWidth,
                                height: ce.scrollHeight
                            }
                        }
                        ),
                        U = !0;
                        break
                    }
                case "viewport":
                    {
                        W = String( () => {
                            const ce = window.visualViewport;
                            return {
                                x: ce.pageLeft,
                                y: ce.pageTop,
                                width: ce.width,
                                height: ce.height
                            }
                        }
                        );
                        break
                    }
                }
                const te = await (await this.getOrCreateSandbox(void 0)).callFunction(W, !1);
                (0,
                t.assert)(te.type === "success");
                const ae = f(te.result);
                (0,
                t.assert)(ae);
                let xe = ae;
                if (I.clip) {
                    const ce = I.clip;
                    I.origin === "viewport" && ce.type === "box" && (ce.x += ae.x,
                    ce.y += ae.y),
                    xe = g(await P(this, j, jL).call(this, ce), ae)
                }
                if (xe.width === 0 || xe.height === 0)
                    throw new e.UnableToCaptureScreenException(`Unable to capture screenshot with zero dimensions: width=${xe.width}, height=${xe.height}`);
                return await o(this, x).cdpClient.sendCommand("Page.captureScreenshot", {
                    clip: {
                        ...xe,
                        scale: 1
                    },
                    ...M,
                    captureBeyondViewport: U
                })
            }
            async print(I) {
                var U, W, X, te, ae, xe;
                if (!this.isTopLevelContext())
                    throw new e.UnsupportedOperationException("Printing of non-top level contexts is not supported");
                const M = {};
                if (I.background !== void 0 && (M.printBackground = I.background),
                ((U = I.margin) == null ? void 0 : U.bottom) !== void 0 && (M.marginBottom = (0,
                a.inchesFromCm)(I.margin.bottom)),
                ((W = I.margin) == null ? void 0 : W.left) !== void 0 && (M.marginLeft = (0,
                a.inchesFromCm)(I.margin.left)),
                ((X = I.margin) == null ? void 0 : X.right) !== void 0 && (M.marginRight = (0,
                a.inchesFromCm)(I.margin.right)),
                ((te = I.margin) == null ? void 0 : te.top) !== void 0 && (M.marginTop = (0,
                a.inchesFromCm)(I.margin.top)),
                I.orientation !== void 0 && (M.landscape = I.orientation === "landscape"),
                ((ae = I.page) == null ? void 0 : ae.height) !== void 0 && (M.paperHeight = (0,
                a.inchesFromCm)(I.page.height)),
                ((xe = I.page) == null ? void 0 : xe.width) !== void 0 && (M.paperWidth = (0,
                a.inchesFromCm)(I.page.width)),
                I.pageRanges !== void 0) {
                    for (const ce of I.pageRanges) {
                        if (typeof ce == "number")
                            continue;
                        const Pe = ce.split("-");
                        if (Pe.length < 1 || Pe.length > 2)
                            throw new e.InvalidArgumentException(`Invalid page range: ${ce} is not a valid integer range.`);
                        if (Pe.length === 1) {
                            y(Pe[0] ?? "");
                            continue
                        }
                        let we, H;
                        const [Q="",ie=""] = Pe;
                        if (Q === "" ? we = 1 : we = y(Q),
                        ie === "" ? H = Number.MAX_SAFE_INTEGER : H = y(ie),
                        we > H)
                            throw new e.InvalidArgumentException(`Invalid page range: ${Q} > ${ie}`)
                    }
                    M.pageRanges = I.pageRanges.join(",")
                }
                I.scale !== void 0 && (M.scale = I.scale),
                I.shrinkToFit !== void 0 && (M.preferCSSPageSize = !I.shrinkToFit);
                try {
                    return {
                        data: (await o(this, x).cdpClient.sendCommand("Page.printToPDF", M)).data
                    }
                } catch (ce) {
                    throw ce.message === "invalid print parameters: content area is empty" ? new e.UnsupportedOperationException(ce.message) : ce
                }
            }
            async close() {
                await o(this, x).cdpClient.sendCommand("Page.close")
            }
            async traverseHistory(I) {
                if (I === 0)
                    return;
                const M = await o(this, x).cdpClient.sendCommand("Page.getNavigationHistory")
                  , U = M.entries[M.currentIndex + I];
                if (!U)
                    throw new e.NoSuchHistoryEntryException(`No history entry at delta ${I}`);
                await o(this, x).cdpClient.sendCommand("Page.navigateToHistoryEntry", {
                    entryId: U.id
                })
            }
            async toggleModulesIfNeeded() {
                await Promise.all([o(this, x).toggleNetworkIfNeeded(), o(this, x).toggleDeviceAccessIfNeeded()])
            }
            async locateNodes(I) {
                return await P(this, j, BL).call(this, await o(this, N), I.locator, I.startNodes ?? [], I.maxNodeCount, I.serializationOptions)
            }
        }
        ,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakMap,
        x = new WeakMap,
        N = new WeakMap,
        R = new WeakMap,
        F = new WeakMap,
        O = new WeakMap,
        T = new WeakMap,
        L = new WeakMap,
        q = new WeakMap,
        Z = new WeakMap,
        j = new WeakSet,
        rv = function(I=!1) {
            this.directChildren.map(M => M.dispose(I))
        }
        ,
        CC = function() {
            o(this, x).cdpClient.on("Network.loadingFailed", I => {
                o(this, T).networkLoadingFailed(I.requestId, I.errorText)
            }
            ),
            o(this, x).cdpClient.on("Page.frameNavigated", I => {
                this.id === I.frame.id && (o(this, T).frameNavigated(I.frame.url + (I.frame.urlFragment ?? ""), I.frame.loaderId, I.frame.unreachableUrl),
                P(this, j, rv).call(this),
                P(this, j, nv).call(this, I.frame.loaderId))
            }
            ),
            o(this, x).on("frameStartedNavigating", I => {
                var U;
                (U = o(this, O)) == null || U.call(this, s.LogType.debugInfo, "Received frameStartedNavigating event", I),
                [this.id, ...this.cdpTarget.id === this.id ? [void 0] : []].includes(I.frameId) && o(this, T).frameStartedNavigating(I.url, I.loaderId)
            }
            ),
            o(this, x).cdpClient.on("Page.navigatedWithinDocument", I => {
                if (this.id === I.frameId && (o(this, T).navigatedWithinDocument(I.url, I.navigationType),
                I.navigationType === "historyApi")) {
                    o(this, F).registerEvent({
                        type: "event",
                        method: "browsingContext.historyUpdated",
                        params: {
                            context: this.id,
                            url: o(this, T).url
                        }
                    }, this.id);
                    return
                }
            }
            ),
            o(this, x).cdpClient.on("Page.frameRequestedNavigation", I => {
                this.id === I.frameId && o(this, T).frameRequestedNavigation(I.url)
            }
            ),
            o(this, x).cdpClient.on("Page.lifecycleEvent", I => {
                if (this.id === I.frameId) {
                    if (I.name === "init") {
                        P(this, j, nv).call(this, I.loaderId);
                        return
                    }
                    if (I.name === "commit") {
                        S(this, v, I.loaderId);
                        return
                    }
                    if (o(this, v) || S(this, v, I.loaderId),
                    I.loaderId === o(this, v))
                        switch (I.name) {
                        case "DOMContentLoaded":
                            o(this, T).isInitialNavigation || o(this, F).registerEvent({
                                type: "event",
                                method: e.ChromiumBidi.BrowsingContext.EventNames.DomContentLoaded,
                                params: {
                                    context: this.id,
                                    navigation: o(this, T).currentNavigationId,
                                    timestamp: (0,
                                    i.getTimestamp)(),
                                    url: o(this, T).url
                                }
                            }, this.id),
                            o(this, k).DOMContentLoaded.resolve();
                            break;
                        case "load":
                            o(this, T).isInitialNavigation || o(this, F).registerEvent({
                                type: "event",
                                method: e.ChromiumBidi.BrowsingContext.EventNames.Load,
                                params: {
                                    context: this.id,
                                    navigation: o(this, T).currentNavigationId,
                                    timestamp: (0,
                                    i.getTimestamp)(),
                                    url: o(this, T).url
                                }
                            }, this.id),
                            o(this, T).loadPageEvent(I.loaderId),
                            o(this, k).load.resolve();
                            break
                        }
                }
            }
            ),
            o(this, x).cdpClient.on("Runtime.executionContextCreated", I => {
                var ce;
                const {auxData: M, name: U, uniqueId: W, id: X} = I.context;
                if (!M || M.frameId !== this.id)
                    return;
                let te, ae;
                switch (M.type) {
                case "isolated":
                    ae = U,
                    o(this, N).isFinished || (ce = o(this, O)) == null || ce.call(this, s.LogType.debugError, "Unexpectedly, isolated realm created before the default one"),
                    te = o(this, N).isFinished ? o(this, N).result.origin : "";
                    break;
                case "default":
                    te = d(I.context.origin);
                    break;
                default:
                    return
                }
                const xe = new c.WindowRealm(this.id,o(this, R),o(this, x).cdpClient,o(this, F),X,o(this, O),te,W,o(this, L),ae);
                M.isDefault && (o(this, N).resolve(xe),
                Promise.all(o(this, x).getChannels().map(Pe => Pe.startListenerFromWindow(xe, o(this, F)))))
            }
            ),
            o(this, x).cdpClient.on("Runtime.executionContextDestroyed", I => {
                o(this, N).isFinished && o(this, N).result.executionContextId === I.executionContextId && S(this, N, new r.Deferred),
                o(this, L).deleteRealms({
                    cdpSessionId: o(this, x).cdpSessionId,
                    executionContextId: I.executionContextId
                })
            }
            ),
            o(this, x).cdpClient.on("Runtime.executionContextsCleared", () => {
                o(this, N).isFinished || o(this, N).reject(new e.UnknownErrorException("execution contexts cleared")),
                S(this, N, new r.Deferred),
                o(this, L).deleteRealms({
                    cdpSessionId: o(this, x).cdpSessionId
                })
            }
            ),
            o(this, x).cdpClient.on("Page.javascriptDialogClosed", I => {
                var U;
                const M = I.result;
                o(this, Z) === void 0 && ((U = o(this, O)) == null || U.call(this, s.LogType.debugError, "Unexpectedly no opening prompt event before closing one")),
                o(this, F).registerEvent({
                    type: "event",
                    method: e.ChromiumBidi.BrowsingContext.EventNames.UserPromptClosed,
                    params: {
                        context: this.id,
                        accepted: M,
                        type: o(this, Z) ?? "UNKNOWN",
                        userText: M && I.userInput ? I.userInput : void 0
                    }
                }, this.id),
                S(this, Z, void 0)
            }
            ),
            o(this, x).cdpClient.on("Page.javascriptDialogOpening", I => {
                var W;
                const M = P(W = n, D, $L).call(W, I.type);
                I.type === "beforeunload" && o(this, T).beforeunload(),
                S(this, Z, M);
                const U = P(this, j, LL).call(this, M);
                switch (o(this, F).registerEvent({
                    type: "event",
                    method: e.ChromiumBidi.BrowsingContext.EventNames.UserPromptOpened,
                    params: {
                        context: this.id,
                        handler: U,
                        type: M,
                        message: I.message,
                        ...I.type === "prompt" ? {
                            defaultValue: I.defaultPrompt
                        } : {}
                    }
                }, this.id),
                U) {
                case "accept":
                    this.handleUserPrompt(!0);
                    break;
                case "dismiss":
                    this.handleUserPrompt(!1);
                    break
                }
            }
            )
        }
        ,
        D = new WeakSet,
        $L = function(I) {
            switch (I) {
            case "alert":
                return "alert";
            case "beforeunload":
                return "beforeunload";
            case "confirm":
                return "confirm";
            case "prompt":
                return "prompt"
            }
        }
        ,
        LL = function(I) {
            var U, W, X, te, ae, xe, ce, Pe;
            const M = "dismiss";
            switch (I) {
            case "alert":
                return ((U = o(this, q)) == null ? void 0 : U.alert) ?? ((W = o(this, q)) == null ? void 0 : W.default) ?? M;
            case "beforeunload":
                return ((X = o(this, q)) == null ? void 0 : X.beforeUnload) ?? ((te = o(this, q)) == null ? void 0 : te.default) ?? "accept";
            case "confirm":
                return ((ae = o(this, q)) == null ? void 0 : ae.confirm) ?? ((xe = o(this, q)) == null ? void 0 : xe.default) ?? M;
            case "prompt":
                return ((ce = o(this, q)) == null ? void 0 : ce.prompt) ?? ((Pe = o(this, q)) == null ? void 0 : Pe.default) ?? M
            }
        }
        ,
        nv = function(I) {
            I === void 0 || o(this, v) === I || (P(this, j, kC).call(this),
            S(this, v, I),
            P(this, j, rv).call(this, !0))
        }
        ,
        kC = function() {
            var I, M;
            o(this, k).DOMContentLoaded.isFinished ? o(this, k).DOMContentLoaded = new r.Deferred : (I = o(this, O)) == null || I.call(this, n.LOGGER_PREFIX, "Document changed (DOMContentLoaded)"),
            o(this, k).load.isFinished ? o(this, k).load = new r.Deferred : (M = o(this, O)) == null || M.call(this, n.LOGGER_PREFIX, "Document changed (load)")
        }
        ,
        FL = function() {
            o(this, k).DOMContentLoaded.isFinished || o(this, k).DOMContentLoaded.reject(new e.UnknownErrorException("navigation canceled")),
            o(this, k).load.isFinished || o(this, k).load.reject(new e.UnknownErrorException("navigation canceled"))
        }
        ,
        PC = async function(I, M, U) {
            if (I !== "none") {
                if (await M,
                U.isFragmentNavigation === !0) {
                    await U.finished;
                    return
                }
                if (I === "interactive") {
                    await o(this, k).DOMContentLoaded;
                    return
                }
                if (I === "complete") {
                    await o(this, k).load;
                    return
                }
                throw new e.InvalidArgumentException(`Wait condition ${I} is not supported`)
            }
        }
        ,
        jL = async function(I) {
            switch (I.type) {
            case "box":
                return {
                    x: I.x,
                    y: I.y,
                    width: I.width,
                    height: I.height
                };
            case "element":
                {
                    const M = await this.getOrCreateSandbox(void 0)
                      , U = await M.callFunction(String(W => W instanceof Element), !1, {
                        type: "undefined"
                    }, [I.element]);
                    if (U.type === "exception")
                        throw new e.NoSuchElementException(`Element '${I.element.sharedId}' was not found`);
                    if ((0,
                    t.assert)(U.result.type === "boolean"),
                    !U.result.value)
                        throw new e.NoSuchElementException(`Node '${I.element.sharedId}' is not an Element`);
                    {
                        const W = await M.callFunction(String(te => {
                            const ae = te.getBoundingClientRect();
                            return {
                                x: ae.x,
                                y: ae.y,
                                height: ae.height,
                                width: ae.width
                            }
                        }
                        ), !1, {
                            type: "undefined"
                        }, [I.element]);
                        (0,
                        t.assert)(W.type === "success");
                        const X = f(W.result);
                        if (!X)
                            throw new e.UnableToCaptureScreenException(`Could not get bounding box for Element '${I.element.sharedId}'`);
                        return X
                    }
                }
            }
        }
        ,
        DL = async function(I, M, U, W) {
            switch (M.type) {
            case "context":
                throw new Error("Unreachable");
            case "css":
                return {
                    functionDeclaration: String( (X, te, ...ae) => {
                        const xe = Pe => {
                            if (!(Pe instanceof HTMLElement || Pe instanceof Document || Pe instanceof DocumentFragment))
                                throw new Error("startNodes in css selector should be HTMLElement, Document or DocumentFragment");
                            return [...Pe.querySelectorAll(X)]
                        }
                        ;
                        ae = ae.length > 0 ? ae : [document];
                        const ce = ae.map(Pe => xe(Pe)).flat(1);
                        return te === 0 ? ce : ce.slice(0, te)
                    }
                    ),
                    argumentsLocalValues: [{
                        type: "string",
                        value: M.value
                    }, {
                        type: "number",
                        value: U ?? 0
                    }, ...W]
                };
            case "xpath":
                return {
                    functionDeclaration: String( (X, te, ...ae) => {
                        const ce = new XPathEvaluator().createExpression(X)
                          , Pe = H => {
                            const Q = ce.evaluate(H, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE)
                              , ie = [];
                            for (let me = 0; me < Q.snapshotLength; me++)
                                ie.push(Q.snapshotItem(me));
                            return ie
                        }
                        ;
                        ae = ae.length > 0 ? ae : [document];
                        const we = ae.map(H => Pe(H)).flat(1);
                        return te === 0 ? we : we.slice(0, te)
                    }
                    ),
                    argumentsLocalValues: [{
                        type: "string",
                        value: M.value
                    }, {
                        type: "number",
                        value: U ?? 0
                    }, ...W]
                };
            case "innerText":
                if (M.value === "")
                    throw new e.InvalidSelectorException("innerText locator cannot be empty");
                return {
                    functionDeclaration: String( (X, te, ae, xe, ce, ...Pe) => {
                        const we = ae ? X.toUpperCase() : X
                          , H = (ie, me) => {
                            var Vr;
                            const Te = [];
                            if (ie instanceof DocumentFragment || ie instanceof Document)
                                return [...ie.children].forEach(Ei => Te.push(...H(Ei, me))),
                                Te;
                            if (!(ie instanceof HTMLElement))
                                return [];
                            const je = ie
                              , dt = ae ? (Vr = je.innerText) == null ? void 0 : Vr.toUpperCase() : je.innerText;
                            if (!dt.includes(we))
                                return [];
                            const ht = [];
                            for (const tr of je.children)
                                tr instanceof HTMLElement && ht.push(tr);
                            if (ht.length === 0)
                                te && dt === we ? Te.push(je) : te || Te.push(je);
                            else {
                                const tr = me <= 0 ? [] : ht.map(Ei => H(Ei, me - 1)).flat(1);
                                tr.length === 0 ? (!te || dt === we) && Te.push(je) : Te.push(...tr)
                            }
                            return Te
                        }
                        ;
                        Pe = Pe.length > 0 ? Pe : [document];
                        const Q = Pe.map(ie => H(ie, ce)).flat(1);
                        return xe === 0 ? Q : Q.slice(0, xe)
                    }
                    ),
                    argumentsLocalValues: [{
                        type: "string",
                        value: M.value
                    }, {
                        type: "boolean",
                        value: M.matchType !== "partial"
                    }, {
                        type: "boolean",
                        value: M.ignoreCase === !0
                    }, {
                        type: "number",
                        value: U ?? 0
                    }, {
                        type: "number",
                        value: M.maxDepth ?? 1e3
                    }, ...W]
                };
            case "accessibility":
                {
                    if (!M.value.name && !M.value.role)
                        throw new e.InvalidSelectorException("Either name or role has to be specified");
                    await Promise.all([o(this, x).cdpClient.sendCommand("Accessibility.enable"), o(this, x).cdpClient.sendCommand("Accessibility.getRootAXNode")]);
                    const X = await I.evaluate("({getAccessibleName, getAccessibleRole})", !1, "root", void 0, !1, !0);
                    if (X.type !== "success")
                        throw new Error("Could not get bindings");
                    if (X.result.type !== "object")
                        throw new Error("Could not get bindings");
                    return {
                        functionDeclaration: String( (te, ae, xe, ce, ...Pe) => {
                            const we = [];
                            let H = !1;
                            function Q(ie, me) {
                                if (!H)
                                    for (const Te of ie) {
                                        let je = !0;
                                        if (me.role) {
                                            const ht = xe.getAccessibleRole(Te);
                                            me.role !== ht && (je = !1)
                                        }
                                        if (me.name) {
                                            const ht = xe.getAccessibleName(Te);
                                            me.name !== ht && (je = !1)
                                        }
                                        if (je) {
                                            if (ce !== 0 && we.length === ce) {
                                                H = !0;
                                                break
                                            }
                                            we.push(Te)
                                        }
                                        const dt = [];
                                        for (const ht of Te.children)
                                            ht instanceof HTMLElement && dt.push(ht);
                                        Q(dt, me)
                                    }
                            }
                            return Pe = Pe.length > 0 ? Pe : Array.from(document.documentElement.children).filter(ie => ie instanceof HTMLElement),
                            Q(Pe, {
                                role: ae,
                                name: te
                            }),
                            we
                        }
                        ),
                        argumentsLocalValues: [{
                            type: "string",
                            value: M.value.name || ""
                        }, {
                            type: "string",
                            value: M.value.role || ""
                        }, {
                            handle: X.result.handle
                        }, {
                            type: "number",
                            value: U ?? 0
                        }, ...W]
                    }
                }
            }
        }
        ,
        BL = async function(I, M, U, W, X) {
            var ce, Pe, we;
            if (M.type === "context") {
                if (U.length !== 0)
                    throw new e.InvalidArgumentException("Start nodes are not supported");
                const H = M.value.context;
                if (!H)
                    throw new e.InvalidSelectorException("Invalid context");
                const ie = o(this, R).getContext(H).parent;
                if (!ie)
                    throw new e.InvalidArgumentException("This context has no container");
                try {
                    const {backendNodeId: me} = await o(ie, x).cdpClient.sendCommand("DOM.getFrameOwner", {
                        frameId: H
                    })
                      , {object: Te} = await o(ie, x).cdpClient.sendCommand("DOM.resolveNode", {
                        backendNodeId: me
                    })
                      , je = await I.callFunction("function () { return this; }", !1, {
                        handle: Te.objectId
                    }, [], "none", X);
                    if (je.type === "exception")
                        throw new Error("Unknown exception");
                    return {
                        nodes: [je.result]
                    }
                } catch {
                    throw new e.InvalidArgumentException("Context does not exist")
                }
            }
            const te = await P(this, j, DL).call(this, I, M, W, U);
            X = {
                ...X,
                maxObjectDepth: 1
            };
            const ae = await I.callFunction(te.functionDeclaration, !1, {
                type: "undefined"
            }, te.argumentsLocalValues, "none", X);
            if (ae.type !== "success")
                throw (ce = o(this, O)) == null || ce.call(this, n.LOGGER_PREFIX, "Failed locateNodesByLocator", ae),
                (Pe = ae.exceptionDetails.text) != null && Pe.endsWith("is not a valid selector.") || (we = ae.exceptionDetails.text) != null && we.endsWith("is not a valid XPath expression.") ? new e.InvalidSelectorException(`Not valid selector ${typeof M.value == "string" ? M.value : JSON.stringify(M.value)}`) : ae.exceptionDetails.text === "Error: startNodes in css selector should be HTMLElement, Document or DocumentFragment" ? new e.InvalidArgumentException("startNodes in css selector should be HTMLElement, Document or DocumentFragment") : new e.UnknownErrorException(`Unexpected error in selector script: ${ae.exceptionDetails.text}`);
            if (ae.result.type !== "array")
                throw new e.UnknownErrorException(`Unexpected selector script result type: ${ae.result.type}`);
            return {
                nodes: ae.result.value.map(H => {
                    if (H.type !== "node")
                        throw new e.UnknownErrorException(`Unexpected selector script result element: ${H.type}`);
                    return H
                }
                )
            }
        }
        ,
        b(m, D),
        J(m, "LOGGER_PREFIX", `${s.LogType.debug}:browsingContext`),
        m);
        qu.BrowsingContextImpl = l,
        n = l;
        function d(pe) {
            return ["://", ""].includes(pe) && (pe = "null"),
            pe
        }
        function h(pe) {
            const {quality: I, type: M} = pe.format ?? {
                type: "image/png"
            };
            switch (M) {
            case "image/png":
                return {
                    format: "png"
                };
            case "image/jpeg":
                return {
                    format: "jpeg",
                    ...I === void 0 ? {} : {
                        quality: Math.round(I * 100)
                    }
                };
            case "image/webp":
                return {
                    format: "webp",
                    ...I === void 0 ? {} : {
                        quality: Math.round(I * 100)
                    }
                }
            }
            throw new e.InvalidArgumentException(`Image format '${M}' is not a supported format`)
        }
        function f(pe) {
            var X, te, ae, xe;
            if (pe.type !== "object" || pe.value === void 0)
                return;
            const I = (X = pe.value.find( ([ce]) => ce === "x")) == null ? void 0 : X[1]
              , M = (te = pe.value.find( ([ce]) => ce === "y")) == null ? void 0 : te[1]
              , U = (ae = pe.value.find( ([ce]) => ce === "height")) == null ? void 0 : ae[1]
              , W = (xe = pe.value.find( ([ce]) => ce === "width")) == null ? void 0 : xe[1];
            if (!((I == null ? void 0 : I.type) !== "number" || (M == null ? void 0 : M.type) !== "number" || (U == null ? void 0 : U.type) !== "number" || (W == null ? void 0 : W.type) !== "number"))
                return {
                    x: I.value,
                    y: M.value,
                    width: W.value,
                    height: U.value
                }
        }
        function p(pe) {
            return {
                ...pe.width < 0 ? {
                    x: pe.x + pe.width,
                    width: -pe.width
                } : {
                    x: pe.x,
                    width: pe.width
                },
                ...pe.height < 0 ? {
                    y: pe.y + pe.height,
                    height: -pe.height
                } : {
                    y: pe.y,
                    height: pe.height
                }
            }
        }
        function g(pe, I) {
            pe = p(pe),
            I = p(I);
            const M = Math.max(pe.x, I.x)
              , U = Math.max(pe.y, I.y);
            return {
                x: M,
                y: U,
                width: Math.max(Math.min(pe.x + pe.width, I.x + I.width) - M, 0),
                height: Math.max(Math.min(pe.y + pe.height, I.y + I.height) - U, 0)
            }
        }
        function y(pe) {
            if (pe = pe.trim(),
            !/^[0-9]+$/.test(pe))
                throw new e.InvalidArgumentException(`Invalid integer: ${pe}`);
            return parseInt(pe)
        }
        return qu
    }
    var Mf = {}, UM;
    function Yz() {
        var t, r, s;
        if (UM)
            return Mf;
        UM = 1,
        Object.defineProperty(Mf, "__esModule", {
            value: !0
        }),
        Mf.WorkerRealm = void 0;
        const n = NM();
        let e = (s = class extends n.Realm {
            constructor(c, u, l, d, h, f, p, g, y) {
                super(c, u, l, d, h, p, g);
                b(this, t);
                b(this, r);
                S(this, r, f),
                S(this, t, y),
                this.initialize()
            }
            get associatedBrowsingContexts() {
                return o(this, r).flatMap(c => c.associatedBrowsingContexts)
            }
            get realmType() {
                return o(this, t)
            }
            get source() {
                var c;
                return {
                    realm: this.realmId,
                    context: (c = this.associatedBrowsingContexts[0]) == null ? void 0 : c.id
                }
            }
            get realmInfo() {
                const c = o(this, r).map(l => l.realmId)
                  , {realmType: u} = this;
                switch (u) {
                case "dedicated-worker":
                    {
                        const l = c[0];
                        if (l === void 0 || c.length !== 1)
                            throw new Error("Dedicated worker must have exactly one owner");
                        return {
                            ...this.baseInfo,
                            type: u,
                            owners: [l]
                        }
                    }
                case "service-worker":
                case "shared-worker":
                    return {
                        ...this.baseInfo,
                        type: u
                    }
                }
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        s);
        return Mf.WorkerRealm = e,
        Mf
    }
    var Nf = {}, $f = {}, Lf = {}, KM;
    function Qz() {
        if (KM)
            return Lf;
        KM = 1,
        Object.defineProperty(Lf, "__esModule", {
            value: !0
        }),
        Lf.logMessageFormatter = r,
        Lf.getRemoteValuesText = a;
        const n = mo()
          , e = ["%s", "%d", "%i", "%f", "%o", "%O", "%c"];
        function t(c) {
            return e.some(u => c.includes(u))
        }
        function r(c) {
            let u = "";
            const l = c[0].value.toString()
              , d = c.slice(1, void 0)
              , h = l.split(new RegExp(e.map(f => `(${f})`).join("|"),"g"));
            for (const f of h)
                if (!(f === void 0 || f === ""))
                    if (t(f)) {
                        const p = d.shift();
                        (0,
                        n.assert)(p, `Less value is provided: "${a(c, !1)}"`),
                        f === "%s" ? u += i(p) : f === "%d" || f === "%i" ? p.type === "bigint" || p.type === "number" || p.type === "string" ? u += parseInt(p.value.toString(), 10) : u += "NaN" : f === "%f" ? p.type === "bigint" || p.type === "number" || p.type === "string" ? u += parseFloat(p.value.toString()) : u += "NaN" : u += s(p)
                    } else
                        u += f;
            if (d.length > 0)
                throw new Error(`More value is provided: "${a(c, !1)}"`);
            return u
        }
        function s(c) {
            var u;
            if (c.type !== "array" && c.type !== "bigint" && c.type !== "date" && c.type !== "number" && c.type !== "object" && c.type !== "string")
                return i(c);
            if (c.type === "bigint")
                return `${c.value.toString()}n`;
            if (c.type === "number")
                return c.value.toString();
            if (["date", "string"].includes(c.type))
                return JSON.stringify(c.value);
            if (c.type === "object")
                return `{${c.value.map(l => `${JSON.stringify(l[0])}:${s(l[1])}`).join(",")}}`;
            if (c.type === "array")
                return `[${((u = c.value) == null ? void 0 : u.map(l => s(l)).join(",")) ?? ""}]`;
            throw Error(`Invalid value type: ${c}`)
        }
        function i(c) {
            var u, l, d, h;
            if (!Object.hasOwn(c, "value"))
                return c.type;
            switch (c.type) {
            case "string":
            case "number":
            case "boolean":
            case "bigint":
                return String(c.value);
            case "regexp":
                return `/${c.value.pattern}/${c.value.flags ?? ""}`;
            case "date":
                return new Date(c.value).toString();
            case "object":
                return `Object(${((u = c.value) == null ? void 0 : u.length) ?? ""})`;
            case "array":
                return `Array(${((l = c.value) == null ? void 0 : l.length) ?? ""})`;
            case "map":
                return `Map(${(d = c.value) == null ? void 0 : d.length})`;
            case "set":
                return `Set(${(h = c.value) == null ? void 0 : h.length})`;
            default:
                return c.type
            }
        }
        function a(c, u) {
            const l = c[0];
            return l ? l.type === "string" && t(l.value.toString()) && u ? r(c) : c.map(d => i(d)).join(" ") : ""
        }
        return Lf
    }
    var HM;
    function eV() {
        var u, l, d, h, f, qL, UL, y, m, KL;
        if (HM)
            return $f;
        HM = 1;
        var n;
        Object.defineProperty($f, "__esModule", {
            value: !0
        }),
        $f.LogManager = void 0;
        const e = mt()
          , t = vn()
          , r = Qz();
        function s(E) {
            const v = E == null ? void 0 : E.callFrames.map(_ => ({
                columnNumber: _.columnNumber,
                functionName: _.functionName,
                lineNumber: _.lineNumber,
                url: _.url
            }));
            return v ? {
                callFrames: v
            } : void 0
        }
        function i(E) {
            return ["error", "assert"].includes(E) ? "error" : ["debug", "trace"].includes(E) ? "debug" : ["warn", "warning"].includes(E) ? "warn" : "info"
        }
        function a(E) {
            switch (E) {
            case "warning":
                return "warn";
            case "startGroup":
                return "group";
            case "startGroupCollapsed":
                return "groupCollapsed";
            case "endGroup":
                return "groupEnd"
            }
            return E
        }
        let c = (m = class {
            constructor(v, _, A, C) {
                b(this, f);
                b(this, u);
                b(this, l);
                b(this, d);
                b(this, h);
                S(this, d, v),
                S(this, l, _),
                S(this, u, A),
                S(this, h, C)
            }
            static create(v, _, A, C) {
                var x;
                const k = new n(v,_,A,C);
                return P(x = k, f, UL).call(x),
                k
            }
        }
        ,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakSet,
        qL = async function(v, _) {
            switch (v.type) {
            case "undefined":
                return {
                    type: "undefined"
                };
            case "boolean":
                return {
                    type: "boolean",
                    value: v.value
                };
            case "string":
                return {
                    type: "string",
                    value: v.value
                };
            case "number":
                return {
                    type: "number",
                    value: v.unserializableValue ?? v.value
                };
            case "bigint":
                if (v.unserializableValue !== void 0 && v.unserializableValue[v.unserializableValue.length - 1] === "n")
                    return {
                        type: v.type,
                        value: v.unserializableValue.slice(0, -1)
                    };
                break;
            case "object":
                if (v.subtype === "null")
                    return {
                        type: "null"
                    };
                break
            }
            return await _.serializeCdpObject(v, "none")
        }
        ,
        UL = function() {
            o(this, d).cdpClient.on("Runtime.consoleAPICalled", v => {
                var C;
                const _ = o(this, l).findRealm({
                    cdpSessionId: o(this, d).cdpSessionId,
                    executionContextId: v.executionContextId
                });
                if (_ === void 0) {
                    (C = o(this, h)) == null || C.call(this, t.LogType.cdp, v);
                    return
                }
                const A = Promise.all(v.args.map(k => P(this, f, qL).call(this, k, _)));
                for (const k of _.associatedBrowsingContexts)
                    o(this, u).registerPromiseEvent(A.then(x => ({
                        kind: "success",
                        value: {
                            type: "event",
                            method: e.ChromiumBidi.Log.EventNames.LogEntryAdded,
                            params: {
                                level: i(v.type),
                                source: _.source,
                                text: (0,
                                r.getRemoteValuesText)(x, !0),
                                timestamp: Math.round(v.timestamp),
                                stackTrace: s(v.stackTrace),
                                type: "console",
                                method: a(v.type),
                                args: x
                            }
                        }
                    }), x => ({
                        kind: "error",
                        error: x
                    })), k.id, e.ChromiumBidi.Log.EventNames.LogEntryAdded)
            }
            ),
            o(this, d).cdpClient.on("Runtime.exceptionThrown", v => {
                var A, C;
                const _ = o(this, l).findRealm({
                    cdpSessionId: o(this, d).cdpSessionId,
                    executionContextId: v.exceptionDetails.executionContextId
                });
                if (_ === void 0) {
                    (A = o(this, h)) == null || A.call(this, t.LogType.cdp, v);
                    return
                }
                for (const k of _.associatedBrowsingContexts)
                    o(this, u).registerPromiseEvent(P(C = n, y, KL).call(C, v, _).then(x => ({
                        kind: "success",
                        value: {
                            type: "event",
                            method: e.ChromiumBidi.Log.EventNames.LogEntryAdded,
                            params: {
                                level: "error",
                                source: _.source,
                                text: x,
                                timestamp: Math.round(v.timestamp),
                                stackTrace: s(v.exceptionDetails.stackTrace),
                                type: "javascript"
                            }
                        }
                    }), x => ({
                        kind: "error",
                        error: x
                    })), k.id, e.ChromiumBidi.Log.EventNames.LogEntryAdded)
            }
            )
        }
        ,
        y = new WeakSet,
        KL = async function(v, _) {
            return v.exceptionDetails.exception ? _ === void 0 ? JSON.stringify(v.exceptionDetails.exception) : await _.stringifyObject(v.exceptionDetails.exception) : v.exceptionDetails.text
        }
        ,
        b(m, y),
        m);
        return $f.LogManager = c,
        n = c,
        $f
    }
    var WM;
    function tV() {
        var c, u, l, d, h, f, p, g, y, m, w, E, v, _, A, C, k, HL, TC, sv, WL, zL, VL, GL, q;
        if (WM)
            return Nf;
        WM = 1,
        Object.defineProperty(Nf, "__esModule", {
            value: !0
        }),
        Nf.CdpTarget = void 0;
        const n = zR()
          , e = fb()
          , t = ju()
          , r = vn()
          , s = qM()
          , i = eV();
        let a = (q = class extends t.EventEmitter {
            constructor($, B, D, z, G, ee, V, K, se, ye, ue, He) {
                super();
                b(this, k);
                b(this, c);
                b(this, u);
                b(this, l);
                b(this, d);
                b(this, h);
                b(this, f);
                b(this, p);
                b(this, g);
                b(this, y);
                b(this, m);
                b(this, w, new e.Deferred);
                b(this, E);
                b(this, v);
                b(this, _, !1);
                b(this, A, !1);
                b(this, C, {
                    request: !1,
                    response: !1,
                    auth: !1
                });
                S(this, c, $),
                S(this, u, B),
                S(this, l, D),
                S(this, d, z),
                S(this, f, G),
                S(this, h, ee),
                S(this, p, V),
                S(this, m, se),
                S(this, g, K),
                S(this, y, ye),
                S(this, E, ue),
                S(this, v, He)
            }
            static create($, B, D, z, G, ee, V, K, se, ye, ue, He) {
                var I, M;
                const pe = new q($,B,D,z,ee,G,V,K,se,ye,ue,He);
                return i.LogManager.create(pe, G, ee, He),
                P(I = pe, k, WL).call(I),
                P(M = pe, k, HL).call(M),
                pe
            }
            get unblocked() {
                return o(this, w)
            }
            get id() {
                return o(this, c)
            }
            get cdpClient() {
                return o(this, u)
            }
            get parentCdpClient() {
                return o(this, d)
            }
            get browserCdpClient() {
                return o(this, l)
            }
            get cdpSessionId() {
                return o(this, u).sessionId
            }
            async toggleFetchIfNeeded() {
                const $ = o(this, m).getInterceptionStages(this.topLevelId);
                if (o(this, C).request === $.request && o(this, C).response === $.response && o(this, C).auth === $.auth)
                    return;
                const B = [];
                if (S(this, C, $),
                ($.request || $.auth) && B.push({
                    urlPattern: "*",
                    requestStage: "Request"
                }),
                $.response && B.push({
                    urlPattern: "*",
                    requestStage: "Response"
                }),
                B.length)
                    await o(this, u).sendCommand("Fetch.enable", {
                        patterns: B,
                        handleAuthRequests: $.auth
                    });
                else {
                    const D = o(this, m).getRequestsByTarget(this).filter(z => z.interceptPhase);
                    Promise.allSettled(D.map(z => z.waitNextPhase)).then(async () => o(this, m).getRequestsByTarget(this).filter(G => G.interceptPhase).length ? await this.toggleFetchIfNeeded() : await o(this, u).sendCommand("Fetch.disable")).catch(z => {
                        var G;
                        (G = o(this, v)) == null || G.call(this, r.LogType.bidi, "Disable failed", z)
                    }
                    )
                }
            }
            async toggleNetworkIfNeeded() {
                var $;
                try {
                    await Promise.all([this.toggleSetCacheDisabled(), this.toggleFetchIfNeeded()])
                } catch (B) {
                    if (($ = o(this, v)) == null || $.call(this, r.LogType.debugError, B),
                    !P(this, k, sv).call(this, B))
                        throw B
                }
            }
            async toggleSetCacheDisabled($) {
                var z;
                const B = o(this, m).defaultCacheBehavior === "bypass"
                  , D = $ ?? B;
                if (o(this, A) !== D) {
                    S(this, A, D);
                    try {
                        await o(this, u).sendCommand("Network.setCacheDisabled", {
                            cacheDisabled: D
                        })
                    } catch (G) {
                        if ((z = o(this, v)) == null || z.call(this, r.LogType.debugError, G),
                        S(this, A, !D),
                        !P(this, k, sv).call(this, G))
                            throw G
                    }
                }
            }
            async toggleDeviceAccessIfNeeded() {
                var B;
                const $ = this.isSubscribedTo(n.Bluetooth.EventNames.RequestDevicePromptUpdated);
                if (o(this, _) !== $) {
                    S(this, _, $);
                    try {
                        await o(this, u).sendCommand($ ? "DeviceAccess.enable" : "DeviceAccess.disable")
                    } catch (D) {
                        if ((B = o(this, v)) == null || B.call(this, r.LogType.debugError, D),
                        S(this, _, !$),
                        !P(this, k, sv).call(this, D))
                            throw D
                    }
                }
            }
            async toggleNetwork() {
                var z;
                const $ = o(this, m).getInterceptionStages(this.topLevelId)
                  , B = Object.values($).some(G => G)
                  , D = o(this, C).request !== $.request || o(this, C).response !== $.response || o(this, C).auth !== $.auth;
                (z = o(this, v)) == null || z.call(this, r.LogType.debugInfo, "Toggle Network", `Fetch (${B}) ${D}`),
                B && D && await P(this, k, zL).call(this, $),
                !B && D && await P(this, k, VL).call(this)
            }
            getChannels() {
                return o(this, p).find().flatMap($ => $.channels)
            }
            get topLevelId() {
                return o(this, g).findTopLevelContextId(this.id) ?? this.id
            }
            isSubscribedTo($) {
                return o(this, f).subscriptionManager.isSubscribedTo($, this.topLevelId)
            }
        }
        ,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakSet,
        HL = async function() {
            var $;
            try {
                await Promise.all([o(this, u).sendCommand("Page.enable"), o(this, u).sendCommand("Page.getFrameTree").then(B => P(this, k, TC).call(this, B.frameTree)), o(this, u).sendCommand("Runtime.enable"), o(this, u).sendCommand("Page.setLifecycleEventsEnabled", {
                    enabled: !0
                }), o(this, u).sendCommand("Page.setPrerenderingAllowed", {
                    isAllowed: !o(this, y)
                }).catch( () => {}
                ), o(this, u).sendCommand("Network.enable").then( () => this.toggleNetworkIfNeeded()), o(this, u).sendCommand("Target.setAutoAttach", {
                    autoAttach: !0,
                    waitForDebuggerOnStart: !0,
                    flatten: !0
                }), P(this, k, GL).call(this), o(this, u).sendCommand("Runtime.runIfWaitingForDebugger"), o(this, d).sendCommand("Runtime.runIfWaitingForDebugger"), this.toggleDeviceAccessIfNeeded()])
            } catch (B) {
                if (($ = o(this, v)) == null || $.call(this, r.LogType.debugError, "Failed to unblock target", B),
                !o(this, u).isCloseError(B)) {
                    o(this, w).resolve({
                        kind: "error",
                        error: B
                    });
                    return
                }
            }
            o(this, w).resolve({
                kind: "success",
                value: void 0
            })
        }
        ,
        TC = function($) {
            var z;
            const B = $.frame
              , D = o(this, g).findContext(B.id);
            if (D !== void 0 && D.parentId === null && B.parentId !== null && B.parentId !== void 0 && (D.parentId = B.parentId),
            D === void 0 && B.parentId !== void 0) {
                const G = o(this, g).getContext(B.parentId);
                s.BrowsingContextImpl.create(B.id, B.parentId, G.userContext, G.cdpTarget, o(this, f), o(this, g), o(this, h), B.url, void 0, o(this, E), o(this, v))
            }
            (z = $.childFrames) == null || z.map(G => P(this, k, TC).call(this, G))
        }
        ,
        sv = function($) {
            const B = $;
            return B.code === -32001 && B.message === "Session with given id not found." || o(this, u).isCloseError($)
        }
        ,
        WL = function() {
            o(this, u).on("Network.requestWillBeSent", $ => {
                $.loaderId === $.requestId && this.emit("frameStartedNavigating", {
                    loaderId: $.loaderId,
                    url: $.request.url,
                    frameId: $.frameId
                })
            }
            ),
            o(this, u).on("*", ($, B) => {
                typeof $ == "string" && (o(this, f).registerEvent({
                    type: "event",
                    method: `goog:cdp.${$}`,
                    params: {
                        event: $,
                        params: B,
                        session: this.cdpSessionId
                    }
                }, this.id),
                o(this, f).registerEvent({
                    type: "event",
                    method: `cdp.${$}`,
                    params: {
                        event: $,
                        params: B,
                        session: this.cdpSessionId
                    }
                }, this.id))
            }
            )
        }
        ,
        zL = async function($) {
            const B = [];
            if (($.request || $.auth) && B.push({
                urlPattern: "*",
                requestStage: "Request"
            }),
            $.response && B.push({
                urlPattern: "*",
                requestStage: "Response"
            }),
            B.length) {
                const D = o(this, C);
                S(this, C, $);
                try {
                    await o(this, u).sendCommand("Fetch.enable", {
                        patterns: B,
                        handleAuthRequests: $.auth
                    })
                } catch {
                    S(this, C, D)
                }
            }
        }
        ,
        VL = async function() {
            o(this, m).getRequestsByTarget(this).filter(B => B.interceptPhase).length === 0 && (S(this, C, {
                request: !1,
                response: !1,
                auth: !1
            }),
            await o(this, u).sendCommand("Fetch.disable"))
        }
        ,
        GL = async function() {
            await Promise.all(o(this, p).find({
                targetId: this.topLevelId,
                global: !0
            }).map($ => $.initInTarget(this, !0)))
        }
        ,
        q);
        return Nf.CdpTarget = a,
        Nf
    }
    var zM;
    function rV() {
        var a, c, u, l, d, h, f, p, g, y, m, w, E, v, _, iv, JL, ZL, XL, YL, QL, av, O, AC, eF, tF, rF, j;
        if (zM)
            return Tf;
        zM = 1,
        Object.defineProperty(Tf, "__esModule", {
            value: !0
        }),
        Tf.CdpTargetManager = void 0;
        const n = vn()
          , e = qM()
          , t = Yz()
          , r = tV()
          , s = {
            service_worker: "service-worker",
            shared_worker: "shared-worker",
            worker: "dedicated-worker"
        };
        let i = (j = class {
            constructor(B, D, z, G, ee, V, K, se, ye, ue, He, pe, I) {
                b(this, _);
                b(this, a);
                b(this, c);
                b(this, u, new Set);
                b(this, l);
                b(this, d);
                b(this, h);
                b(this, f);
                b(this, p);
                b(this, g);
                b(this, y);
                b(this, m);
                b(this, w);
                b(this, E);
                b(this, v);
                b(this, O, new Map);
                S(this, c, B),
                S(this, a, D),
                o(this, u).add(z),
                S(this, l, z),
                S(this, d, G),
                S(this, h, ee),
                S(this, g, ye),
                S(this, f, K),
                S(this, p, se),
                S(this, y, V),
                S(this, m, ue),
                S(this, v, He),
                S(this, E, pe),
                S(this, w, I),
                P(this, _, iv).call(this, D)
            }
        }
        ,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakSet,
        iv = function(B) {
            B.on("Target.attachedToTarget", D => {
                P(this, _, YL).call(this, D, B)
            }
            ),
            B.on("Target.detachedFromTarget", P(this, _, eF).bind(this)),
            B.on("Target.targetInfoChanged", P(this, _, tF).bind(this)),
            B.on("Inspector.targetCrashed", () => {
                P(this, _, rF).call(this, B)
            }
            ),
            B.on("Page.frameAttached", P(this, _, JL).bind(this)),
            B.on("Page.frameDetached", P(this, _, ZL).bind(this)),
            B.on("Page.frameSubtreeWillBeDetached", P(this, _, XL).bind(this))
        }
        ,
        JL = function(B) {
            const D = o(this, h).findContext(B.parentFrameId);
            D !== void 0 && e.BrowsingContextImpl.create(B.frameId, B.parentFrameId, D.userContext, D.cdpTarget, o(this, d), o(this, h), o(this, y), "about:blank", void 0, o(this, E), o(this, w))
        }
        ,
        ZL = function(B) {
            var D;
            B.reason !== "swap" && ((D = o(this, h).findContext(B.frameId)) == null || D.dispose(!0))
        }
        ,
        XL = function(B) {
            var D;
            (D = o(this, h).findContext(B.frameId)) == null || D.dispose(!0)
        }
        ,
        YL = function(B, D) {
            const {sessionId: z, targetInfo: G} = B
              , ee = o(this, c).getCdpClient(z)
              , V = async () => {
                await ee.sendCommand("Runtime.runIfWaitingForDebugger").then( () => D.sendCommand("Target.detachFromTarget", B)).catch(se => {
                    var ye;
                    return (ye = o(this, w)) == null ? void 0 : ye.call(this, n.LogType.debugError, se)
                }
                )
            }
            ;
            if (o(this, l) === G.targetId) {
                V();
                return
            }
            const K = G.type === "service_worker" ? `${D.sessionId}_${G.targetId}` : G.targetId;
            if (!o(this, u).has(K)) {
                switch (o(this, u).add(K),
                G.type) {
                case "tab":
                    P(this, _, iv).call(this, ee),
                    (async () => await ee.sendCommand("Target.setAutoAttach", {
                        autoAttach: !0,
                        waitForDebuggerOnStart: !0,
                        flatten: !0
                    }))();
                    return;
                case "page":
                case "iframe":
                    {
                        const se = P(this, _, av).call(this, ee, D, G)
                          , ye = o(this, h).findContext(G.targetId);
                        if (ye && G.type === "iframe")
                            ye.updateCdpTarget(se);
                        else {
                            const ue = P(this, _, QL).call(this, G, D.sessionId)
                              , He = G.browserContextId && G.browserContextId !== o(this, m) ? G.browserContextId : "default";
                            e.BrowsingContextImpl.create(G.targetId, ue, He, se, o(this, d), o(this, h), o(this, y), G.url === "" ? "about:blank" : G.url, G.openerFrameId ?? G.openerId, o(this, E), o(this, w))
                        }
                        return
                    }
                case "service_worker":
                case "worker":
                    {
                        const se = o(this, y).findRealm({
                            cdpSessionId: D.sessionId
                        });
                        if (!se) {
                            V();
                            return
                        }
                        const ye = P(this, _, av).call(this, ee, D, G);
                        P(this, _, AC).call(this, s[G.type], ye, se);
                        return
                    }
                case "shared_worker":
                    {
                        const se = P(this, _, av).call(this, ee, D, G);
                        P(this, _, AC).call(this, s[G.type], se);
                        return
                    }
                }
                V()
            }
        }
        ,
        QL = function(B, D) {
            var G;
            if (B.type !== "iframe")
                return null;
            const z = B.openerFrameId ?? B.openerId;
            return z !== void 0 ? z : D !== void 0 ? ((G = o(this, h).findContextBySession(D)) == null ? void 0 : G.id) ?? null : null
        }
        ,
        av = function(B, D, z) {
            P(this, _, iv).call(this, B);
            const G = r.CdpTarget.create(z.targetId, B, o(this, a), D, o(this, y), o(this, d), o(this, g), o(this, h), o(this, f), o(this, v), o(this, E), o(this, w));
            return o(this, f).onCdpTargetCreated(G),
            o(this, p).onCdpTargetCreated(G),
            G
        }
        ,
        O = new WeakMap,
        AC = function(B, D, z) {
            D.cdpClient.on("Runtime.executionContextCreated", G => {
                const {uniqueId: ee, id: V, origin: K} = G.context
                  , se = new t.WorkerRealm(D.cdpClient,o(this, d),V,o(this, w),(0,
                e.serializeOrigin)(K),z ? [z] : [],ee,o(this, y),B);
                o(this, O).set(D.cdpSessionId, se)
            }
            )
        }
        ,
        eF = function({sessionId: B, targetId: D}) {
            D && o(this, g).find({
                targetId: D
            }).map(ee => {
                ee.dispose(D)
            }
            );
            const z = o(this, h).findContextBySession(B);
            if (z) {
                z.dispose(!0);
                return
            }
            const G = o(this, O).get(B);
            G && o(this, y).deleteRealms({
                cdpSessionId: G.cdpClient.sessionId
            })
        }
        ,
        tF = function(B) {
            const D = o(this, h).findContext(B.targetInfo.targetId);
            D && D.onTargetInfoChanged(B)
        }
        ,
        rF = function(B) {
            const D = o(this, y).findRealms({
                cdpSessionId: B.sessionId
            });
            for (const z of D)
                z.dispose()
        }
        ,
        j);
        return Tf.CdpTargetManager = i,
        Tf
    }
    var Ff = {}, VM;
    function nV() {
        var r, s, i;
        if (VM)
            return Ff;
        VM = 1,
        Object.defineProperty(Ff, "__esModule", {
            value: !0
        }),
        Ff.BrowsingContextStorage = void 0;
        const n = mt()
          , e = ju();
        let t = (i = class {
            constructor() {
                b(this, r, new Map);
                b(this, s, new e.EventEmitter)
            }
            getTopLevelContexts() {
                return this.getAllContexts().filter(c => c.isTopLevelContext())
            }
            getAllContexts() {
                return Array.from(o(this, r).values())
            }
            deleteContextById(c) {
                o(this, r).delete(c)
            }
            deleteContext(c) {
                o(this, r).delete(c.id)
            }
            addContext(c) {
                o(this, r).set(c.id, c),
                o(this, s).emit("added", {
                    browsingContext: c
                })
            }
            waitForContext(c) {
                return o(this, r).has(c) ? Promise.resolve(this.getContext(c)) : new Promise(u => {
                    const l = d => {
                        d.browsingContext.id === c && (o(this, s).off("added", l),
                        u(d.browsingContext))
                    }
                    ;
                    o(this, s).on("added", l)
                }
                )
            }
            hasContext(c) {
                return o(this, r).has(c)
            }
            findContext(c) {
                return o(this, r).get(c)
            }
            findTopLevelContextId(c) {
                if (c === null)
                    return null;
                const u = this.findContext(c);
                if (!u)
                    return null;
                const l = u.parentId ?? null;
                return l === null ? c : this.findTopLevelContextId(l)
            }
            findContextBySession(c) {
                for (const u of o(this, r).values())
                    if (u.cdpTarget.cdpSessionId === c)
                        return u
            }
            getContext(c) {
                const u = this.findContext(c);
                if (u === void 0)
                    throw new n.NoSuchFrameException(`Context ${c} not found`);
                return u
            }
            verifyTopLevelContextsList(c) {
                const u = new Set;
                if (!c)
                    return u;
                for (const l of c) {
                    const d = this.getContext(l);
                    if (d.isTopLevelContext())
                        u.add(d);
                    else
                        throw new n.InvalidArgumentException(`Non top-level context '${l}' given.`)
                }
                return u
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i);
        return Ff.BrowsingContextStorage = t,
        Ff
    }
    var jf = {}, Df = {}, Bf = {}, GM;
    function JM() {
        var e, t;
        if (GM)
            return Bf;
        GM = 1,
        Object.defineProperty(Bf, "__esModule", {
            value: !0
        }),
        Bf.DefaultMap = void 0;
        let n = (t = class extends Map {
            constructor(i, a) {
                super(a);
                b(this, e);
                S(this, e, i)
            }
            get(i) {
                return this.has(i) || this.set(i, o(this, e).call(this, i)),
                super.get(i)
            }
        }
        ,
        e = new WeakMap,
        t);
        return Bf.DefaultMap = n,
        Bf
    }
    var ZM;
    function sV() {
        var h, f, p, g, y, m, w, E, v, _, A, C, k, x, N, R, IC, nF, sF, iF, aF, Ng, Cd, OC, oF, cF, uF, RC, kd, xi, ov, MC, Pd, Td, Ad, cv, lF, dF, hF, fF, pF, mF, gF, uv, ce, yF;
        if (ZM)
            return Df;
        ZM = 1;
        var n;
        Object.defineProperty(Df, "__esModule", {
            value: !0
        }),
        Df.NetworkRequest = void 0;
        const e = mt()
          , t = mo()
          , r = JM()
          , s = fb()
          , i = vn()
          , a = db()
          , c = new RegExp('(?<=realm=").*(?=")');
        let u = (h = class {
            constructor(H, Q, ie, me, Te=0, je) {
                b(this, R);
                b(this, f);
                b(this, p);
                b(this, g);
                b(this, y, !1);
                b(this, m);
                b(this, w, {});
                b(this, E);
                b(this, v);
                b(this, _, {});
                b(this, A);
                b(this, C);
                b(this, k);
                b(this, x);
                b(this, N, {
                    [e.ChromiumBidi.Network.EventNames.AuthRequired]: !1,
                    [e.ChromiumBidi.Network.EventNames.BeforeRequestSent]: !1,
                    [e.ChromiumBidi.Network.EventNames.FetchError]: !1,
                    [e.ChromiumBidi.Network.EventNames.ResponseCompleted]: !1,
                    [e.ChromiumBidi.Network.EventNames.ResponseStarted]: !1
                });
                J(this, "waitNextPhase", new s.Deferred);
                S(this, f, H),
                S(this, A, Q),
                S(this, C, ie),
                S(this, k, me),
                S(this, m, Te),
                S(this, x, je)
            }
            get id() {
                return o(this, f)
            }
            get fetchId() {
                return o(this, p)
            }
            get interceptPhase() {
                return o(this, g)
            }
            get url() {
                var ie, me, Te, je, dt, ht, Vr, tr;
                const H = ((ie = o(this, w).info) == null ? void 0 : ie.request.urlFragment) ?? ((me = o(this, w).paused) == null ? void 0 : me.request.urlFragment) ?? "";
                return `${((Te = o(this, _).paused) == null ? void 0 : Te.request.url) ?? ((je = o(this, E)) == null ? void 0 : je.url) ?? ((dt = o(this, _).info) == null ? void 0 : dt.url) ?? ((ht = o(this, w).auth) == null ? void 0 : ht.request.url) ?? ((Vr = o(this, w).info) == null ? void 0 : Vr.request.url) ?? ((tr = o(this, w).paused) == null ? void 0 : tr.request.url) ?? n.unknownParameter}${H}`
            }
            get redirectCount() {
                return o(this, m)
            }
            get cdpTarget() {
                return o(this, k)
            }
            get cdpClient() {
                return o(this, k).cdpClient
            }
            isRedirecting() {
                return !!o(this, w).info
            }
            handleRedirect(H) {
                o(this, _).hasExtraInfo = !1,
                o(this, _).info = H.redirectResponse,
                P(this, R, xi).call(this, {
                    wasRedirected: !0
                })
            }
            onRequestWillBeSentEvent(H) {
                o(this, w).info = H,
                P(this, R, xi).call(this)
            }
            onRequestWillBeSentExtraInfoEvent(H) {
                o(this, w).extraInfo = H,
                P(this, R, xi).call(this)
            }
            onResponseReceivedExtraInfoEvent(H) {
                H.statusCode >= 300 && H.statusCode <= 399 && o(this, w).info && H.headers.location === o(this, w).info.request.url || (o(this, _).extraInfo = H,
                P(this, R, xi).call(this))
            }
            onResponseReceivedEvent(H) {
                o(this, _).hasExtraInfo = H.hasExtraInfo,
                o(this, _).info = H.response,
                P(this, R, xi).call(this)
            }
            onServedFromCache() {
                S(this, y, !0),
                P(this, R, xi).call(this)
            }
            onLoadingFailedEvent(H) {
                P(this, R, xi).call(this, {
                    hasFailed: !0
                }),
                P(this, R, Td).call(this, () => ({
                    method: e.ChromiumBidi.Network.EventNames.FetchError,
                    params: {
                        ...P(this, R, Ad).call(this),
                        errorText: H.errorText
                    }
                }))
            }
            async failRequest(H) {
                (0,
                t.assert)(o(this, p), "Network Interception not set-up."),
                await this.cdpClient.sendCommand("Fetch.failRequest", {
                    requestId: o(this, p),
                    errorReason: H
                }),
                S(this, g, void 0)
            }
            onRequestPaused(H) {
                S(this, p, H.requestId),
                H.responseStatusCode || H.responseErrorReason ? (o(this, _).paused = H,
                P(this, R, kd).call(this, "responseStarted") && !o(this, N)[e.ChromiumBidi.Network.EventNames.ResponseStarted] && o(this, p) !== this.id ? S(this, g, "responseStarted") : P(this, R, MC).call(this)) : (o(this, w).paused = H,
                P(this, R, kd).call(this, "beforeRequestSent") && !o(this, N)[e.ChromiumBidi.Network.EventNames.BeforeRequestSent] && o(this, p) !== this.id ? S(this, g, "beforeRequestSent") : P(this, R, ov).call(this)),
                P(this, R, xi).call(this)
            }
            onAuthRequired(H) {
                S(this, p, H.requestId),
                o(this, w).auth = H,
                P(this, R, kd).call(this, "authRequired") && o(this, p) !== this.id ? S(this, g, "authRequired") : P(this, R, Pd).call(this, {
                    response: "Default"
                }),
                P(this, R, Td).call(this, () => ({
                    method: e.ChromiumBidi.Network.EventNames.AuthRequired,
                    params: {
                        ...P(this, R, Ad).call(this, "authRequired"),
                        response: P(this, R, cv).call(this)
                    }
                }))
            }
            async continueRequest(H={}) {
                const Q = P(this, R, uv).call(this, H.headers, H.cookies)
                  , ie = (0,
                a.cdpFetchHeadersFromBidiNetworkHeaders)(Q)
                  , me = l(H.body);
                await P(this, R, ov).call(this, {
                    url: H.url,
                    method: H.method,
                    headers: ie,
                    postData: me
                }),
                S(this, E, {
                    url: H.url,
                    method: H.method,
                    headers: H.headers,
                    cookies: H.cookies,
                    bodySize: d(H.body)
                })
            }
            async continueResponse(H={}) {
                var Q, ie, me;
                if (this.interceptPhase === "authRequired")
                    if (H.credentials)
                        await Promise.all([this.waitNextPhase, await P(this, R, Pd).call(this, {
                            response: "ProvideCredentials",
                            username: H.credentials.username,
                            password: H.credentials.password
                        })]);
                    else
                        return await P(this, R, Pd).call(this, {
                            response: "ProvideCredentials"
                        });
                if (o(this, g) === "responseStarted") {
                    const Te = P(this, R, uv).call(this, H.headers, H.cookies)
                      , je = (0,
                    a.cdpFetchHeadersFromBidiNetworkHeaders)(Te);
                    await P(this, R, MC).call(this, {
                        responseCode: H.statusCode ?? ((Q = o(this, _).paused) == null ? void 0 : Q.responseStatusCode),
                        responsePhrase: H.reasonPhrase ?? ((ie = o(this, _).paused) == null ? void 0 : ie.responseStatusText),
                        responseHeaders: je ?? ((me = o(this, _).paused) == null ? void 0 : me.responseHeaders)
                    }),
                    S(this, v, {
                        statusCode: H.statusCode,
                        headers: Te
                    })
                }
            }
            async continueWithAuth(H) {
                let Q, ie;
                if (H.action === "provideCredentials") {
                    const {credentials: Te} = H;
                    Q = Te.username,
                    ie = Te.password
                }
                const me = (0,
                a.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction)(H.action);
                await P(this, R, Pd).call(this, {
                    response: me,
                    username: Q,
                    password: ie
                })
            }
            async provideResponse(H) {
                if ((0,
                t.assert)(o(this, p), "Network Interception not set-up."),
                this.interceptPhase === "authRequired")
                    return await P(this, R, Pd).call(this, {
                        response: "ProvideCredentials"
                    });
                if (!H.body && !H.headers)
                    return await P(this, R, ov).call(this);
                const Q = P(this, R, uv).call(this, H.headers, H.cookies)
                  , ie = (0,
                a.cdpFetchHeadersFromBidiNetworkHeaders)(Q)
                  , me = H.statusCode ?? o(this, R, Cd) ?? 200;
                await this.cdpClient.sendCommand("Fetch.fulfillRequest", {
                    requestId: o(this, p),
                    responseCode: me,
                    responsePhrase: H.reasonPhrase,
                    responseHeaders: ie,
                    body: l(H.body)
                }),
                S(this, g, void 0)
            }
            dispose() {
                this.waitNextPhase.reject(new Error("waitNextPhase disposed"))
            }
        }
        ,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakMap,
        x = new WeakMap,
        N = new WeakMap,
        R = new WeakSet,
        IC = function() {
            return this.url.startsWith("data:")
        }
        ,
        nF = function() {
            var H, Q, ie, me, Te;
            return ((H = o(this, E)) == null ? void 0 : H.method) ?? ((Q = o(this, w).info) == null ? void 0 : Q.request.method) ?? ((ie = o(this, w).paused) == null ? void 0 : ie.request.method) ?? ((me = o(this, w).auth) == null ? void 0 : me.request.method) ?? ((Te = o(this, _).paused) == null ? void 0 : Te.request.method)
        }
        ,
        sF = function() {
            return !o(this, w).info || !o(this, w).info.loaderId || o(this, w).info.loaderId !== o(this, w).info.requestId ? null : o(this, C).getNavigationId(o(this, R, Ng) ?? void 0)
        }
        ,
        iF = function() {
            let H = [];
            return o(this, w).extraInfo && (H = o(this, w).extraInfo.associatedCookies.filter( ({blockedReasons: Q}) => !Array.isArray(Q) || Q.length === 0).map( ({cookie: Q}) => (0,
            a.cdpToBiDiCookie)(Q))),
            H
        }
        ,
        aF = function() {
            var Q, ie;
            let H = 0;
            return typeof ((Q = o(this, E)) == null ? void 0 : Q.bodySize) == "number" ? H = o(this, E).bodySize : H = (0,
            a.bidiBodySizeFromCdpPostDataEntries)(((ie = o(this, w).info) == null ? void 0 : ie.request.postDataEntries) ?? []),
            H
        }
        ,
        Ng = function() {
            var H, Q, ie, me;
            return ((H = o(this, _).paused) == null ? void 0 : H.frameId) ?? ((Q = o(this, w).info) == null ? void 0 : Q.frameId) ?? ((ie = o(this, w).paused) == null ? void 0 : ie.frameId) ?? ((me = o(this, w).auth) == null ? void 0 : me.frameId) ?? null
        }
        ,
        Cd = function() {
            var H, Q, ie, me;
            return ((H = o(this, v)) == null ? void 0 : H.statusCode) ?? ((Q = o(this, _).paused) == null ? void 0 : Q.responseStatusCode) ?? ((ie = o(this, _).extraInfo) == null ? void 0 : ie.statusCode) ?? ((me = o(this, _).info) == null ? void 0 : me.status)
        }
        ,
        OC = function() {
            var Q, ie, me;
            let H = [];
            if ((Q = o(this, E)) != null && Q.headers) {
                const Te = new r.DefaultMap( () => []);
                for (const je of o(this, E).headers)
                    Te.get(je.name).push(je.value.value);
                for (const [je,dt] of Te.entries())
                    H.push({
                        name: je,
                        value: {
                            type: "string",
                            value: dt.join(`
`).trimEnd()
                        }
                    })
            } else
                H = [...(0,
                a.bidiNetworkHeadersFromCdpNetworkHeaders)((ie = o(this, w).info) == null ? void 0 : ie.request.headers), ...(0,
                a.bidiNetworkHeadersFromCdpNetworkHeaders)((me = o(this, w).extraInfo) == null ? void 0 : me.headers)];
            return H
        }
        ,
        oF = function() {
            var ie;
            if (!o(this, _).info || !(o(this, R, Cd) === 401 || o(this, R, Cd) === 407))
                return;
            const H = o(this, R, Cd) === 401 ? "WWW-Authenticate" : "Proxy-Authenticate"
              , Q = [];
            for (const [me,Te] of Object.entries(o(this, _).info.headers))
                me.localeCompare(H, void 0, {
                    sensitivity: "base"
                }) === 0 && Q.push({
                    scheme: Te.split(" ").at(0) ?? "",
                    realm: ((ie = Te.match(c)) == null ? void 0 : ie.at(0)) ?? ""
                });
            return Q
        }
        ,
        cF = function() {
            var Q, ie, me, Te, je, dt, ht, Vr, tr, Ei, xg, Cg, kg, Pg, BN, qN, UN, KN, HN, WN, zN, VN;
            const H = (0,
            a.getTiming)((0,
            a.getTiming)((ie = (Q = o(this, _).info) == null ? void 0 : Q.timing) == null ? void 0 : ie.requestTime) - (0,
            a.getTiming)((me = o(this, w).info) == null ? void 0 : me.timestamp));
            return {
                timeOrigin: Math.round((0,
                a.getTiming)((Te = o(this, w).info) == null ? void 0 : Te.wallTime) * 1e3),
                requestTime: 0,
                redirectStart: 0,
                redirectEnd: 0,
                fetchStart: (0,
                a.getTiming)((dt = (je = o(this, _).info) == null ? void 0 : je.timing) == null ? void 0 : dt.workerFetchStart, H),
                dnsStart: (0,
                a.getTiming)((Vr = (ht = o(this, _).info) == null ? void 0 : ht.timing) == null ? void 0 : Vr.dnsStart, H),
                dnsEnd: (0,
                a.getTiming)((Ei = (tr = o(this, _).info) == null ? void 0 : tr.timing) == null ? void 0 : Ei.dnsEnd, H),
                connectStart: (0,
                a.getTiming)((Cg = (xg = o(this, _).info) == null ? void 0 : xg.timing) == null ? void 0 : Cg.connectStart, H),
                connectEnd: (0,
                a.getTiming)((Pg = (kg = o(this, _).info) == null ? void 0 : kg.timing) == null ? void 0 : Pg.connectEnd, H),
                tlsStart: (0,
                a.getTiming)((qN = (BN = o(this, _).info) == null ? void 0 : BN.timing) == null ? void 0 : qN.sslStart, H),
                requestStart: (0,
                a.getTiming)((KN = (UN = o(this, _).info) == null ? void 0 : UN.timing) == null ? void 0 : KN.sendStart, H),
                responseStart: (0,
                a.getTiming)((WN = (HN = o(this, _).info) == null ? void 0 : HN.timing) == null ? void 0 : WN.receiveHeadersStart, H),
                responseEnd: (0,
                a.getTiming)((VN = (zN = o(this, _).info) == null ? void 0 : zN.timing) == null ? void 0 : VN.receiveHeadersEnd, H)
            }
        }
        ,
        uF = function() {
            this.waitNextPhase.resolve(),
            this.waitNextPhase = new s.Deferred
        }
        ,
        RC = function(H) {
            return o(this, k).isSubscribedTo(`network.${H}`) ? o(this, C).getInterceptsForPhase(this, H) : new Set
        }
        ,
        kd = function(H) {
            return P(this, R, RC).call(this, H).size > 0
        }
        ,
        xi = function(H={}) {
            const Q = H.wasRedirected || H.hasFailed || P(this, R, IC).call(this) || !!o(this, w).extraInfo || o(this, y) || !!(o(this, _).info && !o(this, _).hasExtraInfo)
              , ie = P(this, R, IC).call(this) || o(this, y)
              , me = !ie && P(this, R, kd).call(this, "beforeRequestSent")
              , Te = !me || me && !!o(this, w).paused;
            o(this, w).info && (me ? Te : Q) && P(this, R, Td).call(this, P(this, R, fF).bind(this));
            const je = !!o(this, _).extraInfo || o(this, y) || !!(o(this, _).info && !o(this, _).hasExtraInfo)
              , dt = !ie && P(this, R, kd).call(this, "responseStarted");
            (o(this, _).info || dt && o(this, _).paused) && P(this, R, Td).call(this, P(this, R, pF).bind(this));
            const ht = !dt || dt && !!o(this, _).paused;
            o(this, _).info && je && ht && (P(this, R, Td).call(this, P(this, R, mF).bind(this)),
            o(this, C).deleteRequest(this.id))
        }
        ,
        ov = async function(H={}) {
            (0,
            t.assert)(o(this, p), "Network Interception not set-up."),
            await this.cdpClient.sendCommand("Fetch.continueRequest", {
                requestId: o(this, p),
                url: H.url,
                method: H.method,
                headers: H.headers,
                postData: H.postData
            }),
            S(this, g, void 0)
        }
        ,
        MC = async function({responseCode: H, responsePhrase: Q, responseHeaders: ie}={}) {
            (0,
            t.assert)(o(this, p), "Network Interception not set-up."),
            await this.cdpClient.sendCommand("Fetch.continueResponse", {
                requestId: o(this, p),
                responseCode: H,
                responsePhrase: Q,
                responseHeaders: ie
            }),
            S(this, g, void 0)
        }
        ,
        Pd = async function(H) {
            (0,
            t.assert)(o(this, p), "Network Interception not set-up."),
            await this.cdpClient.sendCommand("Fetch.continueWithAuth", {
                requestId: o(this, p),
                authChallengeResponse: H
            }),
            S(this, g, void 0)
        }
        ,
        Td = function(H) {
            var ie;
            let Q;
            try {
                Q = H()
            } catch (me) {
                (ie = o(this, x)) == null || ie.call(this, i.LogType.debugError, me);
                return
            }
            P(this, R, gF).call(this) || o(this, N)[Q.method] && Q.method !== e.ChromiumBidi.Network.EventNames.AuthRequired || (P(this, R, uF).call(this),
            o(this, N)[Q.method] = !0,
            o(this, R, Ng) ? o(this, A).registerEvent(Object.assign(Q, {
                type: "event"
            }), o(this, R, Ng)) : o(this, A).registerGlobalEvent(Object.assign(Q, {
                type: "event"
            })))
        }
        ,
        Ad = function(H) {
            var ie;
            const Q = {
                isBlocked: !1
            };
            if (H) {
                const me = P(this, R, RC).call(this, H);
                Q.isBlocked = me.size > 0,
                Q.isBlocked && (Q.intercepts = [...me])
            }
            return {
                context: o(this, R, Ng),
                navigation: o(this, R, sF),
                redirectCount: o(this, m),
                request: P(this, R, lF).call(this),
                timestamp: Math.round((0,
                a.getTiming)((ie = o(this, w).info) == null ? void 0 : ie.wallTime) * 1e3),
                ...Q
            }
        }
        ,
        cv = function() {
            var me, Te, je, dt, ht, Vr, tr, Ei, xg, Cg, kg, Pg;
            (me = o(this, _).info) != null && me.fromDiskCache && (o(this, _).extraInfo = void 0);
            const H = [...(0,
            a.bidiNetworkHeadersFromCdpNetworkHeaders)((Te = o(this, _).info) == null ? void 0 : Te.headers), ...(0,
            a.bidiNetworkHeadersFromCdpNetworkHeaders)((je = o(this, _).extraInfo) == null ? void 0 : je.headers)]
              , Q = o(this, R, oF);
            return {
                ...{
                    url: this.url,
                    protocol: ((dt = o(this, _).info) == null ? void 0 : dt.protocol) ?? "",
                    status: o(this, R, Cd) ?? -1,
                    statusText: ((ht = o(this, _).info) == null ? void 0 : ht.statusText) || ((Vr = o(this, _).paused) == null ? void 0 : Vr.responseStatusText) || "",
                    fromCache: ((tr = o(this, _).info) == null ? void 0 : tr.fromDiskCache) || ((Ei = o(this, _).info) == null ? void 0 : Ei.fromPrefetchCache) || o(this, y),
                    headers: ((xg = o(this, v)) == null ? void 0 : xg.headers) ?? H,
                    mimeType: ((Cg = o(this, _).info) == null ? void 0 : Cg.mimeType) || "",
                    bytesReceived: ((kg = o(this, _).info) == null ? void 0 : kg.encodedDataLength) || 0,
                    headersSize: (0,
                    a.computeHeadersSize)(H),
                    bodySize: 0,
                    content: {
                        size: 0
                    },
                    ...Q ? {
                        authChallenges: Q
                    } : {}
                },
                "goog:securityDetails": (Pg = o(this, _).info) == null ? void 0 : Pg.securityDetails
            }
        }
        ,
        lF = function() {
            var ie, me, Te, je, dt, ht;
            const H = o(this, R, OC);
            return {
                ...{
                    request: o(this, f),
                    url: this.url,
                    method: o(this, R, nF) ?? n.unknownParameter,
                    headers: H,
                    cookies: o(this, R, iF),
                    headersSize: (0,
                    a.computeHeadersSize)(H),
                    bodySize: o(this, R, aF),
                    destination: P(this, R, dF).call(this),
                    initiatorType: P(this, R, hF).call(this),
                    timings: o(this, R, cF)
                },
                "goog:postData": (me = (ie = o(this, w).info) == null ? void 0 : ie.request) == null ? void 0 : me.postData,
                "goog:hasPostData": (je = (Te = o(this, w).info) == null ? void 0 : Te.request) == null ? void 0 : je.hasPostData,
                "goog:resourceType": (dt = o(this, w).info) == null ? void 0 : dt.type,
                "goog:resourceInitiator": (ht = o(this, w).info) == null ? void 0 : ht.initiator
            }
        }
        ,
        dF = function() {
            var H, Q;
            switch ((H = o(this, w).info) == null ? void 0 : H.type) {
            case "Script":
                return "script";
            case "Stylesheet":
                return "style";
            case "Image":
                return "image";
            case "Document":
                return ((Q = o(this, w).info) == null ? void 0 : Q.initiator.type) === "parser" ? "iframe" : "";
            default:
                return ""
            }
        }
        ,
        hF = function() {
            var H, Q, ie, me, Te, je, dt, ht, Vr, tr;
            if (((H = o(this, w).info) == null ? void 0 : H.initiator.type) === "parser")
                switch ((Q = o(this, w).info) == null ? void 0 : Q.type) {
                case "Document":
                    return "iframe";
                case "Font":
                    return ((me = (ie = o(this, w).info) == null ? void 0 : ie.initiator) == null ? void 0 : me.url) === ((Te = o(this, w).info) == null ? void 0 : Te.documentURL) ? "font" : "css";
                case "Image":
                    return ((dt = (je = o(this, w).info) == null ? void 0 : je.initiator) == null ? void 0 : dt.url) === ((ht = o(this, w).info) == null ? void 0 : ht.documentURL) ? "img" : "css";
                case "Script":
                    return "script";
                case "Stylesheet":
                    return "link";
                default:
                    return null
                }
            return ((tr = (Vr = o(this, w)) == null ? void 0 : Vr.info) == null ? void 0 : tr.type) === "Fetch" ? "fetch" : null
        }
        ,
        fF = function() {
            var H;
            return (0,
            t.assert)(o(this, w).info, "RequestWillBeSentEvent is not set"),
            {
                method: e.ChromiumBidi.Network.EventNames.BeforeRequestSent,
                params: {
                    ...P(this, R, Ad).call(this, "beforeRequestSent"),
                    initiator: {
                        type: P(H = n, ce, yF).call(H, o(this, w).info.initiator.type),
                        columnNumber: o(this, w).info.initiator.columnNumber,
                        lineNumber: o(this, w).info.initiator.lineNumber,
                        stackTrace: o(this, w).info.initiator.stack,
                        request: o(this, w).info.initiator.requestId
                    }
                }
            }
        }
        ,
        pF = function() {
            return {
                method: e.ChromiumBidi.Network.EventNames.ResponseStarted,
                params: {
                    ...P(this, R, Ad).call(this, "responseStarted"),
                    response: P(this, R, cv).call(this)
                }
            }
        }
        ,
        mF = function() {
            return {
                method: e.ChromiumBidi.Network.EventNames.ResponseCompleted,
                params: {
                    ...P(this, R, Ad).call(this),
                    response: P(this, R, cv).call(this)
                }
            }
        }
        ,
        gF = function() {
            var Q, ie;
            const H = "/favicon.ico";
            return ((Q = o(this, w).paused) == null ? void 0 : Q.request.url.endsWith(H)) ?? ((ie = o(this, w).info) == null ? void 0 : ie.request.url.endsWith(H)) ?? !1
        }
        ,
        uv = function(H, Q) {
            if (!H && !Q)
                return;
            let ie = H;
            const me = (0,
            a.networkHeaderFromCookieHeaders)(Q);
            return me && !ie && (ie = o(this, R, OC)),
            me && ie && (ie.filter(Te => Te.name.localeCompare("cookie", void 0, {
                sensitivity: "base"
            }) !== 0),
            ie.push(me)),
            ie
        }
        ,
        ce = new WeakSet,
        yF = function(H) {
            switch (H) {
            case "parser":
            case "script":
            case "preflight":
                return H;
            default:
                return "other"
            }
        }
        ,
        b(h, ce),
        J(h, "unknownParameter", "UNKNOWN"),
        h);
        Df.NetworkRequest = u,
        n = u;
        function l(we) {
            let H;
            return (we == null ? void 0 : we.type) === "string" ? H = btoa(we.value) : (we == null ? void 0 : we.type) === "base64" && (H = we.value),
            H
        }
        function d(we) {
            return (we == null ? void 0 : we.type) === "string" ? we.value.length : (we == null ? void 0 : we.type) === "base64" ? atob(we.value).length : 0
        }
        return Df
    }
    var XM;
    function iV() {
        var i, a, c, u, l, d, h, $s, p;
        if (XM)
            return jf;
        XM = 1,
        Object.defineProperty(jf, "__esModule", {
            value: !0
        }),
        jf.NetworkStorage = void 0;
        const n = mt()
          , e = Bu()
          , t = sV()
          , r = db();
        let s = (p = class {
            constructor(y, m, w, E) {
                b(this, h);
                b(this, i);
                b(this, a);
                b(this, c);
                b(this, u, new Map);
                b(this, l, new Map);
                b(this, d, "default");
                S(this, i, m),
                S(this, a, y),
                w.on("Target.detachedFromTarget", ({sessionId: v}) => {
                    this.disposeRequestMap(v)
                }
                ),
                S(this, c, E)
            }
            onCdpTargetCreated(y) {
                const m = y.cdpClient
                  , w = [["Network.requestWillBeSent", E => {
                    const v = this.getRequestById(E.requestId);
                    v && v.isRedirecting() ? (v.handleRedirect(E),
                    this.deleteRequest(E.requestId),
                    P(this, h, $s).call(this, E.requestId, y, v.redirectCount + 1).onRequestWillBeSentEvent(E)) : P(this, h, $s).call(this, E.requestId, y).onRequestWillBeSentEvent(E)
                }
                ], ["Network.requestWillBeSentExtraInfo", E => {
                    P(this, h, $s).call(this, E.requestId, y).onRequestWillBeSentExtraInfoEvent(E)
                }
                ], ["Network.responseReceived", E => {
                    P(this, h, $s).call(this, E.requestId, y).onResponseReceivedEvent(E)
                }
                ], ["Network.responseReceivedExtraInfo", E => {
                    P(this, h, $s).call(this, E.requestId, y).onResponseReceivedExtraInfoEvent(E)
                }
                ], ["Network.requestServedFromCache", E => {
                    P(this, h, $s).call(this, E.requestId, y).onServedFromCache()
                }
                ], ["Network.loadingFailed", E => {
                    P(this, h, $s).call(this, E.requestId, y).onLoadingFailedEvent(E)
                }
                ], ["Fetch.requestPaused", E => {
                    P(this, h, $s).call(this, E.networkId ?? E.requestId, y).onRequestPaused(E)
                }
                ], ["Fetch.authRequired", E => {
                    let v = this.getRequestByFetchId(E.requestId);
                    v || (v = P(this, h, $s).call(this, E.requestId, y)),
                    v.onAuthRequired(E)
                }
                ]];
                for (const [E,v] of w)
                    m.on(E, v)
            }
            getInterceptionStages(y) {
                const m = {
                    request: !1,
                    response: !1,
                    auth: !1
                };
                for (const w of o(this, l).values())
                    w.contexts && !w.contexts.includes(y) || (m.request || (m.request = w.phases.includes("beforeRequestSent")),
                    m.response || (m.response = w.phases.includes("responseStarted")),
                    m.auth || (m.auth = w.phases.includes("authRequired")));
                return m
            }
            getInterceptsForPhase(y, m) {
                if (y.url === t.NetworkRequest.unknownParameter)
                    return new Set;
                const w = new Set;
                for (const [E,v] of o(this, l).entries())
                    if (!(!v.phases.includes(m) || v.contexts && !v.contexts.includes(y.cdpTarget.topLevelId))) {
                        if (v.urlPatterns.length === 0) {
                            w.add(E);
                            continue
                        }
                        for (const _ of v.urlPatterns)
                            if ((0,
                            r.matchUrlPattern)(_, y.url)) {
                                w.add(E);
                                break
                            }
                    }
                return w
            }
            disposeRequestMap(y) {
                for (const m of o(this, u).values())
                    m.cdpClient.sessionId === y && (o(this, u).delete(m.id),
                    m.dispose())
            }
            addIntercept(y) {
                const m = (0,
                e.uuidv4)();
                return o(this, l).set(m, y),
                m
            }
            removeIntercept(y) {
                if (!o(this, l).has(y))
                    throw new n.NoSuchInterceptException(`Intercept '${y}' does not exist.`);
                o(this, l).delete(y)
            }
            getRequestsByTarget(y) {
                const m = [];
                for (const w of o(this, u).values())
                    w.cdpTarget === y && m.push(w);
                return m
            }
            getRequestById(y) {
                return o(this, u).get(y)
            }
            getRequestByFetchId(y) {
                for (const m of o(this, u).values())
                    if (m.fetchId === y)
                        return m
            }
            addRequest(y) {
                o(this, u).set(y.id, y)
            }
            deleteRequest(y) {
                o(this, u).delete(y)
            }
            getNavigationId(y) {
                var m;
                return y === void 0 ? null : ((m = o(this, i).findContext(y)) == null ? void 0 : m.navigationId) ?? null
            }
            set defaultCacheBehavior(y) {
                S(this, d, y)
            }
            get defaultCacheBehavior() {
                return o(this, d)
            }
        }
        ,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakSet,
        $s = function(y, m, w) {
            let E = this.getRequestById(y);
            return E || (E = new t.NetworkRequest(y,o(this, a),this,m,w,o(this, c)),
            this.addRequest(E),
            E)
        }
        ,
        p);
        return jf.NetworkStorage = s,
        jf
    }
    var qf = {}, YM;
    function aV() {
        var e, t;
        if (YM)
            return qf;
        YM = 1,
        Object.defineProperty(qf, "__esModule", {
            value: !0
        }),
        qf.PreloadScriptStorage = void 0;
        let n = (t = class {
            constructor() {
                b(this, e, new Set)
            }
            find(s) {
                return s ? [...o(this, e)].filter(i => !!(s.id !== void 0 && s.id === i.id || s.targetId !== void 0 && i.targetIds.has(s.targetId) || s.global !== void 0 && (s.global && i.contexts === void 0 || !s.global && i.contexts !== void 0))) : [...o(this, e)]
            }
            add(s) {
                o(this, e).add(s)
            }
            remove(s) {
                for (const i of this.find(s))
                    o(this, e).delete(i)
            }
        }
        ,
        e = new WeakMap,
        t);
        return qf.PreloadScriptStorage = n,
        qf
    }
    var Uf = {}, QM;
    function oV() {
        var r, s, i;
        if (QM)
            return Uf;
        QM = 1,
        Object.defineProperty(Uf, "__esModule", {
            value: !0
        }),
        Uf.RealmStorage = void 0;
        const n = mt()
          , e = FM();
        let t = (i = class {
            constructor() {
                b(this, r, new Map);
                b(this, s, new Map)
            }
            get knownHandlesToRealmMap() {
                return o(this, r)
            }
            addRealm(c) {
                o(this, s).set(c.realmId, c)
            }
            findRealms(c) {
                return Array.from(o(this, s).values()).filter(u => !(c.realmId !== void 0 && c.realmId !== u.realmId || c.browsingContextId !== void 0 && !u.associatedBrowsingContexts.map(l => l.id).includes(c.browsingContextId) || c.sandbox !== void 0 && (!(u instanceof e.WindowRealm) || c.sandbox !== u.sandbox) || c.executionContextId !== void 0 && c.executionContextId !== u.executionContextId || c.origin !== void 0 && c.origin !== u.origin || c.type !== void 0 && c.type !== u.realmType || c.cdpSessionId !== void 0 && c.cdpSessionId !== u.cdpClient.sessionId))
            }
            findRealm(c) {
                const u = this.findRealms(c);
                if (u.length === 1)
                    return u[0]
            }
            getRealm(c) {
                const u = this.findRealm(c);
                if (u === void 0)
                    throw new n.NoSuchFrameException(`Realm ${JSON.stringify(c)} not found`);
                return u
            }
            deleteRealms(c) {
                this.findRealms(c).map(u => {
                    u.dispose(),
                    o(this, s).delete(u.realmId),
                    Array.from(this.knownHandlesToRealmMap.entries()).filter( ([,l]) => l === u.realmId).map( ([l]) => this.knownHandlesToRealmMap.delete(l))
                }
                )
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i);
        return Uf.RealmStorage = t,
        Uf
    }
    var Kf = {}, Hf = {}, eN;
    function cV() {
        var e, t, r;
        if (eN)
            return Hf;
        eN = 1,
        Object.defineProperty(Hf, "__esModule", {
            value: !0
        }),
        Hf.Buffer = void 0;
        class n {
            constructor(i, a) {
                b(this, e);
                b(this, t, []);
                b(this, r);
                S(this, e, i),
                S(this, r, a)
            }
            get() {
                return o(this, t)
            }
            add(i) {
                var a;
                for (o(this, t).push(i); o(this, t).length > o(this, e); ) {
                    const c = o(this, t).shift();
                    c !== void 0 && ((a = o(this, r)) == null || a.call(this, c))
                }
            }
        }
        return e = new WeakMap,
        t = new WeakMap,
        r = new WeakMap,
        Hf.Buffer = n,
        Hf
    }
    var Wf = {}, tN;
    function uV() {
        var e, t, r;
        if (tN)
            return Wf;
        tN = 1,
        Object.defineProperty(Wf, "__esModule", {
            value: !0
        }),
        Wf.IdWrapper = void 0;
        let n = (e = class {
            constructor() {
                b(this, r);
                S(this, r, ++_d(e, t)._)
            }
            get id() {
                return o(this, r)
            }
        }
        ,
        t = new WeakMap,
        r = new WeakMap,
        b(e, t, 0),
        e);
        return Wf.IdWrapper = n,
        Wf
    }
    var Uu = {}, rN;
    function lV() {
        if (rN)
            return Uu;
        rN = 1,
        Object.defineProperty(Uu, "__esModule", {
            value: !0
        }),
        Uu.isCdpEvent = e,
        Uu.isDeprecatedCdpEvent = t,
        Uu.assertSupportedEvent = r;
        const n = mt();
        function e(s) {
            var i;
            return ((i = s.split(".").at(0)) == null ? void 0 : i.startsWith(n.ChromiumBidi.BiDiModule.Cdp)) ?? !1
        }
        function t(s) {
            var i;
            return ((i = s.split(".").at(0)) == null ? void 0 : i.startsWith(n.ChromiumBidi.BiDiModule.DeprecatedCdp)) ?? !1
        }
        function r(s) {
            if (!n.ChromiumBidi.EVENT_NAMES.has(s) && !e(s) && !t(s))
                throw new n.InvalidArgumentException(`Unknown event: ${s}`)
        }
        return Uu
    }
    var ea = {}, nN;
    function dV() {
        var u, l, d, lv, f;
        if (nN)
            return ea;
        nN = 1,
        Object.defineProperty(ea, "__esModule", {
            value: !0
        }),
        ea.SubscriptionManager = void 0,
        ea.cartesianProduct = t,
        ea.unrollEvents = r,
        ea.difference = a;
        const n = mt()
          , e = Bu();
        function t(...p) {
            return p.reduce( (g, y) => g.flatMap(m => y.map(w => [m, w].flat())))
        }
        function r(p) {
            const g = new Set;
            function y(m) {
                for (const w of m)
                    g.add(w)
            }
            for (const m of p)
                switch (m) {
                case n.ChromiumBidi.BiDiModule.Bluetooth:
                    y(Object.values(n.ChromiumBidi.Bluetooth.EventNames));
                    break;
                case n.ChromiumBidi.BiDiModule.BrowsingContext:
                    y(Object.values(n.ChromiumBidi.BrowsingContext.EventNames));
                    break;
                case n.ChromiumBidi.BiDiModule.Log:
                    y(Object.values(n.ChromiumBidi.Log.EventNames));
                    break;
                case n.ChromiumBidi.BiDiModule.Network:
                    y(Object.values(n.ChromiumBidi.Network.EventNames));
                    break;
                case n.ChromiumBidi.BiDiModule.Script:
                    y(Object.values(n.ChromiumBidi.Script.EventNames));
                    break;
                default:
                    g.add(m)
                }
            return [...g.values()]
        }
        let s = (f = class {
            constructor(g) {
                b(this, d);
                b(this, u, []);
                b(this, l);
                S(this, l, g)
            }
            getChannelsSubscribedToEvent(g, y) {
                const m = new Map;
                for (const w of o(this, u))
                    P(this, d, lv).call(this, w, g, y) && m.set(JSON.stringify(w.channel), w.channel);
                return Array.from(m.values())
            }
            getChannelsSubscribedToEventGlobally(g) {
                const y = new Map;
                for (const m of o(this, u))
                    P(this, d, lv).call(this, m, g) && y.set(JSON.stringify(m.channel), m.channel);
                return Array.from(y.values())
            }
            isSubscribedTo(g, y) {
                for (const m of o(this, u))
                    if (P(this, d, lv).call(this, m, g, y))
                        return !0;
                return !1
            }
            subscribe(g, y, m) {
                const w = {
                    id: (0,
                    e.uuidv4)(),
                    eventNames: new Set(r(g)),
                    topLevelTraversableIds: new Set(y.map(E => {
                        const v = o(this, l).findTopLevelContextId(E);
                        if (!v)
                            throw new n.NoSuchFrameException(`Top-level navigable not found for context id ${E}`);
                        return v
                    }
                    )),
                    channel: m
                };
                return o(this, u).push(w),
                w
            }
            unsubscribe(g, y, m) {
                const w = new Set(r(g));
                for (const k of y)
                    o(this, l).getContext(k);
                const E = new Set(y.map(k => {
                    const x = o(this, l).findTopLevelContextId(k);
                    if (!x)
                        throw new n.NoSuchFrameException(`Top-level navigable not found for context id ${k}`);
                    return x
                }
                ))
                  , v = E.size === 0
                  , _ = []
                  , A = new Set
                  , C = new Set;
                for (const k of o(this, u)) {
                    if (JSON.stringify(k.channel) !== JSON.stringify(m)) {
                        _.push(k);
                        continue
                    }
                    if (i(k.eventNames, w).size === 0) {
                        _.push(k);
                        continue
                    }
                    if (v) {
                        if (k.topLevelTraversableIds.size !== 0) {
                            _.push(k);
                            continue
                        }
                        const x = new Set(k.eventNames);
                        for (const N of w)
                            x.has(N) && (A.add(N),
                            x.delete(N));
                        x.size !== 0 && _.push({
                            ...k,
                            eventNames: x
                        })
                    } else {
                        if (k.topLevelTraversableIds.size === 0) {
                            _.push(k);
                            continue
                        }
                        const x = new Map;
                        for (const N of k.eventNames)
                            x.set(N, new Set(k.topLevelTraversableIds));
                        for (const N of w) {
                            const R = x.get(N);
                            if (R) {
                                for (const F of E)
                                    R.has(F) && (C.add(F),
                                    A.add(N),
                                    R.delete(F));
                                R.size === 0 && x.delete(N)
                            }
                        }
                        for (const [N,R] of x) {
                            const F = {
                                id: k.id,
                                channel: k.channel,
                                eventNames: new Set([N]),
                                topLevelTraversableIds: R
                            };
                            _.push(F)
                        }
                    }
                }
                if (!c(A, w))
                    throw new n.InvalidArgumentException("No subscription found");
                if (!v && !c(C, E))
                    throw new n.InvalidArgumentException("No subscription found");
                S(this, u, _)
            }
            unsubscribeById(g) {}
        }
        ,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakSet,
        lv = function(g, y, m) {
            let w = !1;
            for (const v of g.eventNames)
                if (v === y || v === y.split(".").at(0) || v.split(".").at(0) === y) {
                    w = !0;
                    break
                }
            if (!w)
                return !1;
            if (g.topLevelTraversableIds.size === 0)
                return !0;
            const E = m ? o(this, l).findTopLevelContextId(m) : null;
            return !!(E !== null && g.topLevelTraversableIds.has(E))
        }
        ,
        f);
        ea.SubscriptionManager = s;
        function i(p, g) {
            const y = new Set;
            for (const m of p)
                g.has(m) && y.add(m);
            return y
        }
        function a(p, g) {
            const y = new Set;
            for (const m of p)
                g.has(m) || y.add(m);
            return y
        }
        function c(p, g) {
            if (p.size !== g.size)
                return !1;
            for (const y of p)
                if (!g.has(y))
                    return !1;
            return !0
        }
        return ea
    }
    var sN;
    function hV() {
        var f, p, g, y, m, w, E, v, _, A, C, $g, x, NC, dv, $C;
        if (sN)
            return Kf;
        sN = 1;
        var n;
        Object.defineProperty(Kf, "__esModule", {
            value: !0
        }),
        Kf.EventManager = void 0;
        const e = mt()
          , t = cV()
          , r = JM()
          , s = ju()
          , i = uV()
          , a = NE()
          , c = lV()
          , u = dV();
        class l {
            constructor(T, L) {
                b(this, f, new i.IdWrapper);
                b(this, p);
                b(this, g);
                S(this, g, T),
                S(this, p, L)
            }
            get id() {
                return o(this, f).id
            }
            get contextId() {
                return o(this, p)
            }
            get event() {
                return o(this, g)
            }
        }
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap;
        const d = new Map([[e.ChromiumBidi.Log.EventNames.LogEntryAdded, 100]]);
        let h = (C = class extends s.EventEmitter {
            constructor(L) {
                super();
                b(this, x);
                b(this, y, new r.DefaultMap( () => new Set));
                b(this, m, new Map);
                b(this, w, new Map);
                b(this, E);
                b(this, v);
                b(this, _);
                S(this, v, L),
                S(this, E, new u.SubscriptionManager(L)),
                S(this, _, new r.DefaultMap( () => []))
            }
            get subscriptionManager() {
                return o(this, E)
            }
            addSubscribeHook(L, q) {
                o(this, _).get(L).push(q)
            }
            registerEvent(L, q) {
                this.registerPromiseEvent(Promise.resolve({
                    kind: "success",
                    value: L
                }), q, L.method)
            }
            registerGlobalEvent(L) {
                this.registerGlobalPromiseEvent(Promise.resolve({
                    kind: "success",
                    value: L
                }), L.method)
            }
            registerPromiseEvent(L, q, Z) {
                const j = new l(L,q)
                  , $ = o(this, E).getChannelsSubscribedToEvent(Z, q);
                P(this, x, NC).call(this, j, Z);
                for (const B of $)
                    this.emit("event", {
                        message: a.OutgoingMessage.createFromPromise(L, B),
                        event: Z
                    }),
                    P(this, x, dv).call(this, j, B, Z)
            }
            registerGlobalPromiseEvent(L, q) {
                const Z = new l(L,null)
                  , j = o(this, E).getChannelsSubscribedToEventGlobally(q);
                P(this, x, NC).call(this, Z, q);
                for (const $ of j)
                    this.emit("event", {
                        message: a.OutgoingMessage.createFromPromise(L, $),
                        event: q
                    }),
                    P(this, x, dv).call(this, Z, $, q)
            }
            async subscribe(L, q, Z) {
                for (const z of L)
                    (0,
                    c.assertSupportedEvent)(z);
                for (const z of q)
                    z !== null && o(this, v).getContext(z);
                const j = new Set((0,
                u.unrollEvents)(L))
                  , $ = new Map
                  , B = new Set(q.length ? q.map(z => {
                    const G = o(this, v).findTopLevelContextId(z);
                    if (!G)
                        throw new e.InvalidArgumentException("Invalid context id");
                    return G
                }
                ) : o(this, v).getTopLevelContexts().map(z => z.id));
                for (const z of j) {
                    const G = new Set(o(this, v).getTopLevelContexts().map(ee => ee.id).filter(ee => o(this, E).isSubscribedTo(z, ee)));
                    $.set(z, (0,
                    u.difference)(B, G))
                }
                const D = o(this, E).subscribe(L, q, Z);
                for (const z of D.eventNames)
                    for (const G of B)
                        for (const ee of P(this, x, $C).call(this, z, G, Z))
                            this.emit("event", {
                                message: a.OutgoingMessage.createFromPromise(ee.event, Z),
                                event: z
                            }),
                            P(this, x, dv).call(this, ee, Z, z);
                for (const [z,G] of $)
                    for (const ee of G)
                        o(this, _).get(z).forEach(V => V(ee));
                return await this.toggleModulesIfNeeded(),
                D.id
            }
            async unsubscribe(L, q, Z) {
                for (const j of L)
                    (0,
                    c.assertSupportedEvent)(j);
                o(this, E).unsubscribe(L, q, Z),
                await this.toggleModulesIfNeeded()
            }
            async toggleModulesIfNeeded() {
                await Promise.all(o(this, v).getAllContexts().map(async L => await L.toggleModulesIfNeeded()))
            }
            clearBufferedEvents(L) {
                var q;
                for (const Z of d.keys()) {
                    const j = P(q = n, A, $g).call(q, Z, L);
                    o(this, m).delete(j)
                }
            }
        }
        ,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakSet,
        $g = function(L, q) {
            return JSON.stringify({
                eventName: L,
                browsingContext: q
            })
        }
        ,
        x = new WeakSet,
        NC = function(L, q) {
            var j;
            if (!d.has(q))
                return;
            const Z = P(j = n, A, $g).call(j, q, L.contextId);
            o(this, m).has(Z) || o(this, m).set(Z, new t.Buffer(d.get(q))),
            o(this, m).get(Z).add(L),
            o(this, y).get(q).add(L.contextId)
        }
        ,
        dv = function(L, q, Z) {
            var D, z;
            if (!d.has(Z))
                return;
            const j = P(D = n, A, $g).call(D, Z, L.contextId)
              , $ = Math.max(((z = o(this, w).get(j)) == null ? void 0 : z.get(JSON.stringify(q))) ?? 0, L.id)
              , B = o(this, w).get(j);
            B ? B.set(JSON.stringify(q), $) : o(this, w).set(j, new Map([[JSON.stringify(q), $]]))
        }
        ,
        $C = function(L, q, Z) {
            var D, z, G;
            const j = P(D = n, A, $g).call(D, L, q)
              , $ = ((z = o(this, w).get(j)) == null ? void 0 : z.get(JSON.stringify(Z))) ?? -1 / 0
              , B = ((G = o(this, m).get(j)) == null ? void 0 : G.get().filter(ee => ee.id > $)) ?? [];
            return q === null && Array.from(o(this, y).get(L).keys()).filter(ee => ee !== null && o(this, v).hasContext(ee)).map(ee => P(this, x, $C).call(this, L, ee, Z)).forEach(ee => B.push(...ee)),
            B.sort( (ee, V) => ee.id - V.id)
        }
        ,
        b(C, A),
        C);
        return Kf.EventManager = h,
        n = h,
        Kf
    }
    var iN;
    function fV() {
        var f, p, g, y, m, w, E, v, _, A, C, k, wF, N;
        if (iN)
            return nf;
        iN = 1,
        Object.defineProperty(nf, "__esModule", {
            value: !0
        }),
        nf.BidiServer = void 0;
        const n = ju()
          , e = vn()
          , t = Sz()
          , r = zz()
          , s = Vz()
          , i = rV()
          , a = nV()
          , c = iV()
          , u = aV()
          , l = oV()
          , d = hV();
        let h = (N = class extends n.EventEmitter {
            constructor(O, T, L, q, Z, j, $) {
                super();
                b(this, k);
                b(this, f);
                b(this, p);
                b(this, g);
                b(this, y);
                b(this, m, new a.BrowsingContextStorage);
                b(this, w, new l.RealmStorage);
                b(this, E, new u.PreloadScriptStorage);
                b(this, v);
                b(this, _);
                b(this, A, O => {
                    o(this, g).processCommand(O).catch(T => {
                        var L;
                        (L = o(this, _)) == null || L.call(this, e.LogType.debugError, T)
                    }
                    )
                }
                );
                b(this, C, async O => {
                    const T = {
                        ...O.message,
                        ...O.channel
                    };
                    await o(this, p).sendMessage(T)
                }
                );
                S(this, _, $),
                S(this, f, new t.ProcessingQueue(o(this, C),o(this, _))),
                S(this, p, O),
                o(this, p).setOnMessage(o(this, A)),
                S(this, y, new d.EventManager(o(this, m)));
                const B = new c.NetworkStorage(o(this, y),o(this, m),L,$);
                S(this, v, new s.BluetoothProcessor(o(this, y),o(this, m))),
                S(this, g, new r.CommandProcessor(T,L,o(this, y),o(this, m),o(this, w),o(this, E),B,o(this, v),j,async D => {
                    await L.sendCommand("Security.setIgnoreCertificateErrors", {
                        ignore: D.acceptInsecureCerts ?? !1
                    }),
                    new i.CdpTargetManager(T,L,q,o(this, y),o(this, m),o(this, w),B,o(this, v),o(this, E),Z,(D == null ? void 0 : D["goog:prerenderingDisabled"]) ?? !1,D == null ? void 0 : D.unhandledPromptBehavior,$),
                    await L.sendCommand("Target.setDiscoverTargets", {
                        discover: !0
                    }),
                    await L.sendCommand("Target.setAutoAttach", {
                        autoAttach: !0,
                        waitForDebuggerOnStart: !0,
                        flatten: !0,
                        filter: [{
                            type: "page",
                            exclude: !0
                        }, {}]
                    }),
                    await P(this, k, wF).call(this)
                }
                ,o(this, _))),
                o(this, y).on("event", ({message: D, event: z}) => {
                    this.emitOutgoingMessage(D, z)
                }
                ),
                o(this, g).on("response", ({message: D, event: z}) => {
                    this.emitOutgoingMessage(D, z)
                }
                )
            }
            static async createAndStart(O, T, L, q, Z, j) {
                const [{browserContextIds: $},{targetInfos: B}] = await Promise.all([L.sendCommand("Target.getBrowserContexts"), L.sendCommand("Target.getTargets")]);
                let D = "default";
                for (const G of B)
                    if (G.browserContextId && !$.includes(G.browserContextId)) {
                        D = G.browserContextId;
                        break
                    }
                return new N(O,T,L,q,D,Z,j)
            }
            emitOutgoingMessage(O, T) {
                o(this, f).add(O, T)
            }
            close() {
                o(this, p).close()
            }
        }
        ,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        E = new WeakMap,
        v = new WeakMap,
        _ = new WeakMap,
        A = new WeakMap,
        C = new WeakMap,
        k = new WeakSet,
        wF = async function() {
            await Promise.all(o(this, m).getTopLevelContexts().map(O => O.lifecycleLoaded()))
        }
        ,
        N);
        return nf.BidiServer = h,
        nf
    }
    var aN;
    function pV() {
        return aN || (aN = 1,
        function(n) {
            Object.defineProperty(n, "__esModule", {
                value: !0
            }),
            n.OutgoingMessage = n.EventEmitter = n.BidiServer = void 0;
            var e = fV();
            Object.defineProperty(n, "BidiServer", {
                enumerable: !0,
                get: function() {
                    return e.BidiServer
                }
            });
            var t = ju();
            Object.defineProperty(n, "EventEmitter", {
                enumerable: !0,
                get: function() {
                    return t.EventEmitter
                }
            });
            var r = NE();
            Object.defineProperty(n, "OutgoingMessage", {
                enumerable: !0,
                get: function() {
                    return r.OutgoingMessage
                }
            })
        }(AE)),
        AE
    }
    var $E = pV();
    const gc = class gc extends Ld {
        constructor(t, r) {
            super();
            b(this, od, !1);
            b(this, Ba);
            b(this, yi, pt.create());
            J(this, "frame");
            J(this, "onClose", () => {
                gc.sessions.delete(this.id()),
                S(this, od, !0)
            }
            );
            if (this.frame = t,
            !this.frame.page().browser().cdpSupported)
                return;
            const s = this.frame.page().browser().connection;
            S(this, Ba, s),
            r ? (o(this, yi).resolve(r),
            gc.sessions.set(r, this)) : (async () => {
                try {
                    const {result: i} = await s.send("goog:cdp.getSession", {
                        context: t._id
                    });
                    o(this, yi).resolve(i.session),
                    gc.sessions.set(i.session, this)
                } catch (i) {
                    o(this, yi).reject(i)
                }
            }
            )(),
            gc.sessions.set(o(this, yi).value(), this)
        }
        connection() {}
        async send(t, r, s) {
            if (o(this, Ba) === void 0)
                throw new Oe("CDP support is required for this feature. The current browser does not support CDP.");
            if (o(this, od))
                throw new xn(`Protocol error (${t}): Session closed. Most likely the page has been closed.`);
            const i = await o(this, yi).valueOrThrow()
              , {result: a} = await o(this, Ba).send("goog:cdp.sendCommand", {
                method: t,
                params: r,
                session: i
            }, s == null ? void 0 : s.timeout);
            return a.result
        }
        async detach() {
            if (!(o(this, Ba) === void 0 || o(this, Ba).closed || o(this, od)))
                try {
                    await this.frame.client.send("Target.detachFromTarget", {
                        sessionId: this.id()
                    })
                } finally {
                    this.onClose()
                }
        }
        id() {
            const t = o(this, yi).value();
            return typeof t == "string" ? t : ""
        }
    }
    ;
    od = new WeakMap,
    Ba = new WeakMap,
    yi = new WeakMap,
    J(gc, "sessions", new Map);
    let zf = gc;
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const mV = Dc("puppeteer:webDriverBiDi:SEND ")
      , gV = Dc("puppeteer:webDriverBiDi:RECV ");
    class oN extends be {
        constructor(t, r, s=0, i) {
            super();
            b(this, eg);
            b(this, Os);
            b(this, cd);
            b(this, tg, 0);
            b(this, yc, !1);
            b(this, wi, new Yv);
            b(this, rg, []);
            S(this, eg, t),
            S(this, cd, s),
            S(this, tg, i ?? 18e4),
            S(this, Os, r),
            o(this, Os).onmessage = this.onMessage.bind(this),
            o(this, Os).onclose = this.unbind.bind(this)
        }
        get closed() {
            return o(this, yc)
        }
        get url() {
            return o(this, eg)
        }
        pipeTo(t) {
            o(this, rg).push(t)
        }
        emit(t, r) {
            for (const s of o(this, rg))
                s.emit(t, r);
            return super.emit(t, r)
        }
        send(t, r, s) {
            return ne(!o(this, yc), "Protocol error: Connection closed."),
            o(this, wi).create(t, s ?? o(this, tg), i => {
                const a = JSON.stringify({
                    id: i,
                    method: t,
                    params: r
                });
                mV(a),
                o(this, Os).send(a)
            }
            )
        }
        async onMessage(t) {
            var s;
            o(this, cd) && await new Promise(i => setTimeout(i, o(this, cd))),
            gV(t);
            const r = JSON.parse(t);
            if ("type"in r)
                switch (r.type) {
                case "success":
                    o(this, wi).resolve(r.id, r);
                    return;
                case "error":
                    if (r.id === null)
                        break;
                    o(this, wi).reject(r.id, yV(r), `${r.error}: ${r.message}`);
                    return;
                case "event":
                    if (wV(r)) {
                        (s = zf.sessions.get(r.params.session)) == null || s.emit(r.params.event, r.params.params);
                        return
                    }
                    this.emit(r.method, r.params);
                    return
                }
            "id"in r && o(this, wi).reject(r.id, `Protocol Error. Message is not in BiDi protocol format: '${t}'`, r.message),
            ge(r)
        }
        unbind() {
            o(this, yc) || (S(this, yc, !0),
            o(this, Os).onmessage = () => {}
            ,
            o(this, Os).onclose = () => {}
            ,
            o(this, wi).clear())
        }
        dispose() {
            this.unbind(),
            o(this, Os).close()
        }
        getPendingProtocolErrors() {
            return o(this, wi).getPendingProtocolErrors()
        }
    }
    eg = new WeakMap,
    Os = new WeakMap,
    cd = new WeakMap,
    tg = new WeakMap,
    yc = new WeakMap,
    wi = new WeakMap,
    rg = new WeakMap;
    function yV(n) {
        let e = `${n.error} ${n.message}`;
        return n.stacktrace && (e += ` ${n.stacktrace}`),
        e
    }
    function wV(n) {
        return n.method.startsWith("goog:cdp.")
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const bV = (n, ...e) => {
        Dc(`bidi:${n}`)(e)
    }
    ;
    async function vV(n) {
        const e = new SV
          , t = new _V(n)
          , r = {
            send(a) {
                e.emitMessage(JSON.parse(a))
            },
            close() {
                i.close(),
                t.close(),
                n.dispose()
            },
            onmessage(a) {}
        };
        e.on("bidiResponse", a => {
            r.onmessage(JSON.stringify(a))
        }
        );
        const s = new oN(n.url(),r,n.delay,n.timeout)
          , i = await $E.BidiServer.createAndStart(e, t, t.browserClient(), "", void 0, bV);
        return s
    }
    class _V {
        constructor(e) {
            b(this, ng);
            b(this, wc, new Map);
            b(this, bc);
            S(this, ng, e),
            S(this, bc, new cN(e))
        }
        browserClient() {
            return o(this, bc)
        }
        getCdpClient(e) {
            const t = o(this, ng).session(e);
            if (!t)
                throw new Error(`Unknown CDP session with id ${e}`);
            if (!o(this, wc).has(t)) {
                const r = new cN(t,e,o(this, bc));
                return o(this, wc).set(t, r),
                r
            }
            return o(this, wc).get(t)
        }
        close() {
            o(this, bc).close();
            for (const e of o(this, wc).values())
                e.close()
        }
    }
    ng = new WeakMap,
    wc = new WeakMap,
    bc = new WeakMap;
    class cN extends $E.EventEmitter {
        constructor(t, r, s) {
            super();
            b(this, ud, !1);
            b(this, vc);
            J(this, "sessionId");
            b(this, sg);
            b(this, ig, (t, r) => {
                this.emit(t, r)
            }
            );
            S(this, vc, t),
            this.sessionId = r,
            S(this, sg, s),
            o(this, vc).on("*", o(this, ig))
        }
        browserClient() {
            return o(this, sg)
        }
        async sendCommand(t, ...r) {
            if (!o(this, ud))
                try {
                    return await o(this, vc).send(t, ...r)
                } catch (s) {
                    if (o(this, ud))
                        return;
                    throw s
                }
        }
        close() {
            o(this, vc).off("*", o(this, ig)),
            S(this, ud, !0)
        }
        isCloseError(t) {
            return t instanceof xn
        }
    }
    ud = new WeakMap,
    vc = new WeakMap,
    sg = new WeakMap,
    ig = new WeakMap;
    class SV extends $E.EventEmitter {
        constructor() {
            super(...arguments);
            b(this, ld, async t => {}
            )
        }
        emitMessage(t) {
            o(this, ld).call(this, t)
        }
        setOnMessage(t) {
            S(this, ld, t)
        }
        async sendMessage(t) {
            this.emit("bidiResponse", t)
        }
        close() {
            S(this, ld, async t => {}
            )
        }
    }
    ld = new WeakMap;
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var EV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , xV = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let CV = ( () => {
        var r, s, i, a, c, u, bF, hv, vF, f;
        let n = be, e = [], t;
        return f = class extends n {
            constructor(y) {
                super();
                b(this, u);
                b(this, r, EV(this, e));
                b(this, s);
                b(this, i);
                b(this, a, new Ot);
                b(this, c);
                S(this, i, y)
            }
            static from(y) {
                var w;
                const m = new f(y);
                return P(w = m, u, bF).call(w),
                m
            }
            get disposed() {
                return o(this, a).disposed
            }
            get request() {
                return o(this, r)
            }
            get navigation() {
                return o(this, s)
            }
            dispose() {
                this[Ce]()
            }
            [(t = [Ti],
            Ce)]() {
                o(this, a).dispose(),
                super[Ce]()
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakSet,
        bF = function() {
            const y = o(this, a).use(new be(o(this, i)));
            y.once("closed", () => {
                this.emit("failed", {
                    url: o(this, i).url,
                    timestamp: new Date
                }),
                this.dispose()
            }
            ),
            y.on("request", ({request: w}) => {
                if (w.navigation === void 0 || !P(this, u, hv).call(this, w.navigation))
                    return;
                S(this, r, w),
                this.emit("request", w),
                o(this, a).use(new be(o(this, r))).on("redirect", v => {
                    S(this, r, v)
                }
                )
            }
            );
            const m = o(this, a).use(new be(o(this, u, vF)));
            m.on("browsingContext.navigationStarted", w => {
                w.context !== o(this, i).id || o(this, s) !== void 0 || S(this, s, f.from(o(this, i)))
            }
            );
            for (const w of ["browsingContext.domContentLoaded", "browsingContext.load"])
                m.on(w, E => {
                    E.context !== o(this, i).id || E.navigation === null || !P(this, u, hv).call(this, E.navigation) || this.dispose()
                }
                );
            for (const [w,E] of [["browsingContext.fragmentNavigated", "fragment"], ["browsingContext.navigationFailed", "failed"], ["browsingContext.navigationAborted", "aborted"]])
                m.on(w, v => {
                    v.context !== o(this, i).id || !P(this, u, hv).call(this, v.navigation) || (this.emit(E, {
                        url: v.url,
                        timestamp: new Date(v.timestamp)
                    }),
                    this.dispose())
                }
                )
        }
        ,
        hv = function(y) {
            return o(this, s) !== void 0 && !o(this, s).disposed ? !1 : o(this, c) === void 0 ? (S(this, c, y),
            !0) : o(this, c) === y
        }
        ,
        vF = function() {
            return o(this, i).userContext.browser.session
        }
        ,
        ( () => {
            const y = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            xV(f, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: m => "dispose"in m,
                    get: m => m.dispose
                },
                metadata: y
            }, null, e),
            y && Object.defineProperty(f, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: y
            })
        }
        )(),
        f
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var kV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }, Vf = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }, LE;
    let FE = ( () => {
        var c, u;
        let n = be, e = [], t, r, s, i, a;
        return u = class extends n {
            constructor(h, f) {
                super();
                b(this, c, kV(this, e));
                J(this, "disposables", new Ot);
                J(this, "id");
                J(this, "origin");
                J(this, "executionContextId");
                this.id = h,
                this.origin = f
            }
            get disposed() {
                return o(this, c) !== void 0
            }
            get target() {
                return {
                    realm: this.id
                }
            }
            dispose(h) {
                S(this, c, h),
                this[Ce]()
            }
            async disown(h) {
                await this.session.send("script.disown", {
                    target: this.target,
                    handles: h
                })
            }
            async callFunction(h, f, p={}) {
                const {result: g} = await this.session.send("script.callFunction", {
                    functionDeclaration: h,
                    awaitPromise: f,
                    target: this.target,
                    ...p
                });
                return g
            }
            async evaluate(h, f, p={}) {
                const {result: g} = await this.session.send("script.evaluate", {
                    expression: h,
                    awaitPromise: f,
                    target: this.target,
                    ...p
                });
                return g
            }
            async resolveExecutionContextId() {
                if (!this.executionContextId) {
                    const {result: h} = await this.session.connection.send("goog:cdp.resolveRealm", {
                        realm: this.id
                    });
                    this.executionContextId = h.executionContextId
                }
                return this.executionContextId
            }
            [(t = [Ti],
            r = [oe(h => o(h, c))],
            s = [oe(h => o(h, c))],
            i = [oe(h => o(h, c))],
            a = [oe(h => o(h, c))],
            Ce)]() {
                o(this, c) ?? S(this, c, "Realm already destroyed, probably because all associated browsing contexts closed."),
                this.emit("destroyed", {
                    reason: o(this, c)
                }),
                this.disposables.dispose(),
                super[Ce]()
            }
        }
        ,
        c = new WeakMap,
        ( () => {
            const h = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            Vf(u, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: f => "dispose"in f,
                    get: f => f.dispose
                },
                metadata: h
            }, null, e),
            Vf(u, null, r, {
                kind: "method",
                name: "disown",
                static: !1,
                private: !1,
                access: {
                    has: f => "disown"in f,
                    get: f => f.disown
                },
                metadata: h
            }, null, e),
            Vf(u, null, s, {
                kind: "method",
                name: "callFunction",
                static: !1,
                private: !1,
                access: {
                    has: f => "callFunction"in f,
                    get: f => f.callFunction
                },
                metadata: h
            }, null, e),
            Vf(u, null, i, {
                kind: "method",
                name: "evaluate",
                static: !1,
                private: !1,
                access: {
                    has: f => "evaluate"in f,
                    get: f => f.evaluate
                },
                metadata: h
            }, null, e),
            Vf(u, null, a, {
                kind: "method",
                name: "resolveExecutionContextId",
                static: !1,
                private: !1,
                access: {
                    has: f => "resolveExecutionContextId"in f,
                    get: f => f.resolveExecutionContextId
                },
                metadata: h
            }, null, e),
            h && Object.defineProperty(u, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: h
            })
        }
        )(),
        u
    }
    )();
    const hx = class hx extends FE {
        constructor(t, r) {
            super("", "");
            b(this, Lb);
            J(this, "browsingContext");
            J(this, "sandbox");
            b(this, ag, new Map);
            this.browsingContext = t,
            this.sandbox = r
        }
        static from(t, r) {
            var i;
            const s = new hx(t,r);
            return P(i = s, Lb, _F).call(i),
            s
        }
        get session() {
            return this.browsingContext.userContext.browser.session
        }
        get target() {
            return {
                context: this.browsingContext.id,
                sandbox: this.sandbox
            }
        }
    }
    ;
    ag = new WeakMap,
    Lb = new WeakSet,
    _F = function() {
        this.disposables.use(new be(this.browsingContext)).on("closed", ({reason: s}) => {
            this.dispose(s)
        }
        );
        const r = this.disposables.use(new be(this.session));
        r.on("script.realmCreated", s => {
            s.type !== "window" || s.context !== this.browsingContext.id || s.sandbox !== this.sandbox || (this.id = s.realm,
            this.origin = s.origin,
            this.executionContextId = void 0,
            this.emit("updated", this))
        }
        ),
        r.on("script.realmCreated", s => {
            if (s.type !== "dedicated-worker" || !s.owners.includes(this.id))
                return;
            const i = DE.from(this, s.realm, s.origin);
            o(this, ag).set(i.id, i);
            const a = this.disposables.use(new be(i));
            a.once("destroyed", () => {
                a.removeAllListeners(),
                o(this, ag).delete(i.id)
            }
            ),
            this.emit("worker", i)
        }
        )
    }
    ;
    let jE = hx;
    class DE extends FE {
        constructor(t, r, s) {
            super(r, s);
            b(this, Fb);
            b(this, og, new Map);
            J(this, "owners");
            this.owners = new Set([t])
        }
        static from(t, r, s) {
            var a;
            const i = new LE(t,r,s);
            return P(a = i, Fb, SF).call(a),
            i
        }
        get session() {
            return this.owners.values().next().value.session
        }
    }
    og = new WeakMap,
    Fb = new WeakSet,
    SF = function() {
        const t = this.disposables.use(new be(this.session));
        t.on("script.realmDestroyed", r => {
            r.realm === this.id && this.dispose("Realm already destroyed.")
        }
        ),
        t.on("script.realmCreated", r => {
            if (r.type !== "dedicated-worker" || !r.owners.includes(this.id))
                return;
            const s = LE.from(this, r.realm, r.origin);
            o(this, og).set(s.id, s),
            this.disposables.use(new be(s)).once("destroyed", () => {
                o(this, og).delete(s.id)
            }
            ),
            this.emit("worker", s)
        }
        )
    }
    ,
    LE = DE;
    const fx = class fx extends FE {
        constructor(t, r, s) {
            super(r, s);
            b(this, jb);
            b(this, cg, new Map);
            J(this, "browser");
            this.browser = t
        }
        static from(t, r, s) {
            var a;
            const i = new fx(t,r,s);
            return P(a = i, jb, EF).call(a),
            i
        }
        get session() {
            return this.browser.session
        }
    }
    ;
    cg = new WeakMap,
    jb = new WeakSet,
    EF = function() {
        const t = this.disposables.use(new be(this.session));
        t.on("script.realmDestroyed", r => {
            r.realm === this.id && this.dispose("Realm already destroyed.")
        }
        ),
        t.on("script.realmCreated", r => {
            if (r.type !== "dedicated-worker" || !r.owners.includes(this.id))
                return;
            const s = DE.from(this, r.realm, r.origin);
            o(this, cg).set(s.id, s),
            this.disposables.use(new be(s)).once("destroyed", () => {
                o(this, cg).delete(s.id)
            }
            ),
            this.emit("worker", s)
        }
        )
    }
    ;
    let BE = fx;
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var PV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , TV = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let AV = ( () => {
        var r, s, i, a, c, u, l, xF, Pc, f;
        let n = be, e = [], t;
        return f = class extends n {
            constructor(y, m) {
                super();
                b(this, l);
                b(this, r, PV(this, e));
                b(this, s);
                b(this, i);
                b(this, a);
                b(this, c, new Ot);
                b(this, u);
                S(this, a, y),
                S(this, u, m)
            }
            static from(y, m) {
                var E;
                const w = new f(y,m);
                return P(E = w, l, xF).call(E),
                w
            }
            get disposed() {
                return o(this, c).disposed
            }
            get error() {
                return o(this, r)
            }
            get headers() {
                return o(this, u).request.headers
            }
            get id() {
                return o(this, u).request.request
            }
            get initiator() {
                return o(this, u).initiator
            }
            get method() {
                return o(this, u).request.method
            }
            get navigation() {
                return o(this, u).navigation ?? void 0
            }
            get redirect() {
                return o(this, s)
            }
            get lastRedirect() {
                let y = o(this, s);
                for (; y; ) {
                    if (y && !o(y, s))
                        return y;
                    y = o(y, s)
                }
                return y
            }
            get response() {
                return o(this, i)
            }
            get url() {
                return o(this, u).request.url
            }
            get isBlocked() {
                return o(this, u).isBlocked
            }
            get resourceType() {
                return o(this, u).request["goog:resourceType"] ?? void 0
            }
            get postData() {
                return o(this, u).request["goog:postData"] ?? void 0
            }
            get hasPostData() {
                return o(this, u).request["goog:hasPostData"] ?? !1
            }
            async continueRequest({url: y, method: m, headers: w, cookies: E, body: v}) {
                await o(this, l, Pc).send("network.continueRequest", {
                    request: this.id,
                    url: y,
                    method: m,
                    headers: w,
                    body: v,
                    cookies: E
                })
            }
            async failRequest() {
                await o(this, l, Pc).send("network.failRequest", {
                    request: this.id
                })
            }
            async provideResponse({statusCode: y, reasonPhrase: m, headers: w, body: E}) {
                await o(this, l, Pc).send("network.provideResponse", {
                    request: this.id,
                    statusCode: y,
                    reasonPhrase: m,
                    headers: w,
                    body: E
                })
            }
            async continueWithAuth(y) {
                y.action === "provideCredentials" ? await o(this, l, Pc).send("network.continueWithAuth", {
                    request: this.id,
                    action: y.action,
                    credentials: y.credentials
                }) : await o(this, l, Pc).send("network.continueWithAuth", {
                    request: this.id,
                    action: y.action
                })
            }
            dispose() {
                this[Ce]()
            }
            [(t = [Ti],
            Ce)]() {
                o(this, c).dispose(),
                super[Ce]()
            }
            timing() {
                return o(this, u).request.timings
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakSet,
        xF = function() {
            o(this, c).use(new be(o(this, a))).once("closed", ({reason: w}) => {
                S(this, r, w),
                this.emit("error", o(this, r)),
                this.dispose()
            }
            );
            const m = o(this, c).use(new be(o(this, l, Pc)));
            m.on("network.beforeRequestSent", w => {
                w.context !== o(this, a).id || w.request.request !== this.id || w.redirectCount !== o(this, u).redirectCount + 1 || (S(this, s, f.from(o(this, a), w)),
                this.emit("redirect", o(this, s)),
                this.dispose())
            }
            ),
            m.on("network.authRequired", w => {
                w.context !== o(this, a).id || w.request.request !== this.id || !w.isBlocked || this.emit("authenticate", void 0)
            }
            ),
            m.on("network.fetchError", w => {
                w.context !== o(this, a).id || w.request.request !== this.id || o(this, u).redirectCount !== w.redirectCount || (S(this, r, w.errorText),
                this.emit("error", o(this, r)),
                this.dispose())
            }
            ),
            m.on("network.responseCompleted", w => {
                w.context !== o(this, a).id || w.request.request !== this.id || o(this, u).redirectCount !== w.redirectCount || (S(this, i, w.response),
                o(this, u).request.timings = w.request.timings,
                this.emit("success", o(this, i)),
                !(o(this, i).status >= 300 && o(this, i).status < 400) && this.dispose())
            }
            )
        }
        ,
        Pc = function() {
            return o(this, a).userContext.browser.session
        }
        ,
        ( () => {
            const y = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            TV(f, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: m => "dispose"in m,
                    get: m => m.dispose
                },
                metadata: y
            }, null, e),
            y && Object.defineProperty(f, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: y
            })
        }
        )(),
        f
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var IV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , uN = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let OV = ( () => {
        var s, i, a, c, CF, LC, d;
        let n = be, e = [], t, r;
        return d = class extends n {
            constructor(p, g) {
                super();
                b(this, c);
                b(this, s, IV(this, e));
                b(this, i);
                b(this, a, new Ot);
                J(this, "browsingContext");
                J(this, "info");
                this.browsingContext = p,
                this.info = g
            }
            static from(p, g) {
                var m;
                const y = new d(p,g);
                return P(m = y, c, CF).call(m),
                y
            }
            get closed() {
                return o(this, s) !== void 0
            }
            get disposed() {
                return this.closed
            }
            get handled() {
                return this.info.handler === "accept" || this.info.handler === "dismiss" ? !0 : o(this, i) !== void 0
            }
            get result() {
                return o(this, i)
            }
            dispose(p) {
                S(this, s, p),
                this[Ce]()
            }
            async handle(p={}) {
                return await o(this, c, LC).send("browsingContext.handleUserPrompt", {
                    ...p,
                    context: this.info.context
                }),
                o(this, i)
            }
            [(t = [Ti],
            r = [oe(p => o(p, s))],
            Ce)]() {
                o(this, s) ?? S(this, s, "User prompt already closed, probably because the associated browsing context was destroyed."),
                this.emit("closed", {
                    reason: o(this, s)
                }),
                o(this, a).dispose(),
                super[Ce]()
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakSet,
        CF = function() {
            o(this, a).use(new be(this.browsingContext)).once("closed", ({reason: y}) => {
                this.dispose(`User prompt already closed: ${y}`)
            }
            ),
            o(this, a).use(new be(o(this, c, LC))).on("browsingContext.userPromptClosed", y => {
                y.context === this.browsingContext.id && (S(this, i, y),
                this.emit("handled", y),
                this.dispose("User prompt already handled."))
            }
            )
        }
        ,
        LC = function() {
            return this.browsingContext.userContext.browser.session
        }
        ,
        ( () => {
            const p = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            uN(d, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: g => "dispose"in g,
                    get: g => g.dispose
                },
                metadata: p
            }, null, e),
            uN(d, null, r, {
                kind: "method",
                name: "handle",
                static: !1,
                private: !1,
                access: {
                    has: g => "handle"in g,
                    get: g => g.handle
                },
                metadata: p
            }, null, e),
            p && Object.defineProperty(d, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: p
            })
        }
        )(),
        d
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var RV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , St = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let MV = ( () => {
        var R, F, O, T, L, q, Z, j, kF, It, FC, z;
        let n = be, e = [], t, r, s, i, a, c, u, l, d, h, f, p, g, y, m, w, E, v, _, A, C, k, x, N;
        return z = class extends n {
            constructor(V, K, se, ye, ue) {
                super();
                b(this, j);
                b(this, R, RV(this, e));
                b(this, F);
                b(this, O);
                b(this, T, new Map);
                b(this, L, new Ot);
                b(this, q, new Map);
                b(this, Z, new Map);
                J(this, "defaultRealm");
                J(this, "id");
                J(this, "parent");
                J(this, "userContext");
                J(this, "originalOpener");
                S(this, O, ye),
                this.id = se,
                this.parent = K,
                this.userContext = V,
                this.originalOpener = ue,
                this.defaultRealm = P(this, j, FC).call(this)
            }
            static from(V, K, se, ye, ue) {
                var pe;
                const He = new z(V,K,se,ye,ue);
                return P(pe = He, j, kF).call(pe),
                He
            }
            get children() {
                return o(this, T).values()
            }
            get closed() {
                return o(this, F) !== void 0
            }
            get disposed() {
                return this.closed
            }
            get realms() {
                const V = this;
                return function*() {
                    yield V.defaultRealm,
                    yield*o(V, q).values()
                }()
            }
            get top() {
                let V = this;
                for (let {parent: K} = V; K; {parent: K} = V)
                    V = K;
                return V
            }
            get url() {
                return o(this, O)
            }
            dispose(V) {
                S(this, F, V);
                for (const K of o(this, T).values())
                    K.dispose("Parent browsing context was disposed");
                this[Ce]()
            }
            async activate() {
                await o(this, j, It).send("browsingContext.activate", {
                    context: this.id
                })
            }
            async captureScreenshot(V={}) {
                const {result: {data: K}} = await o(this, j, It).send("browsingContext.captureScreenshot", {
                    context: this.id,
                    ...V
                });
                return K
            }
            async close(V) {
                await Promise.all([...o(this, T).values()].map(async K => {
                    await K.close(V)
                }
                )),
                await o(this, j, It).send("browsingContext.close", {
                    context: this.id,
                    promptUnload: V
                })
            }
            async traverseHistory(V) {
                await o(this, j, It).send("browsingContext.traverseHistory", {
                    context: this.id,
                    delta: V
                })
            }
            async navigate(V, K) {
                await o(this, j, It).send("browsingContext.navigate", {
                    context: this.id,
                    url: V,
                    wait: K
                })
            }
            async reload(V={}) {
                await o(this, j, It).send("browsingContext.reload", {
                    context: this.id,
                    ...V
                })
            }
            async setCacheBehavior(V) {
                await o(this, j, It).send("network.setCacheBehavior", {
                    contexts: [this.id],
                    cacheBehavior: V
                })
            }
            async print(V={}) {
                const {result: {data: K}} = await o(this, j, It).send("browsingContext.print", {
                    context: this.id,
                    ...V
                });
                return K
            }
            async handleUserPrompt(V={}) {
                await o(this, j, It).send("browsingContext.handleUserPrompt", {
                    context: this.id,
                    ...V
                })
            }
            async setViewport(V={}) {
                await o(this, j, It).send("browsingContext.setViewport", {
                    context: this.id,
                    ...V
                })
            }
            async performActions(V) {
                await o(this, j, It).send("input.performActions", {
                    context: this.id,
                    actions: V
                })
            }
            async releaseActions() {
                await o(this, j, It).send("input.releaseActions", {
                    context: this.id
                })
            }
            createWindowRealm(V) {
                return P(this, j, FC).call(this, V)
            }
            async addPreloadScript(V, K={}) {
                return await this.userContext.browser.addPreloadScript(V, {
                    ...K,
                    contexts: [this]
                })
            }
            async addIntercept(V) {
                const {result: {intercept: K}} = await this.userContext.browser.session.send("network.addIntercept", {
                    ...V,
                    contexts: [this.id]
                });
                return K
            }
            async removePreloadScript(V) {
                await this.userContext.browser.removePreloadScript(V)
            }
            async getCookies(V={}) {
                const {result: {cookies: K}} = await o(this, j, It).send("storage.getCookies", {
                    ...V,
                    partition: {
                        type: "context",
                        context: this.id
                    }
                });
                return K
            }
            async setCookie(V) {
                await o(this, j, It).send("storage.setCookie", {
                    cookie: V,
                    partition: {
                        type: "context",
                        context: this.id
                    }
                })
            }
            async setFiles(V, K) {
                await o(this, j, It).send("input.setFiles", {
                    context: this.id,
                    element: V,
                    files: K
                })
            }
            async subscribe(V) {
                await o(this, j, It).subscribe(V, [this.id])
            }
            async addInterception(V) {
                await o(this, j, It).subscribe(V, [this.id])
            }
            [(t = [Ti],
            r = [oe(V => o(V, F))],
            s = [oe(V => o(V, F))],
            i = [oe(V => o(V, F))],
            a = [oe(V => o(V, F))],
            c = [oe(V => o(V, F))],
            u = [oe(V => o(V, F))],
            l = [oe(V => o(V, F))],
            d = [oe(V => o(V, F))],
            h = [oe(V => o(V, F))],
            f = [oe(V => o(V, F))],
            p = [oe(V => o(V, F))],
            g = [oe(V => o(V, F))],
            y = [oe(V => o(V, F))],
            m = [oe(V => o(V, F))],
            w = [oe(V => o(V, F))],
            E = [oe(V => o(V, F))],
            v = [oe(V => o(V, F))],
            _ = [oe(V => o(V, F))],
            A = [oe(V => o(V, F))],
            C = [oe(V => o(V, F))],
            k = [oe(V => o(V, F))],
            Ce)]() {
                o(this, F) ?? S(this, F, "Browsing context already closed, probably because the user context closed."),
                this.emit("closed", {
                    reason: o(this, F)
                }),
                o(this, L).dispose(),
                super[Ce]()
            }
            async deleteCookie(...V) {
                await Promise.all(V.map(async K => {
                    await o(this, j, It).send("storage.deleteCookies", {
                        filter: K,
                        partition: {
                            type: "context",
                            context: this.id
                        }
                    })
                }
                ))
            }
            async locateNodes(V, K) {
                return (await o(this, j, It).send("browsingContext.locateNodes", {
                    context: this.id,
                    locator: V,
                    startNodes: K.length ? K : void 0
                })).result.nodes
            }
        }
        ,
        R = new WeakMap,
        F = new WeakMap,
        O = new WeakMap,
        T = new WeakMap,
        L = new WeakMap,
        q = new WeakMap,
        Z = new WeakMap,
        j = new WeakSet,
        kF = function() {
            o(this, L).use(new be(this.userContext)).once("closed", ({reason: se}) => {
                this.dispose(`Browsing context already closed: ${se}`)
            }
            );
            const K = o(this, L).use(new be(o(this, j, It)));
            K.on("browsingContext.contextCreated", se => {
                if (se.parent !== this.id)
                    return;
                const ye = z.from(this.userContext, this, se.context, se.url, se.originalOpener);
                o(this, T).set(se.context, ye);
                const ue = o(this, L).use(new be(ye));
                ue.once("closed", () => {
                    ue.removeAllListeners(),
                    o(this, T).delete(ye.id)
                }
                ),
                this.emit("browsingcontext", {
                    browsingContext: ye
                })
            }
            ),
            K.on("browsingContext.contextDestroyed", se => {
                se.context === this.id && this.dispose("Browsing context already closed.")
            }
            ),
            K.on("browsingContext.historyUpdated", se => {
                se.context === this.id && (S(this, O, se.url),
                this.emit("historyUpdated", void 0))
            }
            ),
            K.on("browsingContext.domContentLoaded", se => {
                se.context === this.id && (S(this, O, se.url),
                this.emit("DOMContentLoaded", void 0))
            }
            ),
            K.on("browsingContext.load", se => {
                se.context === this.id && (S(this, O, se.url),
                this.emit("load", void 0))
            }
            ),
            K.on("browsingContext.navigationStarted", se => {
                if (se.context !== this.id)
                    return;
                for (const [ue,He] of o(this, Z))
                    He.disposed && o(this, Z).delete(ue);
                if (o(this, R) !== void 0 && !o(this, R).disposed)
                    return;
                S(this, R, CV.from(this));
                const ye = o(this, L).use(new be(o(this, R)));
                for (const ue of ["fragment", "failed", "aborted"])
                    ye.once(ue, ({url: He}) => {
                        ye[Ce](),
                        S(this, O, He)
                    }
                    );
                this.emit("navigation", {
                    navigation: o(this, R)
                })
            }
            ),
            K.on("network.beforeRequestSent", se => {
                if (se.context !== this.id || o(this, Z).has(se.request.request))
                    return;
                const ye = AV.from(this, se);
                o(this, Z).set(ye.id, ye),
                this.emit("request", {
                    request: ye
                })
            }
            ),
            K.on("log.entryAdded", se => {
                se.source.context === this.id && this.emit("log", {
                    entry: se
                })
            }
            ),
            K.on("browsingContext.userPromptOpened", se => {
                if (se.context !== this.id)
                    return;
                const ye = OV.from(this, se);
                this.emit("userprompt", {
                    userPrompt: ye
                })
            }
            )
        }
        ,
        It = function() {
            return this.userContext.browser.session
        }
        ,
        FC = function(V) {
            const K = jE.from(this, V);
            return K.on("worker", se => {
                this.emit("worker", {
                    realm: se
                })
            }
            ),
            K
        }
        ,
        ( () => {
            const V = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            x = [oe(K => o(K, F))],
            N = [oe(K => o(K, F))],
            St(z, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: K => "dispose"in K,
                    get: K => K.dispose
                },
                metadata: V
            }, null, e),
            St(z, null, r, {
                kind: "method",
                name: "activate",
                static: !1,
                private: !1,
                access: {
                    has: K => "activate"in K,
                    get: K => K.activate
                },
                metadata: V
            }, null, e),
            St(z, null, s, {
                kind: "method",
                name: "captureScreenshot",
                static: !1,
                private: !1,
                access: {
                    has: K => "captureScreenshot"in K,
                    get: K => K.captureScreenshot
                },
                metadata: V
            }, null, e),
            St(z, null, i, {
                kind: "method",
                name: "close",
                static: !1,
                private: !1,
                access: {
                    has: K => "close"in K,
                    get: K => K.close
                },
                metadata: V
            }, null, e),
            St(z, null, a, {
                kind: "method",
                name: "traverseHistory",
                static: !1,
                private: !1,
                access: {
                    has: K => "traverseHistory"in K,
                    get: K => K.traverseHistory
                },
                metadata: V
            }, null, e),
            St(z, null, c, {
                kind: "method",
                name: "navigate",
                static: !1,
                private: !1,
                access: {
                    has: K => "navigate"in K,
                    get: K => K.navigate
                },
                metadata: V
            }, null, e),
            St(z, null, u, {
                kind: "method",
                name: "reload",
                static: !1,
                private: !1,
                access: {
                    has: K => "reload"in K,
                    get: K => K.reload
                },
                metadata: V
            }, null, e),
            St(z, null, l, {
                kind: "method",
                name: "setCacheBehavior",
                static: !1,
                private: !1,
                access: {
                    has: K => "setCacheBehavior"in K,
                    get: K => K.setCacheBehavior
                },
                metadata: V
            }, null, e),
            St(z, null, d, {
                kind: "method",
                name: "print",
                static: !1,
                private: !1,
                access: {
                    has: K => "print"in K,
                    get: K => K.print
                },
                metadata: V
            }, null, e),
            St(z, null, h, {
                kind: "method",
                name: "handleUserPrompt",
                static: !1,
                private: !1,
                access: {
                    has: K => "handleUserPrompt"in K,
                    get: K => K.handleUserPrompt
                },
                metadata: V
            }, null, e),
            St(z, null, f, {
                kind: "method",
                name: "setViewport",
                static: !1,
                private: !1,
                access: {
                    has: K => "setViewport"in K,
                    get: K => K.setViewport
                },
                metadata: V
            }, null, e),
            St(z, null, p, {
                kind: "method",
                name: "performActions",
                static: !1,
                private: !1,
                access: {
                    has: K => "performActions"in K,
                    get: K => K.performActions
                },
                metadata: V
            }, null, e),
            St(z, null, g, {
                kind: "method",
                name: "releaseActions",
                static: !1,
                private: !1,
                access: {
                    has: K => "releaseActions"in K,
                    get: K => K.releaseActions
                },
                metadata: V
            }, null, e),
            St(z, null, y, {
                kind: "method",
                name: "createWindowRealm",
                static: !1,
                private: !1,
                access: {
                    has: K => "createWindowRealm"in K,
                    get: K => K.createWindowRealm
                },
                metadata: V
            }, null, e),
            St(z, null, m, {
                kind: "method",
                name: "addPreloadScript",
                static: !1,
                private: !1,
                access: {
                    has: K => "addPreloadScript"in K,
                    get: K => K.addPreloadScript
                },
                metadata: V
            }, null, e),
            St(z, null, w, {
                kind: "method",
                name: "addIntercept",
                static: !1,
                private: !1,
                access: {
                    has: K => "addIntercept"in K,
                    get: K => K.addIntercept
                },
                metadata: V
            }, null, e),
            St(z, null, E, {
                kind: "method",
                name: "removePreloadScript",
                static: !1,
                private: !1,
                access: {
                    has: K => "removePreloadScript"in K,
                    get: K => K.removePreloadScript
                },
                metadata: V
            }, null, e),
            St(z, null, v, {
                kind: "method",
                name: "getCookies",
                static: !1,
                private: !1,
                access: {
                    has: K => "getCookies"in K,
                    get: K => K.getCookies
                },
                metadata: V
            }, null, e),
            St(z, null, _, {
                kind: "method",
                name: "setCookie",
                static: !1,
                private: !1,
                access: {
                    has: K => "setCookie"in K,
                    get: K => K.setCookie
                },
                metadata: V
            }, null, e),
            St(z, null, A, {
                kind: "method",
                name: "setFiles",
                static: !1,
                private: !1,
                access: {
                    has: K => "setFiles"in K,
                    get: K => K.setFiles
                },
                metadata: V
            }, null, e),
            St(z, null, C, {
                kind: "method",
                name: "subscribe",
                static: !1,
                private: !1,
                access: {
                    has: K => "subscribe"in K,
                    get: K => K.subscribe
                },
                metadata: V
            }, null, e),
            St(z, null, k, {
                kind: "method",
                name: "addInterception",
                static: !1,
                private: !1,
                access: {
                    has: K => "addInterception"in K,
                    get: K => K.addInterception
                },
                metadata: V
            }, null, e),
            St(z, null, x, {
                kind: "method",
                name: "deleteCookie",
                static: !1,
                private: !1,
                access: {
                    has: K => "deleteCookie"in K,
                    get: K => K.deleteCookie
                },
                metadata: V
            }, null, e),
            St(z, null, N, {
                kind: "method",
                name: "locateNodes",
                static: !1,
                private: !1,
                access: {
                    has: K => "locateNodes"in K,
                    get: K => K.locateNodes
                },
                metadata: V
            }, null, e),
            V && Object.defineProperty(z, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: V
            })
        }
        )(),
        z
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var NV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , Ku = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let yb = ( () => {
        var u, l, d, h, f, p, PF, Tc;
        let n = be, e = [], t, r, s, i, a, c;
        return u = class extends n {
            constructor(E, v) {
                super();
                b(this, p);
                b(this, l, NV(this, e));
                b(this, d, new Map);
                b(this, h, new Ot);
                b(this, f);
                J(this, "browser");
                S(this, f, v),
                this.browser = E
            }
            static create(E, v) {
                var A;
                const _ = new u(E,v);
                return P(A = _, p, PF).call(A),
                _
            }
            get browsingContexts() {
                return o(this, d).values()
            }
            get closed() {
                return o(this, l) !== void 0
            }
            get disposed() {
                return this.closed
            }
            get id() {
                return o(this, f)
            }
            dispose(E) {
                S(this, l, E),
                this[Ce]()
            }
            async createBrowsingContext(E, v={}) {
                var C;
                const {result: {context: _}} = await o(this, p, Tc).send("browsingContext.create", {
                    type: E,
                    ...v,
                    referenceContext: (C = v.referenceContext) == null ? void 0 : C.id,
                    userContext: o(this, f)
                })
                  , A = o(this, d).get(_);
                return ne(A, "The WebDriver BiDi implementation is failing to create a browsing context correctly."),
                A
            }
            async remove() {
                try {
                    await o(this, p, Tc).send("browser.removeUserContext", {
                        userContext: o(this, f)
                    })
                } finally {
                    this.dispose("User context already closed.")
                }
            }
            async getCookies(E={}, v=void 0) {
                const {result: {cookies: _}} = await o(this, p, Tc).send("storage.getCookies", {
                    ...E,
                    partition: {
                        type: "storageKey",
                        userContext: o(this, f),
                        sourceOrigin: v
                    }
                });
                return _
            }
            async setCookie(E, v) {
                await o(this, p, Tc).send("storage.setCookie", {
                    cookie: E,
                    partition: {
                        type: "storageKey",
                        sourceOrigin: v,
                        userContext: this.id
                    }
                })
            }
            async setPermissions(E, v, _) {
                await o(this, p, Tc).send("permissions.setPermission", {
                    origin: E,
                    descriptor: v,
                    state: _,
                    userContext: o(this, f)
                })
            }
            [(t = [Ti],
            r = [oe(E => o(E, l))],
            s = [oe(E => o(E, l))],
            i = [oe(E => o(E, l))],
            a = [oe(E => o(E, l))],
            c = [oe(E => o(E, l))],
            Ce)]() {
                o(this, l) ?? S(this, l, "User context already closed, probably because the browser disconnected/closed."),
                this.emit("closed", {
                    reason: o(this, l)
                }),
                o(this, h).dispose(),
                super[Ce]()
            }
        }
        ,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakSet,
        PF = function() {
            const E = o(this, h).use(new be(this.browser));
            E.once("closed", ({reason: _}) => {
                this.dispose(`User context was closed: ${_}`)
            }
            ),
            E.once("disconnected", ({reason: _}) => {
                this.dispose(`User context was closed: ${_}`)
            }
            ),
            o(this, h).use(new be(o(this, p, Tc))).on("browsingContext.contextCreated", _ => {
                if (_.parent || _.userContext !== o(this, f))
                    return;
                const A = MV.from(this, void 0, _.context, _.url, _.originalOpener);
                o(this, d).set(A.id, A);
                const C = o(this, h).use(new be(A));
                C.on("closed", () => {
                    C.removeAllListeners(),
                    o(this, d).delete(A.id)
                }
                ),
                this.emit("browsingcontext", {
                    browsingContext: A
                })
            }
            )
        }
        ,
        Tc = function() {
            return this.browser.session
        }
        ,
        ( () => {
            const E = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            Ku(u, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: v => "dispose"in v,
                    get: v => v.dispose
                },
                metadata: E
            }, null, e),
            Ku(u, null, r, {
                kind: "method",
                name: "createBrowsingContext",
                static: !1,
                private: !1,
                access: {
                    has: v => "createBrowsingContext"in v,
                    get: v => v.createBrowsingContext
                },
                metadata: E
            }, null, e),
            Ku(u, null, s, {
                kind: "method",
                name: "remove",
                static: !1,
                private: !1,
                access: {
                    has: v => "remove"in v,
                    get: v => v.remove
                },
                metadata: E
            }, null, e),
            Ku(u, null, i, {
                kind: "method",
                name: "getCookies",
                static: !1,
                private: !1,
                access: {
                    has: v => "getCookies"in v,
                    get: v => v.getCookies
                },
                metadata: E
            }, null, e),
            Ku(u, null, a, {
                kind: "method",
                name: "setCookie",
                static: !1,
                private: !1,
                access: {
                    has: v => "setCookie"in v,
                    get: v => v.setCookie
                },
                metadata: E
            }, null, e),
            Ku(u, null, c, {
                kind: "method",
                name: "setPermissions",
                static: !1,
                private: !1,
                access: {
                    has: v => "setPermissions"in v,
                    get: v => v.setPermissions
                },
                metadata: E
            }, null, e),
            E && Object.defineProperty(u, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: E
            })
        }
        )(),
        J(u, "DEFAULT", "default"),
        u
    }
    )();
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class Gf {
        static deserialize(e) {
            var t, r, s, i;
            if (!e) {
                ge("Service did not produce a result.");
                return
            }
            switch (e.type) {
            case "array":
                return (t = e.value) == null ? void 0 : t.map(a => this.deserialize(a));
            case "set":
                return (r = e.value) == null ? void 0 : r.reduce( (a, c) => a.add(this.deserialize(c)), new Set);
            case "object":
                return (s = e.value) == null ? void 0 : s.reduce( (a, c) => {
                    const {key: u, value: l} = P(this, _c, jC).call(this, c);
                    return a[u] = l,
                    a
                }
                , {});
            case "map":
                return (i = e.value) == null ? void 0 : i.reduce( (a, c) => {
                    const {key: u, value: l} = P(this, _c, jC).call(this, c);
                    return a.set(u, l)
                }
                , new Map);
            case "promise":
                return {};
            case "regexp":
                return new RegExp(e.value.pattern,e.value.flags);
            case "date":
                return new Date(e.value);
            case "undefined":
                return;
            case "null":
                return null;
            case "number":
                return P(this, _c, TF).call(this, e.value);
            case "bigint":
                return BigInt(e.value);
            case "boolean":
                return !!e.value;
            case "string":
                return e.value
            }
            ge(`Deserialization of type ${e.type} not supported.`)
        }
    }
    _c = new WeakSet,
    TF = function(e) {
        switch (e) {
        case "-0":
            return -0;
        case "NaN":
            return NaN;
        case "Infinity":
            return 1 / 0;
        case "-Infinity":
            return -1 / 0;
        default:
            return e
        }
    }
    ,
    jC = function([e,t]) {
        const r = typeof e == "string" ? e : this.deserialize(e)
          , s = this.deserialize(t);
        return {
            key: r,
            value: s
        }
    }
    ,
    b(Gf, _c);
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const px = class px extends tP {
        constructor(t) {
            super(t.info.type, t.info.message, t.info.defaultValue);
            b(this, ug);
            S(this, ug, t),
            this.handled = t.handled
        }
        static from(t) {
            return new px(t)
        }
        async handle(t) {
            await o(this, ug).handle({
                accept: t.accept,
                userText: t.text
            })
        }
    }
    ;
    ug = new WeakMap;
    let qE = px;
    var $V = mt();
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const mx = class mx extends Xa {
        constructor(t, r) {
            super();
            b(this, Rs);
            J(this, "realm");
            b(this, dd, !1);
            S(this, Rs, t),
            this.realm = r
        }
        static from(t, r) {
            return new mx(t,r)
        }
        get disposed() {
            return o(this, dd)
        }
        async jsonValue() {
            return await this.evaluate(t => t)
        }
        asElement() {
            return null
        }
        async dispose() {
            o(this, dd) || (S(this, dd, !0),
            await this.realm.destroyHandles([this]))
        }
        get isPrimitiveValue() {
            switch (o(this, Rs).type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean":
            case "undefined":
            case "null":
                return !0;
            default:
                return !1
            }
        }
        toString() {
            return this.isPrimitiveValue ? "JSHandle:" + Gf.deserialize(o(this, Rs)) : "JSHandle@" + o(this, Rs).type
        }
        get id() {
            return "handle"in o(this, Rs) ? o(this, Rs).handle : void 0
        }
        remoteValue() {
            return o(this, Rs)
        }
        remoteObject() {
            throw new Oe("Not available in WebDriver BiDi")
        }
    }
    ;
    Rs = new WeakMap,
    dd = new WeakMap;
    let ta = mx;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var LV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , lN = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , FV = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , jV = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    let Jf = ( () => {
        var s, i;
        let n = uP, e = [], t, r;
        return i = class extends n {
            constructor(u, l) {
                super(ta.from(u, l));
                b(this, s, LV(this, e))
            }
            static from(u, l) {
                return new i(u,l)
            }
            get realm() {
                return this.handle.realm
            }
            get frame() {
                return this.realm.environment
            }
            remoteValue() {
                return this.handle.remoteValue()
            }
            async autofill(u) {
                const l = this.frame.client
                  , h = (await l.send("DOM.describeNode", {
                    objectId: this.handle.id
                })).node.backendNodeId
                  , f = this.frame._id;
                await l.send("Autofill.trigger", {
                    fieldId: h,
                    frameId: f,
                    card: u.creditCard
                })
            }
            async contentFrame() {
                const u = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const d = FV(u, await this.evaluateHandle(h => {
                        if (h instanceof HTMLIFrameElement || h instanceof HTMLFrameElement)
                            return h.contentWindow
                    }
                    ), !1).remoteValue();
                    return d.type === "window" ? this.frame.page().frames().find(h => h._id === d.value.context) ?? null : null
                } catch (l) {
                    u.error = l,
                    u.hasError = !0
                } finally {
                    jV(u)
                }
            }
            async uploadFile(...u) {
                const l = Pi.value.path;
                l && (u = u.map(d => l.win32.isAbsolute(d) || l.posix.isAbsolute(d) ? d : l.resolve(d))),
                await this.frame.setFiles(this, u)
            }
            async*queryAXTree(u, l) {
                const d = await this.frame.locateNodes(this, {
                    type: "accessibility",
                    value: {
                        role: l,
                        name: u
                    }
                });
                return yield*Uc.map(d, h => Promise.resolve(i.from(h, this.realm)))
            }
            async backendNodeId() {
                if (!this.frame.page().browser().cdpSupported)
                    throw new Oe;
                if (o(this, s))
                    return o(this, s);
                const {node: u} = await this.frame.client.send("DOM.describeNode", {
                    objectId: this.handle.id
                });
                return S(this, s, u.backendNodeId),
                o(this, s)
            }
        }
        ,
        s = new WeakMap,
        ( () => {
            const u = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            t = [oe()],
            r = [oe(), Xe],
            lN(i, null, t, {
                kind: "method",
                name: "autofill",
                static: !1,
                private: !1,
                access: {
                    has: l => "autofill"in l,
                    get: l => l.autofill
                },
                metadata: u
            }, null, e),
            lN(i, null, r, {
                kind: "method",
                name: "contentFrame",
                static: !1,
                private: !1,
                access: {
                    has: l => "contentFrame"in l,
                    get: l => l.contentFrame
                },
                metadata: u
            }, null, e),
            u && Object.defineProperty(i, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: u
            })
        }
        )(),
        i
    }
    )();
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var UE = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , DV = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    const gx = class gx {
        constructor(e, t, r, s=!1) {
            b(this, Ms);
            b(this, qa);
            J(this, "name");
            b(this, lg);
            b(this, hd);
            b(this, fd);
            b(this, dg, []);
            b(this, hg, new Ot);
            b(this, Db, async e => {
                const t = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    if (e.channel !== o(this, fd))
                        return;
                    const r = P(this, Ms, OF).call(this, e.source);
                    if (!r)
                        return;
                    const s = UE(t, ta.from(e.data, r), !1)
                      , i = UE(t, await s.evaluateHandle( ([,,l]) => l), !1)
                      , a = UE(t, new Ot, !1)
                      , c = [];
                    for (const [l,d] of await i.getProperties()) {
                        if (a.use(d),
                        d instanceof Jf) {
                            c[+l] = d,
                            a.use(d);
                            continue
                        }
                        c[+l] = d.jsonValue()
                    }
                    let u;
                    try {
                        u = await o(this, lg).call(this, ...await Promise.all(c))
                    } catch (l) {
                        try {
                            l instanceof Error ? await s.evaluate( ([,d], h, f, p) => {
                                const g = new Error(f);
                                g.name = h,
                                p && (g.stack = p),
                                d(g)
                            }
                            , l.name, l.message, l.stack) : await s.evaluate( ([,d], h) => {
                                d(h)
                            }
                            , l)
                        } catch (d) {
                            ge(d)
                        }
                        return
                    }
                    try {
                        await s.evaluate( ([l], d) => {
                            l(d)
                        }
                        , u)
                    } catch (l) {
                        ge(l)
                    }
                } catch (r) {
                    t.error = r,
                    t.hasError = !0
                } finally {
                    DV(t)
                }
            }
            );
            S(this, qa, e),
            this.name = t,
            S(this, lg, r),
            S(this, hd, s),
            S(this, fd, `__puppeteer__${o(this, qa)._id}_page_exposeFunction_${this.name}`)
        }
        static async from(e, t, r, s=!1) {
            var a;
            const i = new gx(e,t,r,s);
            return await P(a = i, Ms, AF).call(a),
            i
        }
        [Symbol.dispose]() {
            this[Symbol.asyncDispose]().catch(ge)
        }
        async[Symbol.asyncDispose]() {
            o(this, hg).dispose(),
            await Promise.all(o(this, dg).map(async ([e,t]) => {
                const r = o(this, hd) ? e.isolatedRealm() : e.mainRealm();
                try {
                    await Promise.all([r.evaluate(s => {
                        delete globalThis[s]
                    }
                    , this.name), ...e.childFrames().map(s => s.evaluate(i => {
                        delete globalThis[i]
                    }
                    , this.name)), e.browsingContext.removePreloadScript(t)])
                } catch (s) {
                    ge(s)
                }
            }
            ))
        }
    }
    ;
    qa = new WeakMap,
    lg = new WeakMap,
    hd = new WeakMap,
    fd = new WeakMap,
    dg = new WeakMap,
    hg = new WeakMap,
    Ms = new WeakSet,
    AF = async function() {
        const e = o(this, Ms, IF)
          , t = {
            type: "channel",
            value: {
                channel: o(this, fd),
                ownership: "root"
            }
        };
        o(this, hg).use(new be(e)).on($V.ChromiumBidi.Script.EventNames.Message, o(this, Db));
        const s = is(qc(a => {
            Object.assign(globalThis, {
                [PLACEHOLDER("name")]: function(...c) {
                    return new Promise( (u, l) => {
                        a([u, l, c])
                    }
                    )
                }
            })
        }
        , {
            name: JSON.stringify(this.name)
        }))
          , i = [o(this, qa)];
        for (const a of i)
            i.push(...a.childFrames());
        await Promise.all(i.map(async a => {
            const c = o(this, hd) ? a.isolatedRealm() : a.mainRealm();
            try {
                const [u] = await Promise.all([a.browsingContext.addPreloadScript(s, {
                    arguments: [t],
                    sandbox: c.sandbox
                }), c.realm.callFunction(s, !1, {
                    arguments: [t]
                })]);
                o(this, dg).push([a, u])
            } catch (u) {
                ge(u)
            }
        }
        ))
    }
    ,
    IF = function() {
        return o(this, qa).page().browser().connection
    }
    ,
    Db = new WeakMap,
    OF = function(e) {
        const t = P(this, Ms, RF).call(this, e.context);
        if (t)
            return t.realm(e.realm)
    }
    ,
    RF = function(e) {
        const t = [o(this, qa)];
        for (const r of t) {
            if (r._id === e)
                return r;
            t.push(...r.childFrames())
        }
    }
    ;
    let Zf = gx;
    var BV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , qV = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let dN = ( () => {
        var r, s, i, a, c, MF, l;
        let n = pP, e = [], t;
        return l = class extends n {
            constructor(f, p, g) {
                super();
                b(this, c);
                b(this, r, BV(this, e));
                b(this, s);
                b(this, i);
                b(this, a, !1);
                S(this, r, f),
                S(this, s, p),
                S(this, a, g);
                const y = f["goog:securityDetails"];
                g && y && S(this, i, new DP(y))
            }
            static from(f, p, g) {
                var m;
                const y = new l(f,p,g);
                return P(m = y, c, MF).call(m),
                y
            }
            remoteAddress() {
                return {
                    ip: "",
                    port: -1
                }
            }
            url() {
                return o(this, r).url
            }
            status() {
                return o(this, r).status
            }
            statusText() {
                return o(this, r).statusText
            }
            headers() {
                const f = {};
                for (const p of o(this, r).headers)
                    p.value.type === "string" && (f[p.name.toLowerCase()] = p.value.value);
                return f
            }
            request() {
                return o(this, s)
            }
            fromCache() {
                return o(this, r).fromCache
            }
            timing() {
                const f = o(this, s).timing();
                return {
                    requestTime: f.requestTime,
                    proxyStart: -1,
                    proxyEnd: -1,
                    dnsStart: f.dnsStart,
                    dnsEnd: f.dnsEnd,
                    connectStart: f.connectStart,
                    connectEnd: f.connectEnd,
                    sslStart: f.tlsStart,
                    sslEnd: -1,
                    workerStart: -1,
                    workerReady: -1,
                    workerFetchStart: -1,
                    workerRespondWithSettled: -1,
                    workerRouterEvaluationStart: -1,
                    workerCacheLookupStart: -1,
                    sendStart: f.requestStart,
                    sendEnd: -1,
                    pushStart: -1,
                    pushEnd: -1,
                    receiveHeadersStart: f.responseStart,
                    receiveHeadersEnd: f.responseEnd
                }
            }
            frame() {
                return o(this, s).frame()
            }
            fromServiceWorker() {
                return !1
            }
            securityDetails() {
                if (!o(this, a))
                    throw new Oe;
                return o(this, i) ?? null
            }
            content() {
                throw new Oe
            }
        }
        ,
        r = new WeakMap,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakSet,
        MF = function() {
            var f, p;
            o(this, r).fromCache && (o(this, s)._fromMemoryCache = !0,
            (f = o(this, s).frame()) == null || f.page().trustedEmitter.emit("requestservedfromcache", o(this, s))),
            (p = o(this, s).frame()) == null || p.page().trustedEmitter.emit("response", this)
        }
        ,
        ( () => {
            const f = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            t = [Cn],
            qV(l, null, t, {
                kind: "method",
                name: "remoteAddress",
                static: !1,
                private: !1,
                access: {
                    has: p => "remoteAddress"in p,
                    get: p => p.remoteAddress
                },
                metadata: f
            }, null, e),
            f && Object.defineProperty(l, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: f
            })
        }
        )(),
        l
    }
    )();
    var KE;
    const HE = new WeakMap;
    class WE extends gy {
        constructor(t, r, s) {
            super();
            b(this, un);
            b(this, Sc);
            b(this, fg, null);
            J(this, "id");
            b(this, er);
            b(this, Et);
            b(this, pg, !1);
            b(this, Bb, async () => {
                if (!o(this, er))
                    return;
                const t = o(this, er).page()._credentials;
                t && !o(this, pg) ? (S(this, pg, !0),
                o(this, Et).continueWithAuth({
                    action: "provideCredentials",
                    credentials: {
                        type: "password",
                        username: t.username,
                        password: t.password
                    }
                })) : o(this, Et).continueWithAuth({
                    action: "cancel"
                })
            }
            );
            HE.set(t, this),
            this.interception.enabled = t.isBlocked,
            S(this, Et, t),
            S(this, er, r),
            S(this, Sc, s ? o(s, Sc) : []),
            this.id = t.id
        }
        static from(t, r, s) {
            var a;
            const i = new KE(t,r,s);
            return P(a = i, un, NF).call(a),
            i
        }
        get client() {
            return o(this, er).client
        }
        url() {
            return o(this, Et).url
        }
        resourceType() {
            if (!o(this, er).page().browser().cdpSupported)
                throw new Oe;
            return (o(this, Et).resourceType || "other").toLowerCase()
        }
        method() {
            return o(this, Et).method
        }
        postData() {
            if (!o(this, er).page().browser().cdpSupported)
                throw new Oe;
            return o(this, Et).postData
        }
        hasPostData() {
            if (!o(this, er).page().browser().cdpSupported)
                throw new Oe;
            return o(this, Et).hasPostData
        }
        async fetchPostData() {
            throw new Oe
        }
        headers() {
            const t = {};
            for (const r of o(this, Et).headers)
                t[r.name.toLowerCase()] = r.value.value;
            return {
                ...t,
                ...o(this, un, BC),
                ...o(this, un, qC)
            }
        }
        response() {
            return o(this, fg)
        }
        failure() {
            return o(this, Et).error === void 0 ? null : {
                errorText: o(this, Et).error
            }
        }
        isNavigationRequest() {
            return o(this, Et).navigation !== void 0
        }
        initiator() {
            var t;
            return {
                ...o(this, Et).initiator,
                type: ((t = o(this, Et).initiator) == null ? void 0 : t.type) ?? "other"
            }
        }
        redirectChain() {
            return o(this, Sc).slice()
        }
        frame() {
            return o(this, er)
        }
        async continue(t, r) {
            return await super.continue({
                headers: o(this, un, DC) ? this.headers() : void 0,
                ...t
            }, r)
        }
        async _continue(t={}) {
            const r = hN(t.headers);
            return this.interception.handled = !0,
            await o(this, Et).continueRequest({
                url: t.url,
                method: t.method,
                body: t.postData ? {
                    type: "base64",
                    value: Hk(t.postData)
                } : void 0,
                headers: r.length > 0 ? r : void 0
            }).catch(s => (this.interception.handled = !1,
            yy(s)))
        }
        async _abort() {
            return this.interception.handled = !0,
            await o(this, Et).failRequest().catch(t => {
                throw this.interception.handled = !1,
                t
            }
            )
        }
        async _respond(t, r) {
            this.interception.handled = !0;
            let s;
            t.body && (s = gy.getResponse(t.body));
            const i = hN(t.headers)
              , a = i.some(u => u.name === "content-length");
            t.contentType && i.push({
                name: "content-type",
                value: {
                    type: "string",
                    value: t.contentType
                }
            }),
            s != null && s.contentLength && !a && i.push({
                name: "content-length",
                value: {
                    type: "string",
                    value: String(s.contentLength)
                }
            });
            const c = t.status || 200;
            return await o(this, Et).provideResponse({
                statusCode: c,
                headers: i.length > 0 ? i : void 0,
                reasonPhrase: fP[c],
                body: s != null && s.base64 ? {
                    type: "base64",
                    value: s == null ? void 0 : s.base64
                } : void 0
            }).catch(u => {
                throw this.interception.handled = !1,
                u
            }
            )
        }
        timing() {
            return o(this, Et).timing()
        }
    }
    Sc = new WeakMap,
    fg = new WeakMap,
    er = new WeakMap,
    Et = new WeakMap,
    un = new WeakSet,
    NF = function() {
        o(this, Et).on("redirect", t => {
            const r = KE.from(t, o(this, er), this);
            o(this, Sc).push(this),
            t.once("success", () => {
                o(this, er).page().trustedEmitter.emit("requestfinished", r)
            }
            ),
            t.once("error", () => {
                o(this, er).page().trustedEmitter.emit("requestfailed", r)
            }
            ),
            r.finalizeInterceptions()
        }
        ),
        o(this, Et).once("success", t => {
            S(this, fg, dN.from(t, this, o(this, er).page().browser().cdpSupported))
        }
        ),
        o(this, Et).on("authenticate", o(this, Bb)),
        o(this, er).page().trustedEmitter.emit("request", this),
        o(this, un, DC) && this.interception.handlers.push(async () => {
            await this.continue({
                headers: this.headers()
            }, 0)
        }
        )
    }
    ,
    DC = function() {
        return !!(Object.keys(o(this, un, BC)).length || Object.keys(o(this, un, qC)).length)
    }
    ,
    BC = function() {
        var t;
        return ((t = o(this, er)) == null ? void 0 : t.page()._extraHTTPHeaders) ?? {}
    }
    ,
    qC = function() {
        var t;
        return ((t = o(this, er)) == null ? void 0 : t.page()._userAgentHeaders) ?? {}
    }
    ,
    pg = new WeakMap,
    Bb = new WeakMap,
    KE = WE;
    function hN(n) {
        const e = [];
        for (const [t,r] of Object.entries(n ?? []))
            if (!Object.is(r, void 0)) {
                const s = Array.isArray(r) ? r : [r];
                for (const i of s)
                    e.push({
                        name: t.toLowerCase(),
                        value: {
                            type: "string",
                            value: String(i)
                        }
                    })
            }
        return e
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class fN extends Error {
    }
    class pN {
        static serialize(e) {
            switch (typeof e) {
            case "symbol":
            case "function":
                throw new fN(`Unable to serializable ${typeof e}`);
            case "object":
                return P(this, pd, LF).call(this, e);
            case "undefined":
                return {
                    type: "undefined"
                };
            case "number":
                return P(this, pd, $F).call(this, e);
            case "bigint":
                return {
                    type: "bigint",
                    value: e.toString()
                };
            case "string":
                return {
                    type: "string",
                    value: e
                };
            case "boolean":
                return {
                    type: "boolean",
                    value: e
                }
            }
        }
    }
    pd = new WeakSet,
    $F = function(e) {
        let t;
        return Object.is(e, -0) ? t = "-0" : Object.is(e, 1 / 0) ? t = "Infinity" : Object.is(e, -1 / 0) ? t = "-Infinity" : Object.is(e, NaN) ? t = "NaN" : t = e,
        {
            type: "number",
            value: t
        }
    }
    ,
    LF = function(e) {
        if (e === null)
            return {
                type: "null"
            };
        if (Array.isArray(e))
            return {
                type: "array",
                value: e.map(r => this.serialize(r))
            };
        if (AD(e)) {
            try {
                JSON.stringify(e)
            } catch (r) {
                throw r instanceof TypeError && r.message.startsWith("Converting circular structure to JSON") && (r.message += " Recursive objects are not allowed."),
                r
            }
            const t = [];
            for (const r in e)
                t.push([this.serialize(r), this.serialize(e[r])]);
            return {
                type: "object",
                value: t
            }
        } else {
            if (ID(e))
                return {
                    type: "regexp",
                    value: {
                        pattern: e.source,
                        flags: e.flags
                    }
                };
            if (OD(e))
                return {
                    type: "date",
                    value: e.toISOString()
                }
        }
        throw new fN("Custom object serialization not possible. Use plain objects instead.")
    }
    ,
    b(pN, pd);
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    function UV(n) {
        if (n.exception.type !== "error")
            return Gf.deserialize(n.exception);
        const [e="",...t] = n.text.split(": ")
          , r = t.join(": ")
          , s = new Error(r);
        s.name = e;
        const i = [];
        if (n.stackTrace && i.length < Error.stackTraceLimit)
            for (const a of n.stackTrace.callFrames.reverse()) {
                if (Gr.isPuppeteerURL(a.url) && a.url !== Gr.INTERNAL_URL) {
                    const c = Gr.parse(a.url);
                    i.unshift(`    at ${a.functionName || c.functionName} (${c.functionName} at ${c.siteString}, <anonymous>:${a.lineNumber}:${a.columnNumber})`)
                } else
                    i.push(`    at ${a.functionName || "<anonymous>"} (${a.url}:${a.lineNumber}:${a.columnNumber})`);
                if (i.length >= Error.stackTraceLimit)
                    break
            }
        return s.stack = [n.text, ...i].join(`
`),
        s
    }
    function mN(n, e) {
        return t => {
            throw t instanceof Ga ? t.message += ` at ${n}` : t instanceof Qg && (t.message = `Navigation timeout of ${e} ms exceeded`),
            t
        }
    }
    var KV = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , HV = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    class zE extends xP {
        constructor(t, r) {
            super(r);
            b(this, mg);
            J(this, "realm");
            J(this, "internalPuppeteerUtil");
            this.realm = t
        }
        initialize() {
            this.realm.on("destroyed", ({reason: t}) => {
                this.taskManager.terminateAll(new Error(t)),
                this.dispose()
            }
            ),
            this.realm.on("updated", () => {
                this.internalPuppeteerUtil = void 0,
                this.taskManager.rerunAll()
            }
            )
        }
        get puppeteerUtil() {
            const t = Promise.resolve();
            return Fd.inject(r => {
                this.internalPuppeteerUtil && this.internalPuppeteerUtil.then(s => {
                    s.dispose()
                }
                ),
                this.internalPuppeteerUtil = t.then( () => this.evaluateHandle(r))
            }
            , !this.internalPuppeteerUtil),
            this.internalPuppeteerUtil
        }
        async evaluateHandle(t, ...r) {
            return await P(this, mg, UC).call(this, !1, t, ...r)
        }
        async evaluate(t, ...r) {
            return await P(this, mg, UC).call(this, !0, t, ...r)
        }
        createHandle(t) {
            return (t.type === "node" || t.type === "window") && this instanceof ra ? Jf.from(t, this) : ta.from(t, this)
        }
        async serializeAsync(t) {
            return t instanceof Jr && (t = await t.get(this)),
            this.serialize(t)
        }
        serialize(t) {
            if (t instanceof ta || t instanceof Jf) {
                if (t.realm !== this) {
                    if (!(t.realm instanceof ra) || !(this instanceof ra))
                        throw new Error("Trying to evaluate JSHandle from different global types. Usually this means you're using a handle from a worker in a page or vice versa.");
                    if (t.realm.environment !== this.environment)
                        throw new Error("Trying to evaluate JSHandle from different frames. Usually this means you're using a handle from a page on a different page.")
                }
                if (t.disposed)
                    throw new Error("JSHandle is disposed!");
                return t.remoteValue()
            }
            return pN.serialize(t)
        }
        async destroyHandles(t) {
            if (this.disposed)
                return;
            const r = t.map( ({id: s}) => s).filter(s => s !== void 0);
            r.length !== 0 && await this.realm.disown(r).catch(s => {
                ge(s)
            }
            )
        }
        async adoptHandle(t) {
            return await this.evaluateHandle(r => r, t)
        }
        async transferHandle(t) {
            if (t.realm === this)
                return t;
            const r = this.adoptHandle(t);
            return await t.dispose(),
            await r
        }
    }
    mg = new WeakSet,
    UC = async function(t, r, ...s) {
        var d;
        const i = Xk(((d = Vk(r)) == null ? void 0 : d.toString()) ?? Gr.INTERNAL_URL);
        let a;
        const c = t ? "none" : "root"
          , u = t ? {} : {
            maxObjectDepth: 0,
            maxDomDepth: 0
        };
        if (js(r)) {
            const h = ry.test(r) ? r : `${r}
${i}
`;
            a = this.realm.evaluate(h, !0, {
                resultOwnership: c,
                userActivation: !0,
                serializationOptions: u
            })
        } else {
            let h = is(r);
            h = ry.test(h) ? h : `${h}
${i}
`,
            a = this.realm.callFunction(h, !0, {
                arguments: s.some(f => f instanceof Jr) ? await Promise.all(s.map(f => this.serializeAsync(f))) : s.map(f => this.serialize(f)),
                resultOwnership: c,
                userActivation: !0,
                serializationOptions: u
            })
        }
        const l = await a;
        if ("type"in l && l.type === "exception")
            throw UV(l.exceptionDetails);
        return t ? Gf.deserialize(l.result) : this.createHandle(l.result)
    }
    ;
    const Ub = class Ub extends zE {
        constructor(t, r) {
            super(t, r.timeoutSettings);
            b(this, qb);
            b(this, md);
            b(this, gd, !1);
            S(this, md, r)
        }
        static from(t, r) {
            var i;
            const s = new Ub(t,r);
            return P(i = s, qb, FF).call(i),
            s
        }
        get puppeteerUtil() {
            let t = Promise.resolve();
            return o(this, gd) || (t = Promise.all([Zf.from(this.environment, "__ariaQuerySelector", Za.queryOne, !!this.sandbox), Zf.from(this.environment, "__ariaQuerySelectorAll", async (r, s) => {
                const i = Za.queryAll(r, s);
                return await r.realm.evaluateHandle( (...a) => a, ...await Uc.collect(i))
            }
            , !!this.sandbox)]),
            S(this, gd, !0)),
            t.then( () => super.puppeteerUtil)
        }
        get sandbox() {
            return this.realm.sandbox
        }
        get environment() {
            return o(this, md)
        }
        async adoptBackendNode(t) {
            const r = {
                stack: [],
                error: void 0,
                hasError: !1
            };
            try {
                const {object: s} = await o(this, md).client.send("DOM.resolveNode", {
                    backendNodeId: t,
                    executionContextId: await this.realm.resolveExecutionContextId()
                });
                return await KV(r, Jf.from({
                    handle: s.objectId,
                    type: "node"
                }, this), !1).evaluateHandle(a => a)
            } catch (s) {
                r.error = s,
                r.hasError = !0
            } finally {
                HV(r)
            }
        }
    }
    ;
    md = new WeakMap,
    qb = new WeakSet,
    FF = function() {
        GN(Ub.prototype, this, "initialize").call(this),
        this.realm.on("updated", () => {
            this.environment.clearDocumentHandle(),
            S(this, gd, !1)
        }
        )
    }
    ,
    gd = new WeakMap;
    let ra = Ub;
    const yx = class yx extends zE {
        constructor(t, r) {
            super(t, r.timeoutSettings);
            b(this, gg);
            S(this, gg, r)
        }
        static from(t, r) {
            const s = new yx(t,r);
            return s.initialize(),
            s
        }
        get environment() {
            return o(this, gg)
        }
        async adoptBackendNode() {
            throw new Error("Cannot adopt DOM nodes into a worker.")
        }
    }
    ;
    gg = new WeakMap;
    let wb = yx;
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const wx = class wx extends CP {
        constructor(t, r) {
            super(r.origin);
            b(this, yg);
            b(this, wg);
            S(this, yg, t),
            S(this, wg, wb.from(r, this))
        }
        static from(t, r) {
            return new wx(t,r)
        }
        get frame() {
            return o(this, yg)
        }
        mainRealm() {
            return o(this, wg)
        }
        get client() {
            throw new Oe
        }
    }
    ;
    yg = new WeakMap,
    wg = new WeakMap;
    let VE = wx;
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var WV = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , go = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , gN = function(n, e, t) {
        return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
        Object.defineProperty(n, "name", {
            configurable: !0,
            value: t ? "".concat(t, " ", e) : e
        })
    };
    function zV(n) {
        switch (n) {
        case "group":
            return "startGroup";
        case "groupCollapsed":
            return "startGroupCollapsed";
        case "groupEnd":
            return "endGroup";
        default:
            return n
        }
    }
    let yN = ( () => {
        var h, f, p, jF, KC, fv, w, pv, mv, _;
        let n = dP, e = [], t, r, s, i, a, c, u, l, d;
        return _ = class extends n {
            constructor(k, x) {
                super();
                b(this, p);
                b(this, h, WV(this, e));
                J(this, "browsingContext");
                b(this, f, new WeakMap);
                J(this, "realms");
                J(this, "_id");
                J(this, "client");
                J(this, "accessibility");
                b(this, w, new Map);
                S(this, h, k),
                this.browsingContext = x,
                this._id = x.id,
                this.client = new zf(this),
                this.realms = {
                    default: ra.from(this.browsingContext.defaultRealm, this),
                    internal: ra.from(this.browsingContext.createWindowRealm(`__puppeteer_internal_${Math.ceil(Math.random() * 1e4)}`), this)
                },
                this.accessibility = new kP(this.realms.default,this._id)
            }
            static from(k, x) {
                var R;
                const N = new _(k,x);
                return P(R = N, p, jF).call(R),
                N
            }
            get timeoutSettings() {
                return this.page()._timeoutSettings
            }
            mainRealm() {
                return this.realms.default
            }
            isolatedRealm() {
                return this.realms.internal
            }
            realm(k) {
                for (const x of Object.values(this.realms))
                    if (x.realm.id === k)
                        return x
            }
            page() {
                let k = o(this, h);
                for (; k instanceof _; )
                    k = o(k, h);
                return k
            }
            url() {
                return this.browsingContext.url
            }
            parentFrame() {
                return o(this, h)instanceof _ ? o(this, h) : null
            }
            childFrames() {
                return [...this.browsingContext.children].map(k => o(this, f).get(k))
            }
            async goto(k, x={}) {
                const [N] = await Promise.all([this.waitForNavigation(x), this.browsingContext.navigate(k, "interactive").catch(R => {
                    if (!(hn(R) && R.message.includes("net::ERR_HTTP_RESPONSE_CODE_FAILURE")) && !R.message.includes("navigation canceled") && !R.message.includes("Navigation was aborted by another navigation"))
                        throw R
                }
                )]).catch(mN(k, x.timeout ?? this.timeoutSettings.navigationTimeout()));
                return N
            }
            async setContent(k, x={}) {
                await Promise.all([this.setFrameContent(k), Kt(Wg([o(this, p, pv).call(this, x), o(this, p, mv).call(this, x)]))])
            }
            async waitForNavigation(k={}) {
                const {timeout: x=this.timeoutSettings.navigationTimeout(), signal: N} = k
                  , R = this.childFrames().map(F => {
                    var O;
                    return P(O = F, p, fv).call(O)
                }
                );
                return await Kt(Wg([Dk(at(this.browsingContext, "navigation"), at(this.browsingContext, "historyUpdated").pipe(Pt( () => ({
                    navigation: null
                })))).pipe(jc()).pipe(Jg( ({navigation: F}) => F === null ? ss(null) : o(this, p, pv).call(this, k).pipe(bD( () => R.length === 0 ? ss(void 0) : Wg(R)), sr(at(F, "fragment"), at(F, "failed"), at(F, "aborted").pipe(Pt( ({url: O}) => {
                    throw new Error(`Navigation aborted: ${O}`)
                }
                ))), Jg( () => {
                    if (F.request) {
                        let O = function(T) {
                            return F === null ? ss(null) : T.response || T.error ? ss(F) : T.redirect ? O(T.redirect) : at(T, "success").pipe(sr(at(T, "error")), sr(at(T, "redirect"))).pipe(Jg( () => O(T)))
                        };
                        return O(F.request)
                    }
                    return ss(F)
                }
                )))), o(this, p, mv).call(this, k)]).pipe(Pt( ([F]) => {
                    if (!F)
                        return null;
                    const O = F.request;
                    if (!O)
                        return null;
                    const T = O.lastRedirect ?? O;
                    return HE.get(T).response()
                }
                ), sr(Or(x), Ja(N), P(this, p, fv).call(this).pipe(Pt( () => {
                    throw new xn("Frame detached.")
                }
                )))))
            }
            waitForDevicePrompt() {
                throw new Oe
            }
            get detached() {
                return this.browsingContext.closed
            }
            async exposeFunction(k, x) {
                if (o(this, w).has(k))
                    throw new Error(`Failed to add page binding with name ${k}: globalThis['${k}'] already exists!`);
                const N = await Zf.from(this, k, x);
                o(this, w).set(k, N)
            }
            async removeExposedFunction(k) {
                const x = o(this, w).get(k);
                if (!x)
                    throw new Error(`Failed to remove page binding with name ${k}: window['${k}'] does not exists!`);
                o(this, w).delete(k),
                await x[Symbol.asyncDispose]()
            }
            async createCDPSession() {
                if (!this.page().browser().cdpSupported)
                    throw new Oe;
                return await this.page().browser().cdpConnection._createSession({
                    targetId: this._id
                })
            }
            async setFiles(k, x) {
                await this.browsingContext.setFiles(k.remoteValue(), x)
            }
            async locateNodes(k, x) {
                return await this.browsingContext.locateNodes(x, [k.remoteValue()])
            }
        }
        ,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakSet,
        jF = function() {
            for (const k of this.browsingContext.children)
                P(this, p, KC).call(this, k);
            this.browsingContext.on("browsingcontext", ({browsingContext: k}) => {
                P(this, p, KC).call(this, k)
            }
            ),
            this.browsingContext.on("closed", () => {
                for (const k of zf.sessions.values())
                    k.frame === this && k.onClose();
                this.page().trustedEmitter.emit("framedetached", this)
            }
            ),
            this.browsingContext.on("request", ({request: k}) => {
                const x = WE.from(k, this);
                k.once("success", () => {
                    this.page().trustedEmitter.emit("requestfinished", x)
                }
                ),
                k.once("error", () => {
                    this.page().trustedEmitter.emit("requestfailed", x)
                }
                ),
                x.finalizeInterceptions()
            }
            ),
            this.browsingContext.on("navigation", ({navigation: k}) => {
                k.once("fragment", () => {
                    this.page().trustedEmitter.emit("framenavigated", this)
                }
                )
            }
            ),
            this.browsingContext.on("load", () => {
                this.page().trustedEmitter.emit("load", void 0)
            }
            ),
            this.browsingContext.on("DOMContentLoaded", () => {
                this._hasStartedLoading = !0,
                this.page().trustedEmitter.emit("domcontentloaded", void 0),
                this.page().trustedEmitter.emit("framenavigated", this)
            }
            ),
            this.browsingContext.on("userprompt", ({userPrompt: k}) => {
                this.page().trustedEmitter.emit("dialog", qE.from(k))
            }
            ),
            this.browsingContext.on("log", ({entry: k}) => {
                if (this._id === k.source.context)
                    if (VV(k)) {
                        const x = k.args.map(R => this.mainRealm().createHandle(R))
                          , N = x.reduce( (R, F) => {
                            const O = F instanceof ta && F.isPrimitiveValue ? Gf.deserialize(F.remoteValue()) : F.toString();
                            return `${R} ${O}`
                        }
                        , "").slice(1);
                        this.page().trustedEmitter.emit("console", new Xv(zV(k.method),N,x,JV(k.stackTrace),this))
                    } else if (GV(k)) {
                        const x = new Error(k.text ?? "")
                          , N = x.message.split(`
`).length
                          , R = x.stack.split(`
`).splice(0, N)
                          , F = [];
                        if (k.stackTrace) {
                            for (const O of k.stackTrace.callFrames)
                                if (F.push(`    at ${O.functionName || "<anonymous>"} (${O.url}:${O.lineNumber + 1}:${O.columnNumber + 1})`),
                                F.length >= Error.stackTraceLimit)
                                    break
                        }
                        x.stack = [...R, ...F].join(`
`),
                        this.page().trustedEmitter.emit("pageerror", x)
                    } else
                        ge(`Unhandled LogEntry with type "${k.type}", text "${k.text}" and level "${k.level}"`)
            }
            ),
            this.browsingContext.on("worker", ({realm: k}) => {
                const x = VE.from(this, k);
                k.on("destroyed", () => {
                    this.page().trustedEmitter.emit("workerdestroyed", x)
                }
                ),
                this.page().trustedEmitter.emit("workercreated", x)
            }
            )
        }
        ,
        KC = function(k) {
            const x = _.from(this, k);
            return o(this, f).set(k, x),
            this.page().trustedEmitter.emit("frameattached", x),
            k.on("closed", () => {
                o(this, f).delete(k)
            }
            ),
            x
        }
        ,
        fv = function() {
            return za( () => this.detached ? ss(this) : at(this.page().trustedEmitter, "framedetached").pipe(Va(k => k === this)))
        }
        ,
        w = new WeakMap,
        pv = function() {
            return a.value
        }
        ,
        mv = function() {
            return u.value
        }
        ,
        ( () => {
            const k = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            t = [ze],
            r = [ze],
            s = [ze],
            i = [ze],
            c = [ze],
            l = [ze],
            d = [ze],
            go(_, null, t, {
                kind: "method",
                name: "goto",
                static: !1,
                private: !1,
                access: {
                    has: x => "goto"in x,
                    get: x => x.goto
                },
                metadata: k
            }, null, e),
            go(_, null, r, {
                kind: "method",
                name: "setContent",
                static: !1,
                private: !1,
                access: {
                    has: x => "setContent"in x,
                    get: x => x.setContent
                },
                metadata: k
            }, null, e),
            go(_, null, s, {
                kind: "method",
                name: "waitForNavigation",
                static: !1,
                private: !1,
                access: {
                    has: x => "waitForNavigation"in x,
                    get: x => x.waitForNavigation
                },
                metadata: k
            }, null, e),
            go(_, a = {
                value: gN(function(x={}) {
                    let {waitUntil: N="load"} = x;
                    const {timeout: R=this.timeoutSettings.navigationTimeout()} = x;
                    Array.isArray(N) || (N = [N]);
                    const F = new Set;
                    for (const O of N)
                        switch (O) {
                        case "load":
                            {
                                F.add("load");
                                break
                            }
                        case "domcontentloaded":
                            {
                                F.add("DOMContentLoaded");
                                break
                            }
                        }
                    return F.size === 0 ? ss(void 0) : Wg([...F].map(O => at(this.browsingContext, O))).pipe(Pt( () => {}
                    ), jc(), sr(Or(R), P(this, p, fv).call(this).pipe(Pt( () => {
                        throw new Error("Frame detached.")
                    }
                    ))))
                }, "#waitForLoad$")
            }, i, {
                kind: "method",
                name: "#waitForLoad$",
                static: !1,
                private: !0,
                access: {
                    has: x => Ir(p, x),
                    get: x => o(x, p, pv)
                },
                metadata: k
            }, null, e),
            go(_, u = {
                value: gN(function(x={}) {
                    let {waitUntil: N="load"} = x;
                    Array.isArray(N) || (N = [N]);
                    let R = 1 / 0;
                    for (const F of N)
                        switch (F) {
                        case "networkidle0":
                            {
                                R = Math.min(0, R);
                                break
                            }
                        case "networkidle2":
                            {
                                R = Math.min(2, R);
                                break
                            }
                        }
                    return R === 1 / 0 ? ss(void 0) : this.page().waitForNetworkIdle$({
                        idleTime: 500,
                        timeout: x.timeout ?? this.timeoutSettings.timeout(),
                        concurrency: R
                    })
                }, "#waitForNetworkIdle$")
            }, c, {
                kind: "method",
                name: "#waitForNetworkIdle$",
                static: !1,
                private: !0,
                access: {
                    has: x => Ir(p, x),
                    get: x => o(x, p, mv)
                },
                metadata: k
            }, null, e),
            go(_, null, l, {
                kind: "method",
                name: "setFiles",
                static: !1,
                private: !1,
                access: {
                    has: x => "setFiles"in x,
                    get: x => x.setFiles
                },
                metadata: k
            }, null, e),
            go(_, null, d, {
                kind: "method",
                name: "locateNodes",
                static: !1,
                private: !1,
                access: {
                    has: x => "locateNodes"in x,
                    get: x => x.locateNodes
                },
                metadata: k
            }, null, e),
            k && Object.defineProperty(_, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: k
            })
        }
        )(),
        _
    }
    )();
    function VV(n) {
        return n.type === "console"
    }
    function GV(n) {
        return n.type === "javascript"
    }
    function JV(n) {
        const e = [];
        if (n)
            for (const t of n.callFrames)
                e.push({
                    url: t.url,
                    lineNumber: t.lineNumber,
                    columnNumber: t.columnNumber
                });
        return e
    }
    /**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var Kr;
    (function(n) {
        n.None = "none",
        n.Key = "key",
        n.Pointer = "pointer",
        n.Wheel = "wheel"
    }
    )(Kr || (Kr = {}));
    var bt;
    (function(n) {
        n.Pause = "pause",
        n.KeyDown = "keyDown",
        n.KeyUp = "keyUp",
        n.PointerUp = "pointerUp",
        n.PointerDown = "pointerDown",
        n.PointerMove = "pointerMove",
        n.Scroll = "scroll"
    }
    )(bt || (bt = {}));
    const Xf = n => {
        switch (n) {
        case "\r":
        case `
`:
            n = "Enter";
            break
        }
        if ([...n].length === 1)
            return n;
        switch (n) {
        case "Cancel":
            return "";
        case "Help":
            return "";
        case "Backspace":
            return "";
        case "Tab":
            return "";
        case "Clear":
            return "";
        case "Enter":
            return "";
        case "Shift":
        case "ShiftLeft":
            return "";
        case "Control":
        case "ControlLeft":
            return "";
        case "Alt":
        case "AltLeft":
            return "";
        case "Pause":
            return "";
        case "Escape":
            return "";
        case "PageUp":
            return "";
        case "PageDown":
            return "";
        case "End":
            return "";
        case "Home":
            return "";
        case "ArrowLeft":
            return "";
        case "ArrowUp":
            return "";
        case "ArrowRight":
            return "";
        case "ArrowDown":
            return "";
        case "Insert":
            return "";
        case "Delete":
            return "";
        case "NumpadEqual":
            return "";
        case "Numpad0":
            return "";
        case "Numpad1":
            return "";
        case "Numpad2":
            return "";
        case "Numpad3":
            return "";
        case "Numpad4":
            return "";
        case "Numpad5":
            return "";
        case "Numpad6":
            return "";
        case "Numpad7":
            return "";
        case "Numpad8":
            return "";
        case "Numpad9":
            return "";
        case "NumpadMultiply":
            return "";
        case "NumpadAdd":
            return "";
        case "NumpadSubtract":
            return "";
        case "NumpadDecimal":
            return "";
        case "NumpadDivide":
            return "";
        case "F1":
            return "";
        case "F2":
            return "";
        case "F3":
            return "";
        case "F4":
            return "";
        case "F5":
            return "";
        case "F6":
            return "";
        case "F7":
            return "";
        case "F8":
            return "";
        case "F9":
            return "";
        case "F10":
            return "";
        case "F11":
            return "";
        case "F12":
            return "";
        case "Meta":
        case "MetaLeft":
            return "";
        case "ShiftRight":
            return "";
        case "ControlRight":
            return "";
        case "AltRight":
            return "";
        case "MetaRight":
            return "";
        case "Digit0":
            return "0";
        case "Digit1":
            return "1";
        case "Digit2":
            return "2";
        case "Digit3":
            return "3";
        case "Digit4":
            return "4";
        case "Digit5":
            return "5";
        case "Digit6":
            return "6";
        case "Digit7":
            return "7";
        case "Digit8":
            return "8";
        case "Digit9":
            return "9";
        case "KeyA":
            return "a";
        case "KeyB":
            return "b";
        case "KeyC":
            return "c";
        case "KeyD":
            return "d";
        case "KeyE":
            return "e";
        case "KeyF":
            return "f";
        case "KeyG":
            return "g";
        case "KeyH":
            return "h";
        case "KeyI":
            return "i";
        case "KeyJ":
            return "j";
        case "KeyK":
            return "k";
        case "KeyL":
            return "l";
        case "KeyM":
            return "m";
        case "KeyN":
            return "n";
        case "KeyO":
            return "o";
        case "KeyP":
            return "p";
        case "KeyQ":
            return "q";
        case "KeyR":
            return "r";
        case "KeyS":
            return "s";
        case "KeyT":
            return "t";
        case "KeyU":
            return "u";
        case "KeyV":
            return "v";
        case "KeyW":
            return "w";
        case "KeyX":
            return "x";
        case "KeyY":
            return "y";
        case "KeyZ":
            return "z";
        case "Semicolon":
            return ";";
        case "Equal":
            return "=";
        case "Comma":
            return ",";
        case "Minus":
            return "-";
        case "Period":
            return ".";
        case "Slash":
            return "/";
        case "Backquote":
            return "`";
        case "BracketLeft":
            return "[";
        case "Backslash":
            return "\\";
        case "BracketRight":
            return "]";
        case "Quote":
            return '"';
        default:
            throw new Error(`Unknown key: "${n}"`)
        }
    }
    ;
    class wN extends gP {
        constructor(t) {
            super();
            b(this, bi);
            S(this, bi, t)
        }
        async down(t, r) {
            await o(this, bi).mainFrame().browsingContext.performActions([{
                type: Kr.Key,
                id: "__puppeteer_keyboard",
                actions: [{
                    type: bt.KeyDown,
                    value: Xf(t)
                }]
            }])
        }
        async up(t) {
            await o(this, bi).mainFrame().browsingContext.performActions([{
                type: Kr.Key,
                id: "__puppeteer_keyboard",
                actions: [{
                    type: bt.KeyUp,
                    value: Xf(t)
                }]
            }])
        }
        async press(t, r={}) {
            const {delay: s=0} = r
              , i = [{
                type: bt.KeyDown,
                value: Xf(t)
            }];
            s > 0 && i.push({
                type: bt.Pause,
                duration: s
            }),
            i.push({
                type: bt.KeyUp,
                value: Xf(t)
            }),
            await o(this, bi).mainFrame().browsingContext.performActions([{
                type: Kr.Key,
                id: "__puppeteer_keyboard",
                actions: i
            }])
        }
        async type(t, r={}) {
            const {delay: s=0} = r
              , i = [...t].map(Xf)
              , a = [];
            if (s <= 0)
                for (const c of i)
                    a.push({
                        type: bt.KeyDown,
                        value: c
                    }, {
                        type: bt.KeyUp,
                        value: c
                    });
            else
                for (const c of i)
                    a.push({
                        type: bt.KeyDown,
                        value: c
                    }, {
                        type: bt.Pause,
                        duration: s
                    }, {
                        type: bt.KeyUp,
                        value: c
                    });
            await o(this, bi).mainFrame().browsingContext.performActions([{
                type: Kr.Key,
                id: "__puppeteer_keyboard",
                actions: a
            }])
        }
        async sendCharacter(t) {
            if ([...t].length > 1)
                throw new Error("Cannot send more than 1 character.");
            await (await o(this, bi).focusedFrame()).isolatedRealm().evaluate(async s => {
                document.execCommand("insertText", !1, s)
            }
            , t)
        }
    }
    bi = new WeakMap;
    const GE = n => {
        switch (n) {
        case wt.Left:
            return 0;
        case wt.Middle:
            return 1;
        case wt.Right:
            return 2;
        case wt.Back:
            return 3;
        case wt.Forward:
            return 4
        }
    }
    ;
    class bN extends yP {
        constructor(t) {
            super();
            b(this, Ns);
            b(this, Ec, {
                x: 0,
                y: 0
            });
            S(this, Ns, t)
        }
        async reset() {
            S(this, Ec, {
                x: 0,
                y: 0
            }),
            await o(this, Ns).mainFrame().browsingContext.releaseActions()
        }
        async move(t, r, s={}) {
            const i = o(this, Ec)
              , a = {
                x: Math.round(t),
                y: Math.round(r)
            }
              , c = []
              , u = s.steps ?? 0;
            for (let l = 0; l < u; ++l)
                c.push({
                    type: bt.PointerMove,
                    x: i.x + (a.x - i.x) * (l / u),
                    y: i.y + (a.y - i.y) * (l / u),
                    origin: s.origin
                });
            c.push({
                type: bt.PointerMove,
                ...a,
                origin: s.origin
            }),
            S(this, Ec, a),
            await o(this, Ns).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: "__puppeteer_mouse",
                actions: c
            }])
        }
        async down(t={}) {
            await o(this, Ns).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: "__puppeteer_mouse",
                actions: [{
                    type: bt.PointerDown,
                    button: GE(t.button ?? wt.Left)
                }]
            }])
        }
        async up(t={}) {
            await o(this, Ns).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: "__puppeteer_mouse",
                actions: [{
                    type: bt.PointerUp,
                    button: GE(t.button ?? wt.Left)
                }]
            }])
        }
        async click(t, r, s={}) {
            const i = [{
                type: bt.PointerMove,
                x: Math.round(t),
                y: Math.round(r),
                origin: s.origin
            }]
              , a = {
                type: bt.PointerDown,
                button: GE(s.button ?? wt.Left)
            }
              , c = {
                type: bt.PointerUp,
                button: a.button
            };
            for (let u = 1; u < (s.count ?? 1); ++u)
                i.push(a, c);
            i.push(a),
            s.delay && i.push({
                type: bt.Pause,
                duration: s.delay
            }),
            i.push(c),
            await o(this, Ns).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: "__puppeteer_mouse",
                actions: i
            }])
        }
        async wheel(t={}) {
            await o(this, Ns).mainFrame().browsingContext.performActions([{
                type: Kr.Wheel,
                id: "__puppeteer_wheel",
                actions: [{
                    type: bt.Scroll,
                    ...o(this, Ec) ?? {
                        x: 0,
                        y: 0
                    },
                    deltaX: t.deltaX ?? 0,
                    deltaY: t.deltaY ?? 0
                }]
            }])
        }
        drag() {
            throw new Oe
        }
        dragOver() {
            throw new Oe
        }
        dragEnter() {
            throw new Oe
        }
        drop() {
            throw new Oe
        }
        dragAndDrop() {
            throw new Oe
        }
    }
    Ns = new WeakMap,
    Ec = new WeakMap;
    class ZV {
        constructor(e, t, r, s, i, a) {
            b(this, bg, !1);
            b(this, vg);
            b(this, _g);
            b(this, xc);
            b(this, Cc);
            b(this, Sg);
            b(this, yd);
            S(this, Cc, e),
            S(this, Sg, t),
            S(this, vg, Math.round(s)),
            S(this, _g, Math.round(i)),
            S(this, yd, a),
            S(this, xc, `__puppeteer_finger_${r}`)
        }
        async start(e={}) {
            if (o(this, bg))
                throw new ey("Touch has already started");
            await o(this, Cc).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: o(this, xc),
                parameters: {
                    pointerType: "touch"
                },
                actions: [{
                    type: bt.PointerMove,
                    x: o(this, vg),
                    y: o(this, _g),
                    origin: e.origin
                }, {
                    ...o(this, yd),
                    type: bt.PointerDown,
                    button: 0
                }]
            }]),
            S(this, bg, !0)
        }
        move(e, t) {
            const r = Math.round(e)
              , s = Math.round(t);
            return o(this, Cc).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: o(this, xc),
                parameters: {
                    pointerType: "touch"
                },
                actions: [{
                    ...o(this, yd),
                    type: bt.PointerMove,
                    x: r,
                    y: s
                }]
            }])
        }
        async end() {
            await o(this, Cc).mainFrame().browsingContext.performActions([{
                type: Kr.Pointer,
                id: o(this, xc),
                parameters: {
                    pointerType: "touch"
                },
                actions: [{
                    type: bt.PointerUp,
                    button: 0
                }]
            }]),
            o(this, Sg).removeHandle(this)
        }
    }
    bg = new WeakMap,
    vg = new WeakMap,
    _g = new WeakMap,
    xc = new WeakMap,
    Cc = new WeakMap,
    Sg = new WeakMap,
    yd = new WeakMap;
    class vN extends wP {
        constructor(t) {
            super();
            b(this, Eg);
            S(this, Eg, t)
        }
        async touchStart(t, r, s={}) {
            const i = this.idGenerator()
              , a = {
                width: .5 * 2,
                height: .5 * 2,
                pressure: .5,
                altitudeAngle: Math.PI / 2
            }
              , c = new ZV(o(this, Eg),this,i,t,r,a);
            return await c.start(s),
            this.touches.push(c),
            c
        }
    }
    Eg = new WeakMap;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var XV = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , _N = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , SN = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , EN = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    let Yf = ( () => {
        var s, i, a, c, u, l, d, h, DF, p, g, y, m, w, Lg, HC, WC, A;
        let n = _P, e, t = [], r = [];
        return A = class extends n {
            constructor(x, N) {
                super();
                b(this, h);
                b(this, s, _N(this, t, new be));
                b(this, i, _N(this, r));
                b(this, a);
                b(this, c, null);
                b(this, u, new Set);
                J(this, "keyboard");
                J(this, "mouse");
                J(this, "touchscreen");
                J(this, "tracing");
                J(this, "coverage");
                b(this, l);
                b(this, d);
                J(this, "_userAgentHeaders", {});
                b(this, p);
                b(this, g);
                b(this, y);
                J(this, "_extraHTTPHeaders", {});
                b(this, m);
                J(this, "_credentials", null);
                b(this, w);
                S(this, i, x),
                S(this, a, yN.from(this, N)),
                S(this, l, new IP(o(this, a).client)),
                this.tracing = new KP(o(this, a).client),
                this.coverage = new TP(o(this, a).client),
                this.keyboard = new wN(this),
                this.mouse = new bN(this),
                this.touchscreen = new vN(this)
            }
            static from(x, N) {
                var F;
                const R = new A(x,N);
                return P(F = R, h, DF).call(F),
                R
            }
            get trustedEmitter() {
                return o(this, s)
            }
            set trustedEmitter(x) {
                S(this, s, x)
            }
            _client() {
                return o(this, a).client
            }
            async setUserAgent(x, N) {
                if (!o(this, i).browser().cdpSupported && N)
                    throw new Oe("Current Browser does not support `userAgentMetadata`");
                if (o(this, i).browser().cdpSupported && N)
                    return await this._client().send("Network.setUserAgentOverride", {
                        userAgent: x,
                        userAgentMetadata: N
                    });
                const R = x !== "";
                x = x ?? await o(this, i).browser().userAgent(),
                this._userAgentHeaders = R ? {
                    "User-Agent": x
                } : {},
                S(this, p, await P(this, h, Lg).call(this, ["beforeRequestSent"], o(this, p), R));
                const F = L => {
                    Object.defineProperty(navigator, "userAgent", {
                        value: L
                    })
                }
                  , O = [o(this, a)];
                for (const L of O)
                    O.push(...L.childFrames());
                o(this, g) && await this.removeScriptToEvaluateOnNewDocument(o(this, g));
                const [T] = await Promise.all([R ? this.evaluateOnNewDocument(F, x) : void 0, O.map(L => L.evaluate(F, x))]);
                S(this, g, T == null ? void 0 : T.identifier)
            }
            async setBypassCSP(x) {
                await this._client().send("Page.setBypassCSP", {
                    enabled: x
                })
            }
            async queryObjects(x) {
                ne(!x.disposed, "Prototype JSHandle is disposed!"),
                ne(x.id, "Prototype JSHandle must not be referencing primitive value");
                const N = await o(this, a).client.send("Runtime.queryObjects", {
                    prototypeObjectId: x.id
                });
                return o(this, a).mainRealm().createHandle({
                    type: "array",
                    handle: N.objects.objectId
                })
            }
            browser() {
                return this.browserContext().browser()
            }
            browserContext() {
                return o(this, i)
            }
            mainFrame() {
                return o(this, a)
            }
            async focusedFrame() {
                const x = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const R = SN(x, await this.mainFrame().isolatedRealm().evaluateHandle( () => {
                        let O = window;
                        for (; (O.document.activeElement instanceof O.HTMLIFrameElement || O.document.activeElement instanceof O.HTMLFrameElement) && O.document.activeElement.contentWindow !== null; )
                            O = O.document.activeElement.contentWindow;
                        return O
                    }
                    ), !1).remoteValue();
                    ne(R.type === "window");
                    const F = this.frames().find(O => O._id === R.value.context);
                    return ne(F),
                    F
                } catch (N) {
                    x.error = N,
                    x.hasError = !0
                } finally {
                    EN(x)
                }
            }
            frames() {
                const x = [o(this, a)];
                for (const N of x)
                    x.push(...N.childFrames());
                return x
            }
            isClosed() {
                return o(this, a).detached
            }
            async close(x) {
                const N = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const R = SN(N, await o(this, i).waitForScreenshotOperations(), !1);
                    try {
                        await o(this, a).browsingContext.close(x == null ? void 0 : x.runBeforeUnload)
                    } catch {
                        return
                    }
                } catch (R) {
                    N.error = R,
                    N.hasError = !0
                } finally {
                    EN(N)
                }
            }
            async reload(x={}) {
                const [N] = await Promise.all([o(this, a).waitForNavigation(x), o(this, a).browsingContext.reload()]).catch(mN(this.url(), x.timeout ?? this._timeoutSettings.navigationTimeout()));
                return N
            }
            setDefaultNavigationTimeout(x) {
                this._timeoutSettings.setDefaultNavigationTimeout(x)
            }
            setDefaultTimeout(x) {
                this._timeoutSettings.setDefaultTimeout(x)
            }
            getDefaultTimeout() {
                return this._timeoutSettings.timeout()
            }
            getDefaultNavigationTimeout() {
                return this._timeoutSettings.navigationTimeout()
            }
            isJavaScriptEnabled() {
                return o(this, l).javascriptEnabled
            }
            async setGeolocation(x) {
                return await o(this, l).setGeolocation(x)
            }
            async setJavaScriptEnabled(x) {
                return await o(this, l).setJavaScriptEnabled(x)
            }
            async emulateMediaType(x) {
                return await o(this, l).emulateMediaType(x)
            }
            async emulateCPUThrottling(x) {
                return await o(this, l).emulateCPUThrottling(x)
            }
            async emulateMediaFeatures(x) {
                return await o(this, l).emulateMediaFeatures(x)
            }
            async emulateTimezone(x) {
                return await o(this, l).emulateTimezone(x)
            }
            async emulateIdleState(x) {
                return await o(this, l).emulateIdleState(x)
            }
            async emulateVisionDeficiency(x) {
                return await o(this, l).emulateVisionDeficiency(x)
            }
            async setViewport(x) {
                if (!this.browser().cdpSupported) {
                    await o(this, a).browsingContext.setViewport({
                        viewport: x != null && x.width && (x != null && x.height) ? {
                            width: x.width,
                            height: x.height
                        } : null,
                        devicePixelRatio: x != null && x.deviceScaleFactor ? x.deviceScaleFactor : null
                    }),
                    S(this, c, x);
                    return
                }
                const N = await o(this, l).emulateViewport(x);
                S(this, c, x),
                N && await this.reload()
            }
            viewport() {
                return o(this, c)
            }
            async pdf(x={}) {
                const {timeout: N=this._timeoutSettings.timeout(), path: R=void 0} = x
                  , {printBackground: F, margin: O, landscape: T, width: L, height: q, pageRanges: Z, scale: j, preferCSSPageSize: $} = Yk(x, "cm")
                  , B = Z ? Z.split(", ") : [];
                await Kt(Ze(this.mainFrame().isolatedRealm().evaluate( () => document.fonts.ready)).pipe(sr(Or(N))));
                const D = await Kt(Ze(o(this, a).browsingContext.print({
                    background: F,
                    margin: O,
                    orientation: T ? "landscape" : "portrait",
                    page: {
                        width: L,
                        height: q
                    },
                    pageRanges: B,
                    scale: j,
                    shrinkToFit: !$
                })).pipe(sr(Or(N))))
                  , z = $v(D, !0);
                return await this._maybeWriteTypedArrayToFile(R, z),
                z
            }
            async createPDFStream(x) {
                const N = await this.pdf(x);
                return new ReadableStream({
                    start(R) {
                        R.enqueue(N),
                        R.close()
                    }
                })
            }
            async _screenshot(x) {
                const {clip: N, type: R, captureBeyondViewport: F, quality: O} = x;
                if (x.omitBackground !== void 0 && x.omitBackground)
                    throw new Oe("BiDi does not support 'omitBackground'.");
                if (x.optimizeForSpeed !== void 0 && x.optimizeForSpeed)
                    throw new Oe("BiDi does not support 'optimizeForSpeed'.");
                if (x.fromSurface !== void 0 && !x.fromSurface)
                    throw new Oe("BiDi does not support 'fromSurface'.");
                if (N !== void 0 && N.scale !== void 0 && N.scale !== 1)
                    throw new Oe("BiDi does not support 'scale' in 'clip'.");
                let T;
                if (N)
                    if (F)
                        T = N;
                    else {
                        const [q,Z] = await this.evaluate( () => {
                            if (!window.visualViewport)
                                throw new Error("window.visualViewport is not supported.");
                            return [window.visualViewport.pageLeft, window.visualViewport.pageTop]
                        }
                        );
                        T = {
                            ...N,
                            x: N.x - q,
                            y: N.y - Z
                        }
                    }
                return await o(this, a).browsingContext.captureScreenshot({
                    origin: F ? "document" : "viewport",
                    format: {
                        type: `image/${R}`,
                        ...O !== void 0 ? {
                            quality: O / 100
                        } : {}
                    },
                    ...T ? {
                        clip: {
                            type: "box",
                            ...T
                        }
                    } : {}
                })
            }
            async createCDPSession() {
                return await o(this, a).createCDPSession()
            }
            async bringToFront() {
                await o(this, a).browsingContext.activate()
            }
            async evaluateOnNewDocument(x, ...N) {
                const R = YV(x, ...N);
                return {
                    identifier: await o(this, a).browsingContext.addPreloadScript(R)
                }
            }
            async removeScriptToEvaluateOnNewDocument(x) {
                await o(this, a).browsingContext.removePreloadScript(x)
            }
            async exposeFunction(x, N) {
                return await this.mainFrame().exposeFunction(x, "default"in N ? N.default : N)
            }
            isDragInterceptionEnabled() {
                return !1
            }
            async setCacheEnabled(x) {
                if (!o(this, i).browser().cdpSupported) {
                    await o(this, a).browsingContext.setCacheBehavior(x ? "default" : "bypass");
                    return
                }
                await this._client().send("Network.setCacheDisabled", {
                    cacheDisabled: !x
                })
            }
            async cookies(...x) {
                const N = (x.length ? x : [this.url()]).map(F => new URL(F));
                return (await o(this, a).browsingContext.getCookies()).map(F => JE(F)).filter(F => N.some(O => t9(F, O)))
            }
            isServiceWorkerBypassed() {
                throw new Oe
            }
            target() {
                throw new Oe
            }
            waitForFileChooser() {
                throw new Oe
            }
            workers() {
                return [...o(this, u)]
            }
            async setRequestInterception(x) {
                S(this, y, await P(this, h, Lg).call(this, ["beforeRequestSent"], o(this, y), x))
            }
            async setExtraHTTPHeaders(x) {
                const N = {};
                for (const [R,F] of Object.entries(x))
                    ne(js(F), `Expected value of header "${R}" to be String, but "${typeof F}" is found.`),
                    N[R.toLowerCase()] = F;
                this._extraHTTPHeaders = N,
                S(this, m, await P(this, h, Lg).call(this, ["beforeRequestSent"], o(this, m), !!Object.keys(this._extraHTTPHeaders).length))
            }
            async authenticate(x) {
                S(this, w, await P(this, h, Lg).call(this, ["authRequired"], o(this, w), !!x)),
                this._credentials = x
            }
            setDragInterception() {
                throw new Oe
            }
            setBypassServiceWorker() {
                throw new Oe
            }
            async setOfflineMode(x) {
                if (!o(this, i).browser().cdpSupported)
                    throw new Oe;
                return o(this, d) || S(this, d, {
                    offline: !1,
                    upload: -1,
                    download: -1,
                    latency: 0
                }),
                o(this, d).offline = x,
                await P(this, h, HC).call(this)
            }
            async emulateNetworkConditions(x) {
                if (!o(this, i).browser().cdpSupported)
                    throw new Oe;
                return o(this, d) || S(this, d, {
                    offline: !1,
                    upload: -1,
                    download: -1,
                    latency: 0
                }),
                o(this, d).upload = x ? x.upload : -1,
                o(this, d).download = x ? x.download : -1,
                o(this, d).latency = x ? x.latency : 0,
                await P(this, h, HC).call(this)
            }
            async setCookie(...x) {
                const N = this.url()
                  , R = N.startsWith("http");
                for (const F of x) {
                    let O = F.url || "";
                    !O && R && (O = N),
                    ne(O !== "about:blank", `Blank page can not have cookie "${F.name}"`),
                    ne(!String.prototype.startsWith.call(O || "", "data:"), `Data URL page can not have cookie "${F.name}"`),
                    ne(F.partitionKey === void 0 || typeof F.partitionKey == "string", "BiDi only allows domain partition keys");
                    const T = URL.canParse(O) ? new URL(O) : void 0
                      , L = F.domain ?? (T == null ? void 0 : T.hostname);
                    ne(L !== void 0, "At least one of the url and domain needs to be specified");
                    const q = {
                        domain: L,
                        name: F.name,
                        value: {
                            type: "string",
                            value: F.value
                        },
                        ...F.path !== void 0 ? {
                            path: F.path
                        } : {},
                        ...F.httpOnly !== void 0 ? {
                            httpOnly: F.httpOnly
                        } : {},
                        ...F.secure !== void 0 ? {
                            secure: F.secure
                        } : {},
                        ...F.sameSite !== void 0 ? {
                            sameSite: XE(F.sameSite)
                        } : {},
                        expiry: YE(F.expires),
                        ...ZE(F, "sameParty", "sourceScheme", "priority", "url")
                    };
                    F.partitionKey !== void 0 ? await this.browserContext().userContext.setCookie(q, F.partitionKey) : await o(this, a).browsingContext.setCookie(q)
                }
            }
            async deleteCookie(...x) {
                await Promise.all(x.map(async N => {
                    const R = N.url ?? this.url()
                      , F = URL.canParse(R) ? new URL(R) : void 0
                      , O = N.domain ?? (F == null ? void 0 : F.hostname);
                    ne(O !== void 0, "At least one of the url and domain needs to be specified");
                    const T = {
                        domain: O,
                        name: N.name,
                        ...N.path !== void 0 ? {
                            path: N.path
                        } : {}
                    };
                    await o(this, a).browsingContext.deleteCookie(T)
                }
                ))
            }
            async removeExposedFunction(x) {
                await o(this, a).removeExposedFunction(x)
            }
            metrics() {
                throw new Oe
            }
            async goBack(x={}) {
                return await P(this, h, WC).call(this, -1, x)
            }
            async goForward(x={}) {
                return await P(this, h, WC).call(this, 1, x)
            }
            waitForDevicePrompt() {
                throw new Oe
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakSet,
        DF = function() {
            o(this, a).browsingContext.on("closed", () => {
                this.trustedEmitter.emit("close", void 0),
                this.trustedEmitter.removeAllListeners()
            }
            ),
            this.trustedEmitter.on("workercreated", x => {
                o(this, u).add(x)
            }
            ),
            this.trustedEmitter.on("workerdestroyed", x => {
                o(this, u).delete(x)
            }
            )
        }
        ,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakMap,
        m = new WeakMap,
        w = new WeakMap,
        Lg = async function(x, N, R) {
            if (R && !N)
                return await o(this, a).browsingContext.addIntercept({
                    phases: x
                });
            if (!R && N) {
                await o(this, a).browsingContext.userContext.browser.removeIntercept(N);
                return
            }
            return N
        }
        ,
        HC = async function() {
            o(this, d) && await this._client().send("Network.emulateNetworkConditions", {
                offline: o(this, d).offline,
                latency: o(this, d).latency,
                uploadThroughput: o(this, d).upload,
                downloadThroughput: o(this, d).download
            })
        }
        ,
        WC = async function(x, N) {
            const R = new AbortController;
            try {
                const [F] = await Promise.all([this.waitForNavigation({
                    ...N,
                    signal: R.signal
                }), o(this, a).browsingContext.traverseHistory(x)]);
                return F
            } catch (F) {
                if (R.abort(),
                hn(F) && F.message.includes("no such history entry"))
                    return null;
                throw F
            }
        }
        ,
        ( () => {
            const x = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            e = [ly()],
            XV(A, null, e, {
                kind: "accessor",
                name: "trustedEmitter",
                static: !1,
                private: !1,
                access: {
                    has: N => "trustedEmitter"in N,
                    get: N => N.trustedEmitter,
                    set: (N, R) => {
                        N.trustedEmitter = R
                    }
                },
                metadata: x
            }, t, r),
            x && Object.defineProperty(A, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: x
            })
        }
        )(),
        A
    }
    )();
    function YV(n, ...e) {
        return `() => {${Fv(n, ...e)}}`
    }
    function QV(n, e) {
        const t = n.domain.toLowerCase()
          , r = e.hostname.toLowerCase();
        return t === r ? !0 : t.startsWith(".") && r.endsWith(t)
    }
    function e9(n, e) {
        const t = e.pathname
          , r = n.path;
        return !!(t === r || t.startsWith(r) && (r.endsWith("/") || t[r.length] === "/"))
    }
    function t9(n, e) {
        const t = new URL(e);
        return ne(n !== void 0),
        QV(n, t) ? e9(n, t) : !1
    }
    function JE(n, e=!1) {
        const t = n[bb + "partitionKey"];
        function r() {
            return typeof t == "string" ? {
                partitionKey: t
            } : typeof t == "object" && t !== null ? e ? {
                partitionKey: {
                    sourceOrigin: t.topLevelSite,
                    hasCrossSiteAncestor: t.hasCrossSiteAncestor ?? !1
                }
            } : {
                partitionKey: t.topLevelSite
            } : {}
        }
        return {
            name: n.name,
            value: n.value.value,
            domain: n.domain,
            path: n.path,
            size: n.size,
            httpOnly: n.httpOnly,
            secure: n.secure,
            sameSite: n9(n.sameSite),
            expires: n.expiry ?? -1,
            session: n.expiry === void 0 || n.expiry <= 0,
            ...r9(n, "sameParty", "sourceScheme", "partitionKeyOpaque", "priority"),
            ...r()
        }
    }
    const bb = "goog:";
    function r9(n, ...e) {
        const t = {};
        for (const r of e)
            n[bb + r] !== void 0 && (t[r] = n[bb + r]);
        return t
    }
    function ZE(n, ...e) {
        const t = {};
        for (const r of e)
            n[r] !== void 0 && (t[bb + r] = n[r]);
        return t
    }
    function n9(n) {
        return n === "strict" ? "Strict" : n === "lax" ? "Lax" : "None"
    }
    function XE(n) {
        return n === "Strict" ? "strict" : n === "Lax" ? "lax" : "none"
    }
    function YE(n) {
        return [void 0, -1].includes(n) ? void 0 : n
    }
    function xN(n) {
        if (n === void 0 || typeof n == "string")
            return n;
        if (n.hasCrossSiteAncestor)
            throw new Oe("WebDriver BiDi does not support `hasCrossSiteAncestor` yet.");
        return n.sourceOrigin
    }
    /**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    class s9 extends qd {
        constructor(t) {
            super();
            b(this, wd);
            S(this, wd, t)
        }
        asPage() {
            throw new Oe
        }
        url() {
            return ""
        }
        createCDPSession() {
            throw new Oe
        }
        type() {
            return ar.BROWSER
        }
        browser() {
            return o(this, wd)
        }
        browserContext() {
            return o(this, wd).defaultBrowserContext()
        }
        opener() {
            throw new Oe
        }
    }
    wd = new WeakMap;
    class i9 extends qd {
        constructor(t) {
            super();
            b(this, vi);
            S(this, vi, t)
        }
        async page() {
            return o(this, vi)
        }
        async asPage() {
            return Yf.from(this.browserContext(), o(this, vi).mainFrame().browsingContext)
        }
        url() {
            return o(this, vi).url()
        }
        createCDPSession() {
            return o(this, vi).createCDPSession()
        }
        type() {
            return ar.PAGE
        }
        browser() {
            return this.browserContext().browser()
        }
        browserContext() {
            return o(this, vi).browserContext()
        }
        opener() {
            throw new Oe
        }
    }
    vi = new WeakMap;
    class a9 extends qd {
        constructor(t) {
            super();
            b(this, _i);
            b(this, bd);
            S(this, _i, t)
        }
        async page() {
            return o(this, bd) === void 0 && S(this, bd, Yf.from(this.browserContext(), o(this, _i).browsingContext)),
            o(this, bd)
        }
        async asPage() {
            return Yf.from(this.browserContext(), o(this, _i).browsingContext)
        }
        url() {
            return o(this, _i).url()
        }
        createCDPSession() {
            return o(this, _i).createCDPSession()
        }
        type() {
            return ar.PAGE
        }
        browser() {
            return this.browserContext().browser()
        }
        browserContext() {
            return o(this, _i).page().browserContext()
        }
        opener() {
            throw new Oe
        }
    }
    _i = new WeakMap,
    bd = new WeakMap;
    class o9 extends qd {
        constructor(t) {
            super();
            b(this, vd);
            S(this, vd, t)
        }
        async page() {
            throw new Oe
        }
        async asPage() {
            throw new Oe
        }
        url() {
            return o(this, vd).url()
        }
        createCDPSession() {
            throw new Oe
        }
        type() {
            return ar.OTHER
        }
        browser() {
            return this.browserContext().browser()
        }
        browserContext() {
            return o(this, vd).frame.page().browserContext()
        }
        opener() {
            throw new Oe
        }
    }
    vd = new WeakMap;
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var c9 = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , CN = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , u9 = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , l9 = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    let kN = ( () => {
        var s, i, a, c, u, l, d, BF, zC, p;
        let n = eP, e, t = [], r = [];
        return p = class extends n {
            constructor(m, w, E) {
                super();
                b(this, d);
                b(this, s, CN(this, t, new be));
                b(this, i, CN(this, r));
                b(this, a);
                J(this, "userContext");
                b(this, c, new WeakMap);
                b(this, u, new Map);
                b(this, l, []);
                S(this, i, m),
                this.userContext = w,
                S(this, a, E.defaultViewport)
            }
            static from(m, w, E) {
                var _;
                const v = new p(m,w,E);
                return P(_ = v, d, BF).call(_),
                v
            }
            get trustedEmitter() {
                return o(this, s)
            }
            set trustedEmitter(m) {
                S(this, s, m)
            }
            targets() {
                return [...o(this, u).values()].flatMap( ([m,w]) => [m, ...w.values()])
            }
            async newPage() {
                const m = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    const w = u9(m, await this.waitForScreenshotOperations(), !1)
                      , E = await this.userContext.createBrowsingContext("tab")
                      , v = o(this, c).get(E);
                    if (!v)
                        throw new Error("Page is not found");
                    if (o(this, a))
                        try {
                            await v.setViewport(o(this, a))
                        } catch {}
                    return v
                } catch (w) {
                    m.error = w,
                    m.hasError = !0
                } finally {
                    l9(m)
                }
            }
            async close() {
                ne(this.userContext.id !== yb.DEFAULT, "Default BrowserContext cannot be closed!");
                try {
                    await this.userContext.remove()
                } catch (m) {
                    ge(m)
                }
                o(this, u).clear()
            }
            browser() {
                return o(this, i)
            }
            async pages() {
                return [...this.userContext.browsingContexts].map(m => o(this, c).get(m))
            }
            async overridePermissions(m, w) {
                const E = new Set(w.map(v => {
                    if (!Dv.get(v))
                        throw new Error("Unknown permission: " + v);
                    return v
                }
                ));
                await Promise.all(Array.from(Dv.keys()).map(v => {
                    const _ = this.userContext.setPermissions(m, {
                        name: v
                    }, E.has(v) ? "granted" : "denied");
                    return o(this, l).push({
                        origin: m,
                        permission: v
                    }),
                    E.has(v) ? _ : _.catch(ge)
                }
                ))
            }
            async clearPermissionOverrides() {
                const m = o(this, l).map( ({permission: w, origin: E}) => this.userContext.setPermissions(E, {
                    name: w
                }, "prompt").catch(ge));
                S(this, l, []),
                await Promise.all(m)
            }
            get id() {
                if (this.userContext.id !== yb.DEFAULT)
                    return this.userContext.id
            }
            async cookies() {
                return (await this.userContext.getCookies()).map(w => JE(w, !0))
            }
            async setCookie(...m) {
                await Promise.all(m.map(async w => {
                    const E = {
                        domain: w.domain,
                        name: w.name,
                        value: {
                            type: "string",
                            value: w.value
                        },
                        ...w.path !== void 0 ? {
                            path: w.path
                        } : {},
                        ...w.httpOnly !== void 0 ? {
                            httpOnly: w.httpOnly
                        } : {},
                        ...w.secure !== void 0 ? {
                            secure: w.secure
                        } : {},
                        ...w.sameSite !== void 0 ? {
                            sameSite: XE(w.sameSite)
                        } : {},
                        expiry: YE(w.expires),
                        ...ZE(w, "sameParty", "sourceScheme", "priority", "url")
                    };
                    return await this.userContext.setCookie(E, xN(w.partitionKey))
                }
                ))
            }
        }
        ,
        s = new WeakMap,
        i = new WeakMap,
        a = new WeakMap,
        c = new WeakMap,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakSet,
        BF = function() {
            for (const m of this.userContext.browsingContexts)
                P(this, d, zC).call(this, m);
            this.userContext.on("browsingcontext", ({browsingContext: m}) => {
                const w = P(this, d, zC).call(this, m);
                if (m.originalOpener)
                    for (const E of this.userContext.browsingContexts)
                        E.id === m.originalOpener && o(this, c).get(E).trustedEmitter.emit("popup", w)
            }
            ),
            this.userContext.on("closed", () => {
                this.trustedEmitter.removeAllListeners()
            }
            )
        }
        ,
        zC = function(m) {
            const w = Yf.from(this, m);
            o(this, c).set(m, w),
            w.trustedEmitter.on("close", () => {
                o(this, c).delete(m)
            }
            );
            const E = new i9(w)
              , v = new Map;
            return o(this, u).set(w, [E, v]),
            w.trustedEmitter.on("frameattached", _ => {
                const A = _
                  , C = new a9(A);
                v.set(A, C),
                this.trustedEmitter.emit("targetcreated", C)
            }
            ),
            w.trustedEmitter.on("framenavigated", _ => {
                const A = _
                  , C = v.get(A);
                C === void 0 ? this.trustedEmitter.emit("targetchanged", E) : this.trustedEmitter.emit("targetchanged", C)
            }
            ),
            w.trustedEmitter.on("framedetached", _ => {
                const A = _
                  , C = v.get(A);
                C !== void 0 && (v.delete(A),
                this.trustedEmitter.emit("targetdestroyed", C))
            }
            ),
            w.trustedEmitter.on("workercreated", _ => {
                const A = _
                  , C = new o9(A);
                v.set(A, C),
                this.trustedEmitter.emit("targetcreated", C)
            }
            ),
            w.trustedEmitter.on("workerdestroyed", _ => {
                const A = _
                  , C = v.get(A);
                C !== void 0 && (v.delete(_),
                this.trustedEmitter.emit("targetdestroyed", C))
            }
            ),
            w.trustedEmitter.on("close", () => {
                o(this, u).delete(w),
                this.trustedEmitter.emit("targetdestroyed", E)
            }
            ),
            this.trustedEmitter.emit("targetcreated", E),
            w
        }
        ,
        ( () => {
            const m = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            e = [ly()],
            c9(p, null, e, {
                kind: "accessor",
                name: "trustedEmitter",
                static: !1,
                private: !1,
                access: {
                    has: w => "trustedEmitter"in w,
                    get: w => w.trustedEmitter,
                    set: (w, E) => {
                        w.trustedEmitter = E
                    }
                },
                metadata: m
            }, t, r),
            m && Object.defineProperty(p, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: m
            })
        }
        )(),
        p
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var d9 = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , Hu = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , h9 = function(n, e, t) {
        if (e != null) {
            if (typeof e != "object" && typeof e != "function")
                throw new TypeError("Object expected.");
            var r, s;
            if (t) {
                if (!Symbol.asyncDispose)
                    throw new TypeError("Symbol.asyncDispose is not defined.");
                r = e[Symbol.asyncDispose]
            }
            if (r === void 0) {
                if (!Symbol.dispose)
                    throw new TypeError("Symbol.dispose is not defined.");
                r = e[Symbol.dispose],
                t && (s = r)
            }
            if (typeof r != "function")
                throw new TypeError("Object not disposable.");
            s && (r = function() {
                try {
                    s.call(this)
                } catch (i) {
                    return Promise.reject(i)
                }
            }
            ),
            n.stack.push({
                value: e,
                dispose: r,
                async: t
            })
        } else
            t && n.stack.push({
                async: !0
            });
        return e
    }
      , f9 = function(n) {
        return function(e) {
            function t(a) {
                e.error = e.hasError ? new n(a,e.error,"An error was suppressed during disposal.") : a,
                e.hasError = !0
            }
            var r, s = 0;
            function i() {
                for (; r = e.stack.pop(); )
                    try {
                        if (!r.async && s === 1)
                            return s = 0,
                            e.stack.push(r),
                            Promise.resolve().then(i);
                        if (r.dispose) {
                            var a = r.dispose.call(r.value);
                            if (r.async)
                                return s |= 2,
                                Promise.resolve(a).then(i, function(c) {
                                    return t(c),
                                    i()
                                })
                        } else
                            s |= 1
                    } catch (c) {
                        t(c)
                    }
                if (s === 1)
                    return e.hasError ? Promise.reject(e.error) : Promise.resolve();
                if (e.hasError)
                    throw e.error
            }
            return i()
        }
    }(typeof SuppressedError == "function" ? SuppressedError : function(n, e, t) {
        var r = new Error(t);
        return r.name = "SuppressedError",
        r.error = n,
        r.suppressed = e,
        r
    }
    );
    let p9 = ( () => {
        var u, l, d, h, f, p, qF, UF, KF, VC, E;
        let n = be, e = [], t, r, s, i, a, c;
        return E = class extends n {
            constructor(A) {
                super();
                b(this, p);
                b(this, u, (d9(this, e),
                !1));
                b(this, l);
                b(this, d, new Ot);
                b(this, h, new Map);
                J(this, "session");
                b(this, f, new Map);
                this.session = A
            }
            static async from(A) {
                var k;
                const C = new E(A);
                return await P(k = C, p, qF).call(k),
                C
            }
            get closed() {
                return o(this, u)
            }
            get defaultUserContext() {
                return o(this, h).get(yb.DEFAULT)
            }
            get disconnected() {
                return o(this, l) !== void 0
            }
            get disposed() {
                return this.disconnected
            }
            get userContexts() {
                return o(this, h).values()
            }
            dispose(A, C=!1) {
                S(this, u, C),
                S(this, l, A),
                this[Ce]()
            }
            async close() {
                try {
                    await this.session.send("browser.close", {})
                } finally {
                    this.dispose("Browser already closed.", !0)
                }
            }
            async addPreloadScript(A, C={}) {
                var x;
                const {result: {script: k}} = await this.session.send("script.addPreloadScript", {
                    functionDeclaration: A,
                    ...C,
                    contexts: (x = C.contexts) == null ? void 0 : x.map(N => N.id)
                });
                return k
            }
            async removeIntercept(A) {
                await this.session.send("network.removeIntercept", {
                    intercept: A
                })
            }
            async removePreloadScript(A) {
                await this.session.send("script.removePreloadScript", {
                    script: A
                })
            }
            async createUserContext() {
                const {result: {userContext: A}} = await this.session.send("browser.createUserContext", {});
                return P(this, p, VC).call(this, A)
            }
            [(t = [Ti],
            r = [oe(A => o(A, l))],
            s = [oe(A => o(A, l))],
            i = [oe(A => o(A, l))],
            a = [oe(A => o(A, l))],
            c = [oe(A => o(A, l))],
            Ce)]() {
                o(this, l) ?? S(this, l, "Browser was disconnected, probably because the session ended."),
                this.closed && this.emit("closed", {
                    reason: o(this, l)
                }),
                this.emit("disconnected", {
                    reason: o(this, l)
                }),
                o(this, d).dispose(),
                super[Ce]()
            }
        }
        ,
        u = new WeakMap,
        l = new WeakMap,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakSet,
        qF = async function() {
            const A = o(this, d).use(new be(this.session));
            A.once("ended", ({reason: C}) => {
                this.dispose(C)
            }
            ),
            A.on("script.realmCreated", C => {
                C.type === "shared-worker" && o(this, f).set(C.realm, BE.from(this, C.realm, C.origin))
            }
            ),
            await P(this, p, UF).call(this),
            await P(this, p, KF).call(this)
        }
        ,
        UF = async function() {
            const {result: {userContexts: A}} = await this.session.send("browser.getUserContexts", {});
            for (const C of A)
                P(this, p, VC).call(this, C.userContext)
        }
        ,
        KF = async function() {
            const A = new Set;
            let C;
            {
                const k = {
                    stack: [],
                    error: void 0,
                    hasError: !1
                };
                try {
                    h9(k, new be(this.session), !1).on("browsingContext.contextCreated", R => {
                        A.add(R.context)
                    }
                    );
                    const {result: N} = await this.session.send("browsingContext.getTree", {});
                    C = N.contexts
                } catch (x) {
                    k.error = x,
                    k.hasError = !0
                } finally {
                    f9(k)
                }
            }
            for (const k of C)
                A.has(k.context) || this.session.emit("browsingContext.contextCreated", k),
                k.children && C.push(...k.children)
        }
        ,
        VC = function(A) {
            const C = yb.create(this, A);
            o(this, h).set(C.id, C);
            const k = o(this, d).use(new be(C));
            return k.once("closed", () => {
                k.removeAllListeners(),
                o(this, h).delete(C.id)
            }
            ),
            C
        }
        ,
        ( () => {
            const A = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            Hu(E, null, t, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: C => "dispose"in C,
                    get: C => C.dispose
                },
                metadata: A
            }, null, e),
            Hu(E, null, r, {
                kind: "method",
                name: "close",
                static: !1,
                private: !1,
                access: {
                    has: C => "close"in C,
                    get: C => C.close
                },
                metadata: A
            }, null, e),
            Hu(E, null, s, {
                kind: "method",
                name: "addPreloadScript",
                static: !1,
                private: !1,
                access: {
                    has: C => "addPreloadScript"in C,
                    get: C => C.addPreloadScript
                },
                metadata: A
            }, null, e),
            Hu(E, null, i, {
                kind: "method",
                name: "removeIntercept",
                static: !1,
                private: !1,
                access: {
                    has: C => "removeIntercept"in C,
                    get: C => C.removeIntercept
                },
                metadata: A
            }, null, e),
            Hu(E, null, a, {
                kind: "method",
                name: "removePreloadScript",
                static: !1,
                private: !1,
                access: {
                    has: C => "removePreloadScript"in C,
                    get: C => C.removePreloadScript
                },
                metadata: A
            }, null, e),
            Hu(E, null, c, {
                kind: "method",
                name: "createUserContext",
                static: !1,
                private: !1,
                access: {
                    has: C => "createUserContext"in C,
                    get: C => C.createUserContext
                },
                metadata: A
            }, null, e),
            A && Object.defineProperty(E, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: A
            })
        }
        )(),
        E
    }
    )();
    /**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var QE = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , Wu = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    };
    let m9 = ( () => {
        var d, h, f, p, g, HF, m;
        let n = be, e = [], t, r = [], s = [], i, a, c, u, l;
        return m = class extends n {
            constructor(v, _) {
                super();
                b(this, g);
                b(this, d, QE(this, e));
                b(this, h, new Ot);
                b(this, f);
                J(this, "browser");
                b(this, p, QE(this, r, void 0));
                QE(this, s),
                S(this, f, _),
                this.connection = v
            }
            static async from(v, _) {
                var k;
                const {result: A} = await v.send("session.new", {
                    capabilities: _
                })
                  , C = new m(v,A);
                return await P(k = C, g, HF).call(k),
                C
            }
            get connection() {
                return o(this, p)
            }
            set connection(v) {
                S(this, p, v)
            }
            get capabilities() {
                return o(this, f).capabilities
            }
            get disposed() {
                return this.ended
            }
            get ended() {
                return o(this, d) !== void 0
            }
            get id() {
                return o(this, f).sessionId
            }
            dispose(v) {
                S(this, d, v),
                this[Ce]()
            }
            async send(v, _) {
                return await this.connection.send(v, _)
            }
            async subscribe(v, _) {
                await this.send("session.subscribe", {
                    events: v,
                    contexts: _
                })
            }
            async addIntercepts(v, _) {
                await this.send("session.subscribe", {
                    events: v,
                    contexts: _
                })
            }
            async end() {
                try {
                    await this.send("session.end", {})
                } finally {
                    this.dispose("Session already ended.")
                }
            }
            [(t = [ly()],
            i = [Ti],
            a = [oe(v => o(v, d))],
            c = [oe(v => o(v, d))],
            u = [oe(v => o(v, d))],
            l = [oe(v => o(v, d))],
            Ce)]() {
                o(this, d) ?? S(this, d, "Session already destroyed, probably because the connection broke."),
                this.emit("ended", {
                    reason: o(this, d)
                }),
                o(this, h).dispose(),
                super[Ce]()
            }
        }
        ,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakSet,
        HF = async function() {
            this.browser = await p9.from(this),
            o(this, h).use(this.browser).once("closed", ({reason: A}) => {
                this.dispose(A)
            }
            );
            const _ = new WeakSet;
            this.on("browsingContext.fragmentNavigated", A => {
                _.has(A) || (_.add(A),
                this.emit("browsingContext.navigationStarted", A),
                this.emit("browsingContext.fragmentNavigated", A))
            }
            )
        }
        ,
        ( () => {
            const v = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            Wu(m, null, t, {
                kind: "accessor",
                name: "connection",
                static: !1,
                private: !1,
                access: {
                    has: _ => "connection"in _,
                    get: _ => _.connection,
                    set: (_, A) => {
                        _.connection = A
                    }
                },
                metadata: v
            }, r, s),
            Wu(m, null, i, {
                kind: "method",
                name: "dispose",
                static: !1,
                private: !1,
                access: {
                    has: _ => "dispose"in _,
                    get: _ => _.dispose
                },
                metadata: v
            }, null, e),
            Wu(m, null, a, {
                kind: "method",
                name: "send",
                static: !1,
                private: !1,
                access: {
                    has: _ => "send"in _,
                    get: _ => _.send
                },
                metadata: v
            }, null, e),
            Wu(m, null, c, {
                kind: "method",
                name: "subscribe",
                static: !1,
                private: !1,
                access: {
                    has: _ => "subscribe"in _,
                    get: _ => _.subscribe
                },
                metadata: v
            }, null, e),
            Wu(m, null, u, {
                kind: "method",
                name: "addIntercepts",
                static: !1,
                private: !1,
                access: {
                    has: _ => "addIntercepts"in _,
                    get: _ => _.addIntercepts
                },
                metadata: v
            }, null, e),
            Wu(m, null, l, {
                kind: "method",
                name: "end",
                static: !1,
                private: !1,
                access: {
                    has: _ => "end"in _,
                    get: _ => _.end
                },
                metadata: v
            }, null, e),
            v && Object.defineProperty(m, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: v
            })
        }
        )(),
        m
    }
    )();
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    var g9 = function(n, e, t, r, s, i) {
        function a(w) {
            if (w !== void 0 && typeof w != "function")
                throw new TypeError("Function expected");
            return w
        }
        for (var c = r.kind, u = c === "getter" ? "get" : c === "setter" ? "set" : "value", l = !e && n ? r.static ? n : n.prototype : null, d = e || (l ? Object.getOwnPropertyDescriptor(l, r.name) : {}), h, f = !1, p = t.length - 1; p >= 0; p--) {
            var g = {};
            for (var y in r)
                g[y] = y === "access" ? {} : r[y];
            for (var y in r.access)
                g.access[y] = r.access[y];
            g.addInitializer = function(w) {
                if (f)
                    throw new TypeError("Cannot add initializers after decoration has completed");
                i.push(a(w || null))
            }
            ;
            var m = (0,
            t[p])(c === "accessor" ? {
                get: d.get,
                set: d.set
            } : d[u], g);
            if (c === "accessor") {
                if (m === void 0)
                    continue;
                if (m === null || typeof m != "object")
                    throw new TypeError("Object expected");
                (h = a(m.get)) && (d.get = h),
                (h = a(m.set)) && (d.set = h),
                (h = a(m.init)) && s.unshift(h)
            } else
                (h = a(m)) && (c === "field" ? s.unshift(h) : d[u] = h)
        }
        l && Object.defineProperty(l, r.name, d),
        f = !0
    }
      , PN = function(n, e, t) {
        for (var r = arguments.length > 2, s = 0; s < e.length; s++)
            t = r ? e[s].call(n, t) : e[s].call(n);
        return r ? t : void 0
    }
      , TN = function(n, e, t) {
        return typeof e == "symbol" && (e = e.description ? "[".concat(e.description, "]") : ""),
        Object.defineProperty(n, "name", {
            configurable: !0,
            value: t ? "".concat(t, " ", e) : e
        })
    };
    let y9 = ( () => {
        var i, a, c, Ac, WF, d, h, f, p, g, y, m, zF, VF, GF, GC;
        let n = Qk, e, t = [], r = [], s;
        return i = class extends n {
            constructor(k, x) {
                super();
                b(this, c);
                J(this, "protocol", "webDriverBiDi");
                b(this, a, PN(this, t, new be));
                b(this, d, PN(this, r));
                b(this, h);
                b(this, f);
                b(this, p);
                b(this, g, new WeakMap);
                b(this, y, new s9(this));
                b(this, m);
                S(this, d, x.process),
                S(this, h, x.closeCallback),
                S(this, f, k),
                S(this, p, x.defaultViewport),
                S(this, m, x.cdpConnection)
            }
            static async create(k) {
                var R, F, O;
                const x = await m9.from(k.connection, {
                    firstMatch: (R = k.capabilities) == null ? void 0 : R.firstMatch,
                    alwaysMatch: {
                        ...(F = k.capabilities) == null ? void 0 : F.alwaysMatch,
                        acceptInsecureCerts: k.acceptInsecureCerts,
                        unhandledPromptBehavior: {
                            default: "ignore"
                        },
                        webSocketUrl: !0,
                        "goog:prerenderingDisabled": !0
                    }
                });
                await x.subscribe(x.capabilities.browserName.toLocaleLowerCase().includes("firefox") ? i.subscribeModules : [...i.subscribeModules, ...i.subscribeCdpEvents]);
                const N = new i(x.browser,k);
                return P(O = N, c, zF).call(O),
                N
            }
            get cdpSupported() {
                return o(this, m) !== void 0
            }
            get cdpConnection() {
                return o(this, m)
            }
            async userAgent() {
                return o(this, f).session.capabilities.userAgent
            }
            get connection() {
                return o(this, f).session.connection
            }
            wsEndpoint() {
                return this.connection.url
            }
            async close() {
                var k;
                if (!this.connection.closed)
                    try {
                        await o(this, f).close(),
                        await ((k = o(this, h)) == null ? void 0 : k.call(null))
                    } catch (x) {
                        ge(x)
                    } finally {
                        this.connection.dispose()
                    }
            }
            get connected() {
                return !o(this, f).disconnected
            }
            process() {
                return o(this, d) ?? null
            }
            async createBrowserContext(k) {
                const x = await o(this, f).createUserContext();
                return P(this, c, GC).call(this, x)
            }
            async version() {
                return `${o(this, c, VF)}/${o(this, c, GF)}`
            }
            browserContexts() {
                return [...o(this, f).userContexts].map(k => o(this, g).get(k))
            }
            defaultBrowserContext() {
                return o(this, g).get(o(this, f).defaultUserContext)
            }
            newPage() {
                return this.defaultBrowserContext().newPage()
            }
            targets() {
                return [o(this, y), ...this.browserContexts().flatMap(k => k.targets())]
            }
            target() {
                return o(this, y)
            }
            async disconnect() {
                try {
                    await o(this, f).session.end()
                } catch (k) {
                    ge(k)
                } finally {
                    this.connection.dispose()
                }
            }
            get debugInfo() {
                return {
                    pendingProtocolErrors: this.connection.getPendingProtocolErrors()
                }
            }
        }
        ,
        a = new WeakMap,
        c = new WeakSet,
        Ac = function() {
            return s.get.call(this)
        }
        ,
        WF = function(k) {
            return s.set.call(this, k)
        }
        ,
        d = new WeakMap,
        h = new WeakMap,
        f = new WeakMap,
        p = new WeakMap,
        g = new WeakMap,
        y = new WeakMap,
        m = new WeakMap,
        zF = function() {
            var k;
            for (const x of o(this, f).userContexts)
                P(this, c, GC).call(this, x);
            o(this, f).once("disconnected", () => {
                o(this, c, Ac).emit("disconnected", void 0),
                o(this, c, Ac).removeAllListeners()
            }
            ),
            (k = o(this, d)) == null || k.once("close", () => {
                o(this, f).dispose("Browser process exited.", !0),
                this.connection.dispose()
            }
            )
        }
        ,
        VF = function() {
            return o(this, f).session.capabilities.browserName
        }
        ,
        GF = function() {
            return o(this, f).session.capabilities.browserVersion
        }
        ,
        GC = function(k) {
            const x = kN.from(this, k, {
                defaultViewport: o(this, p)
            });
            return o(this, g).set(k, x),
            x.trustedEmitter.on("targetcreated", N => {
                o(this, c, Ac).emit("targetcreated", N)
            }
            ),
            x.trustedEmitter.on("targetchanged", N => {
                o(this, c, Ac).emit("targetchanged", N)
            }
            ),
            x.trustedEmitter.on("targetdestroyed", N => {
                o(this, c, Ac).emit("targetdestroyed", N)
            }
            ),
            x
        }
        ,
        ( () => {
            const k = typeof Symbol == "function" && Symbol.metadata ? Object.create(n[Symbol.metadata] ?? null) : void 0;
            e = [ly()],
            g9(i, s = {
                get: TN(function() {
                    return o(this, a)
                }, "#trustedEmitter", "get"),
                set: TN(function(x) {
                    S(this, a, x)
                }, "#trustedEmitter", "set")
            }, e, {
                kind: "accessor",
                name: "#trustedEmitter",
                static: !1,
                private: !0,
                access: {
                    has: x => Ir(c, x),
                    get: x => o(x, c, Ac),
                    set: (x, N) => {
                        S(x, c, N, WF)
                    }
                },
                metadata: k
            }, t, r),
            k && Object.defineProperty(i, Symbol.metadata, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: k
            })
        }
        )(),
        J(i, "subscribeModules", ["browsingContext", "network", "log", "script"]),
        J(i, "subscribeCdpEvents", ["goog:cdp.Debugger.scriptParsed", "goog:cdp.CSS.styleSheetAdded", "goog:cdp.Runtime.executionContextsCleared", "goog:cdp.Tracing.tracingComplete", "goog:cdp.Network.requestWillBeSent", "goog:cdp.Debugger.scriptParsed", "goog:cdp.Page.screencastFrame"]),
        i
    }
    )();
    /**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const AN = Object.freeze(Object.defineProperty({
        __proto__: null,
        BidiBrowser: y9,
        BidiBrowserContext: kN,
        BidiConnection: oN,
        BidiElementHandle: Jf,
        BidiFrame: yN,
        BidiFrameRealm: ra,
        BidiHTTPRequest: WE,
        BidiHTTPResponse: dN,
        BidiJSHandle: ta,
        BidiKeyboard: wN,
        BidiMouse: bN,
        BidiPage: Yf,
        BidiRealm: zE,
        BidiTouchscreen: vN,
        BidiWorkerRealm: wb,
        bidiToPuppeteerCookie: JE,
        cdpSpecificCookiePropertiesFromPuppeteerToBidi: ZE,
        connectBidiOverCdp: vV,
        convertCookiesExpiryCdpToBiDi: YE,
        convertCookiesPartitionKeyFromPuppeteerToBiDi: xN,
        convertCookiesSameSiteCdpToBiDi: XE,
        requests: HE
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var ex, IN;
    function w9() {
        return IN || (IN = 1,
        ex = function() {
            throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
        }
        ),
        ex
    }
    var b9 = w9();
    const v9 = De(b9);
    /**
 * @license
 * Copyright 2018 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
    const bx = class bx {
        constructor(e) {
            b(this, Si);
            J(this, "onmessage");
            J(this, "onclose");
            S(this, Si, e),
            o(this, Si).addEventListener("message", t => {
                this.onmessage && this.onmessage.call(null, t.data)
            }
            ),
            o(this, Si).addEventListener("close", () => {
                this.onclose && this.onclose.call(null)
            }
            ),
            o(this, Si).addEventListener("error", () => {}
            )
        }
        static create(e, t) {
            return new Promise( (r, s) => {
                const i = new v9(e,[],{
                    followRedirects: !0,
                    perMessageDeflate: !1,
                    allowSynchronousEvents: !1,
                    maxPayload: 268435456,
                    headers: {
                        "User-Agent": `Puppeteer ${Kk}`,
                        ...t
                    }
                });
                i.addEventListener("open", () => r(new bx(i))),
                i.addEventListener("error", s)
            }
            )
        }
        send(e) {
            o(this, Si).send(e)
        }
        close() {
            o(this, Si).close()
        }
    }
    ;
    Si = new WeakMap;
    let tx = bx;
    const _9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        NodeWebSocketTransport: tx
    }, Symbol.toStringTag, {
        value: "Module"
    }))
}
)();
