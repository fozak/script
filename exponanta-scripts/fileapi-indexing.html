<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Office File Indexer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
<h1>Office File Indexer</h1>
<input type="file" id="folderInput" webkitdirectory multiple />
<div id="status"></div>
<div id="log"></div>

<script>
const dbName = "OfficeIndexDB";
const storeName = "documents";

// Open IndexedDB
function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName, { keyPath: "filename" });
            }
        };
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
    });
}

// Save document to IndexedDB
function saveDoc(db, filename, content) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        store.put({ filename, content });
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
    });
}

// Extract main text from Office file
async function extractOfficeText(file, arrayBuffer) {
    try {
        const zip = await JSZip.loadAsync(arrayBuffer);
        let content = "";

        if (file.name.endsWith(".docx")) {
            const docXml = zip.file("word/document.xml");
            if (docXml) {
                const xmlText = await docXml.async("text");
                content = xmlText.replace(/<[^>]+>/g, " ");
            }
        } else if (file.name.endsWith(".xlsx")) {
            const sheets = Object.keys(zip.files).filter(f => f.startsWith("xl/worksheets/sheet"));
            for (let sheet of sheets) {
                const sheetFile = zip.file(sheet);
                if (sheetFile) {
                    const sheetText = await sheetFile.async("text");
                    content += sheetText.replace(/<[^>]+>/g, " ") + " ";
                }
            }
        } else if (file.name.endsWith(".pptx")) {
            const slides = Object.keys(zip.files).filter(f => f.startsWith("ppt/slides/slide"));
            for (let slide of slides) {
                const slideFile = zip.file(slide);
                if (slideFile) {
                    const slideText = await slideFile.async("text");
                    content += slideText.replace(/<[^>]+>/g, " ") + " ";
                }
            }
        }

        return content.trim();
    } catch (err) {
        throw new Error(`Failed to parse ZIP: ${err.message}`);
    }
}

// Process files
document.getElementById("folderInput").addEventListener("change", async (event) => {
    const files = event.target.files;
    const db = await openDB();
    const status = document.getElementById("status");
    const log = document.getElementById("log");
    log.innerHTML = "";

    let indexedCount = 0;

    for (let i = 0; i < files.length; i++) {
        const file = files[i];

        // Skip non-Office files
        if (!/\.(docx|xlsx|pptx)$/i.test(file.name)) continue;
        if (file.size === 0) {
            log.innerHTML += `<p>Skipping empty file: ${file.webkitRelativePath || file.name}</p>`;
            continue;
        }

        try {
            const arrayBuffer = await file.arrayBuffer();
            const content = await extractOfficeText(file, arrayBuffer);
            await saveDoc(db, file.webkitRelativePath || file.name, content);
            indexedCount++;
            status.innerText = `Indexed ${indexedCount}/${files.length}: ${file.name}`;
        } catch (err) {
            log.innerHTML += `<p>Error processing ${file.webkitRelativePath || file.name}: ${err.message}</p>`;
            console.warn("File skipped due to error:", file.name, err);
        }
    }

    status.innerText = `Indexing complete. Total files indexed: ${indexedCount}`;
});
</script>
</body>
</html>

