<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Office ZIP Indexer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
<h1>Office File Indexer</h1>
<input type="file" id="folderInput" webkitdirectory multiple />
<div id="status"></div>

<script>
const dbName = "OfficeIndexDB";
const storeName = "documents";

// Open IndexedDB
function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);
        request.onupgradeneeded = e => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName, { keyPath: "filename" });
            }
        };
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject(e.target.error);
    });
}

// Save document to IndexedDB
function saveDoc(db, filename, content) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        store.put({ filename, content });
        tx.oncomplete = () => resolve();
        tx.onerror = e => reject(e.target.error);
    });
}

// Extract main text from DOCX/XLSX/PPTX
async function extractOfficeText(file, arrayBuffer) {
    const zip = await JSZip.loadAsync(arrayBuffer);
    let content = "";

    if (file.name.endsWith(".docx")) {
        const docXml = zip.file("word/document.xml");
        if (docXml) {
            const xmlText = await docXml.async("text");
            // Remove XML tags to get plain text
            content = xmlText.replace(/<[^>]+>/g, " ");
        }
    } else if (file.name.endsWith(".xlsx")) {
        const sheets = Object.keys(zip.files).filter(f => f.startsWith("xl/worksheets/sheet"));
        for (let sheet of sheets) {
            const sheetText = await zip.file(sheet)?.async("text");
            if (sheetText) content += sheetText.replace(/<[^>]+>/g, " ") + " ";
        }
    } else if (file.name.endsWith(".pptx")) {
        const slides = Object.keys(zip.files).filter(f => f.startsWith("ppt/slides/slide"));
        for (let slide of slides) {
            const slideText = await zip.file(slide)?.async("text");
            if (slideText) content += slideText.replace(/<[^>]+>/g, " ") + " ";
        }
    }
    return content.trim();
}

// Process files
document.getElementById("folderInput").addEventListener("change", async (event) => {
    const files = event.target.files;
    const db = await openDB();
    const status = document.getElementById("status");

    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (!/\.(docx|xlsx|pptx)$/i.test(file.name)) continue;

        const arrayBuffer = await file.arrayBuffer();
        const content = await extractOfficeText(file, arrayBuffer);
        await saveDoc(db, file.webkitRelativePath || file.name, content);
        status.innerText = `Indexed ${i + 1}/${files.length}: ${file.name}`;
    }

    status.innerText = `Indexing complete. Total files indexed: ${files.length}`;
});
</script>
</body>
</html>
