┌─────────────────────────────────────────────────────────────┐
│ 1. SCHEMA DEFINITION (Storage Layer)                        │
└─────────────────────────────────────────────────────────────┘
PocketBase Collection: "item"
├─ doctype: "Schema"
├─ data.schema_name: "Task"  ← Defines which doctype
├─ data.is_submittable: 0        ← Behavior flag
├─ data._autosave: 1             ← Only matters if is_submittable=1
├─ data.fields: [...]            ← Field definitions
└─ data.permissions: [...]

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 2. SCHEMA FETCH & CACHE (coworker.getSchema)                │
└─────────────────────────────────────────────────────────────┘
User calls: coworker.run({ operation: 'edit', doctype: 'Task' })
                           ↓
controller.execute(run_doc)
                           ↓
opConfig.requiresSchema === true
                           ↓
coworker.getSchema('Task')
  ├─ Check cache: coworker._schemaCache['Task']
  ├─ If missing: query PocketBase
  │   filter: doctype="Schema" && data.schema_name="Task"
  ├─ Cache result
  └─ return schema

run_doc.target.schema = { is_submittable, _autosave, fields, ... }

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 3. CONTROLLER ROUTING (Operation Config)                    │
└─────────────────────────────────────────────────────────────┘
controller.execute(run_doc)
                           ↓
opConfig = coworker._config.operations[operation]
{
  type: "read" | "write" | "custom",
  requiresSchema: true/false,
  validate: true/false,
  fetchOriginals: true/false
}
                           ↓
if (type === "read")  → _handlers[operation](run_doc)
if (type === "write") → _processWrite(run_doc, opConfig)
if (type === "custom")→ _handlers[operation](run_doc)

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 4. WRITE OPERATIONS (Validation Layer)                      │
└─────────────────────────────────────────────────────────────┘
_processWrite(run_doc, opConfig)
                           ↓
if (opConfig.fetchOriginals) {
  items = await dbQuery(where)  // Fetch existing records
}
                           ↓
if (opConfig.validate) {
  schema.fields.forEach(field => {
    validateField(field, doc[field.fieldname])
    // Check: reqd, type, length, min/max, etc.
  })
  if (!valid) return { errors }
}
                           ↓
_handlers[operation](run_doc)  // Execute actual DB operation

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 5. UI RENDERING (Component Layer)                           │
└─────────────────────────────────────────────────────────────┘
coworker._render(run)
                           ↓
<MainForm run={run} />
  schema = run.target.schema
  
  schema.fields.map(field => {
    // Dynamic component selection
    Component = globalThis.components[`Field${field.fieldtype}`]
    
    return <Component 
      field={field}
      run={run}
      value={run.doc[field.fieldname]}
    />
  })

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 6. FIELD INTERACTION (AutoSave Flow)                        │
└─────────────────────────────────────────────────────────────┘
<FieldData onChange={handleChange} />
                           ↓
User types in field
                           ↓
handleChange(newValue)
  ├─ run.input[fieldname] = newValue  // Update delta
  └─ coworker.controller.autoSave(run)

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 7. AUTOSAVE LOGIC (Schema-Driven Behavior)                  │
└─────────────────────────────────────────────────────────────┘
async autoSave(run) {
  if (!run.options?.draft) return;        // Not in draft mode
  if (run._saving) return;                // Already saving
  
  schema = run.target.schema;
  
  // ✅ CHECK SCHEMA AUTOSAVE RULES
  if (schema?.is_submittable === 1) {
    if (schema._autosave === 0) return;   // No autosave at all
    if (run.doc.docstatus !== 0) return;  // Only autosave drafts
  }
  // Default: is_submittable=0 → autosave enabled
  
  if (!isComplete(run)) {
    coworker._render(run);  // Show validation errors
    return;
  }
  
  return await save(run);  // Trigger save
}

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 8. SAVE OPERATION (Merge & Persist)                         │
└─────────────────────────────────────────────────────────────┘
async save(run) {
  // Validate
  validation = validate(run)
  if (!valid) return { errors }
  
  // Merge original + delta
  original = run.target.data[0]    // { name: "TASK-001", status: "Open" }
  delta = run.input                // { status: "Completed" }
  merged = { ...original, ...delta }
  
  // Determine operation
  isNew = !merged.name || merged.name.startsWith("new-")
  operation = isNew ? "create" : "update"
  
  // Create child run
  saveRun = await run.child({
    operation: operation,
    doctype: run.source_doctype,
    input: merged
  })
  
  // Update parent run
  if (saveRun.success) {
    run.target.data = [saveRun.target.data[0]]  // Updated doc
    run.input = {}                               // Clear delta
    coworker._render(run)
  }
}

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 9. CHILD RUN EXECUTION (Back to Controller)                 │
└─────────────────────────────────────────────────────────────┘
saveRun → controller.execute()
  → _processWrite() → validate → _handlers.update()
    → PocketBase API → Database persisted
      → Return updated document

                           ↓

┌─────────────────────────────────────────────────────────────┐
│ 10. UI UPDATE (Re-render with Fresh Data)                   │
└─────────────────────────────────────────────────────────────┘
coworker._render(run)
  ↓
<MainForm run={run} />
  ├─ run.target.data[0] = { name: "TASK-001", status: "Completed" }
  ├─ run.input = {}  (cleared)
  └─ Fields show updated values, no validation errors
