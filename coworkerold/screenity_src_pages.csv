Full Path,Comments,Mime Type,Size (bytes),Text Content
Background\index.js,Truncated to 6000 bytes due to size > 6000,text/javascript,54071,"import saveToDrive from ""./modules/saveToDrive"";

import {
  sendMessageTab,
  focusTab,
  removeTab,
  getCurrentTab,
  createTab,
} from ""./modules/tabHelper"";

import localforage from ""localforage"";

localforage.config({
  driver: localforage.INDEXEDDB,
  name: ""screenity"",
  version: 1,
});

// Get chunks store
const chunksStore = localforage.createInstance({
  name: ""chunks"",
});

// Get localDirectory store
const localDirectoryStore = localforage.createInstance({
  name: ""localDirectory"",
});

const startAfterCountdown = async () => {
  // Check that the recording didn't get dismissed
  const { recordingTab } = await chrome.storage.local.get([""recordingTab""]);
  const { offscreen } = await chrome.storage.local.get([""offscreen""]);

  if (recordingTab != null || offscreen) {
    chrome.storage.local.set({ recording: true });
    startRecording();
  }
};

const resetActiveTab = async () => {
  let editor_url = ""editor.html"";

  // Check if Chrome version is 109 or below
  if (navigator.userAgent.includes(""Chrome/"")) {
    const version = parseInt(navigator.userAgent.match(/Chrome\/([0-9]+)/)[1]);
    if (version <= 109) {
      editor_url = ""editorfallback.html"";
    }
  }
  const { activeTab } = await chrome.storage.local.get([""activeTab""]);

  // Check if activeTab exists
  chrome.tabs.get(activeTab, (tab) => {
    if (tab) {
      // Focus the window
      chrome.windows.update(tab.windowId, { focused: true }, async () => {
        chrome.tabs.update(activeTab, {
          active: true,
          selected: true,
          highlighted: true,
        });

        focusTab(activeTab);

        sendMessageTab(activeTab, { type: ""ready-to-record"" });

        // Check if countdown is set, if so start recording after 3 seconds
        const { countdown } = await chrome.storage.local.get([""countdown""]);
        if (countdown) {
          setTimeout(() => {
            startAfterCountdown();
          }, 3500);
        } else {
          setTimeout(() => {
            startAfterCountdown();
          }, 500);
        }
      });
    }
  });
};

const resetActiveTabRestart = async () => {
  const { activeTab } = await chrome.storage.local.get([""activeTab""]);
  focusTab(activeTab).then(async () => {
    sendMessageTab(activeTab, { type: ""ready-to-record"" });

    // Check if countdown is set, if so start recording after 3 seconds
    const { countdown } = await chrome.storage.local.get([""countdown""]);
    if (countdown) {
      setTimeout(() => {
        startAfterCountdown();
      }, 3000);
    } else {
      startRecording();
    }
  });
};

const startRecording = async () => {
  chrome.storage.local.set({
    recordingStartTime: Date.now(),
    restarting: false,
    recording: true,
  });

  // Check if customRegion is set
  const { customRegion } = await chrome.storage.local.get([""customRegion""]);

  if (customRegion) {
    sendMessageRecord({ type: ""start-recording-tab"", region: true });
  } else {
    sendMessageRecord({ type: ""start-recording-tab"" });
  }
  chrome.action.setIcon({ path: ""assets/recording-logo.png"" });
  // Set up alarm if set in storage
  const { alarm } = await chrome.storage.local.get([""alarm""]);
  const { alarmTime } = await chrome.storage.local.get([""alarmTime""]);
  if (alarm) {
    const seconds = parseFloat(alarmTime);
    chrome.alarms.create(""recording-alarm"", { delayInMinutes: seconds / 60 });
  }
};

// Detect commands
chrome.commands.onCommand.addListener(async (command) => {
  if (command === ""start-recording"") {
    // get active tab
    const activeTab = await getCurrentTab();

    // Check if it's possible to inject into content (not a chrome:// page, new tab, etc)
    if (
      !(
        (navigator.onLine === false &&
          !activeTab.url.includes(""/playground.html"") &&
          !activeTab.url.includes(""/setup.html"")) ||
        activeTab.url.startsWith(""chrome://"") ||
        (activeTab.url.startsWith(""chrome-extension://"") &&
          !activeTab.url.includes(""/playground.html"") &&
          !activeTab.url.includes(""/setup.html""))
      ) &&
      !activeTab.url.includes(""stackoverflow.com/"") &&
      !activeTab.url.includes(""chrome.google.com/webstore"") &&
      !activeTab.url.includes(""chromewebstore.google.com"")
    ) {
      sendMessageTab(activeTab.id, { type: ""start-stream"" });
    } else {
      chrome.tabs
        .create({
          url: ""playground.html"",
          active: true,
        })
        .then((tab) => {
          chrome.storage.local.set({ activeTab: tab.id });
          // Wait for the tab to load
          chrome.tabs.onUpdated.addListener(function _(tabId, changeInfo, tab) {
            if (tabId === tab.id && changeInfo.status === ""complete"") {
              setTimeout(() => {
                sendMessageTab(tab.id, { type: ""start-stream"" });
              }, 500);
              chrome.tabs.onUpdated.removeListener(_);
            }
          });
        });
    }
  } else if (command === ""cancel-recording"") {
    // get active tab
    const activeTab = await getCurrentTab();
    sendMessageTab(activeTab.id, { type: ""cancel-recording"" });
  } else if (command == ""pause-recording"") {
    const activeTab = await getCurrentTab();
    sendMessageTab(activeTab.id, { type: ""pause-recording"" });
  }
});

const handleAlarm = async (alarm) => {
  if (alarm.name === ""recording-alarm"") {
    // Check if recording
    const { recording } = await chrome.storage.local.get([""recording""]);
    if (recording) {
      stopRecording();

      const { activeTab } = await chrome.storage.local.get([""activeTab""]);

      // Check if actual tab
      chrome.tabs.get(activeTab, (t) => {
        if (t) {
          sendMessageTab(activeTab, { type: ""stop-recording-tab"" });
        } else {
          sendMessageTab(tab.id, { type: ""stop-recording-tab"" });
          chrome.storage.local.set({ activeTab: tab.id });
        }
      });
    }
    chrome.alarms.clear(""recording-alarm"");
  }
};

const alarmListener = (alarm) => {
  handleAlarm(alarm);"
Background\modules\base64ToUint8Array.js,Included,text/javascript,855,"const base64ToUint8Array = (base64) => {
  const dataUrlRegex = /^data:(.*?);base64,/;
  const matches = base64.match(dataUrlRegex);
  if (matches !== null) {
    // Base64 is a data URL
    const mimeType = matches[1];
    const binaryString = atob(base64.slice(matches[0].length));
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return new Blob([bytes], { type: mimeType });
  } else {
    // Base64 is a regular string
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return new Blob([bytes], { type: ""video/webm"" });
  }
};

export default base64ToUint8Array;
"
Background\modules\saveToDrive.js,Included,text/javascript,4692,"import signIn from ""./signIn"";

// Function to upload a video to Google Drive
const saveToDrive = async (videoBlob, fileName, sendResponse) => {
  // Function to get an access token from Chrome storage
  async function getAuthTokenFromStorage() {
    return new Promise((resolve, reject) => {
      chrome.storage.local.get([""token""], async (result) => {
        if (chrome.runtime.lastError) {
          reject(new Error(chrome.runtime.lastError));
        } else {
          const token = result.token;
          if (!token || token === null) {
            // Token is not set, trigger sign-in
            const newToken = await signIn();
            if (!newToken || newToken === null) {
              // Sign-in failed, throw an error
              reject(new Error(""Sign-in failed""));
            }
            resolve(newToken);
          } else {
            // Token is set, check if it has expired
            let payload;
            try {
              payload = JSON.parse(atob(token.split(""."")[1]));
            } catch (err) {
              // Token is invalid, refresh it
              chrome.identity.getAuthToken(
                { interactive: true },
                (newToken) => {
                  if (chrome.runtime.lastError) {
                    reject(new Error(chrome.runtime.lastError));
                  } else {
                    resolve(newToken);
                  }
                }
              );
              return;
            }

            const expirationTime = payload.exp * 1000; // Convert to milliseconds
            const currentTime = Date.now();
            if (currentTime >= expirationTime) {
              // Token has expired, refresh it
              chrome.identity.getAuthToken(
                { interactive: true },
                (newToken) => {
                  if (chrome.runtime.lastError) {
                    reject(new Error(chrome.runtime.lastError));
                  } else {
                    resolve(newToken);
                  }
                }
              );
            } else {
              // Token is still valid
              resolve(token);
            }
          }
        }
      });
    });
  }

  return new Promise(async (resolve, reject) => {
    try {
      // Get the access token from Chrome storage
      let token = await getAuthTokenFromStorage();

      if (!token || token === null) {
        throw new Error(""Sign-in failed"");
      }

      // Upload the video to Google Drive
      const headers = new Headers({
        Authorization: `Bearer ${token}`,
        ""Content-Type"": videoBlob.type,
      });

      const uploadResponse = await fetch(
        ""https://www.googleapis.com/upload/drive/v3/files?uploadType=media"",
        {
          method: ""POST"",
          headers,
          body: videoBlob,
        }
      );

      if (!uploadResponse.ok) {
        throw new Error(
          `Error uploading to Google Drive: ${uploadResponse.status}`
        );
      }

      const responseData = await uploadResponse.json();
      const fileId = responseData.id;

      if (!fileId) {
        throw new Error(""File ID is undefined"");
      }

      // Create the metadata for the file
      const fileMetadata = {
        name: fileName,
      };

      // Update the file metadata with the name
      const metadataResponse = await fetch(
        `https://www.googleapis.com/drive/v3/files/${fileId}`,
        {
          method: ""PATCH"",
          headers: new Headers({
            Authorization: `Bearer ${token}`,
            ""Content-Type"": ""application/json; charset=UTF-8"",
          }),
          body: JSON.stringify(fileMetadata),
        }
      );

      if (!metadataResponse.ok) {
        const errorResponse = await metadataResponse.json();
        console.error(
          ""Error updating file metadata:"",
          metadataResponse.status,
          errorResponse.error.message
        );
        throw new Error(
          `Error updating file metadata: ${metadataResponse.status}`
        );
      }
      sendResponse({ status: ""ok"", url: fileId });

      // Open the Google Drive file in a new tab
      chrome.tabs.create({
        url: `https://drive.google.com/file/d/${fileId}/view`,
      });

      resolve(`https://drive.google.com/file/d/${fileId}/view`); // Return the file ID if needed
    } catch (error) {
      console.error(""Error uploading to Google Drive:"", error.message);
      sendResponse({ status: ""ew"", url: null });
      reject(error);
    }
  });
};

export default saveToDrive;
"
Background\modules\secrets.development.js,Included,text/javascript,0,
Background\modules\signIn.js,Included,text/javascript,694,"const signIn = async () => {
  try {
    const token = await chrome.identity.getAuthToken({ interactive: true });

    if (!token) {
      throw new Error(""User cancelled sign-in or failed to get token"");
    }

    // Save token to storage
    await new Promise((resolve) =>
      chrome.storage.local.set({ token: token.token }, () => resolve())
    );

    const userInfo = await chrome.identity.getProfileUserInfo();

    return token.token; // Return the token if sign-in is successful
  } catch (error) {
    console.error(""Error signing in:"", error.message);
    return null;
    throw error; // Reject the Promise if sign-in fails
  }
};

export default signIn;
"
Background\modules\tabHelper.js,Included,text/javascript,2909,"const sendMessageTab = async (
  tabId,
  message,
  responseCallback = null,
  noTab = null
) => {
  if (tabId === null || message === null)
    return Promise.reject(""Tab ID or message is null"");

  try {
    const tab = await new Promise((resolve, reject) => {
      chrome.tabs.get(tabId, (tab) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError.message);
        } else {
          resolve(tab);
        }
      });
    });

    if (
      !tab ||
      !tab.url ||
      tab.url.startsWith(""chrome://"") ||
      tab.url.startsWith(""chromewebstore.google.com"") ||
      tab.url.startsWith(""chrome.google.com/webstore"") ||
      tab.url === """" ||
      tab.url === ""about:blank""
    ) {
      return Promise.reject(""Invalid tab URL"");
    }

    return new Promise((resolve, reject) => {
      chrome.tabs.sendMessage(tab.id, message, (response) => {
        if (chrome.runtime.lastError) {
          reject(chrome.runtime.lastError.message);
        } else {
          responseCallback ? responseCallback(response) : resolve(response);
        }
      });
    });
  } catch (error) {
    console.error(""Error sending message to tab:"", error);
    if (noTab && typeof noTab === ""function"") {
      noTab();
    }
    return Promise.reject(error);
  }
};

const focusTab = async (tabId) => {
  if (tabId === null) return;

  try {
    const tab = await new Promise((resolve) => {
      chrome.tabs.get(tabId, (tab) => {
        resolve(tab);
      });
    });

    if (tab && tab.id) {
      chrome.windows.update(tab.windowId, { focused: true }).then(() => {
        chrome.tabs.update(tab.id, { active: true });
      });
    }
  } catch (error) {
    // Tab doesn't exist or can't be accessed
  }
};

const removeTab = async (tabId) => {
  if (tabId === null) return;

  try {
    const tab = await new Promise((resolve) => {
      chrome.tabs.get(tabId, (tab) => {
        resolve(tab);
      });
    });

    if (tab && tab.id) {
      chrome.tabs.remove(tab.id);
    }
  } catch (error) {
    // Tab doesn't exist or can't be accessed
  }
};

// Get current tab (requires activeTab permission)
const getCurrentTab = async () => {
  const queryOptions = { active: true, lastFocusedWindow: true };
  const [tab] = await chrome.tabs.query(queryOptions);
  return tab;
};

const createTab = async (url, translate = false, active = false) => {
  if (!url) return;

  if (translate) {
    const locale = chrome.i18n.getMessage(""@@ui_locale"");
    if (!locale.includes(""en"")) {
      url =
        ""http://translate.google.com/translate?js=n&sl=auto&tl="" +
        locale +
        ""&u="" +
        url;
    }
  }

  chrome.tabs.create({
    url: url,
    active: active,
  });
};

export { sendMessageTab, focusTab, removeTab, getCurrentTab, createTab };
"
Backup\Backup.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,21156,"import React, { useState, useEffect, useRef } from ""react"";

import localforage from ""localforage"";

localforage.config({
  driver: localforage.INDEXEDDB,
  name: ""screenity"",
  version: 1,
});

// Get chunks store
const chunksStore = localforage.createInstance({
  name: ""chunks"",
});

// Get localDirectory store
const localDirectoryStore = localforage.createInstance({
  name: ""localDirectory"",
});

const Backup = () => {
  const [setupComplete, setSetupComplete] = useState(false);
  const writable = useRef(null);
  const request = useRef(null);
  const tabId = useRef(null);
  const repeatRef = useRef(0);
  const [backupAgain, setBackupAgain] = useState(false);
  const backupRef = useRef(false);
  const writingFile = useRef(false);
  const titleRef = useRef(null);
  const [override, setOverride] = useState(false);
  const waitWrite = useRef(false);
  const closeRequest = useRef(false);

  useEffect(() => {
    backupRef.current = backupAgain;
  }, [backupAgain]);

  const verifyFilePermissions = async (fileHandle) => {
    const opts = {
      mode: ""readwrite"",
    };
    const permission = await fileHandle.queryPermission(opts);
    if (permission === ""granted"") {
      return true;
    } else if (permission === ""prompt"") {
      chrome.runtime.sendMessage({ type: ""focus-this-tab"" });
      return false;
    } else if ((await fileHandle.requestPermission(opts)) === ""granted"") {
      chrome.runtime.sendMessage({ type: ""focus-this-tab"" });
      return true;
    } else {
      return false;
    }
  };

  const initLocalDirectory = async (directoryHandle, prompt = true) => {
    const permissions = await verifyFilePermissions(directoryHandle);
    if (permissions) {
      let videoTitle = `Screenity video - ${new Date().toLocaleString(""en-US"", {
        month: ""short"",
        day: ""numeric"",
        year: ""numeric"",
        hour: ""numeric"",
        minute: ""numeric"",
        second: ""numeric"",
        hour12: true,
      })}.webm`;

      videoTitle = videoTitle.replace(/:/g, ""-"");

      titleRef.current = videoTitle;

      const fileHandle = await directoryHandle.getFileHandle(videoTitle, {
        create: true,
      });
      writable.current = await fileHandle.createWritable();

      setSetupComplete(true);
      setBackupAgain(true);
      if (prompt) {
        chrome.storage.local.set({ backupSetup: true }).then(() => {
          chrome.runtime.sendMessage({
            type: ""backup-created"",
            request: request.current,
            tabId: tabId.current,
          });
        });
      }
      writingFile.current = true;
    } else if (repeatRef.current < 3) {
      chrome.runtime.sendMessage({ type: ""focus-this-tab"" });
      repeatRef.current = repeatRef.current + 1;
      localDirectoryStore.clear();

      localSaving(prompt);
    } else {
      alert(
        ""Failed to set up local backup. Reach out to us at support@screenity.io for more help. You can still record your screen.""
      );
      chrome.storage.local.set({ backup: false });
      chrome.runtime.sendMessage({
        type: ""backup-created"",
        request: request.current,
        tabId: tabId.current,
      });
      setOverride(true);
      window.close();
    }
  };

  const directoryPicker = async (prompt = true) => {
    chrome.runtime.sendMessage({ type: ""focus-this-tab"" });
    let directoryPicker = null;
    // Request access to create a file in a user-selected directory
    try {
      directoryPicker = await window.showDirectoryPicker({
        startIn: ""videos"",
        mode: ""readwrite"",
      });
    } catch (err) {
      if (backupRef.current) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""backup-error"",
          why: JSON.stringify(err),
        });
      }
      return;
    }
    // check if user cancelled the prompt
    if (!directoryPicker) {
      if (backupRef.current) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""backup-error"",
          why: JSON.stringify(err),
        });
      }
      return;
    }

    let directoryHandle = directoryPicker;

    // Check if the selected directory is the ""Screenity recordings"" folder
    if (directoryPicker.name === ""Screenity Recordings"") {
      // Use the selected directory directly
      directoryHandle = directoryPicker;
    } else {
      // If not, create the ""Screenity recordings"" folder within it
      directoryHandle = await directoryPicker.getDirectoryHandle(
        ""Screenity Recordings"",
        { create: true }
      );
    }

    await localDirectoryStore.clear();
    await localDirectoryStore.setItem(""directoryHandle"", directoryHandle);

    initLocalDirectory(directoryHandle, prompt);
  };

  const localSaving = async (prompt = true) => {
    waitWrite.current = false;
    closeRequest.current = false;
    // Check if user gesture has happened with UserActivation API
    if (!navigator.userActivation.isActive) {
      chrome.runtime.sendMessage({ type: ""focus-this-tab"" });
      return;
    }

    if (!backupRef.current) {
      localDirectoryStore.clear();
    }

    // Check if the FileSystem API is available
    if (""showDirectoryPicker"" in window) {
      localDirectoryStore.getItem(""directoryHandle"").then(async (directory) => {
        if (directory) {
          try {
            const permissions = await verifyFilePermissions(
              directory.directoryHandle
            );
            if (!permissions) {
              directoryPicker(prompt);
            } else {
              initLocalDirectory(directory.directoryHandle, prompt);
            }
          } catch (e) {
            localDirectoryStore.clear();
            directoryPicker(prompt);
          }
        } else {
          directoryPicker(prompt);
        }
      });
    } else {
      alert(
        ""Your browser doesn't support local backups. Reach out to us at support@screenity.io for more help. You can still record your screen.""
      );
      chrome.stora"
Backup\index.html,Included,text/html,1362,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Screenity - Backups</title>
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <style>
      @font-face {
        font-family: Satoshi-Light;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Light.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Medium;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Medium.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Bold;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Bold.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Gloria-Hallelujah;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/GloriaHallelujah-Regular.ttf)
          format(""truetype"");
      }
    </style>
  </head>

  <body>
    <div id=""app-container""></div>
    <!-- <script src=""chrome-extension://__MSG_@@extension_id__/assets/vendor/ffmpeg-core.js""></script> -->
  </body>
</html>
"
Backup\index.jsx,Included,application/octet-stream,260,"import React from ""react"";
import { render } from ""react-dom"";

import Backup from ""./Backup"";

// Render at the end of the body of any website
render(<Backup />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Camera\Camera.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,12153,"import React, { useEffect, useState, useRef } from ""react"";
import Background from ""./modules/Background"";

const Camera = () => {
  const [width, setWidth] = useState(0);
  const [height, setHeight] = useState(0);
  const [backgroundEffects, setBackgroundEffects] = useState(false);
  const backgroundEffectsRef = useRef(false);
  const streamRef = useRef(null);
  const videoRef = useRef(null);
  const [imageDataState, setImageDataState] = useState(null);
  const [pipMode, setPipMode] = useState(false);
  const recordingTypeRef = useRef(""screen"");

  // Offscreen canvas for getting video frame
  const offScreenCanvasRef = useRef(null);
  const offScreenCanvasContextRef = useRef(null);

  useEffect(() => {
    offScreenCanvasRef.current = document.createElement(""canvas"");
  }, []);

  const getCameraStream = (constraints) => {
    navigator.mediaDevices
      .getUserMedia(constraints)
      .then((stream) => {
        streamRef.current = stream;
        const videoTrack = stream.getVideoTracks()[0];
        const { width, height } = videoTrack.getSettings();
        if (recordingTypeRef.current === ""camera"") {
          setWidth(""100%"");
          setHeight(""auto"");
        } else {
          setWidth(width / height < 1 ? ""100%"" : ""auto"");
          setHeight(width / height < 1 ? ""auto"" : ""100%"");
        }
        const video = videoRef.current;
        video.srcObject = stream;
        video.onloadedmetadata = (e) => {
          video.play();

          const canvas = offScreenCanvasRef.current;
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          offScreenCanvasContextRef.current = canvas.getContext(""2d"");
          requestAnimationFrame(captureFrame);
        };
      })
      .catch((err) => {
        // Error getting camera stream
      });
  };

  const stopCameraStream = () => {
    if (!streamRef.current) return;
    streamRef.current.getTracks().forEach((track) => track.stop());
    videoRef.current.srcObject = null;
  };

  useEffect(() => {
    backgroundEffectsRef.current = backgroundEffects;
  }, [backgroundEffects]);

  const captureFrame = () => {
    if (
      backgroundEffectsRef.current &&
      offScreenCanvasContextRef.current &&
      offScreenCanvasRef.current
    ) {
      const video = videoRef.current;
      offScreenCanvasContextRef.current.drawImage(
        video,
        0,
        0,
        offScreenCanvasRef.current.width,
        offScreenCanvasRef.current.height
      );
      setImageDataState(
        offScreenCanvasContextRef.current.getImageData(
          0,
          0,
          offScreenCanvasRef.current.width,
          offScreenCanvasRef.current.height
        )
      );
    }
    requestAnimationFrame(captureFrame);
  };

  useEffect(() => {
    chrome.runtime.onMessage.addListener(function (
      request,
      sender,
      sendResponse
    ) {
      if (request.type === ""switch-camera"") {
        if (request.id !== ""none"") {
          stopCameraStream();
          setTimeout(() => {
            getCameraStream({
              video: {
                deviceId: {
                  exact: request.id,
                },
              },
            });
          }, 2000);
        }
      } else if (request.type === ""background-effects-active"") {
        setBackgroundEffects(true);
      } else if (request.type === ""background-effects-inactive"") {
        setBackgroundEffects(false);
      } else if (request.type === ""camera-only-update"") {
        setWidth(""auto"");
        setHeight(""100%"");
        recordingTypeRef.current = ""camera"";
      } else if (request.type === ""screen-update"") {
        // Needs to fit 100% width and height but considering aspect ratio
        const video = videoRef.current;
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;

        if (videoWidth > videoHeight) {
          setWidth(""auto"");
          setHeight(""100%"");
        } else {
          setWidth(""100%"");
          setHeight(""auto"");
        }

        recordingTypeRef.current = ""screen"";
      } else if (request.type === ""toggle-pip"") {
        // If picture in picture is active, close it, otherwise open it
        if (document.pictureInPictureElement) {
          document.exitPictureInPicture();
        } else {
          try {
            videoRef.current.requestPictureInPicture().catch(() => {
              // Cancel pip mode if it fails
              setPipMode(false);
              chrome.runtime.sendMessage({ type: ""pip-ended"" });
            });
          } catch (error) {
            // Cancel pip mode if it fails
            setPipMode(false);
            chrome.runtime.sendMessage({ type: ""pip-ended"" });
          }
        }
      } else if (request.type === ""set-surface"") {
        if (request.surface === ""monitor"") {
          try {
            videoRef.current.requestPictureInPicture().catch(() => {
              // Cancel pip mode if it fails
              setPipMode(false);
              chrome.runtime.sendMessage({ type: ""pip-ended"" });
            });
          } catch (error) {
            // Cancel pip mode if it fails
            setPipMode(false);
            chrome.runtime.sendMessage({ type: ""pip-ended"" });
          }
        }
      } else if (request.type === ""camera-toggled-toolbar"") {
        if (request.active) {
          stopCameraStream();
          setTimeout(() => {
            getCameraStream({
              video: {
                deviceId: {
                  exact: request.id,
                },
              },
            });
          }, 2000);
          setPipMode(false);
        }
      }
    });
  }, []);

  // Check chrome local storage
  useEffect(() => {
    chrome.storage.local.get([""recordingType""], (result) => {
      if (result.recordingType === ""camera"") {
        recordingTypeRef.current = ""camera"";
      } else {
        recordingTypeRef.current = ""screen"";
      }
    });
  }, []);

  useEffect(() => {
    chrome.s"
Camera\index.html,Included,text/html,334,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title></title>
  </head>

  <body>
    <div id=""app-container""></div>
		<style>
			html, body, #app-container {
				width: 100%;
				height: 100%;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}
		</style>
  </body>
</html>
"
Camera\index.jsx,Included,application/octet-stream,260,"import React from ""react"";
import { render } from ""react-dom"";

import Camera from ""./Camera"";

// Render at the end of the body of any website
render(<Camera />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Camera\modules\Background.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,9744,"// first, import all you need
import React, { useRef, useEffect, useCallback, useState } from ""react"";

import * as bodySegmentation from ""@tensorflow-models/body-segmentation"";
import ""@tensorflow/tfjs-core"";
// Register WebGL backend.
//import ""@tensorflow/tfjs-backend-webgl"";
import ""@mediapipe/selfie_segmentation"";

const Background = (props) => {
  // Canvases
  const offScreenCanvasRef = useRef(null);
  const offScreenCanvasContextRef = useRef(null);
  const canvasRef = useRef(null);
  const canvasContextRef = useRef(null);
  const bottomCanvasRef = useRef(null);
  const bottomCanvasContextRef = useRef(null);

  const segmenterRef = useRef(null);

  // Variables to track frame rendering
  const latestImageDataRef = useRef(null);
  const frameRequestedRef = useRef(false);
  const blurRef = useRef(false);
  const effectRef = useRef(null);

  useEffect(() => {
    // Offscreen canvas
    offScreenCanvasRef.current = document.createElement(""canvas"");
    offScreenCanvasContextRef.current = offScreenCanvasRef.current.getContext(
      ""2d"",
      { willReadFrequently: true }
    );

    // Canvas
    canvasContextRef.current = canvasRef.current.getContext(""2d"", {
      willReadFrequently: true,
    });

    // Bottom canvas
    bottomCanvasContextRef.current = bottomCanvasRef.current.getContext(""2d"", {
      willReadFrequently: true,
    });
  }, []);

  // Track window size
  const [windowSize, setWindowSize] = useState({
    width: innerWidth,
    height: innerHeight,
  });

  // Check if window size has changed, if so re-render Effect canvas
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: innerWidth,
        height: innerHeight,
      });
    };

    window.addEventListener(""resize"", handleResize);

    return () => {
      window.removeEventListener(""resize"", handleResize);
    };
  }, []);

  useEffect(() => {
    chrome.storage.local.get([""backgroundEffect""], (result) => {
      if (result.backgroundEffect != ""blur"") {
        blurRef.current = false;
        loadEffect(result.backgroundEffect);
      } else {
        blurRef.current = true;
      }
    });
  }, []);

  useEffect(() => {
    // Event listener (extension messaging)
    chrome.runtime.onMessage.addListener(function (
      request,
      sender,
      sendResponse
    ) {
      if (request.type === ""set-background-effect"") {
        if (request.effect === ""blur"") {
          blurRef.current = true;
          effectRef.current = null;
        } else if (request.effect != """") {
          blurRef.current = false;
          loadEffect(request.effect);
        }
      }
    });
  }, []);

  useEffect(() => {
    if (blurRef.current) return;
    if (!effectRef.current) return;
    if (!bottomCanvasRef.current) return;

    renderEffectBackground();
  }, [windowSize]);

  const renderEffectBackground = () => {
    bottomCanvasRef.current.width = innerWidth;
    bottomCanvasRef.current.height = innerHeight;
    bottomCanvasContextRef.current.drawImage(
      effectRef.current,
      0,
      0,
      effectRef.current.width,
      effectRef.current.height,
      0,
      0,
      innerWidth,
      innerHeight
    );
  };

  const loadEffect = (effect) => {
    const img = new Image();
    img.src = effect;
    img.onload = () => {
      effectRef.current = img;
      renderEffectBackground();
    };
  };

  useEffect(() => {
    loadModel();
  }, []);

  const loadModel = async () => {
    const model = bodySegmentation.SupportedModels.MediaPipeSelfieSegmentation;
    const segmenterConfig = {
      runtime: ""mediapipe"",
      solutionPath: ""./assets/selfieSegmentation"",
      modelType: ""general"",
    };
    segmenterRef.current = await bodySegmentation.createSegmenter(
      model,
      segmenterConfig
    );
  };

  useEffect(() => {
    if (props.frame === null) return;

    latestImageDataRef.current = props.frame;
    requestFrameRender();
  }, [props.frame]);

  // Function to handle rendering updates using requestAnimationFrame
  const requestFrameRender = useCallback(() => {
    if (!frameRequestedRef.current) {
      frameRequestedRef.current = true;
      requestAnimationFrame(() => {
        frameRequestedRef.current = false;
        renderFrame();
      });
    }
  }, [frameRequestedRef.current]);

  // Function to handle frame rendering
  const renderFrame = async () => {
    try {
      if (!latestImageDataRef.current) return; // No new frame to render
      if (!segmenterRef.current) return; // Model not loaded yet

      segmentPerson(latestImageDataRef.current);
    } catch (error) {
      console.error(error);
    }
  };

  const segmentPerson = async (img) => {
    try {
      if (!blurRef.current && !effectRef.current) return;
      if (!latestImageDataRef.current) return;
      if (!segmenterRef.current) return; // Model not loaded yet

      const people = await segmenterRef.current.segmentPeople(img);
      if (people.length === 0) return; // No people in the frame

      const width = people[0].mask.mask.width;
      const height = people[0].mask.mask.height;

      if (blurRef.current) {
        renderBlur(img, people);
      } else {
        renderEffect(img, people, width, height);
      }
    } catch (error) {
      console.error(error);
    }
  };

  const renderBlur = async (img, people) => {
    try {
      const backgroundBlurAmount = 16;
      const edgeBlurAmount = 10;
      const flipHorizontal = false;
      const foregroundThresholdProbability = 0.6;

      const ratio = img.width / img.height;
      canvasRef.current.width = innerHeight * ratio;
      canvasRef.current.height = innerHeight;
      await bodySegmentation.drawBokehEffect(
        canvasRef.current,
        img,
        people,
        foregroundThresholdProbability,
        backgroundBlurAmount,
        edgeBlurAmount,
        flipHorizontal
      );

      // Prevent redundant rendering
      latestImageDataRef.current = null;
    } catch (error) {
      console.error(error);
  "
Content\camera\Camera.jsx,Included,application/octet-stream,509,"import React, { useContext } from ""react"";

import CameraWrap from ""./layout/CameraWrap"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const Camera = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <div className=""camera-page"">
      {contentState.defaultVideoInput != ""none"" &&
        contentState.cameraActive && <CameraWrap shadowRef={props.shadowRef} />}
    </div>
  );
};

export default Camera;
"
Content\camera\components\ResizeHandle.jsx,Included,application/octet-stream,271,"import React from ""react"";

import { CameraResizeIcon } from ""../../toolbar/components/SVG"";

const ResizeHandle = ({ position }) => {
  return (
    <div className=""camera-resize"">
      <CameraResizeIcon />
    </div>
  );
};

export default ResizeHandle;
"
Content\camera\layout\CameraToolbar.jsx,Included,application/octet-stream,1428,"import React, { useState, useEffect, useContext } from ""react"";

import * as Toolbar from ""@radix-ui/react-toolbar"";
// Tooltip
import TooltipWrap from ""../../toolbar/components/TooltipWrap"";

import { CameraCloseIcon, Pip } from ""../../toolbar/components/SVG"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const CameraToolbar = () => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <Toolbar.Root className=""camera-toolbar"">
      <Toolbar.Button
        className=""CameraToolbarButton""
        onClick={() => {
          setContentState((prevContentState) => ({
            ...prevContentState,
            cameraActive: false,
          }));
          chrome.storage.local.set({ cameraActive: false });
        }}
      >
        <CameraCloseIcon />
      </Toolbar.Button>
      {contentState.recording && contentState.surface === ""monitor"" && (
        <TooltipWrap
          content={chrome.i18n.getMessage(""togglePictureinPictureModeTooltip"")}
        >
          <Toolbar.Button
            className=""CameraToolbarButton CameraMore""
            onClick={() => {
              chrome.runtime.sendMessage({ type: ""toggle-pip"" });
            }}
          >
            <Pip />
          </Toolbar.Button>
        </TooltipWrap>
      )}
    </Toolbar.Root>
  );
};

export default CameraToolbar;
"
Content\camera\layout\CameraWrap.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,6408,"import React, {
  useEffect,
  useContext,
  useRef,
  useState,
  useLayoutEffect,
} from ""react"";

import { Rnd } from ""react-rnd"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

import CameraToolbar from ""./CameraToolbar"";
import ResizeHandle from ""../components/ResizeHandle"";

const CameraWrap = (props) => {
  const [contentState, setContentState] = React.useContext(contentStateContext);
  const cameraRef = React.useRef();
  const [cx, setCx] = useState(200);
  const [cy, setCy] = useState(200);
  const [w, setW] = useState(200);
  const [h, setH] = useState(200);

  const updateUIPosition = () => {
    const ref =
      props.shadowRef.current.shadowRoot.querySelector("".camera-draggable"");
    const circleCenterX =
      ref.getBoundingClientRect().left + ref.getBoundingClientRect().width / 2;
    const circleCenterY =
      ref.getBoundingClientRect().top + ref.getBoundingClientRect().height / 2;
    const circleRadius = ref.getBoundingClientRect().width / 2;
    const squareBottomRightX =
      ref.getBoundingClientRect().left + ref.getBoundingClientRect().width;
    const squareBottomRightY =
      ref.getBoundingClientRect().top + ref.getBoundingClientRect().height;
    const handle =
      props.shadowRef.current.shadowRoot.querySelector("".camera-resize"");
    const toolbar =
      props.shadowRef.current.shadowRoot.querySelector("".camera-toolbar"");

    // Calculate 'r' using the formula we derived earlier
    const c = Math.sqrt(
      Math.pow(circleCenterX - squareBottomRightX, 2) +
        Math.pow(circleCenterY - squareBottomRightY, 2)
    );
    const a = circleRadius / Math.sqrt(2);
    const r = (c + Math.sqrt(c ** 2 + 16 * a ** 2)) / 4;

    // Calculate the handle position
    const x = r - r / Math.sqrt(2);
    const y = r - r / Math.sqrt(2);

    // Position the handle element to the calculated coordinates
    handle.style.bottom = `${y - handle.getBoundingClientRect().width / 2}px`;
    handle.style.right = `${x - handle.getBoundingClientRect().height / 2}px`;
    toolbar.style.top = `${y - toolbar.getBoundingClientRect().width / 2}px`;
    toolbar.style.left = `${x - toolbar.getBoundingClientRect().height / 2}px`;
  };

  const saveDimensions = () => {
    const ref =
      props.shadowRef.current.shadowRoot.querySelector("".camera-draggable"");

    setContentState((prevContentState) => ({
      ...prevContentState,
      cameraDimensions: {
        size: ref.getBoundingClientRect().width,
        x: ref.getBoundingClientRect().x,
        y: ref.getBoundingClientRect().y,
      },
    }));
    chrome.storage.local.set({
      cameraDimensions: {
        size: ref.getBoundingClientRect().width,
        x: ref.getBoundingClientRect().x,
        y: ref.getBoundingClientRect().y,
      },
    });
  };

  useEffect(() => {
    if (!cameraRef.current) return;
    if (!props.shadowRef.current.shadowRoot.querySelector("".camera-resize""))
      return;
    if (!props.shadowRef.current.shadowRoot.querySelector("".camera-toolbar""))
      return;

    updateUIPosition();
  }, [cameraRef.current]);

  // I need to make sure the camera is never offscreen (if the user resizes the window)
  useLayoutEffect(() => {
    const updateCameraPosition = () => {
      if (
        !props.shadowRef.current.shadowRoot.querySelector("".camera-draggable"")
      )
        return;
      const ref =
        props.shadowRef.current.shadowRoot.querySelector("".camera-draggable"");
      let xpos = cameraRef.current.getDraggablePosition().x;
      let ypos = cameraRef.current.getDraggablePosition().y;

      // Width and height of camera
      const width = ref.getBoundingClientRect().width;
      const height = ref.getBoundingClientRect().height;

      const { innerWidth, innerHeight } = window;

      // Keep camera positioned relative to the bottom and right of the screen, proportionally
      if (xpos + width > innerWidth) {
        xpos = innerWidth - width;
      }
      if (ypos + height > innerHeight) {
        ypos = innerHeight - height;
      }

      cameraRef.current.updatePosition({ x: xpos, y: ypos });

      saveDimensions();
    };

    updateCameraPosition();

    window.addEventListener(""resize"", updateCameraPosition);

    return () => {
      window.removeEventListener(""resize"", updateCameraPosition);
    };
  }, []);

  return (
    <div
      style={{
        visibility:
          (contentState.pendingRecording || contentState.recording) &&
          contentState.surface === ""monitor"" &&
          !contentState.pipEnded
            ? ""hidden""
            : ""visible"",
      }}
    >
      <Rnd
        default={{
          x: contentState.cameraDimensions.x,
          y: contentState.cameraDimensions.y,
          width: contentState.cameraDimensions.size,
          height: contentState.cameraDimensions.size,
        }}
        ref={cameraRef}
        className=""camera-draggable""
        dragHandleClassName=""camera-grab""
        resizeHandleComponent={{
          bottomRight: <ResizeHandle />,
        }}
        minHeight={150}
        minWidth={150}
        enableResizing={{
          bottom: false,
          bottomRight: true,
          bottomLeft: false,
          left: false,
          right: false,
          top: false,
          topRight: false,
          topLeft: false,
        }}
        onResize={(e, direction, ref, delta, position) => {
          updateUIPosition();
        }}
        onResizeStop={(e, direction, ref, delta, position) => {
          saveDimensions();
        }}
        onDragStop={(node, x, y) => {
          saveDimensions();
        }}
        lockAspectRatio={1}
        bounds={""window""}
      >
        <div className=""camera-grab""></div>
        <CameraToolbar />
        <iframe
          style={{
            width: ""100%"",
            height: ""100%"",
            borderRadius: ""50%"",
            outline: ""none"",
            border: ""none"",
            pointerEvents: ""none"",
          }}
          className={contentState."
Content\camera\styles\components\_ResizeHandle.scss,Excluded by file type,,0,
Content\camera\styles\layout\_CameraToolbar.scss,Excluded by file type,,0,
Content\camera\styles\layout\_CameraWrap.scss,Excluded by file type,,0,
Content\camera\styles\_Camera.scss,Excluded by file type,,0,
Content\camera-only\CameraOnly.jsx,Included,application/octet-stream,593,"import React, { useContext } from ""react"";

import CameraWrap from ""./layout/CameraWrap"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const CameraOnly = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <div className=""camera-page"">
      {contentState.defaultVideoInput != ""none"" &&
        contentState.cameraActive &&
        contentState.recordingType === ""camera"" && (
          <CameraWrap shadowRef={props.shadowRef} />
        )}
    </div>
  );
};

export default CameraOnly;
"
Content\camera-only\layout\CameraWrap.jsx,Included,application/octet-stream,850,"import React, { useEffect, useContext, useRef, useState } from ""react"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const CameraWrap = (props) => {
  const [contentState, setContentState] = React.useContext(contentStateContext);

  return (
    <div>
      <iframe
        style={{
          width: ""80vw"",
          outline: ""none"",
          border: ""none"",
          pointerEvents: ""none"",
          zIndex: 0,
          position: ""absolute"",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          margin: ""auto"",
        }}
        className={contentState.cameraFlipped ? ""camera-flipped"" : """"}
        src={chrome.runtime.getURL(""camera.html"")}
        allow=""camera; microphone""
      ></iframe>
    </div>
  );
};

export default CameraWrap;
"
Content\camera-only\styles\_CameraOnly.scss,Excluded by file type,,0,
Content\canvas\Canvas.jsx,Included,application/octet-stream,236,"import React, { useContext } from ""react"";

import CanvasWrap from ""./layout/CanvasWrap"";

const Canvas = () => {
  return (
    <div className=""canvas-page"">
      <CanvasWrap />
    </div>
  );
};

export default Canvas;
"
Content\canvas\layout\CanvasWrap.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,7315,"import React, { useEffect, useRef, useContext } from ""react"";
import { fabric } from ""fabric"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

// Components
import TextToolbar from ""./TextToolbar"";

// Canvas setup
import CustomControls from ""../modules/CustomControls"";

// Canvas tools
import ArrowTool from ""../modules/ArrowTool"";
import EraserTool from ""../modules/EraserTool"";
import ShapeTool from ""../modules/ShapeTool"";
import TextTool from ""../modules/TextTool"";
import PenTool from ""../modules/PenTool"";
import SelectTool from ""../modules/SelectTool"";

// Canvas utils
import {
  undoCanvas,
  redoCanvas,
  saveCanvas,
  checkChanges,
} from ""../modules/History"";

const CanvasWrap = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const contentStateRef = useRef(null);
  const canvasContainer = useRef();
  const canvasRef = useRef();
  const fabricRef = useRef();

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  // INIT
  useEffect(() => {
    if (!canvasRef.current) return;
    if (fabricRef.current) return;

    const canvas = new fabric.Canvas(""canvas-screenity"", {
      perPixelTargetFind: true,
    });
    fabricRef.current = canvas;

    // Get context
    canvas.getContext(""2d"", { willReadFrequently: true });

    // Set width and height of canvas to full size of document
    canvas.setWidth(window.document.body.offsetWidth);

    // set max height of 2000px
    //canvas.setHeight(Math.min(window.document.body.offsetHeight, 2500));
    // set height to viewport
    canvas.setHeight(window.innerHeight);

    canvas.renderAll();

    setContentState((prevContentState) => ({
      ...prevContentState,
      canvas: canvas,
    }));

    CustomControls(canvas);
    saveCanvas(
      {
        ...contentState,
        canvas: canvas,
      },
      setContentState
    );
  }, []);

  // Update canvas dimensions + panning on window resize
  useEffect(() => {
    if (!fabricRef.current) return;

    const resizeCanvas = () => {
      fabricRef.current.setWidth(window.document.body.offsetWidth);
      fabricRef.current.setHeight(window.innerHeight);
      fabricRef.current.renderAll();
    };

    window.addEventListener(""resize"", resizeCanvas);

    return () => {
      window.removeEventListener(""resize"", resizeCanvas);
    };
  }, []);

  const panXRef = useRef(window.scrollX);
  const panYRef = useRef(window.scrollY);

  useEffect(() => {
    if (!fabricRef.current) return;

    panXRef.current = window.scrollX;
    panYRef.current = window.scrollY;

    // Function to update canvas panning
    const updateCanvasPan = () => {
      fabricRef.current.setZoom(fabricRef.current.getZoom());
      fabricRef.current.absolutePan({
        x: panXRef.current,
        y: panYRef.current,
      });
    };

    // Event listener for window scroll
    const handleScroll = () => {
      // Update canvas pan position based on scroll position
      panXRef.current = window.scrollX;
      panYRef.current = window.scrollY;
      updateCanvasPan();
    };

    updateCanvasPan();

    // Attach scroll event listener
    window.addEventListener(""scroll"", handleScroll, { passive: true });

    // Cleanup function
    return () => {
      // Remove scroll event listener
      window.removeEventListener(""scroll"", handleScroll);

      // Reset canvas pan position
      panXRef.current = 0;
      panYRef.current = 0;
    };
  }, []);

  useEffect(() => {
    if (!fabricRef.current) return;

    const eraserDrawing = EraserTool(
      fabricRef.current,
      contentState,
      setContentState
    );

    const arrowDrawing = ArrowTool(
      fabricRef.current,
      contentState,
      setContentState,
      saveCanvas
    );

    const shapeDrawing = ShapeTool(
      fabricRef.current,
      contentState,
      setContentState,
      saveCanvas
    );
    const textDrawing = TextTool(
      fabricRef.current,
      contentState,
      setContentState,
      saveCanvas
    );
    const penDrawing = PenTool(
      fabricRef.current,
      contentState,
      setContentState,
      saveCanvas
    );

    return () => {
      arrowDrawing.removeEventListeners();
      eraserDrawing.removeEventListeners();
      shapeDrawing.removeEventListeners();
      textDrawing.removeEventListeners();
      penDrawing.removeEventListeners();
    };
  }, [contentState]);

  useEffect(() => {
    const selection = SelectTool(
      fabricRef.current,
      contentState,
      setContentState
    );
    const objectChanges = checkChanges(
      fabricRef.current,
      contentState,
      setContentState
    );

    return () => {
      selection.removeEventListeners();
      objectChanges.removeEventListeners();
    };
  }, [fabricRef, contentState]);

  useEffect(() => {
    // Prevent selecting elements unless in select mode
    if (!fabricRef.current) return;
    if (contentState.tool !== ""select"") {
      // De-select all objects on canvas
      fabricRef.current.discardActiveObject();

      fabricRef.current.selection = false;
      fabricRef.current.forEachObject((obj) => {
        obj.selectable = false;
      });
      fabricRef.current.renderAll();
    } else {
      fabricRef.current.selection = true;
      fabricRef.current.forEachObject((obj) => {
        obj.selectable = true;
      });
      fabricRef.current.renderAll();
    }
  }, [contentState.tool]);

  // handle what happens on key press
  const handleKeyPress = (event) => {
    if ((event.ctrlKey || event.metaKey) && event.key === ""z"")
      undoCanvas(contentState, setContentState);
    if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === ""z"")
      redoCanvas(contentState, setContentState);
  };

  useEffect(() => {
    if (!fabricRef.current) return;
    // attach the event listener
    document.addEventListener(""keydown"", handleKeyPress);

    // remove the event listener
    return () => {
      document.removeEventLis"
Content\canvas\layout\TextToolbar.jsx,Included,application/octet-stream,2862,"import React, { useRef, useContext, useEffect, useState } from ""react"";

import * as Toolbar from ""@radix-ui/react-toolbar"";
import * as Select from ""@radix-ui/react-select"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const TextToolbar = (props) => {
  const toolbarRef = useRef(null);
  const [contentState, setContentState] = useContext(contentStateContext);
  const [left, setLeft] = useState(0);
  const [top, setTop] = useState(0);

  useEffect(() => {
    if (!contentState.canvas) return;

    const canvas = contentState.canvas;
    const toolbar = toolbarRef.current;

    function positionToolbarOnTextbox(textbox) {
      // place the toolbar on top of the textbox, centered, with a vertical offset
      const textCoords = textbox.getBoundingRect();
      const textOffset = textCoords.left;
      const textWidth = textCoords.width;
      const textHeight = textCoords.height;
      const textTop = textCoords.top;
      const textLeft = textCoords.left;
      const textCenter = textLeft + textWidth / 2;
      const textCenterOffset = textCenter;
      const toolbarWidth = toolbar.clientWidth;
      const toolbarHeight = toolbar.clientHeight;
      const toolbarLeft = textCenterOffset - toolbarWidth / 2;
      const toolbarTop = textTop - toolbarHeight - 10;
      setLeft(toolbarLeft);
      setTop(toolbarTop);
    }

    function hideToolbar() {
      toolbar.style.display = ""none"";
    }

    canvas.on(""selection:created"", function (e) {
      const selectedObject = canvas.getActiveObject();
      if (selectedObject === null || selectedObject === undefined) return;

      if (selectedObject.type === ""textbox"") {
        positionToolbarOnTextbox(selectedObject);
      }
    });

    canvas.on(""selection:cleared"", function () {
      hideToolbar();
    });

    canvas.on(""object:moving"", function (e) {
      const movedObject = e.target;

      if (
        movedObject.type === ""textbox"" &&
        canvas.getActiveObject() === movedObject
      ) {
        positionToolbarOnTextbox(movedObject);
      }
    });

    canvas.on(""object:scaling"", function (e) {
      const resizedObject = e.target;

      if (
        resizedObject.type === ""textbox"" &&
        canvas.getActiveObject() === resizedObject
      ) {
        positionToolbarOnTextbox(resizedObject);
      }
    });
  }, [contentState.canvas]);

  return (
    <div
      className=""text-toolbar""
      ref={toolbarRef}
      style={{
        left: left + ""px"",
        top: top + ""px"",
        position: ""absolute"",
        backgroundColor: ""black"",
        borderRadius: ""10px"",
        padding: ""10px"",
        color: ""white"",
        display: ""block"",
      }}
    >
      oioi
    </div>
  );
};

export default TextToolbar;
"
Content\canvas\modules\ArrowTool.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,11381,"import { fabric } from ""fabric"";

const createArrowLine = (x, y, color, toolSettings) => {
  return new fabric.Line([x, y, x, y], {
    strokeWidth: toolSettings.strokeWidth * 6,
    stroke: color,
    originX: ""center"",
    originY: ""center"",
    selectable: false,
    evented: false,
    id: ""arrowLine"",
  });
};

const createArrowHead = (x, y, color, toolSettings) => {
  return new fabric.Triangle({
    width: toolSettings.strokeWidth * 16,
    height: toolSettings.strokeWidth * 16,
    left: x,
    top: y,
    fill: color,
    originX: ""center"",
    originY: ""center"",
    selectable: false,
    evented: false,
    id: ""arrowHead"",
  });
};

const createArrowCircle = (x, y, id) => {
  return new fabric.Circle({
    radius: 5,
    fill: ""white"",
    stroke: ""#0D99FF"",
    strokeWidth: 2,
    left: x,
    top: y,
    selectable: false,
    evented: true,
    id: id,
    opacity: 0,
  });
};

const createArrowLineControl = (x, y) => {
  return new fabric.Line([x, y, x, y], {
    strokeWidth: 2,
    stroke: ""#0D99FF"",
    originX: ""center"",
    originY: ""center"",
    selectable: false,
    evented: false,
    id: ""arrowLineControl"",
    opacity: 0,
  });
};

const moveArrowCircle = (
  canvas,
  arrowCircle,
  saveCanvas,
  toolSettings,
  setToolSettings
) => {
  let isDown = true;
  const group = arrowCircle.group;
  const items = group._objects;

  const arrowCircle1 = group._objects.find(
    (item) => item.id === ""arrowCircle1""
  );
  const arrowCircle2 = group._objects.find(
    (item) => item.id === ""arrowCircle2""
  );
  const arrowLine = group._objects.find((item) => item.id === ""arrowLine"");
  const arrowHead = group._objects.find((item) => item.id === ""arrowHead"");
  const arrowLineControl = group._objects.find(
    (item) => item.id === ""arrowLineControl""
  );
  arrowLineControl.set({ opacity: 0 });
  group._restoreObjectsState();

  canvas.remove(group);
  items.forEach((item) => {
    canvas.add(item);
  });
  canvas.renderAll();

  canvas.on(""mouse:move"", (o) => {
    if (!isDown) return;

    const pointer = canvas.getPointer(o.e);
    const { x, y } = pointer;
    arrowCircle.set({ left: x - 5, top: y - 5 });
    canvas.renderAll();

    arrowLine.set({
      x1: arrowCircle1.left + 5,
      y1: arrowCircle1.top + 5,
      x2: arrowCircle2.left + 5,
      y2: arrowCircle2.top + 5,
    });

    arrowLineControl.set({
      x1: arrowCircle1.left + 5,
      y1: arrowCircle1.top + 5,
      x2: arrowCircle2.left + 5,
      y2: arrowCircle2.top + 5,
    });

    const xDiff = arrowLine.x2 - arrowLine.x1;
    const yDiff = arrowLine.y2 - arrowLine.y1;
    const angle = (Math.atan2(yDiff, xDiff) * 180) / Math.PI;
    arrowHead.set({ angle: angle + 90, left: arrowLine.x2, top: arrowLine.y2 });
  });

  canvas.on(""mouse:up"", (o) => {
    if (!isDown) return;
    isDown = false;
    canvas.off(""mouse:move"");
    arrowLineControl.set({ opacity: 1 });
    const group = new fabric.Group(
      [arrowLine, arrowHead, arrowLineControl, arrowCircle1, arrowCircle2],
      {
        selectable: true,
        evented: true,
        id: ""arrowGroup"",
        hasControls: false,
        hasBorders: false,
        hasRotatingPoint: false,
        subTargetCheck: true,
        originX: ""left"",
        originY: ""top"",
        perPixelTargetFind: true,
      }
    );

    canvas.add(group);
    canvas.remove(arrowLine);
    canvas.remove(arrowHead);
    canvas.remove(arrowCircle1);
    canvas.remove(arrowCircle2);
    canvas.remove(arrowLineControl);
    canvas.renderAll();
    canvas.setActiveObject(group);
    canvas.renderAll();

    // De-select arrow group
    canvas.discardActiveObject();
    canvas.renderAll();
    saveCanvas({ ...toolSettings, tool: ""select"" }, setToolSettings);

    // Re-select
    canvas.setActiveObject(group);
    canvas.renderAll();
  });
};

const ArrowTool = (canvas, toolSettings, setToolSettings, saveCanvas) => {
  let arrowPoints = [];
  let arrowLine = null;
  let arrowHead = null;
  let arrowCircle1 = null;
  let arrowCircle2 = null;
  let arrowLineControl = null;

  const onMouseDown = (o) => {
    if (toolSettings.tool !== ""arrow"") return;
    if (arrowPoints.length) return;

    // Disable canvas selection
    canvas.selection = false;
    canvas.renderAll();

    const pointer = canvas.getPointer(o.e);
    const x = pointer.x;
    const y = pointer.y;

    arrowPoints.push({ x: x, y: y });

    arrowLine = createArrowLine(x, y, toolSettings.color, toolSettings);
    arrowHead = createArrowHead(x, y, toolSettings.color, toolSettings);
    arrowCircle1 = createArrowCircle(x, y, ""arrowCircle1"");
    arrowCircle2 = createArrowCircle(x, y, ""arrowCircle2"");
    arrowLineControl = createArrowLineControl(x, y, ""arrowLineControl"");

    canvas.add(arrowLine);
    canvas.add(arrowHead);
    canvas.add(arrowLineControl);
    canvas.add(arrowCircle1);
    canvas.add(arrowCircle2);
  };

  const onMouseMove = (o) => {
    if (toolSettings.tool !== ""arrow"") return;
    if (!arrowPoints.length) return;
    if (
      !arrowLine ||
      !arrowHead ||
      !arrowCircle1 ||
      !arrowCircle2 ||
      !arrowLineControl
    )
      return;

    const pointer = canvas.getPointer(o.e);
    const x = pointer.x;
    const y = pointer.y;

    arrowLine.set({ x2: x, y2: y });
    arrowLineControl.set({ x2: x, y2: y });

    arrowHead.set({ left: x, top: y });

    const xDiff = arrowLine.x2 - arrowLine.x1;
    const yDiff = arrowLine.y2 - arrowLine.y1;
    const angle = (Math.atan2(yDiff, xDiff) * 180) / Math.PI;
    arrowHead.set({ angle: angle + 90 });

    // Position circle with offset to arrow head
    const xDiff2 = Math.cos(angle * (Math.PI / 180));
    const yDiff2 = Math.sin(angle * (Math.PI / 180));
    arrowCircle1.set({ left: arrowLine.x1 - 5, top: arrowLine.y1 - 5 });
    arrowCircle2.set({
      left: arrowLine.x2 + xDiff2 - 5,
      top: arrowLine.y2 + yDiff2 - 5,
    });

    canvas.renderAll();
  };

  const onMouseUp = (o) => {
    if (toolSettings.tool !== ""arro"
Content\canvas\modules\CustomControls.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,12915,"import React from ""react"";
import { fabric } from ""fabric"";

import {
  HandleControl,
  RotateControl,
  MiddleHandleControl,
  MiddleHandleControlV,
} from ""./../../images/popup/images.js"";

// Custom controls for the canvas, with rounded square handles and a circular rotate handle
const CustomControls = (canvas) => {
  fabric.Object.prototype.set({
    transparentCorners: false,
    borderColor: ""#0D99FF"",
    cornerColor: ""#FFF"",
    borderScaleFactor: 2,
    cornerStyle: ""circle"",
    cornerStrokeColor: ""#0D99FF"",
    borderOpacityWhenMoving: 1,
  });

  fabric.Textbox.prototype.set({
    transparentCorners: false,
    borderColor: ""#0D99FF"",
    cornerColor: ""#FFF"",
    borderScaleFactor: 2,
    cornerStyle: ""circle"",
    cornerStrokeColor: ""#0D99FF"",
    borderOpacityWhenMoving: 1,
  });

  canvas.selectionColor = ""rgba(46, 115, 252, 0.11)"";
  canvas.selectionBorderColor = ""rgba(98, 155, 255, 0.81)"";
  canvas.selectionLineWidth = 1.5;

  // Handle control
  var img = new Image();
  img.src = HandleControl;

  function renderIcon(ctx, left, top, styleOverride, fabricObject) {
    const size = 25;
    ctx.save();
    ctx.translate(left, top);
    ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
    ctx.drawImage(img, -size / 2, -size / 2, size, size);
    ctx.restore();
  }

  // Rotate control
  var img2 = new Image();
  img2.src = RotateControl;

  function renderIconRotate(ctx, left, top, styleOverride, fabricObject) {
    const wsize = 30;
    const hsize = 30;
    ctx.save();
    ctx.translate(left, top);
    ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
    ctx.drawImage(img2, -wsize / 2, -hsize / 2, wsize, hsize);
    ctx.restore();
  }

  // Middle handle control
  var img3 = new Image();
  img3.src = MiddleHandleControl;

  function renderIconMiddle(ctx, left, top, styleOverride, fabricObject) {
    const size = 18;
    ctx.save();
    ctx.translate(left, top);
    ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
    ctx.drawImage(img3, -(size + 14) / 2, -size / 2, size + 14, size);
    ctx.restore();
  }

  // Middle handle control vertical
  var img4 = new Image();
  img4.src = MiddleHandleControlV;

  function renderIconMiddleV(ctx, left, top, styleOverride, fabricObject) {
    const size = 18;
    ctx.save();
    ctx.translate(left, top);
    ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
    ctx.drawImage(img4, -size / 2, -(size + 14) / 2, size, size + 14);
    ctx.restore();
  }

  fabric.Object.prototype.controls.tl = new fabric.Control({
    x: -0.5,
    y: -0.5,
    offsetX: -1,
    offsetY: -1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Object.prototype.controls.tr = new fabric.Control({
    x: 0.5,
    y: -0.5,
    offsetX: 1,
    offsetY: -1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Object.prototype.controls.bl = new fabric.Control({
    x: -0.5,
    y: 0.5,
    offsetX: -1,
    offsetY: 1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Object.prototype.controls.br = new fabric.Control({
    x: 0.5,
    y: 0.5,
    offsetX: 1,
    offsetY: 1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Object.prototype.controls.mr = new fabric.Control({
    x: 0.5,
    y: 0,
    offsetX: 1,
    offsetY: 0,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingXOrSkewingY,
    render: renderIconMiddleV,
  });

  fabric.Object.prototype.controls.ml = new fabric.Control({
    x: -0.5,
    y: 0,
    offsetX: -1,
    offsetY: 0,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingXOrSkewingY,
    render: renderIconMiddleV,
  });

  fabric.Object.prototype.controls.mb = new fabric.Control({
    x: 0,
    y: 0.5,
    offsetX: 0,
    offsetY: 1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingYOrSkewingX,
    render: renderIconMiddle,
  });

  fabric.Object.prototype.controls.mt = new fabric.Control({
    x: 0,
    y: -0.5,
    offsetX: 0,
    offsetY: -1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingYOrSkewingX,
    render: renderIconMiddle,
  });

  fabric.Object.prototype.controls.mtr = new fabric.Control({
    x: 0,
    y: 0.5,
    cursorStyleHandler: fabric.controlsUtils.rotationStyleHandler,
    actionHandler: fabric.controlsUtils.rotationWithSnapping,
    offsetY: 26,
    withConnecton: false,
    actionName: ""rotate"",
    render: renderIconRotate,
  });

  // Also use same controls for Textbox
  fabric.Textbox.prototype.controls.tl = new fabric.Control({
    x: -0.5,
    y: -0.5,
    offsetX: -1,
    offsetY: -1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Textbox.prototype.controls.tr = new fabric.Control({
    x: 0.5,
    y: -0.5,
    offsetX: 1,
    offsetY: -1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Textbox.prototype.controls.bl = new fabric.Control({
    x: -0.5,
    y: 0.5,
    offsetX: -1,
    offsetY: 1,
    cursorStyleHandler: fabric.controlsUtils.scaleCursorStyleHandler,
    actionHandler: fabric.controlsUtils.scalingEqually,
    render: renderIcon,
  });

  fabric.Textbox.prototype.controls.br = new fabric.Control({
    x: 0"
Content\canvas\modules\EraserTool.jsx,Included,application/octet-stream,3878,"import React from ""react"";

import { fabric } from ""fabric"";
import { saveCanvas } from ""./History"";

const EraserTool = (canvas, toolSettings, setToolSettings) => {
  const tool = toolSettings;

  const removeEventListeners = () => {
    canvas.off(""mouse:down"");
    canvas.off(""mouse:move"");
    canvas.off(""mouse:up"");
    document.removeEventListener(""keydown"", onKeyDown);
  };

  // Eraser that deletes objects as the cursor moves (and while it is clicked, dragging) over them
  // Store objecs in an array, then delete them on mouse up
  let objectsToDelete = [];
  let isDown = false;

  if (tool.tool === ""eraser"") {
    // Make all objects unselectable. If a group, only set the group to unselectable, not the objects inside
    canvas.forEachObject((object) => {
      object.set({ selectable: false, perPixelTargetFind: true });
    });

    canvas.renderAll();
  }

  // Mouse down
  const onMouseDown = (o) => {
    if (tool.tool !== ""eraser"") return;
    objectsToDelete = [];

    isDown = true;

    if (!o.target) return;

    // Make all objects unselectable. If a group, only set the group to unselectable, not the objects inside
    canvas.forEachObject((object) => {
      object.set({ selectable: false, perPixelTargetFind: true });
    });

    // Add object to array, and set its opacity to .5
    objectsToDelete.push(o.target);
    o.target.set({ opacity: 0.5 });

    canvas.renderAll();
  };

  // Mouse move
  const onMouseMove = (o) => {
    if (tool.tool !== ""eraser"") return;

    // Make all objects unselectable. If a group, only set the group to unselectable, not the objects inside
    canvas.forEachObject((object) => {
      object.set({ selectable: false, perPixelTargetFind: true });
    });

    if (!isDown) return;
    if (!o.target) return;

    // Add object to array, and set its opacity to .5
    objectsToDelete.push(o.target);
    o.target.set({ opacity: 0.5 });

    canvas.renderAll();
  };

  // Mouse up
  const onMouseUp = (o) => {
    if (tool.tool !== ""eraser"") return;
    // Delete all objects in the array. Make sure to delete groups
    objectsToDelete.forEach((object) => {
      if (object.type === ""group"") {
        // If object is a group, delete it and all objects inside
        object.forEachObject((object) => {
          canvas.remove(object);
        });
        canvas.remove(object);
      } else {
        canvas.remove(object);
      }
    });

    canvas.renderAll();

    objectsToDelete = [];
    isDown = false;

    // Make all objects on the canvas selectable
    canvas.forEachObject((object) => {
      object.set({ selectable: true, perPixelTargetFind: false });
    });

    saveCanvas(toolSettings, setToolSettings);
  };

  // Detect pressing the delete or backspace key
  const onKeyDown = (e) => {
    if (e.keyCode === 8 || e.keyCode === 46) {
      // if multiple objects are selected
      const activeGroup = canvas.getActiveObjects();
      const activeObject = canvas.getActiveObject();

      if (activeGroup & !activeObject) {
        if (activeGroup.isEditing) return;
        canvas.discardActiveObject();
        activeGroup.forEach((object) => {
          canvas.remove(object);
        });
        saveCanvas(toolSettings, setToolSettings);
      }

      if (activeObject) {
        // Check if not in text editing mode
        if (activeObject.isEditing) return;
        canvas.remove(activeObject);
        saveCanvas(toolSettings, setToolSettings);
      }
    }
  };

  // Add event listeners
  document.addEventListener(""keydown"", onKeyDown);
  canvas.on(""mouse:down"", onMouseDown);
  canvas.on(""mouse:move"", onMouseMove);
  canvas.on(""mouse:up"", onMouseUp);

  return {
    removeEventListeners,
  };
};

export default EraserTool;
"
Content\canvas\modules\History.jsx,Included,application/octet-stream,2525,"import { fabric } from ""fabric"";

// Undo and redo functionality for Fabric.js
const undoCanvas = (toolSettings, setToolSettings) => {
  if (!toolSettings.canvas) return;
  const canvas = toolSettings.canvas;
  if (toolSettings.undoStack.length > 0) {
    const undoStack = [...toolSettings.undoStack];
    const redoStack = [...toolSettings.redoStack];
    const lastItem = undoStack.pop();
    redoStack.push(lastItem);
    // penultimate item is the last item before the last item
    const penultimateItem = undoStack[undoStack.length - 1];
    canvas.clear();
    canvas.renderAll();
    canvas.loadFromJSON(penultimateItem, () => {
      // De-select everything
      canvas.discardActiveObject();
      canvas.renderAll();
    });
    setToolSettings({
      ...toolSettings,
      undoStack,
      redoStack,
    });
  }
};

const redoCanvas = (toolSettings, setToolSettings) => {
  if (!toolSettings.canvas) return;
  const canvas = toolSettings.canvas;
  if (toolSettings.redoStack.length > 0) {
    const undoStack = [...toolSettings.undoStack];
    const redoStack = [...toolSettings.redoStack];
    const lastItem = redoStack.pop();
    undoStack.push(lastItem);
    canvas.loadFromJSON(lastItem, () => {
      // De-select everything
      canvas.discardActiveObject();
      canvas.renderAll();
    });
    setToolSettings({
      ...toolSettings,
      undoStack,
      redoStack,
    });
  }
};

const saveCanvas = (toolSettings, setToolSettings) => {
  if (!toolSettings.canvas) return;
  const canvas = toolSettings.canvas;

  let json = canvas.toJSON([
    ""id"",
    ""selectable"",
    ""evented"",
    ""hasControls"",
    ""hasBorders"",
    ""hasRotatingPoint"",
    ""subTargetCheck"",
    ""originX"",
    ""originY"",
    ""perPixelTargetFind"",
    ""skipAutoWidthAdjustment"",
  ]);

  const jsonString = JSON.stringify(json);
  const undoStack = [...toolSettings.undoStack, jsonString];
  setToolSettings({
    ...toolSettings,
    undoStack,
    redoStack: [],
  });
};

const checkChanges = (canvas, toolSettings, setToolSettings) => {
  // Check when objects are modified (after action is completed) to save the canvas

  const onChange = (e) => {
    saveCanvas(toolSettings, setToolSettings);
  };

  canvas.on(""object:modified"", onChange);

  return {
    removeEventListeners: function () {
      canvas.off(""object:modified"", onChange);
    },
  };
};

export { undoCanvas, redoCanvas, saveCanvas, checkChanges };
"
Content\canvas\modules\ImageTool.jsx,Included,application/octet-stream,3574,"import { fabric } from ""fabric"";

const ImageTool = (canvas, src, toolSettings, setToolSettings, saveCanvas) => {
  // Show image placeholder (semi transparent ghost image following cursor) to allow user to place image on canvas (source is in the image argument), drag to resize
  const image = new Image();
  let fabricImage = null;
  image.src = src;

  setToolSettings({ ...toolSettings, tool: ""select"", isAddingImage: true });

  // Make all objects unselectable
  canvas.forEachObject((obj) => {
    obj.selectable = false;
    canvas.renderAll();
  });

  image.onload = () => {
    fabricImage = new fabric.Image(image);
    fabricImage.set({
      left: 0,
      top: 0,
      originX: ""left"",
      originY: ""top"",
      strokeUniform: true,
      angle: 0,
      fill: ""transparent"",
      noScaleCache: false,
      opacity: 0.5,
      selectable: false,
    });
    canvas.add(fabricImage);
    canvas.renderAll();

    // Scale image to max width or height of 500px
    const maxWidth = 500;
    const maxHeight = 500;
    const width = fabricImage.width;
    const height = fabricImage.height;
    const ratio = Math.min(maxWidth / width, maxHeight / height);
    fabricImage.set({ scaleX: ratio, scaleY: ratio });
    canvas.renderAll();

    toolSettings.openToast(chrome.i18n.getMessage(""addImageToastTitle""), () => {
      canvas.remove(fabricImage);
      canvas.renderAll();
      fabricImage = null;
      setToolSettings({ ...toolSettings, isAddingImage: false });

      // Make all objects selectable
      canvas.forEachObject((obj) => {
        obj.selectable = true;
      });
    });
  };

  let isDown = false;

  // Mouse move
  const onMouseMove = (o) => {
    if (!fabricImage) return;

    //if (!isDown) {
    // Show ghost image following cursor, drag to resize, click to place
    var pointer = canvas.getPointer(o.e);
    fabricImage.set({
      left: pointer.x,
      top: pointer.y,
    });
    fabricImage.setCoords();
    canvas.renderAll();
    //} else {
    //  // Rescale image based on mouse position
    //  var pointer = canvas.getPointer(o.e);
    //  const width = pointer.x - fabricImage.left;
    //   const height = pointer.y - fabricImage.top;
    //   const ratio = Math.min(
    //     width / fabricImage.width,
    //     height / fabricImage.height
    //   );
    //   fabricImage.set({ scaleX: ratio, scaleY: ratio });
    //   canvas.renderAll();
    // }
  };

  const onMouseDown = (o) => {
    if (!fabricImage) return;
    isDown = true;
    // Disable canvas selection
    canvas.selection = false;
    canvas.renderAll();
  };

  const onMouseUp = (o) => {
    if (!fabricImage) return;
    isDown = false;
    fabricImage.set({
      opacity: 1,
      selectable: true,
    });
    fabricImage.setCoords();
    canvas.renderAll();
    saveCanvas(toolSettings, setToolSettings);
    setToolSettings({ ...toolSettings, tool: ""select"", isAddingImage: false });
    canvas.setActiveObject(fabricImage);
    canvas.renderAll();
    // Make all objects selectable
    canvas.forEachObject((obj) => {
      obj.selectable = true;
    });
    canvas.renderAll();
    fabricImage = null;
  };

  canvas.on(""mouse:move"", onMouseMove);
  canvas.on(""mouse:down"", onMouseDown);
  canvas.on(""mouse:up"", onMouseUp);

  return {
    removeEventListeners: () => {
      canvas.off(""mouse:move"", onMouseMove);
      canvas.off(""mouse:down"", onMouseDown);
    },
  };
};

export default ImageTool;
"
Content\canvas\modules\PenTool.jsx,Included,application/octet-stream,3994,"import { fabric } from ""fabric"";

const PenTool = (canvas, toolSettings, setToolSettings, saveCanvas) => {
  if (toolSettings.tool === ""pen"") {
    canvas.isDrawingMode = true;
    canvas.freeDrawingBrush.drawStraightLine = false;
    canvas.freeDrawingBrush.width = toolSettings.strokeWidth * 4;
    canvas.freeDrawingBrush.color = toolSettings.color;
    canvas.freeDrawingBrush.straightLineKey = ""none"";
  } else if (toolSettings.tool === ""highlighter"") {
    canvas.isDrawingMode = true;
    canvas.freeDrawingBrush.drawStraightLine = false;
    canvas.freeDrawingBrush.straightLineKey = ""none"";
    canvas.freeDrawingBrush.width = toolSettings.strokeWidth * 10;
    // Make the highlighter transparent
    canvas.freeDrawingBrush.color = new fabric.Color(toolSettings.color)
      .setAlpha(0.5)
      .toRgba();
    // Make the highlighter not draw on top of existing objects
    canvas.freeDrawingBrush.globalCompositeOperation = ""destination-over"";
    // Make the highlighter brush tip square
    canvas.freeDrawingBrush.strokeLineCap = ""square"";
  } else {
    canvas.isDrawingMode = false;
  }

  const onMouseUp = (o) => {
    if (toolSettings.tool !== ""pen"" && toolSettings.tool !== ""highlighter"")
      return;
    saveCanvas(toolSettings, setToolSettings);
  };

  const onPathCreated = (o) => {
    // Make a copy of the path with a thin blue stroke. Then group the two paths together
    const path = o.path;
    const pathCopy = new fabric.Path(path.path, {
      id: ""select-stroke"",
      stroke: ""#0D99FF"",
      strokeWidth: 2,
      fill: null,
      opacity: 0,
    });
    const group = new fabric.Group([path, pathCopy], {
      // Make the group selectable
      selectable: true,
      id: ""select-group"",
    });
    canvas.add(group);
    // Remove the original path from the canvas
    canvas.remove(path);
    canvas.renderAll();
  };

  const activateStroke = (o) => {
    if (toolSettings.tool !== ""select"") return;

    canvas.getObjects().forEach((obj) => {
      if (obj.type == ""group"") {
        obj._objects.forEach((obj2) => {
          if (obj2.id === ""select-stroke"") {
            obj2.set({ opacity: 0 });
            canvas.renderAll();
          }
        });
      }
    });

    const activeObject = canvas.getActiveObject();
    if (activeObject && activeObject.id === ""select-group"") {
      activeObject._objects.forEach((obj) => {
        if (obj.id === ""select-stroke"") {
          obj.set({ opacity: 1 });
        }
      });
      canvas.renderAll();
    }

    // Also if multiple selected objects, show the blue border in all of them
    const activeGroup = canvas.getActiveObjects();
    if (activeGroup && activeGroup.length > 1) {
      activeGroup.forEach((obj) => {
        if (obj.id === ""select-group"") {
          obj._objects.forEach((obj) => {
            if (obj.id === ""select-stroke"") {
              obj.set({ opacity: 1 });
            }
          });
        }
      });
      canvas.renderAll();
    }
  };
  const deactivateStroke = (o) => {
    canvas.getObjects().forEach((obj) => {
      if (obj.type == ""group"") {
        obj._objects.forEach((obj2) => {
          if (obj2.id === ""select-stroke"") {
            obj2.set({ opacity: 0 });
            canvas.renderAll();
          }
        });
      }
    });
  };

  canvas.on(""mouse:up"", onMouseUp);
  canvas.on(""path:created"", onPathCreated);
  canvas.on(""selection:created"", activateStroke);
  canvas.on(""selection:updated"", activateStroke);
  canvas.on(""selection:cleared"", deactivateStroke);

  return {
    removeEventListeners: () => {
      canvas.off(""mouse:up"", onMouseUp);
      canvas.off(""path:created"", onPathCreated);
      canvas.off(""selection:created"", activateStroke);
      canvas.off(""selection:updated"", activateStroke);
      canvas.off(""selection:cleared"", deactivateStroke);
    },
  };
};

export default PenTool;
"
Content\canvas\modules\SelectTool.jsx,Included,application/octet-stream,3185,"import { fabric } from ""fabric"";

const SelectTool = (canvas, toolSettings, setToolSettings) => {
  if (toolSettings.tool === ""select"") {
    // Check if there's any objects on the canvas
    if (canvas.getObjects().length > 0) {
      // Make all objects on the canvas selectable
      canvas.forEachObject((object) => {
        object.set({ selectable: true, perPixelTargetFind: false });
      });

      // Make canvas selectable
      canvas.selection = true;
      canvas.renderAll();
    }
  } else {
    // Make canvas unselectable
    canvas.selection = false;
    canvas.renderAll();
  }

  // On mouse over object
  const onMouseOver = (o) => {
    if (toolSettings.tool !== ""select"") return;
    if (toolSettings.isAddingImage) return;
    if (!o.target) return;

    if (o.target != canvas.getActiveObject()) {
      if (o.target.type === ""group"" && o.target.id === ""select-group"") {
        // Find child of group with ID ""select-stroke""
        const selectStroke = o.target._objects.find(
          (object) => object.id === ""select-stroke""
        );
        selectStroke.set({ opacity: 1 });
      } else if (o.target.type === ""group"" && o.target.id === ""arrowGroup"") {
        o.target._objects.forEach((obj) => {
          if (obj.id === ""arrowLineControl"") {
            obj.set({ opacity: 1 });
          }
        });
      } else {
        o.target._renderControls(o.target.canvas.contextTop, {
          hasControls: false,
        });
      }
      canvas.renderAll();
    }

    // Show blue border on hover
    // o.target.set({ stroke: ""blue"", strokeWidth: 2 });
    //canvas.renderAll();
  };

  // On mouse out object
  const onMouseOut = (o) => {
    if (toolSettings.tool !== ""select"") return;
    if (!o.target) return;

    if (o.target != canvas.getActiveObject()) {
      if (o.target.type === ""group"" && o.target.id === ""select-group"") {
        // Find child of group with ID ""select-stroke""
        const selectStroke = o.target._objects.find(
          (object) => object.id === ""select-stroke""
        );
        selectStroke.set({ opacity: 0 });
        canvas.renderAll();
      } else if (o.target.type === ""group"" && o.target.id === ""arrowGroup"") {
        o.target._objects.forEach((obj) => {
          if (obj.id === ""arrowLineControl"") {
            obj.set({ opacity: 0 });
          }
        });
        canvas.renderAll();
      }
    }

    o.target.canvas.clearContext(o.target.canvas.contextTop);
    canvas.renderAll();
  };

  const checkObject = (o) => {
    if (toolSettings.isAddingImage) return;
    if (toolSettings.tool !== ""select"") return;
    if (!o.target) return;
    if (!o.target.canvas) return;

    o.target.canvas.clearContext(o.target.canvas.contextTop);
  };

  canvas.on(""mouse:over"", onMouseOver);
  canvas.on(""mouse:out"", onMouseOut);
  canvas.on(""mouse:down"", checkObject);

  return {
    removeEventListeners: function () {
      canvas.off(""mouse:over"", onMouseOver);
      canvas.off(""mouse:out"", onMouseOut);
      canvas.off(""mouse:down"", checkObject);
    },
  };
};

export default SelectTool;
"
Content\canvas\modules\ShapeTool.jsx,Included,application/octet-stream,3258,"import React from ""react"";

import { fabric } from ""fabric"";

const ShapeTool = (canvas, toolSettings, setToolSettings, saveCanvas) => {
  const tool = toolSettings;
  let shape;
  let isDown = false;
  let origX;
  let origY;

  const onMouseDown = (o) => {
    if (tool.tool !== ""shape"") return;
    isDown = true;
    const pointer = canvas.getPointer(o.e);
    origX = pointer.x;
    origY = pointer.y;
    if (tool.shape === ""rectangle"") {
      shape = new fabric.Rect({
        left: origX,
        top: origY,
        originX: ""left"",
        originY: ""top"",
        width: pointer.x - origX,
        height: pointer.y - origY,
        strokeUniform: true,
        angle: 0,
        fill: tool.shapeFill ? toolSettings.color : ""transparent"",
        noScaleCache: false,
        stroke: toolSettings.color,
        strokeWidth: toolSettings.strokeWidth * 6,
      });
    } else if (tool.shape === ""triangle"") {
      shape = new fabric.Triangle({
        left: origX,
        top: origY,
        originX: ""left"",
        originY: ""top"",
        strokeMilterLimit: 8,
        objectCaching: false,
        width: pointer.x - origX,
        height: pointer.y - origY,
        strokeUniform: true,
        angle: 0,
        fill: tool.shapeFill ? toolSettings.color : ""transparent"",
        noScaleCache: false,
        stroke: toolSettings.color,
        strokeWidth: toolSettings.strokeWidth * 6,
      });
    } else if (tool.shape === ""circle"") {
      shape = new fabric.Circle({
        left: origX,
        top: origY,
        originX: ""left"",
        originY: ""top"",
        radius: Math.abs(pointer.x - origX) / 2,
        strokeUniform: true,
        angle: 0,
        fill: tool.shapeFill ? toolSettings.color : ""transparent"",
        noScaleCache: false,
        stroke: toolSettings.color,
        strokeWidth: toolSettings.strokeWidth * 6,
      });
    }
    canvas.add(shape);
  };

  const onMouseMove = (o) => {
    if (tool.tool !== ""shape"") return;
    if (!isDown) return;
    const pointer = canvas.getPointer(o.e);

    if (origX > pointer.x) {
      shape.set({ left: Math.abs(pointer.x) });
    }
    if (origY > pointer.y) {
      shape.set({ top: Math.abs(pointer.y) });
    }

    if (tool.shape === ""rectangle"" || tool.shape === ""triangle"") {
      shape.set({ width: Math.abs(origX - pointer.x) });
      shape.set({ height: Math.abs(origY - pointer.y) });
    } else if (tool.shape === ""circle"") {
      shape.set({
        radius: Math.abs(pointer.x - origX) / 2,
      });
    }

    canvas.requestRenderAll();
  };

  const onMouseUp = (o) => {
    if (tool.tool !== ""shape"") return;
    isDown = false;
    canvas.renderAll();
    saveCanvas({ ...toolSettings, tool: ""select"" }, setToolSettings);
    canvas.setActiveObject(shape);
    canvas.renderAll();
  };

  canvas.on(""mouse:down"", onMouseDown);
  canvas.on(""mouse:move"", onMouseMove);
  canvas.on(""mouse:up"", onMouseUp);

  return {
    removeEventListeners: function () {
      canvas.off(""mouse:down"", onMouseDown);
      canvas.off(""mouse:move"", onMouseMove);
      canvas.off(""mouse:up"", onMouseUp);
    },
  };
};

export default ShapeTool;
"
Content\canvas\modules\TextTool.jsx,Included,application/octet-stream,5466,"import { fabric } from ""fabric"";

const TextTool = (canvas, toolSettings, setToolSettings, saveCanvas) => {
  // Add interactive text on click, start editing
  const onMouseDown = (o) => {
    if (toolSettings.tool !== ""text"") return;

    const pointer = canvas.getPointer(o.e);
    const x = pointer.x;
    const y = pointer.y;

    const text = new fabric.Textbox("""", {
      left: x,
      top: y,
      fontFamily: ""Satoshi-Medium"",
      fontSize: 20,
      fill: toolSettings.color,
      fontWeight: ""normal"",
      fontStyle: ""normal"",
      originX: ""left"",
      originY: ""top"",
      textAlign: ""center"",
      lockUniScaling: true,
      centeredScaling: true,
      skipAutoWidthAdjustment: false,
      perPixelTargetFind: false,
    });
    // Blue selection box while editing
    text.on(""editing:entered"", () => {
      text.borderColor = ""#0D99FF"";
    });

    canvas.add(text);
    canvas.setActiveObject(text);
    text.enterEditing();
    text.selectAll();

    // Set tool back to cursor
    setToolSettings({
      ...toolSettings,
      tool: ""select"",
    });

    // When user clicks off of text, save canvas
    canvas.on(""mouse:down"", () => {
      if (canvas.getActiveObject() !== text) {
        // Check if text is empty, if so, remove it
        if (text.text === """") {
          canvas.remove(text);
        } else {
          saveCanvas(canvas);
        }
      }
    });
  };

  const onKeyPress = (event) => {
    if (canvas.getActiveObject() === null) return;
    // check if getactiveobject is an object
    if (typeof canvas.getActiveObject() !== ""object"") return;

    // Check if the active object is a textbox and if the user is editing it
    if (
      canvas.getActiveObject().type !== ""textbox"" ||
      !canvas.getActiveObject().isEditing
    )
      return;

    // Get the active text object
    var text = canvas.getActiveObject();

    // Check if the user has explicitly set the width of the textbox
    if (text.skipAutoWidthAdjustment) return;

    // Get text in current line of text
    var currentLine = text._textLines[text._textLines.length - 1];
    // current line to string
    currentLine = currentLine.join("""");

    // Check if the user is backspacing
    if (event.keyCode === 8 && currentLine.length > 0) {
      // Remove the last character from the current line
      currentLine = currentLine.slice(0, -1);
    } else {
      // Add the pressed character to the current line
      var charCode = event.charCode || event.keyCode;
      var character = String.fromCharCode(charCode);
      currentLine += character;
    }

    var newText = currentLine;

    // Create a temporary canvas to measure the text width
    var tempCanvas = document.createElement(""canvas"");
    var tempCtx = tempCanvas.getContext(""2d"");
    tempCtx.font = text.fontSize + ""px "" + text.fontFamily;
    var textMetrics = tempCtx.measureText(newText);

    // Adjust the width of the text if necessary
    var textWidth = Math.max(text.width, textMetrics.width + 2);
    if (textMetrics.width > text.width) {
      text.set({
        left: text.left - (textWidth - text.width) / 2,
      });

      canvas.renderAll();
      text.set(""width"", textWidth);
    } else {
      var maxLineWidth = getMaxLineWidth(text._textLines, text);
      if (textMetrics.width < maxLineWidth) {
        text.set({
          left: text.left + (text.width - maxLineWidth) / 2,
        });

        canvas.renderAll();
        text.set(""width"", maxLineWidth);
      }
    }

    canvas.renderAll();
  };

  function getMaxLineWidth(textLines, text) {
    var maxLineWidth = 0;
    var tempCanvas = document.createElement(""canvas"");
    var tempCtx = tempCanvas.getContext(""2d"");
    tempCtx.font = text.fontSize + ""px "" + text.fontFamily;

    for (var i = 0; i < textLines.length; i++) {
      var line = textLines[i].join("""");
      var lineMetrics = tempCtx.measureText(line);
      var lineWidth = lineMetrics.width;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }

    return maxLineWidth;
  }

  const onResize = (e) => {
    // Check if the active object is a textbox
    if (e.target.type !== ""textbox"") return;

    // Set flag to skip auto width adjustment
    var text = e.target;
    text.skipAutoWidthAdjustment = true;
    canvas.renderAll();
  };

  canvas.on(""mouse:down"", onMouseDown);
  document.addEventListener(""keydown"", onKeyPress);
  canvas.on(""object:resizing"", onResize);
  canvas.on(""mouse:move"", function (event) {
    var pointer = canvas.getPointer(event.e);
    var isHoveringTextbox = false;

    canvas.forEachObject(function (obj) {
      if (obj.type === ""textbox"" && obj.containsPoint(pointer)) {
        isHoveringTextbox = true;
        return false;
      }
    });

    if (isHoveringTextbox) {
      // Disable perPixelTargetFind when hovering over a textbox
      canvas.perPixelTargetFind = false;
    } else {
      // Re-enable perPixelTargetFind when mouse leaves the textbox
      canvas.perPixelTargetFind = true;
    }
  });

  return {
    removeEventListeners: () => {
      canvas.off(""mouse:down"", onMouseDown);
      document.removeEventListener(""keydown"", onKeyPress);
      canvas.off(""object:resizing"", onResize);
      canvas.off(""mouse:move"");
    },
  };
};

export default TextTool;
"
Content\canvas\styles\layout\_Canvas.scss,Excluded by file type,,0,
Content\canvas\styles\_Canvas.scss,Excluded by file type,,0,
Content\Content.jsx,Included,application/octet-stream,5952,"import React, { useState, useContext, useEffect, useRef } from ""react"";

// Components
import Wrapper from ""./Wrapper"";

// Context
import ContentState from ""./context/ContentState"";

const Content = () => {
  return (
    <div className=""screenity-shadow-dom"">
      <ContentState>
        <Wrapper />
      </ContentState>
      <style type=""text/css"">{`
			#screenity-ui, #screenity-ui div {
				background-color: unset;
				padding: unset;
				width: unset;
				box-shadow: unset;
				display: unset;
				margin: unset;
				border-radius: unset;
			}
			.screenity-outline {
				position: absolute;
				z-index: 99999999999;
				border: 2px solid #3080F8;
				outline-offset: -2px;
				pointer-events: none;
				border-radius: 5px!important;
			}
		.screenity-blur {
			filter: blur(10px)!important;
		}
			.screenity-shadow-dom * {
				transition: unset;
			}
			.screenity-shadow-dom .TooltipContent {
  border-radius: 30px!important;
	background-color: #29292F!important;
  padding: 10px 15px!important;
  font-size: 12px;
	margin-bottom: 10px!important;
	bottom: 100px;
  line-height: 1;
	font-family: 'Satoshi-Medium', sans-serif;
	z-index: 99999999!important;
  color: #FFF;
  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px!important;
  user-select: none;
	transition: opacity 0.3 ease-in-out;
  will-change: transform, opacity;
	animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
}

.screenity-shadow-dom .hide-tooltip {
	display: none!important;
}

.screenity-shadow-dom .tooltip-tall {
	margin-bottom: 20px;
}

.screenity-shadow-dom .tooltip-small {
	margin-bottom: 5px;
}

.screenity-shadow-dom .TooltipContent[data-state='delayed-open'][data-side='top'] {
	animation-name: slideDownAndFade;
}
.screenity-shadow-dom .TooltipContent[data-state='delayed-open'][data-side='right'] {
  animation-name: slideLeftAndFade;
}
.screenity-shadow-dom.TooltipContent[data-state='delayed-open'][data-side='bottom'] {
  animation-name: slideUpAndFade;
}
.screenity-shadow-dom.TooltipContent[data-state='delayed-open'][data-side='left'] {
  animation-name: slideRightAndFade;
}

@keyframes slideUpAndFade {
  from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideRightAndFade {
  from {
    opacity: 0;
    transform: translateX(-2px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideDownAndFade {
  from {
    opacity: 0;
    transform: translateY(-2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideLeftAndFade {
  from {
    opacity: 0;
    transform: translateX(2px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

#screenity-ui [data-radix-popper-content-wrapper] { z-index: 999999999999!important; } 

.screenity-shadow-dom .CanvasContainer {
	position: fixed;
	pointer-events: all!important;
	top: 0px!important;
	left: 0px!important;
	z-index: 99999999999!important;
}
.screenity-shadow-dom .canvas {
	position: fixed;
	top: 0px!important;
	left: 0px!important;
	z-index: 99999999999!important;
	background: transparent!important;
}
.screenity-shadow-dom .canvas-container {
	top: 0px!important;
	left: 0px!important;
	z-index: 99999999999;
	position: fixed!important;
	background: transparent!important;
}

.ScreenityDropdownMenuContent {
	z-index: 99999999999!important;
  min-width: 200px;
  background-color: white;
  margin-top: 4px;
  margin-right: 8px;
  padding-top: 12px;
  padding-bottom: 12px;
  border-radius: 15px;
  z-index: 99999;
  font-family: 'Satoshi-Medium', sans-serif;
  color: #29292F;
  box-shadow: 0px 10px 38px -10px rgba(22, 23, 24, 0.35),
    0px 10px 20px -15px rgba(22, 23, 24, 0.2);
  animation-duration: 400ms;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  will-change: transform, opacity;
}
.ScreenityDropdownMenuContent[data-side=""top""] {
  animation-name: slideDownAndFade;
}
.ScreenityDropdownMenuContent[data-side=""right""] {
  animation-name: slideLeftAndFade;
}
.ScreenityDropdownMenuContent[data-side=""bottom""] {
  animation-name: slideUpAndFade;
}
.ScreenityDropdownMenuContent[data-side=""left""] {
  animation-name: slideRightAndFade;
}
.ScreenityItemIndicator {
  position: absolute;
  right: 12px; 
  width: 18px;
  height: 18px;
  background: #3080F8;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.ScreenityDropdownMenuItem,
.ScreenityDropdownMenuRadioItem {
  font-size: 14px;
  line-height: 1;
  display: flex;
  align-items: center;
  height: 40px;
  padding: 0 5px;
  position: relative;
  padding-left: 22px;
  padding-right: 22px;
  user-select: none;
  outline: none;
}
.ScreenityDropdownMenuItem:hover {
    background-color: #F6F7FB !important;
    cursor: pointer;
}
.ScreenityDropdownMenuItem[data-disabled] {
  color: #6E7684; !important;
  cursor: not-allowed;
  background-color: #F6F7FB !important;
}



@keyframes slideUpAndFade {
  from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideRightAndFade {
  from {
    opacity: 0;
    transform: translateX(-2px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideDownAndFade {
  from {
    opacity: 0;
    transform: translateY(-2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideLeftAndFade {
  from {
    opacity: 0;
    transform: translateX(2px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

`}</style>
    </div>
  );
};

export default Content;
"
Content\context\ContentState.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,51769,"import React, {
  createContext,
  useState,
  useEffect,
  useCallback,
  useRef,
  useMemo,
} from ""react"";

// Shortcuts
import Shortcuts from ""../shortcuts/Shortcuts"";

//create a context, with createContext api
export const contentStateContext = createContext();

const ContentState = (props) => {
  const [timer, setTimer] = React.useState(0);
  const contentStateRef = useRef();
  const [URL, setURL] = useState(
    ""https://help.screenity.io/getting-started/77KizPC8MHVGfpKpqdux9D/why-does-screenity-ask-for-permissions/9AAE8zJ6iiUtCAtjn4SUT1""
  );
  const [URL2, setURL2] = useState(
    ""https://help.screenity.io/troubleshooting/9Jy5RGjNrBB42hqUdREQ7W/how-to-grant-screenity-permission-to-record-your-camera-and-microphone/x6U69TnrbMjy5CQ96Er2E9""
  );

  useEffect(() => {
    const locale = chrome.i18n.getMessage(""@@ui_locale"");
    if (!locale.includes(""en"")) {
      setURL(
        ""https://translate.google.com/translate?sl=en&tl="" +
          locale +
          ""&u=https://help.screenity.io/getting-started/77KizPC8MHVGfpKpqdux9D/why-does-screenity-ask-for-permissions/9AAE8zJ6iiUtCAtjn4SUT1""
      );
      setURL2(
        ""https://translate.google.com/translate?sl=en&tl="" +
          locale +
          ""&u=https://help.screenity.io/troubleshooting/9Jy5RGjNrBB42hqUdREQ7W/how-to-grant-screenity-permission-to-record-your-camera-and-microphone/x6U69TnrbMjy5CQ96Er2E9""
      );
    }
  }, []);

  const startRecording = useCallback(() => {
    if (contentStateRef.current.alarm) {
      if (contentStateRef.current.alarmTime === 0) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          alarm: false,
        }));
        chrome.storage.local.set({ alarm: false });
        setTimer(0);
      } else {
        setTimer(contentStateRef.current.alarmTime);
      }
    } else {
      setTimer(0);
    }
    setContentState((prevContentState) => ({
      ...prevContentState,
      recording: true,
      paused: false,
      pendingRecording: false,
    }));
    chrome.storage.local.set({
      recording: true,
      restarting: false,
    });

    // This cannot be triggered from here because the user might not have the page focused
    //chrome.runtime.sendMessage({ type: ""start-recording"" });
  }, [contentStateRef.current]);

  const restartRecording = useCallback(() => {
    chrome.storage.local.set({ recording: false, restarting: true });
    setTimeout(() => {
      chrome.runtime.sendMessage({ type: ""discard-backup-restart"" });
      chrome.runtime.sendMessage({ type: ""restart-recording-tab"" });
      // Check if custom region is set
      if (
        contentStateRef.current.recordingType === ""region"" &&
        contentStateRef.current.cropTarget
      ) {
        contentStateRef.current.regionCaptureRef.contentWindow.postMessage(
          {
            type: ""restart-recording"",
          },
          ""*""
        );
      }
      if (contentStateRef.current.alarm) {
        setTimer(contentStateRef.current.alarmTime);
      } else {
        setTimer(0);
      }
      setContentState((prevContentState) => ({
        ...prevContentState,
        recording: false,
        time: 0,
        paused: false,
      }));
    }, 100);
  }, [contentStateRef.current]);

  const stopRecording = useCallback(() => {
    chrome.storage.local.set({
      recording: false,
      restarting: false,
      tabRecordedID: null,
    });
    setContentState((prevContentState) => ({
      ...prevContentState,
      recording: false,
      paused: false,
      showExtension: false,
      showPopup: true,
      pendingRecording: false,
      tabCaptureFrame: false,
      time: 0,
      timer: 0,
    }));
    setTimer(0);
    chrome.runtime.sendMessage({ type: ""stop-recording-tab"" });
    // Play beep sound at 50% volume
    const audio = new Audio(chrome.runtime.getURL(""/assets/sounds/beep.mp3""));
    audio.volume = 0.5;
    audio.play();
  });

  const pauseRecording = useCallback((dismiss) => {
    chrome.runtime.sendMessage({ type: ""pause-recording-tab"" });

    setTimeout(() => {
      setContentState((prevContentState) => ({
        ...prevContentState,
        paused: true,
      }));
      if (!dismiss) {
        contentStateRef.current.openToast(
          chrome.i18n.getMessage(""pausedRecordingToast""),
          function () {}
        );
      }
    }, 100);
  });

  const resumeRecording = useCallback(() => {
    chrome.runtime.sendMessage({ type: ""resume-recording-tab"" });
    setContentState((prevContentState) => ({
      ...prevContentState,
      paused: false,
    }));
  });

  const dismissRecording = useCallback(() => {
    chrome.storage.local.set({ restarting: false });
    chrome.runtime.sendMessage({ type: ""dismiss-recording-tab"" });
    setContentState((prevContentState) => ({
      ...prevContentState,
      recording: false,
      paused: false,
      showExtension: false,
      showPopup: true,
      time: 0,
      timer: 0,
      tabCaptureFrame: false,
      pendingRecording: false,
    }));
    setTimer(0);
  });

  const checkChromeCapturePermissions = useCallback(async () => {
    const containsPromise = new Promise((resolve) => {
      chrome.permissions.contains(
        {
          permissions: [""desktopCapture"", ""alarms"", ""offscreen""],
        },
        (result) => {
          resolve(result);
        }
      );
    });

    const result = await containsPromise;

    if (!result) {
      const requestPromise = new Promise((resolve) => {
        chrome.permissions.request(
          {
            permissions: [""desktopCapture"", ""alarms"", ""offscreen""],
          },
          (granted) => {
            resolve(granted);
          }
        );
      });

      const granted = await requestPromise;

      if (!granted) {
        return false;
      } else {
        chrome.runtime.sendMessage({
          type: ""add-alarm-listener"",
        });
        return true;
      }
    } else {
      return true;
    }
  }, []);

  const checkChromeCapturePermissi"
Content\countdown\Countdown.jsx,Included,application/octet-stream,5501,"import React, {
  useState,
  useEffect,
  useRef,
  useContext,
  useCallback,
} from ""react"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const Countdown = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [count, setCount] = useState(3);
  const [showCountdown, setShowCountdown] = useState(false);
  const [countActive, setCountActive] = useState(false);
  const backgroundRef = useRef(null);
  const circleRef = useRef(null);
  const c1Ref = useRef(null);
  const c2Ref = useRef(null);
  const countdownRef = useRef(contentState.countdown);
  const wrapperRef = useRef(null);
  const cancelRef = useRef(false);

  // 3, 2, 1 countdown when recording starts
  useEffect(() => {
    if (countActive && count > 1) {
      const timer = setInterval(() => {
        setCount((prevCount) => prevCount - 1);
      }, 1000);
      return () => clearInterval(timer);
    }
  }, [countActive, count]);

  const startCountdown = () => {
    if (circleRef.current === null) return;
    if (backgroundRef.current === null) return;

    setCount(3);
    cancelRef.current = false;
    wrapperRef.current.style.pointerEvents = ""all"";

    setTimeout(() => {
      if (circleRef.current === null) return;
      if (backgroundRef.current === null) return;
      circleRef.current.style.transform = ""scale(1)"";
      backgroundRef.current.style.transform = ""rotate(90deg)"";
    }, 10);
    setTimeout(() => {
      if (circleRef.current === null) return;
      circleRef.current.style.transform = ""scale(.8)"";
    }, (count * 1000) / 2);
  };

  useEffect(() => {
    countdownRef.current = contentState.countdown;
  }, [contentState.countdown]);

  const onMessage = useCallback(
    (request, sender, sendResponse) => {
      if (request.type === ""ready-to-record"") {
        if (countdownRef.current) {
          setCountActive(true);
          setShowCountdown(true);
          startCountdown();

          setTimeout(() => {
            if (!cancelRef.current) {
              setShowCountdown(false);
              setCountActive(false);
              cancelRef.current = false;
              setCount(3);
              wrapperRef.current.style.pointerEvents = ""none"";

              // Play beep sound at 50% volume
              const audio = new Audio(
                chrome.runtime.getURL(""/assets/sounds/beep2.mp3"")
              );
              audio.volume = 0.5;
              audio.play();
              setTimeout(() => {
                contentState.startRecording();
              }, 500);
            }
          }, count * 1000);
        } else {
          if (!cancelRef.current) {
            // Play beep sound at 50% volume
            const audio = new Audio(
              chrome.runtime.getURL(""/assets/sounds/beep2.mp3"")
            );
            audio.volume = 0.5;
            audio.play();
            setShowCountdown(false);
            setCountActive(false);
            setTimeout(() => {
              contentState.startRecording();
            }, 500);
          }
        }
      }
    },
    [countdownRef, contentState, cancelRef.current]
  );

  useEffect(() => {
    chrome.runtime.onMessage.addListener(onMessage);

    return () => {
      setCountActive(false);
      setShowCountdown(false);
      setCount(3);
      chrome.runtime.onMessage.removeListener(onMessage);
    };
  }, []);

  // I need to make a 3, 2, 1 countdown, full screen (black overlay with the number in a circle on the middle), with a beep at the end
  return (
    <div
      className={!countActive ? ""countdown"" : ""countdown recording-countdown""}
      onClick={() => {
        if (countActive) {
          cancelRef.current = true;
          wrapperRef.current.style.pointerEvents = ""none"";
          setCountActive(false);
          setShowCountdown(false);
          setCount(3);
          contentState.dismissRecording();
          setContentState((prevContentState) => ({
            ...prevContentState,
            recording: false,
            showPopup: true,
            showExtension: true,
          }));
        }
      }}
      ref={wrapperRef}
    >
      {showCountdown && (
        <div>
          <svg xmlns=""http://www.w3.org/2000/svg"" version=""1.1"">
            <defs>
              <filter id=""goo"">
                <feGaussianBlur in=""SourceGraphic"" stdDeviation=""10"" />
                <feColorMatrix
                  in=""blur""
                  mode=""matrix""
                  values=""1 0 0 0 0
                      0 1 0 0 0
                      0 0 1 0 0
                      0 0 0 20 -10""
                  result=""goo""
                />
              </filter>
            </defs>
          </svg>
          <div className=""countdown-circle"">
            <div className=""countdown-number"">{count}</div>
            <div className=""background"" ref={backgroundRef}>
              <div className=""circle"" ref={circleRef}></div>
              <div className=""c c2"" ref={c1Ref}></div>
              <div className=""c c3"" ref={c2Ref}></div>
            </div>
          </div>
          <div className=""countdown-info"">
            {chrome.i18n.getMessage(""countdownMessage"")}
          </div>
          <div className=""countdown-overlay""></div>
        </div>
      )}
    </div>
  );
};

export default Countdown;
"
Content\countdown\styles\_Countdown.scss,Excluded by file type,,0,
Content\images\popup\images.js,Included,text/javascript,2852,"// I need to make this work for a Chrome extension, so I can't import images, instead it needs to be a string with the path to the image
const URL =
  ""chrome-extension://"" + chrome.i18n.getMessage(""@@extension_id"") + ""/assets"";

const DropdownIcon = `${URL}/dropdown.svg`;
const MicOnIcon = `${URL}/mic-on.svg`;
const MicOffIcon = `${URL}/mic-off.svg`;
const CameraOnIcon = `${URL}/camera-on.svg`;
const CameraOffIcon = `${URL}/camera-off.svg`;
const CheckWhiteIcon = `${URL}/check-white.svg`;
const Waveform = `${URL}/waveform.svg`;
const RecordTabActive = `${URL}/record-tab-active.svg`;
const RecordTabInactive = `${URL}/record-tab-inactive.svg`;
const VideoTabActive = `${URL}/video-tab-active.svg`;
const VideoTabInactive = `${URL}/video-tab-inactive.svg`;
const ScreenTabOn = `${URL}/screen-tab-on.svg`;
const ScreenTabOff = `${URL}/screen-tab-off.svg`;
const RegionTabOn = `${URL}/region-tab-on.svg`;
const RegionTabOff = `${URL}/region-tab-off.svg`;
const AudioTabOn = `${URL}/audio-tab-on.svg`;
const AudioTabOff = `${URL}/audio-tab-off.svg`;
const MockupTabOn = `${URL}/mockup-tab-on.svg`;
const MockupTabOff = `${URL}/mockup-tab-off.svg`;
const TempLogo = `${URL}/temp-logo.png`;
const TempFigma = `${URL}/temp/figma.webp`;
const TempTwitter = `${URL}/temp/twitter.webp`;
const TempDesignSystem = `${URL}/temp/designsystem.webp`;
const TempMarketing = `${URL}/temp/marketing.webp`;
const TempSubstack = `${URL}/temp/substack.webp`;
const CopyLinkIcon = `${URL}/copy-link.svg`;
const MoreActionsIcon = `${URL}/more-actions.svg`;
const ProfilePic = `${URL}/pfp.png`;
const HandleControl = `${URL}/canvas/handle.png`;
const RotateControl = `${URL}/canvas/rotate.png`;
const MiddleHandleControl = `${URL}/canvas/middle-handle.png`;
const MiddleHandleControlV = `${URL}/canvas/middle-handle-v.png`;
const DefaultCursor = `${URL}/cursors/default.svg`;
const CameraTabIconOn = `${URL}/camera-tab-icon-on.svg`;
const CameraTabIconOff = `${URL}/camera-tab-icon-off.svg`;
const CameraOffBlue = `${URL}/camera-off-blue.svg`;
const MicOffBlue = `${URL}/mic-off-blue.svg`;
const DropdownGroup = `${URL}/dropdown-group.svg`;

export {
  DropdownIcon,
  MicOnIcon,
  MicOffIcon,
  CameraOnIcon,
  CameraOffIcon,
  CheckWhiteIcon,
  Waveform,
  RecordTabActive,
  RecordTabInactive,
  VideoTabActive,
  VideoTabInactive,
  ScreenTabOn,
  ScreenTabOff,
  RegionTabOn,
  RegionTabOff,
  AudioTabOn,
  AudioTabOff,
  MockupTabOn,
  MockupTabOff,
  TempLogo,
  TempFigma,
  TempTwitter,
  TempDesignSystem,
  TempMarketing,
  TempSubstack,
  CopyLinkIcon,
  MoreActionsIcon,
  ProfilePic,
  HandleControl,
  RotateControl,
  MiddleHandleControl,
  MiddleHandleControlV,
  DefaultCursor,
  CameraTabIconOn,
  CameraTabIconOff,
  CameraOffBlue,
  MicOffBlue,
  DropdownGroup,
};
"
Content\index.css,Excluded by file type,,0,
Content\index.js,Included,text/javascript,261,"import React from ""react"";
import ReactDOM from ""react-dom/client"";
import ""./styles/app.scss"";
import Content from ""./Content"";

const root = ReactDOM.createRoot(document.getElementById(""root""));
root.render(
  <React>
    <Content />
  </React>
);
"
Content\index.jsx,Included,application/octet-stream,427,"import React from ""react"";
import { render } from ""react-dom"";
import Content from ""./Content"";

// Check if screenity-ui already exists, if so, remove it
const existingRoot = document.getElementById(""screenity-ui"");
if (existingRoot) {
  document.body.removeChild(existingRoot);
}

const root = document.createElement(""div"");
root.id = ""screenity-ui"";
document.body.appendChild(root);
render(<Content />, root);
"
Content\mockup\MockupContainer.jsx,Included,application/octet-stream,4965,"// Work in progress...

// import React, { useState, useEffect } from ""react"";
// import { PhoneTest, wallpaper } from ""./utils/DeviceImages"";

// const devices = [
//   {
//     name: ""iPhone"",
//     image: PhoneTest,
//     width: 340,
//     height: 760,
//   },
//   // Add more device options here
// ];

// const MockupContainer = () => {
//   const [selectedDevice, setSelectedDevice] = useState(devices[0]);
//   const [src, setSrc] = useState("""");
//   const [width, setWidth] = useState(0);
//   const [height, setHeight] = useState(0);
//   const useragent =
//     ""Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"";

//   useEffect(() => {
//     setSrc(window.location.href);
//     document.body.style.overflow = ""hidden""; // Hide the body overflow
//     document.body.style.display = ""none""; // Hide the body
//     return () => {
//       document.body.style.overflow = ""auto""; // Restore the body overflow on component unmount
//       document.body.style.display = ""block""; // Restore the body
//     };
//   }, []);

//   const handleDeviceChange = (device) => {
//     setSelectedDevice(device);
//   };

//   useEffect(() => {
//     setWidth(selectedDevice.width);
//     setHeight(selectedDevice.height);
//   }, [selectedDevice]);

//   useEffect(() => {
//     Object.defineProperty(navigator, ""userAgent"", {
//       value:
//         ""Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"",
//       configurable: false,
//       writable: false,
//     });
//   }, []);

//   return (
//     <div style={styles.container} id=""mockup-wrapper"">
//       <div style={styles.deviceContainer}>
//         <div style={{ ...styles.device, width, height }}>
//           <div style={styles.screen}>
//             <iframe
//               src={src}
//               style={styles.iframe}
//               scrolling=""auto""
//               sandbox=""allow-scripts allow-forms allow-same-origin allow-presentation allow-orientation-lock allow-modals allow-popups-to-escape-sandbox allow-pointer-lock""
//               seamless
//               ref={(iframe) => {}}
//             />
//           </div>
//         </div>
//         <div style={styles.deviceSwitcher}>
//           {devices.map((device) => (
//             <button
//               key={device.name}
//               style={styles.deviceSwitch}
//               onClick={() => handleDeviceChange(device)}
//             >
//               {device.name}
//             </button>
//           ))}
//         </div>
//       </div>
//       <div
//         style={{
//           ...styles.mockupOverlay,
//           backgroundImage: `url(${selectedDevice.image})`,
//           width,
//           height,
//         }}
//       />
//       <div className=""wallpaper"" styles={styles.wallpaper}>
//         <img src={wallpaper} alt=""wallpaper"" />
//       </div>
//     </div>
//   );
// };

// const styles = {
//   wallpaper: {
//     position: ""absolute"",
//     top: ""0"",
//     left: ""0"",
//     width: ""100%"",
//     height: ""100%"",
//     zIndex: ""-999"",
//   },
//   container: {
//     position: ""fixed"",
//     top: 0,
//     left: 0,
//     right: 0,
//     bottom: 0,
//     display: ""flex"",
//     justifyContent: ""center"",
//     alignItems: ""center"",
//     background: ""#f0f0f0"",
//     pointerEvents: ""none"",
//   },
//   deviceContainer: {
//     position: ""absolute"",
//     margin: ""0 auto"",
//     borderRadius: ""30px"",
//     overflow: ""hidden"",
//   },
//   device: {
//     position: ""relative"",
//   },
//   screen: {
//     position: ""absolute"",
//     top: ""80px"",
//     left: ""20px"",
//     right: ""20px"",
//     bottom: ""80px"",
//     overflow: ""hidden"",
//     background: ""#fff"",
//     borderRadius: ""30px"",
//   },
//   iframe: {
//     border: ""none"",
//     overflowClipMargin: ""content-box"",
//     overflow: ""clip"",
//     width: ""100%"",
//     height: ""100%"",
//   },
//   mockupOverlay: {
//     position: ""absolute"",
//     top: ""50%"",
//     left: ""50%"",
//     transform: ""translate(-50%, -50%)"",
//     backgroundPosition: ""center"",
//     backgroundSize: ""contain"",
//     backgroundRepeat: ""no-repeat"",
//     opacity: ""0.8"",
//     pointerEvents: ""none"",
//   },
//   deviceSwitcher: {
//     position: ""absolute"",
//     bottom: ""20px"",
//     left: ""50%"",
//     transform: ""translateX(-50%)"",
//     display: ""flex"",
//     justifyContent: ""center"",
//   },
//   deviceSwitch: {
//     margin: ""0 10px"",
//     padding: ""5px 10px"",
//     border: ""none"",
//     borderRadius: ""5px"",
//     background: ""transparent"",
//     cursor: ""pointer"",
//   },
// };

// export default MockupContainer;
"
Content\mockup\utils\DeviceImages.js,Included,text/javascript,351,"// // I need to make this work for a Chrome extension, so I can't import images, instead it needs to be a string with the path to the image
// const URL = ""chrome-extension://__MSG_@@extension_id__/assets"";

// const PhoneTest = `${URL}/mockups/phone-test.png`;
// const wallpaper = `${URL}/mockups/1.png`;

// export { PhoneTest, wallpaper };
"
Content\modal\Modal.jsx,Included,application/octet-stream,4410,"import React, { useState, useEffect, useContext, useCallback } from ""react"";
import * as AlertDialog from ""@radix-ui/react-alert-dialog"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const Modal = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [title, setTitle] = useState(""Test"");
  const [description, setDescription] = useState(""Description here"");
  const [button1, setButton1] = useState(""Submit"");
  const [button2, setButton2] = useState(""Cancel"");
  const [trigger, setTrigger] = useState(() => {});
  const [trigger2, setTrigger2] = useState(() => {});
  const [showModal, setShowModal] = useState(false);
  const [image, setImage] = useState(null);
  const [learnmore, setLearnMore] = useState(null);
  const [learnMoreLink, setLearnMoreLink] = useState(() => {});
  const [colorSafe, setColorSafe] = useState(false);
  const [sideButton, setSideButton] = useState(false);
  const [sideButtonAction, setSideButtonAction] = useState(() => {});

  const openModal = useCallback(
    (
      title,
      description,
      button1,
      button2,
      action,
      action2,
      image = null,
      learnMore = null,
      learnMoreLink = null,
      colorSafe = false,
      sideButton = false,
      sideButtonAction = () => {}
    ) => {
      setTitle(title);
      setDescription(description);
      setButton1(button1);
      setButton2(button2);
      setShowModal(true);
      setTrigger(() => action);
      setTrigger2(() => action2);
      setImage(image);
      setLearnMore(learnMore);
      setLearnMoreLink(() => learnMoreLink);
      setColorSafe(colorSafe);
      setSideButton(sideButton);
      setSideButtonAction(() => sideButtonAction);
    }
  );

  useEffect(() => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      openModal: openModal,
    }));

    return () => {
      setContentState((prevContentState) => ({
        ...prevContentState,
        openModal: null,
      }));
    };
  }, []);

  return (
    <AlertDialog.Root
      open={showModal}
      modal={false}
      onOpenChange={(open) => {
        setShowModal(open);
      }}
    >
      <AlertDialog.Trigger asChild />
      <AlertDialog.Portal
        container={props.shadowRef.current.shadowRoot.querySelector(
          "".container""
        )}
      >
        <div className=""AlertDialogOverlay""></div>
        <AlertDialog.Content className=""AlertDialogContent"">
          <AlertDialog.Title className=""AlertDialogTitle"">
            {title}
          </AlertDialog.Title>
          <AlertDialog.Description className=""AlertDialogDescription"">
            {description}
            {learnmore && "" ""}
            {learnmore && (
              <a href={learnMoreLink} target=""_blank"">
                {learnmore}
              </a>
            )}
          </AlertDialog.Description>
          {image && (
            <img
              src={image}
              style={{
                width: ""100%"",
                marginBottom: 15,
                marginTop: 5,
                borderRadius: ""15px"",
              }}
            />
          )}
          <div style={{ display: ""flex"", gap: 12, justifyContent: ""flex-end"" }}>
            {sideButton && (
              <button
                className=""SideButtonModal""
                onClick={() => {
                  sideButtonAction();
                  setShowModal(false);
                }}
              >
                {sideButton}
              </button>
            )}
            {button2 && (
              <AlertDialog.Cancel asChild>
                <button className=""Button grey"" onClick={() => trigger2()}>
                  {button2}
                </button>
              </AlertDialog.Cancel>
            )}
            {button1 && (
              <AlertDialog.Action asChild>
                <button
                  className={!colorSafe ? ""Button red"" : ""Button blue""}
                  onClick={() => trigger()}
                >
                  {button1}
                </button>
              </AlertDialog.Action>
            )}
          </div>
        </AlertDialog.Content>
      </AlertDialog.Portal>
    </AlertDialog.Root>
  );
};

export default Modal;
"
Content\modal\styles\_Modal.scss,Excluded by file type,,0,
Content\popup\components\BackgroundEffects.jsx,Included,application/octet-stream,1911,"import React, { useContext } from ""react"";
import * as ToggleGroup from ""@radix-ui/react-toggle-group"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const BackgroundEffects = () => {
  const [contentState, setContentState] = React.useContext(contentStateContext);

  // Background images
  const URL =
    ""chrome-extension://"" +
    chrome.i18n.getMessage(""@@extension_id"") +
    ""/assets/"";

  const images = [
    URL + ""backgrounds/back1.webp"",
    URL + ""backgrounds/back2.webp"",
    URL + ""backgrounds/back3.webp"",
    URL + ""backgrounds/back4.webp"",
    URL + ""backgrounds/back5.webp"",
    URL + ""backgrounds/back6.webp"",
  ];

  return (
    <div className=""background-effects"">
      <ToggleGroup.Root
        className=""background-effects-toggle-group""
        type=""single""
        defaultValue=""blur""
        value={contentState.backgroundEffect}
        onValueChange={(value) => {
          if (value) {
            setContentState((prevContentState) => ({
              ...prevContentState,
              backgroundEffect: value,
            }));
            chrome.storage.local.set({ backgroundEffect: value });
          }
        }}
      >
        <ToggleGroup.Item
          className=""background-effect""
          value=""blur""
          aria-label=""Blur effect""
        >
          <span>{chrome.i18n.getMessage(""blurTypeLabel"")}</span>
          <img src={URL + ""backgrounds/blur.webp""} alt=""blur"" />
        </ToggleGroup.Item>
        {images.map((image, index) => (
          <ToggleGroup.Item
            className=""background-effect""
            value={image}
            aria-label=""Background image""
          >
            <img src={image} alt=""background"" />
          </ToggleGroup.Item>
        ))}
      </ToggleGroup.Root>
    </div>
  );
};

export default BackgroundEffects;
"
Content\popup\components\Dropdown.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,11784,"import React, { useEffect, useState, useContext, useRef } from ""react"";

import * as Select from ""@radix-ui/react-select"";
import {
  DropdownIcon,
  CheckWhiteIcon,
  CameraOnIcon,
  CameraOffIcon,
  MicOnIcon,
  MicOffIcon,
} from ""../../images/popup/images"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const Dropdown = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [label, setLabel] = useState(chrome.i18n.getMessage(""None""));
  const [open, setOpen] = useState(false);

  const updateItems = () => {
    if (props.type === ""camera"") {
      if (
        contentState.defaultVideoInput === ""none"" ||
        !contentState.cameraActive
      ) {
        setLabel(chrome.i18n.getMessage(""noCameraDropdownLabel""));
      } else {
        // Check if defaultVideoInput is in camdevices, if not set to none
        if (
          contentState.videoInput.find(
            (device) => device.deviceId === contentState.defaultVideoInput
          )
        ) {
          setLabel(
            contentState.videoInput.find(
              (device) => device.deviceId === contentState.defaultVideoInput
            ).label
          );
        } else {
          setLabel(chrome.i18n.getMessage(""noCameraDropdownLabel""));
        }
      }
    } else {
      if (
        contentState.defaultAudioInput === ""none"" ||
        (!contentState.micActive && !contentState.pushToTalk)
      ) {
        setLabel(chrome.i18n.getMessage(""noMicrophoneDropdownLabel""));
      } else {
        // Check if defaultAudioInput is in micdevices, if not set to none
        if (
          contentState.audioInput.find(
            (device) => device.deviceId === contentState.defaultAudioInput
          )
        ) {
          setLabel(
            contentState.audioInput.find(
              (device) => device.deviceId === contentState.defaultAudioInput
            ).label
          );
        } else {
          setLabel(chrome.i18n.getMessage(""noMicrophoneDropdownLabel""));
        }
      }
    }
  };

  useEffect(() => {
    updateItems();
  }, [
    contentState.defaultAudioInput,
    contentState.defaultVideoInput,
    contentState.audioInput,
    contentState.videoInput,
    contentState.cameraActive,
    contentState.micActive,
  ]);

  useEffect(() => {
    updateItems();
  }, []);

  const toggleActive = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setOpen(false);
    if (props.type === ""camera"") {
      if (contentState.cameraActive) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          cameraActive: false,
        }));
        chrome.storage.local.set({
          cameraActive: false,
        });
        setLabel(chrome.i18n.getMessage(""noCameraDropdownLabel""));
      } else {
        setContentState((prevContentState) => ({
          ...prevContentState,
          cameraActive: true,
        }));
        chrome.storage.local.set({
          cameraActive: true,
        });
        setLabel(
          contentState.videoInput.find(
            (device) => device.deviceId === contentState.defaultVideoInput
          ).label
        );
      }
    } else {
      if (contentState.micActive) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          micActive: false,
        }));
        chrome.storage.local.set({
          micActive: false,
        });
        setLabel(chrome.i18n.getMessage(""noMicrophoneDropdownLabel""));
      } else {
        setContentState((prevContentState) => ({
          ...prevContentState,
          micActive: true,
        }));
        chrome.storage.local.set({
          micActive: true,
        });
        setLabel(
          contentState.audioInput.find(
            (device) => device.deviceId === contentState.defaultAudioInput
          ).label
        );
      }
    }
  };

  const clickedIcon = useRef(false);

  return (
    <Select.Root
      open={open}
      onOpenChange={(open) => {
        if (clickedIcon.current) return;
        setOpen(open);
      }}
      value={
        props.type === ""camera"" && contentState.cameraActive
          ? contentState.defaultVideoInput
          : props.type === ""camera"" && !contentState.cameraActive
          ? ""none""
          : props.type === ""mic"" &&
            (contentState.micActive || contentState.pushToTalk)
          ? contentState.defaultAudioInput
          : props.type === ""mic"" && !contentState.micActive
          ? ""none""
          : ""none""
      }
      onValueChange={(newValue) => {
        if (props.type === ""camera"") {
          if (newValue === ""none"") {
            setContentState((prevContentState) => ({
              ...prevContentState,
              cameraActive: false,
            }));
            chrome.storage.local.set({
              cameraActive: false,
            });
            setLabel(chrome.i18n.getMessage(""noCameraDropdownLabel""));
          } else {
            setContentState((prevContentState) => ({
              ...prevContentState,
              defaultVideoInput: newValue,
              cameraActive: true,
            }));
            chrome.storage.local.set({
              defaultVideoInput: newValue,
              cameraActive: true,
            });
            chrome.runtime.sendMessage({
              type: ""switch-camera"",
              id: newValue,
            });
            setLabel(
              contentState.videoInput.find(
                (device) => device.deviceId === newValue
              ).label
            );
          }
        } else {
          if (newValue === ""none"") {
            setContentState((prevContentState) => ({
              ...prevContentState,
              micActive: false,
            }));
            chrome.storage.local.set({
              micActive: false,
            });
            setLabel(chrome.i18n.getMessage(""noMicrophoneDropdownLabel""));
          } else {
            setContentState((prevContentState"
Content\popup\components\RegionDimensions.jsx,Included,application/octet-stream,2617,"import React, { useState, useRef, useContext, useEffect } from ""react"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const RegionDimensions = () => {
  const [contentState, setContentState] = useContext(contentStateContext);

  const handleWidth = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      regionWidth: value,
      fromRegion: false,
    }));
    chrome.storage.local.set({
      regionWidth: value,
    });
  };

  const handleHeight = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      regionHeight: value,
      fromRegion: false,
    }));
    chrome.storage.local.set({
      regionHeight: value,
    });
  };

  return (
    <div className=""region-dimensions"">
      <div className=""region-input"">
        <label htmlFor=""region-width"" style={{ display: ""none"" }}>
          {chrome.i18n.getMessage(""regionWidthLabel"")}
        </label>
        <input
          id=""region-width""
          onChange={(e) => handleWidth(e)}
          onBlur={(e) => {
            if (e.target.value === """") {
              setContentState((prevContentState) => ({
                ...prevContentState,
                regionWidth: 100,
                fromRegion: false,
              }));
              chrome.storage.local.set({
                regionWidth: 100,
              });
            }
          }}
          value={contentState.regionWidth}
        />
        <span>W</span>
      </div>
      <div className=""region-input"">
        <label htmlFor=""region-height"" style={{ display: ""none"" }}>
          {chrome.i18n.getMessage(""regionHeightLabel"")}
        </label>
        <input
          id=""region-height""
          onChange={(e) => handleHeight(e)}
          onBlur={(e) => {
            if (e.target.value === """") {
              setContentState((prevContentState) => ({
                ...prevContentState,
                regionHeight: 100,
                fromRegion: false,
              }));
              chrome.storage.local.set({
                regionHeight: 100,
              });
            }
          }}
          value={contentState.regionHeight}
        />
        <span>H</span>
      </div>
    </div>
  );
};

export default RegionDimensions;
"
Content\popup\components\Switch.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,9073,"import React, { useContext, useEffect, useState, useRef } from ""react"";
import * as S from ""@radix-ui/react-switch"";

// Components
import { DropdownIcon } from ""../../images/popup/images"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const Switch = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const switchRef = useRef(null);
  const [hideToolbarLabel, setHideToolbarLabel] = useState(
    chrome.i18n.getMessage(""hideToolbarLabel"")
  );
  const [hideToolbarState, setHideToolbarState] = useState(1);

  useEffect(() => {
    // Check click outside
    const handleClickOutside = (event) => {
      if (props.name != ""hideUI"") return;
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target) &&
        !dropdownInRef.current.contains(event.target)
      ) {
        if (dropdownRef.current.querySelector("":hover"")) return;
        if (dropdownInRef.current.querySelector("":hover"")) return;
        // Check if any children of dropdownref are clicked also
        let children = dropdownRef.current.querySelectorAll(""*"");
        for (let i = 0; i < children.length; i++) {
          if (children[i].contains(event.target)) return;
        }

        dropdownRef.current.classList.remove(""labelDropdownActive"");
      }
    };

    // Bind the event listener
    document.addEventListener(""click"", handleClickOutside);

    return () => {
      // Unbind the event listener on clean up
      document.removeEventListener(""click"", handleClickOutside);
    };
  }, []);

  useEffect(() => {
    if (props.name === ""hideUI"") {
      if (contentState.hideUIAlerts) {
        setHideToolbarLabel(chrome.i18n.getMessage(""hideUIAlerts""));
        setHideToolbarState(2);
      } else if (contentState.hideToolbar) {
        setHideToolbarLabel(chrome.i18n.getMessage(""hideToolbarLabel""));
        setHideToolbarState(1);
      } else if (contentState.toolbarHover) {
        setHideToolbarLabel(chrome.i18n.getMessage(""toolbarHoverOnly""));
        setHideToolbarState(3);
      }
    }
  }, [contentState.hideToolbar]);

  const dropdownRef = useRef(null);
  const dropdownInRef = useRef(null);
  return (
    <form>
      <div className=""SwitchRow"">
        <label
          className=""Label""
          htmlFor={props.name}
          style={{ paddingRight: 15 }}
          onClick={(e) => {
            if (props.name === ""hideUI"") {
              e.preventDefault();
              e.stopPropagation();
              if (e.target.classList.contains(""labelDropdownContentItem""))
                return;
              dropdownRef.current.classList.toggle(""labelDropdownActive"");
            }
          }}
        >
          {props.name !== ""hideUI"" && props.label}
          {props.name === ""hideUI"" && (
            <div className=""labelDropdownWrap"" ref={dropdownRef}>
              <div className=""labelDropdown"" ref={dropdownInRef}>
                {hideToolbarLabel}
                <img src={DropdownIcon} />
              </div>
              <div className=""labelDropdownContent"">
                <div
                  className=""labelDropdownContentItem""
                  onClick={() => {
                    setContentState((prevContentState) => ({
                      ...prevContentState,
                      hideToolbar: true,
                      hideUIAlerts: false,
                      toolbarHover: false,
                    }));
                    chrome.storage.local.set({
                      hideToolbar: true,
                      hideUIAlerts: false,
                      toolbarHover: false,
                    });
                    setHideToolbarLabel(
                      chrome.i18n.getMessage(""hideToolbarLabel"")
                    );
                    dropdownRef.current.classList.remove(""labelDropdownActive"");
                    setHideToolbarState(1);
                  }}
                >
                  {chrome.i18n.getMessage(""hideToolbarLabel"")}
                </div>
                <div
                  className=""labelDropdownContentItem""
                  onClick={() => {
                    setContentState((prevContentState) => ({
                      ...prevContentState,
                      hideToolbar: false,
                      hideUIAlerts: true,
                      toolbarHover: false,
                    }));
                    chrome.storage.local.set({
                      hideToolbar: false,
                      hideUIAlerts: true,
                      toolbarHover: false,
                    });
                    setHideToolbarLabel(chrome.i18n.getMessage(""hideUIAlerts""));
                    dropdownRef.current.classList.remove(""labelDropdownActive"");
                    setHideToolbarState(2);
                  }}
                >
                  {chrome.i18n.getMessage(""hideUIAlerts"")}
                </div>
                <div
                  className=""labelDropdownContentItem""
                  onClick={() => {
                    setContentState((prevContentState) => ({
                      ...prevContentState,
                      hideToolbar: false,
                      hideUIAlerts: false,
                      toolbarHover: true,
                    }));
                    chrome.storage.local.set({
                      hideToolbar: false,
                      hideUIAlerts: false,
                      toolbarHover: true,
                    });
                    setHideToolbarLabel(
                      chrome.i18n.getMessage(""toolbarHoverOnly"")
                    );
                    dropdownRef.current.classList.remove(""labelDropdownActive"");
                    setHideToolbarState(3);
                  }}
                >
                  {chrome.i18n.getMessage(""toolbarHoverOnly"")}
                </div>
              </div>
            </div>
          )}
          {props.experimental && (
            <span className=""Exp"
Content\popup\components\TimeSetter.jsx,Included,application/octet-stream,4576,"import React, { useContext, useEffect, useState, useRef } from ""react"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const TimeSetter = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [hours, setHours] = useState(Math.floor(contentState.alarmTime / 3600));
  const [minutes, setMinutes] = useState(
    Math.floor((contentState.alarmTime % 3600) / 60)
  );
  const [seconds, setSeconds] = useState(
    Math.floor((contentState.alarmTime % 3600) % 60)
  );

  useEffect(() => {
    // Get from contentState
    setHours(Math.floor(contentState.alarmTime / 3600));
    setMinutes(Math.floor((contentState.alarmTime % 3600) / 60));
    setSeconds(Math.floor((contentState.alarmTime % 3600) % 60));
  }, []);

  useEffect(() => {
    if (!contentState.fromAlarm) return;
    // Set the time in seconds
    setHours(Math.floor(contentState.alarmTime / 3600));
    setMinutes(Math.floor((contentState.alarmTime % 3600) / 60));
    setSeconds(Math.floor((contentState.alarmTime % 3600) % 60));
  }, [contentState.alarmTime]);

  useEffect(() => {
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
    if (hours === """" || minutes === """" || seconds === """") return;
    setHours(parseFloat(hours));
    setMinutes(parseFloat(minutes));
    setSeconds(parseFloat(seconds));
    // Set the time in seconds
    setContentState((prevContentState) => ({
      ...prevContentState,
      alarmTime: hours * 3600 + minutes * 60 + seconds,
      fromAlarm: false,
      time: hours * 3600 + minutes * 60 + seconds,
      timer: hours * 3600 + minutes * 60 + seconds,
    }));
    chrome.storage.local.set({
      alarmTime: hours * 3600 + minutes * 60 + seconds,
    });
  }, [hours, minutes, seconds]);

  useEffect(() => {
    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) return;
    if (contentState.alarm) {
      setContentState((prevContentState) => ({
        ...prevContentState,
        time: hours * 3600 + minutes * 60 + seconds,
        timer: hours * 3600 + minutes * 60 + seconds,
        fromAlarm: false,
      }));
    } else {
      setContentState((prevContentState) => ({
        ...prevContentState,
        time: 0,
        timer: 0,
      }));
    }
  }, [contentState.alarm]);

  const handleHours = (e) => {
    // Limit between 0 to 4, number only
    // Only 1 digit
    if (e.target.value.length > 1) {
      if (e.target.value[0] === ""0"") {
        e.target.value = parseFloat(e.target.value[1]);
      } else {
        return;
      }
    }
    if (isNaN(e.target.value)) {
      return;
    }
    if (e.target.value > 4) {
      e.target.value = 4;
    }
    setContentState((prevContentState) => ({
      ...prevContentState,
      fromAlarm: true,
    }));

    setHours(e.target.value);
  };

  const handleMinutes = (e) => {
    // Limit between 0 to 59, number only
    if (isNaN(e.target.value)) {
      return;
    }
    if (e.target.value > 59) {
      e.target.value = 59;
    }
    setContentState((prevContentState) => ({
      ...prevContentState,
      fromAlarm: true,
    }));

    setMinutes(e.target.value);
  };

  const handleSeconds = (e) => {
    // Limit between 0 to 59, number only
    if (isNaN(e.target.value)) {
      return;
    }
    if (e.target.value > 59) {
      e.target.value = 59;
    }
    setContentState((prevContentState) => ({
      ...prevContentState,
      fromAlarm: true,
    }));
    setSeconds(e.target.value);
  };

  return (
    <div className=""time-set-parent"">
      <div className=""time-set-input"">
        <input
          placeholder=""0""
          onChange={handleMinutes}
          value={minutes}
          onBlur={(e) => {
            if (e.target.value === """") {
              e.target.value = 0;
              setMinutes(0);
            }
          }}
          onFocus={(e) => {
            e.target.select();
          }}
        />
        <span>M</span>
      </div>
      <div className=""time-set-input"">
        <input
          placeholder=""0""
          onChange={handleSeconds}
          value={seconds}
          onBlur={(e) => {
            if (e.target.value === """") {
              e.target.value = 0;
              setSeconds(0);
            }
          }}
          onFocus={(e) => {
            e.target.select();
          }}
        />
        <span>S</span>
      </div>
    </div>
  );
};

export default TimeSetter;
"
Content\popup\components\TooltipWrap.jsx,Included,application/octet-stream,1758,"import React, { useEffect, useContext, useState } from ""react"";

import * as Tooltip from ""@radix-ui/react-tooltip"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const TooltipWrap = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const classname = props.name ? props.name : """";
  const [override, setOverride] = useState("""");

  useEffect(() => {
    // Check if hideUI is set
    if (contentState.hideUI) {
      setOverride(""override"");
    } else {
      setOverride("""");
    }
  }, [contentState.hideUI]);

  return (
    <div className={classname} style={props.style}>
      {props.content == """" ? (
        <div>{props.children}</div>
      ) : (
        <Tooltip.Provider>
          <Tooltip.Root delayDuration={700} defaultOpen={false}>
            <Tooltip.Trigger asChild>{props.children}</Tooltip.Trigger>
            <Tooltip.Portal
              container={
                document.getElementsByClassName(""screenity-shadow-dom"")[0]
              }
            >
              <Tooltip.Content
                className={
                  ""TooltipContent"" +
                  "" "" +
                  props.override +
                  "" "" +
                  props.hide +
                  "" "" +
                  override
                }
                style={{
                  display: override === ""override"" ? ""none"" : ""block"",
                }}
                side={""left""}
              >
                {props.content}
              </Tooltip.Content>
            </Tooltip.Portal>
          </Tooltip.Root>
        </Tooltip.Provider>
      )}
    </div>
  );
};

export default TooltipWrap;
"
Content\popup\components\VideoItem.jsx,Included,application/octet-stream,1271,"import React from ""react"";

import { CopyLinkIcon, MoreActionsIcon } from ""../../images/popup/images"";

const VideoItem = (props) => {
  return (
    <div className=""video-item-root"" tabIndex=""0"">
      <div className=""video-item"">
        <div className=""video-item-left"">
          <div
            className=""video-item-thumbnail""
            style={{
              backgroundImage: ""url("" + props.thumbnail + "")"",
              backgroundSize: ""cover"",
              backgroundPosition: ""center"",
            }}
          ></div>
          <div className=""video-item-info"">
            <div className=""video-item-info-title"">{props.title}</div>
            <div className=""video-item-info-date"">{props.date}</div>
          </div>
        </div>
        <div className=""video-item-right"">
          <button role=""button"" tabIndex=""0"" className=""copy-link"">
            <img src={CopyLinkIcon} />
            Copy link
          </button>
          <button
            role=""button""
            tabIndex=""0""
            title=""More actions""
            className=""more-actions""
          >
            <img src={MoreActionsIcon} />
          </button>
        </div>
      </div>
    </div>
  );
};

export default VideoItem;
"
Content\popup\layout\Announcement.jsx,Included,application/octet-stream,1715,"import React, { useState, useEffect } from ""react"";

const Announcement = (props) => {
  const [URL, setURL] = useState(
    ""https://help.screenity.io/getting-started/77KizPC8MHVGfpKpqdux9D/what%E2%80%99s-changed-in-the-new-version-of-screenity/bDtvcwAtw9PPesQeNH4zjE""
  );

  useEffect(() => {
    // check i18n locale, and set URL accordingly w/ google translate
    const locale = chrome.i18n.getMessage(""@@ui_locale"");
    if (!locale.includes(""en"")) {
      setURL(
        ""https://translate.google.com/translate?sl=en&tl="" +
          locale +
          ""&u="" +
          URL
      );
    }
  }, []);
  return (
    <div className=""announcement"">
      <div className=""announcement-wrap"">
        <div className=""announcement-hero"">
          <img src={chrome.runtime.getURL(""assets/helper/hero.png"")} />
        </div>
        <div className=""announcement-details"">
          <div className=""announcement-title"">
            {chrome.i18n.getMessage(""updateAnnouncementTitle"")} 
          </div>
          <div className=""announcement-description"">
            {chrome.i18n.getMessage(""updateAnnouncementDescription"")}{"" ""}
            <a href={URL} target=""_blank"">
              {chrome.i18n.getMessage(""updateAnnouncementLearnMore"")}
            </a>
          </div>
          <div
            className=""announcement-cta""
            onClick={() => {
              props.setOnboarding(false);
              chrome.storage.local.set({ updatingFromOld: false });
            }}
          >
            {chrome.i18n.getMessage(""updateAnnouncementButton"")}
          </div>
        </div>
      </div>
    </div>
  );
};

export default Announcement;
"
Content\popup\layout\RecordingTab.jsx,Included,application/octet-stream,4197,"import React, { useEffect, useState, useContext } from ""react"";
import * as Tabs from ""@radix-ui/react-tabs"";

import RecordingType from ""./RecordingType"";
import {
  ScreenTabOn,
  ScreenTabOff,
  RegionTabOn,
  RegionTabOff,
  MockupTabOn,
  MockupTabOff,
  CameraTabIconOn,
  CameraTabIconOff,
} from ""../../images/popup/images"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const RecordingTab = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);

  const onValueChange = (tab) => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      recordingType: tab,
    }));
    chrome.storage.local.set({ recordingType: tab });

    if (tab === ""camera"") {
      chrome.runtime.sendMessage({ type: ""camera-only-update"" });
    } else {
      chrome.runtime.sendMessage({ type: ""screen-update"" });
    }
  };

  return (
    <div className=""recording-ui"">
      <Tabs.Root
        className=""TabsRoot""
        defaultValue=""screen""
        onValueChange={onValueChange}
        value={contentState.recordingType}
      >
        <Tabs.List
          className=""TabsList""
          aria-label=""Manage your account""
          tabIndex={0}
        >
          <Tabs.Trigger className=""TabsTrigger"" value=""screen"" tabIndex={0}>
            <div className=""TabsTriggerLabel"">
              <div className=""TabsTriggerIcon"">
                <img
                  src={
                    contentState.recordingType === ""screen""
                      ? ScreenTabOn
                      : ScreenTabOff
                  }
                />
              </div>
              <span>{chrome.i18n.getMessage(""screenType"")}</span>
            </div>
          </Tabs.Trigger>
          <Tabs.Trigger className=""TabsTrigger"" value=""region"" tabIndex={0}>
            <div className=""TabsTriggerLabel"">
              <div className=""TabsTriggerIcon"">
                <img
                  src={
                    contentState.recordingType === ""region""
                      ? RegionTabOn
                      : RegionTabOff
                  }
                />
              </div>
              <span>{chrome.i18n.getMessage(""tabType"")}</span>
            </div>
          </Tabs.Trigger>
          <Tabs.Trigger className=""TabsTrigger"" value=""camera"" tabIndex={0}>
            <div className=""TabsTriggerLabel"">
              <div className=""TabsTriggerIcon"">
                <img
                  src={
                    contentState.recordingType === ""camera""
                      ? CameraTabIconOn
                      : CameraTabIconOff
                  }
                />
              </div>
              <span>{chrome.i18n.getMessage(""cameraType"")}</span>
            </div>
          </Tabs.Trigger>
          <Tabs.Trigger
            className=""TabsTrigger""
            value=""mockup""
            tabIndex={0}
            disabled
            style={{ pointerEvents: ""none"", opacity: 0.5 }}
          >
            <div className=""TabsTriggerLabel"">
              <div className=""TabsTriggerIcon"">
                <img
                  src={
                    contentState.recordingType === ""mockup""
                      ? MockupTabOn
                      : MockupTabOff
                  }
                />
              </div>
              <span>{chrome.i18n.getMessage(""MockupType"")}</span>
            </div>
          </Tabs.Trigger>
        </Tabs.List>
        <Tabs.Content className=""TabsContent"" value=""screen"">
          <RecordingType shadowRef={props.shadowRef} />
        </Tabs.Content>
        <Tabs.Content className=""TabsContent"" value=""region"">
          <RecordingType shadowRef={props.shadowRef} />
        </Tabs.Content>
        <Tabs.Content className=""TabsContent"" value=""camera"">
          <RecordingType shadowRef={props.shadowRef} />
        </Tabs.Content>
        <Tabs.Content className=""TabsContent"" value=""mockup"">
          WIP
        </Tabs.Content>
      </Tabs.Root>
    </div>
  );
};

export default RecordingTab;
"
Content\popup\layout\RecordingType.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,11145,"import React, { useEffect, useContext, useState, useRef } from ""react"";

import Dropdown from ""../components/Dropdown"";
import Switch from ""../components/Switch"";
import RegionDimensions from ""../components/RegionDimensions"";
import Settings from ""./Settings"";
import { contentStateContext } from ""../../context/ContentState"";
import { CameraOffBlue, MicOffBlue } from ""../../images/popup/images"";

import BackgroundEffects from ""../components/BackgroundEffects"";

import { AlertIcon, TimeIcon, NoInternet } from ""../../toolbar/components/SVG"";

const RecordingType = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [cropActive, setCropActive] = useState(false);
  const [time, setTime] = useState(0);
  const [URL, setURL] = useState(
    ""https://help.screenity.io/getting-started/77KizPC8MHVGfpKpqdux9D/what-are-the-technical-requirements-for-using-screenity/6kdB6qru6naVD8ZLFvX3m9""
  );
  const [URL2, setURL2] = useState(
    ""https://help.screenity.io/troubleshooting/9Jy5RGjNrBB42hqUdREQ7W/how-to-grant-screenity-permission-to-record-your-camera-and-microphone/x6U69TnrbMjy5CQ96Er2E9""
  );

  const buttonRef = useRef(null);
  const isMac = navigator.platform.toUpperCase().indexOf(""MAC"") >= 0;

  useEffect(() => {
    const locale = chrome.i18n.getMessage(""@@ui_locale"");
    if (!locale.includes(""en"")) {
      setURL(
        `https://translate.google.com/translate?sl=en&tl=${locale}&u=https://help.screenity.io/getting-started/77KizPC8MHVGfpKpqdux9D/what-are-the-technical-requirements-for-using-screenity/6kdB6qru6naVD8ZLFvX3m9`
      );
      setURL2(
        `https://translate.google.com/translate?sl=en&tl=${locale}&u=https://help.screenity.io/troubleshooting/9Jy5RGjNrBB42hqUdREQ7W/how-to-grant-screenity-permission-to-record-your-camera-and-microphone/x6U69TnrbMjy5CQ96Er2E9`
      );
    }
  }, []);

  useEffect(() => {
    // Convert seconds to mm:ss
    let minutes = Math.floor(contentState.alarmTime / 60);
    let seconds = contentState.alarmTime - minutes * 60;
    if (seconds < 10) {
      seconds = ""0"" + seconds;
    }
    setTime(minutes + "":"" + seconds);
  }, []);

  useEffect(() => {
    // Convert seconds to mm:ss
    let minutes = Math.floor(contentState.alarmTime / 60);
    let seconds = contentState.alarmTime - minutes * 60;
    if (seconds < 10) {
      seconds = ""0"" + seconds;
    }
    setTime(minutes + "":"" + seconds);
  }, [contentState.alarmTime]);

  // Start recording
  const startStreaming = () => {
    contentState.startStreaming();
  };

  useEffect(() => {
    // Check if CropTarget is null
    if (typeof CropTarget === ""undefined"") {
      setCropActive(false);
      setContentState((prevContentState) => ({
        ...prevContentState,
        customRegion: false,
      }));
    } else {
      setCropActive(true);
    }
  }, []);

  useEffect(() => {
    if (contentState.recording) {
      setContentState((prevContentState) => ({
        ...prevContentState,
        pendingRecording: false,
      }));
    }
  }, [contentState.recording]);

  return (
    <div>
      {contentState.updateChrome && (
        <div className=""popup-warning"">
          <div className=""popup-warning-left"">
            <AlertIcon />
          </div>
          <div className=""popup-warning-middle"">
            <div className=""popup-warning-title"">
              {chrome.i18n.getMessage(""customAreaRecordingDisabledTitle"")}
            </div>
            <div className=""popup-warning-description"">
              {chrome.i18n.getMessage(""customAreaRecordingDisabledDescription"")}
            </div>
          </div>
          <div className=""popup-warning-right"">
            <a href={URL} target=""_blank"">
              {chrome.i18n.getMessage(""customAreaRecordingDisabledAction"")}
            </a>
          </div>
        </div>
      )}
      {/*contentState.offline && (
        <div className=""popup-warning"">
          <div className=""popup-warning-left"">
            <NoInternet />
          </div>
          <div className=""popup-warning-middle"">
            <div className=""popup-warning-title"">You are currently offline</div>
            <div className=""popup-warning-description"">
              Some features are unavailable
            </div>
          </div>
          <div className=""popup-warning-right"">
            <a href=""#"">Try again</a>
          </div>
        </div>
			)*/}
      {!cropActive &&
        contentState.recordingType === ""region"" &&
        !contentState.offline && (
          <div className=""popup-warning"">
            <div className=""popup-warning-left"">
              <AlertIcon />
            </div>
            <div className=""popup-warning-middle"">
              <div className=""popup-warning-title"">
                {chrome.i18n.getMessage(""customAreaRecordingDisabledTitle"")}
              </div>
              <div className=""popup-warning-description"">
                {chrome.i18n.getMessage(
                  ""customAreaRecordingDisabledDescription""
                )}
              </div>
            </div>
            <div className=""popup-warning-right"">
              <a
                href=""https://support.google.com/chrome/answer/95414?hl=en-GB&co=GENIE.Platform%3DDesktop""
                target=""_blank""
              >
                {chrome.i18n.getMessage(""customAreaRecordingDisabledAction"")}
              </a>
            </div>
          </div>
        )}
      {!contentState.cameraPermission && (
        <button
          className=""permission-button""
          onClick={() => {
            if (typeof contentState.openModal === ""function"") {
              contentState.openModal(
                chrome.i18n.getMessage(""permissionsModalTitle""),
                chrome.i18n.getMessage(""permissionsModalDescription""),
                chrome.i18n.getMessage(""permissionsModalReview""),
                chrome.i18n.getMessage(""permissionsModalDismiss""),
                () => {
                  chrome.runtime.sendMessage({
       "
Content\popup\layout\Settings.jsx,Included,application/octet-stream,2971,"import React, { useState, useContext, useEffect } from ""react"";
import * as Collapsible from ""@radix-ui/react-collapsible"";
import { DropdownIcon } from ""../../images/popup/images"";

// Components
import Switch from ""../components/Switch"";
import TimeSetter from ""../components/TimeSetter"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const Settings = () => {
  const [open, setOpen] = useState(false);
  const [contentState, setContentState] = useContext(contentStateContext);
  const [chromeVersion, setChromeVersion] = useState(null);
  // Check if Mac
  const isMac = navigator.platform.toUpperCase().indexOf(""MAC"") >= 0;
  // Set shortcut to Option+Shift+E on Mac and Alt+Shift+E on Windows, using character codes
  const shortcut = isMac ? ""E"" : ""AltE"";

  // Get Chrome version
  const getChromeVersion = () => {
    var raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    return raw ? parseInt(raw[2], 10) : false;
  };

  useEffect(() => {
    setChromeVersion(getChromeVersion());
  }, []);

  useEffect(() => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      settingsOpen: open,
    }));
  }, [open]);

  return (
    <Collapsible.Root
      className=""CollapsibleRoot""
      open={open}
      onOpenChange={setOpen}
    >
      <Collapsible.Trigger className=""CollapsibleTrigger"">
        <div className=""CollapsibleLabel"">
           {chrome.i18n.getMessage(""showMoreOptionsLabel"")}{"" ""}
          <img src={DropdownIcon} />
        </div>
      </Collapsible.Trigger>
      <Collapsible.Content>
        <Switch
          label={chrome.i18n.getMessage(""hideToolbarLabel"")}
          name=""hideUI""
          value=""hideUI""
        />
        <Switch
          label={chrome.i18n.getMessage(""countdownLabel"")}
          name=""countdown""
          value=""countdown""
        />
        <Switch
          label={chrome.i18n.getMessage(""alarmLabel"")}
          name=""alarm""
          value=""alarm""
        />
        {contentState.alarm && <TimeSetter />}
        <Switch
          label={chrome.i18n.getMessage(""micReminderPopup"")}
          name=""askMicrophone""
          value=""askMicrophone""
        />
        {contentState.recordingType != ""region"" &&
          contentState.recordingType != ""camera"" &&
          (chromeVersion === null || chromeVersion >= 109) && (
            <Switch
              label={chrome.i18n.getMessage(""stayInPagePopup"")}
              name=""offscreenRecording""
              value=""offscreenRecording""
            />
          )}
        <Switch
          label={
            chrome.i18n.getMessage(""zoomToPointPopup"") + "" ("" + shortcut + "")""
          }
          name=""zoomEnabled""
          value=""zoomEnabled""
          experimental={true}
        />
      </Collapsible.Content>
    </Collapsible.Root>
  );
};

export default Settings;
"
Content\popup\layout\SettingsMenu.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,24478,"// Work in progress - settings for the recording

import React, { useState, useContext, useRef, useEffect } from ""react"";
import * as DropdownMenu from ""@radix-ui/react-dropdown-menu"";

import { MoreIconPopup } from ""../../toolbar/components/SVG"";

import TooltipWrap from ""../components/TooltipWrap"";

import { CheckWhiteIcon, DropdownGroup } from ""../../images/popup/images"";

import JSZip from ""jszip"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const SettingsMenu = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [restore, setRestore] = useState(false);
  const [oldChrome, setOldChrome] = useState(false);
  const [openQuality, setOpenQuality] = useState(false);
  const [openResize, setOpenResize] = useState(false);
  const [openFPS, setOpenFPS] = useState(false);
  const [RAM, setRAM] = useState(0);
  const [width, setWidth] = useState(0);
  const [height, setHeight] = useState(0);

  useEffect(() => {
    // Check chrome version
    const chromeVersion = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    const MIN_CHROME_VERSION = 110;

    if (chromeVersion && parseInt(chromeVersion[2], 10) < MIN_CHROME_VERSION) {
      setOldChrome(true);
    }
  }, []);

  // Check if user has enough RAM to record for each quality option
  useEffect(() => {
    if (width === 0 || height === 0) return;
    const checkRAM = () => {
      const ram = navigator.deviceMemory;

      // Check if ramValue needs to be updated
      if (
        (ram < 2 || width < 1280 || height < 720) &&
        (contentState.qualityValue === ""720p"" ||
          contentState.qualityValue === ""4k"" ||
          contentState.qualityValue === ""1080p"")
      ) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          qualityValue: ""480p"",
        }));
        chrome.storage.local.set({
          qualityValue: ""480p"",
        });
      } else if (
        (ram < 8 || width < 3840 || height < 2160) &&
        contentState.qualityValue === ""4k""
      ) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          qualityValue: ""720p"",
        }));
        chrome.storage.local.set({
          qualityValue: ""720p"",
        });
      }

      setRAM(ram);
    };
    checkRAM();
  }, [contentState.qualityValue, width, height]);

  const handleTroubleshooting = () => {
    if (typeof contentState.openModal === ""function"") {
      contentState.openModal(
        chrome.i18n.getMessage(""troubleshootModalTitle""),
        chrome.i18n.getMessage(""troubleshootModalDescription""),
        chrome.i18n.getMessage(""troubleshootModalButton""),
        chrome.i18n.getMessage(""sandboxEditorCancelButton""),
        () => {
          // Need to create a file with the original data, any console logs, and system info
          const userAgent = navigator.userAgent;
          let platformInfo = {};
          chrome.runtime
            .sendMessage({ type: ""get-platform-info"" })
            .then((response) => {
              platformInfo = response;
              const manifestInfo = chrome.runtime.getManifest().version;

              // Now we need to create a file with all of this data
              const data = {
                userAgent: userAgent,
                platformInfo: platformInfo,
                manifestInfo: manifestInfo,
                defaultAudioInput: contentState.defaultAudioInput,
                defaultAudioOutput: contentState.defaultAudioOutput,
                defaultVideoInput: contentState.defaultVideoInput,
                quality: contentState.quality,
                systemAudio: contentState.systemAudio,
                audioInput: contentState.audioInput,
                audioOutput: contentState.audioOutput,
                backgroundEffectsActive: contentState.backgroundEffectsActive,
                recording: contentState.recording,
                recordingType: contentState.recordingType,
                askForPermissions: contentState.askForPermissions,
                cameraPermission: contentState.cameraPermission,
                microphonePermission: contentState.microphonePermission,
                askMicrophone: contentState.askMicrophone,
                cursorMode: contentState.cursorMode,
                zoomEnabled: contentState.zoomEnabled,
                offscreenRecording: contentState.offscreenRecording,
                updateChrome: contentState.updateChrome,
                permissionsChecked: contentState.permissionsChecked,
                permissionsLoaded: contentState.permissionsLoaded,
                hideUI: contentState.hideUI,
                alarm: contentState.alarm,
                alarmTime: contentState.alarmTime,
                surface: contentState.surface,
                blurMode: contentState.blurMode,
                //contentState: contentStateData,
              };
              // Create a zip file with the original recording and the data
              const zip = new JSZip();
              zip.file(""troubleshooting.json"", JSON.stringify(data));
              zip.generateAsync({ type: ""blob"" }).then(function (blob) {
                const url = window.URL.createObjectURL(blob);

                // Download file
                const a = document.createElement(""a"");
                a.href = url;
                a.download = ""screenity-troubleshooting.zip"";
                a.click();
                window.URL.revokeObjectURL(url);

                chrome.runtime.sendMessage({
                  type: ""indexed-db-download"",
                });
              });
            });
        },
        () => {}
      );
    }
  };

  useEffect(() => {
    setWidth(Math.round(window.screen.width * window.devicePixelRatio));
    setHeight(Math.round(window.screen.height * window.devicePixelRatio));
  }, []);

  return (
    <DropdownMenu.Root
      open={props.open}
      onOpenChange={(open) => {
        props.setOpen(open);

     "
Content\popup\layout\VideosTab.jsx,Included,application/octet-stream,3753,"import React, { useState, useEffect } from ""react"";
import * as Tabs from ""@radix-ui/react-tabs"";

import VideoItem from ""../components/VideoItem"";

import {
  TempTwitter,
  TempDesignSystem,
  TempFigma,
  TempSubstack,
  TempMarketing,
  DropdownIcon,
} from ""../../images/popup/images"";

const VideosTab = () => {
  const [URL, SetURL] = useState(""https://tally.so/r/npojNV"");

  useEffect(() => {
    const locale = chrome.i18n.getMessage(""@@ui_locale"");
    if (!locale.includes(""en"")) {
      SetURL(
        `https://translate.google.com/translate?sl=en&tl=${locale}&u=https://tally.so/r/npojNV`
      );
    }
  }, []);

  // Example temporary data
  const videos = [
    { name: ""Bug report"", thumbnail: TempTwitter, date: ""3 minutes ago"" },
    { name: ""Figma async review"", thumbnail: TempFigma, date: ""1 hour ago"" },
    {
      name: ""Design systems onboarding"",
      thumbnail: TempDesignSystem,
      date: ""4 days ago"",
    },
    { name: ""Cool SaaS resources"", thumbnail: TempMarketing, date: ""Feb 12"" },
    { name: ""Newsletter promo"", thumbnail: TempSubstack, date: ""Jan 23"" },
  ];

  return (
    <div className=""video-ui"">
      <div className=""ModalSoon"">
        <div className=""ModalSoonEmoji""></div>
        <div className=""ModalSoonTitle"">
          {chrome.i18n.getMessage(""shareModalSandboxTitle"")}
        </div>
        <div className=""ModalSoonDescription"">
          {chrome.i18n.getMessage(""shareModalSandboxDescription"")}
        </div>
        <a className=""ModalSoonButton"" href={URL} target=""_blank"">
          {chrome.i18n.getMessage(""shareModalSandboxButton"")}
        </a>
      </div>
      <Tabs.Root className=""TabsRoot"" defaultValue=""personal"">
        <Tabs.List className=""TabsList"" aria-label=""Manage your account"">
          <div className=""TabsTriggerWrap"">
            <Tabs.Trigger className=""TabsTrigger"" value=""personal"">
              <div className=""TabsTriggerLabel"">
                <span>Personal</span>
              </div>
            </Tabs.Trigger>
            <Tabs.Trigger className=""TabsTrigger"" value=""team"">
              <div className=""TabsTriggerLabel"">
                <span>Team</span>
              </div>
            </Tabs.Trigger>
            <Tabs.Trigger className=""TabsTrigger"" value=""shared"">
              <div className=""TabsTriggerLabel"">
                <span>Shared</span>
              </div>
            </Tabs.Trigger>
          </div>
          <div className=""TabsSort"" tabIndex=""0"">
            <div className=""TabsSortLabel"">
              Latest <img src={DropdownIcon} />
            </div>
          </div>
        </Tabs.List>
        <Tabs.Content className=""TabsContent"" value=""personal"">
          <div className=""videos-list"">
            {videos.map((video, i) => (
              <VideoItem
                title={video.name}
                key={i}
                date={video.date}
                thumbnail={video.thumbnail}
              />
            ))}
          </div>
          <div className=""bottom-section"">
            <button
              role=""button""
              className=""main-button dashboard-button""
              tabIndex=""0""
            >
              <span className=""main-button-label"">Go to dashboard</span>
              <span className=""main-button-shortcut"">Ctrl+D</span>
            </button>
          </div>
        </Tabs.Content>
        <Tabs.Content className=""TabsContent"" value=""team"">
          Temp
        </Tabs.Content>
        <Tabs.Content className=""TabsContent"" value=""shared"">
          Temp
        </Tabs.Content>
      </Tabs.Root>
    </div>
  );
};

export default VideosTab;
"
Content\popup\PopupContainer.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,12348,"import React, {
  useState,
  useEffect,
  useContext,
  useLayoutEffect,
  useRef,
} from ""react"";
import * as Tabs from ""@radix-ui/react-tabs"";

import {
  RecordTabActive,
  RecordTabInactive,
  VideoTabActive,
  VideoTabInactive,
  TempLogo,
  ProfilePic,
} from ""../images/popup/images"";

import { Rnd } from ""react-rnd"";

import {
  CloseIconPopup,
  GrabIconPopup,
  HelpIconPopup,
} from ""../toolbar/components/SVG"";

/* Component import */
import RecordingTab from ""./layout/RecordingTab"";
import VideosTab from ""./layout/VideosTab"";

// Layouts
import Announcement from ""./layout/Announcement"";
import SettingsMenu from ""./layout/SettingsMenu"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const PopupContainer = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const contentStateRef = useRef(contentState);
  const [tab, setTab] = useState(""record"");
  const [badge, setBadge] = useState(TempLogo);
  const DragRef = useRef(null);
  const PopupRef = useRef(null);
  const [elastic, setElastic] = React.useState("""");
  const [shake, setShake] = React.useState("""");
  const [dragging, setDragging] = React.useState("""");
  const [onboarding, setOnboarding] = useState(false);
  const [open, setOpen] = useState(false);
  const recordTabRef = useRef(null);
  const videoTabRef = useRef(null);
  const pillRef = useRef(null);
  const [URL, setURL] = useState(""https://help.screenity.io/"");

  useEffect(() => {
    // Check chrome storage
    chrome.storage.local.get([""updatingFromOld""], function (result) {
      if (result.updatingFromOld) {
        setOnboarding(true);
      }
    });
  }, []);

  useEffect(() => {
    const locale = chrome.i18n.getMessage(""@@ui_locale"");
    if (!locale.includes(""en"")) {
      setURL(
        `https://translate.google.com/translate?sl=en&tl=${locale}&u=https://help.screenity.io/`
      );
    }
  }, []);

  const onValueChange = (tab) => {
    setTab(tab);
    if (tab === ""record"") {
      setBadge(TempLogo);
    } else {
      setBadge(ProfilePic);
    }
    setContentState((prevContentState) => ({
      ...prevContentState,
      bigTab: tab,
    }));
  };

  useEffect(() => {
    setTab(contentState.bigTab);
  }, []);

  useEffect(() => {
    if (!recordTabRef.current) return;
    if (!videoTabRef.current) return;
    if (!pillRef.current) return;

    if (tab === ""record"") {
      pillRef.current.style.left = recordTabRef.current.offsetLeft + ""px"";
      pillRef.current.style.width =
        recordTabRef.current.getBoundingClientRect().width + ""px"";
    } else {
      pillRef.current.style.left = videoTabRef.current.offsetLeft + ""px"";

      pillRef.current.style.width =
        videoTabRef.current.getBoundingClientRect().width + ""px"";
    }
  }, [tab, recordTabRef.current, videoTabRef.current, pillRef.current]);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  useLayoutEffect(() => {
    function setPopupPosition(e) {
      let xpos = DragRef.current.getDraggablePosition().x;
      let ypos = DragRef.current.getDraggablePosition().y;

      // Width and height of popup
      const width = PopupRef.current.getBoundingClientRect().width;
      const height = PopupRef.current.getBoundingClientRect().height;

      // Keep popup positioned relative to the bottom and right of the screen, proportionally
      if (xpos > window.innerWidth + 10) {
        xpos = window.innerWidth + 10;
      }
      if (ypos + height + 40 > window.innerHeight) {
        ypos = window.innerHeight - height - 40;
      }

      // Check if attached to right or bottom, if so, keep it there
      if (contentStateRef.current.popupPosition.fixed) {
        if (xpos < window.innerWidth) {
          xpos = window.innerWidth + 10;
        }
      }

      DragRef.current.updatePosition({ x: xpos, y: ypos });
    }
    window.addEventListener(""resize"", setPopupPosition);
    setPopupPosition();
    return () => window.removeEventListener(""resize"", setPopupPosition);
  }, []);

  const handleDragStart = (e, d) => {
    setDragging(""ToolbarDragging"");
  };

  const handleDrag = (e, d) => {
    // Width and height
    const width = PopupRef.current.getBoundingClientRect().width;
    const height = PopupRef.current.getBoundingClientRect().height;

    if (
      d.x - 40 < width ||
      d.x > window.innerWidth + 10 ||
      d.y < 0 ||
      d.y + height + 40 > window.innerHeight
    ) {
      setShake(""ToolbarShake"");
    } else {
      setShake("""");
    }
  };

  const handleDrop = (e, d) => {
    let anim = ""ToolbarElastic"";
    if (e === null) {
      anim = """";
    }
    setShake("""");
    setDragging("""");
    let xpos = d.x;
    let ypos = d.y;

    // Width and height
    const width = PopupRef.current.getBoundingClientRect().width;
    const height = PopupRef.current.getBoundingClientRect().height;

    // Check if popup is off screen
    if (d.x - 40 < width) {
      setElastic(anim);
      xpos = width + 40;
    } else if (d.x + 10 > window.innerWidth) {
      setElastic(anim);
      xpos = window.innerWidth + 10;
    }

    if (d.y < 0) {
      setElastic(anim);
      ypos = 0;
    } else if (d.y + height + 40 > window.innerHeight) {
      setElastic(anim);
      ypos = window.innerHeight - height - 40;
    }
    DragRef.current.updatePosition({ x: xpos, y: ypos });

    setTimeout(() => {
      setElastic("""");
    }, 250);

    setContentState((prevContentState) => ({
      ...prevContentState,
      popupPosition: {
        ...prevContentState.popupPosition,
        offsetX: xpos,
        offsetY: ypos,
        left: xpos < window.innerWidth / 2 ? true : false,
        right: xpos < window.innerWidth / 2 ? false : true,
        top: ypos < window.innerHeight / 2 ? true : false,
        bottom: ypos < window.innerHeight / 2 ? false : true,
      },
    }));

    // Is it on the left or right, also top or bottom
    let left = xpos < window.innerWidth / 2 ? true : false;
    let rig"
Content\popup\styles\components\_BackgroundEffects.scss,Excluded by file type,,0,
Content\popup\styles\components\_Dropdown.scss,Excluded by file type,,0,
Content\popup\styles\components\_MainButton.scss,Excluded by file type,,0,
Content\popup\styles\components\_RegionDimensions.scss,Excluded by file type,,0,
Content\popup\styles\components\_Switch.scss,Excluded by file type,,0,
Content\popup\styles\components\_Tabs.scss,Excluded by file type,,0,
Content\popup\styles\components\_TimeSetter.scss,Excluded by file type,,0,
Content\popup\styles\components\_Tooltip.scss,Excluded by file type,,0,
Content\popup\styles\components\_VideoItem.scss,Excluded by file type,,0,
Content\popup\styles\layout\_Announcement.scss,Excluded by file type,,0,
Content\popup\styles\layout\_PopupContainer.scss,Excluded by file type,,0,
Content\popup\styles\layout\_Settings.scss,Excluded by file type,,0,
Content\popup\styles\layout\_SettingsMenu.scss,Excluded by file type,,0,
Content\popup\styles\layout\_VideosTab.scss,Excluded by file type,,0,
Content\popup\styles\_Popup.scss,Excluded by file type,,0,
Content\region\components\RegionHandles.jsx,Included,application/octet-stream,5363,"import React, { useState, useContext, useRef, useEffect } from ""react"";
import { Rnd } from ""react-rnd"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const ResizableBox = () => {
  return (
    <div style={{ position: ""relative"" }}>
      <div
        style={{
          position: ""fixed"",
          top: 0,
          left: 0,
          width: ""100%"",
          height: ""100%"",
          backgroundColor: ""rgba(0, 0, 0, 0.5)"",
          zIndex: 999999999,
        }}
      >
        <div
          style={{
            position: ""absolute"",
            top: 0,
            left: 0,
            width: ""100%"",
            height: ""100%"",
            zIndex: 9999999999,
          }}
          className=""box-hole""
        />
      </div>
      <Rnd
        ref={regionRef}
        style={{ position: ""fixed"", zIndex: 9999999999 }}
        default={{
          x: 0,
          y: 0,
          width: 200,
          height: 200,
        }}
        minWidth={100}
        minHeight={100}
        resizeHandleWrapperClass=""resize-handle-wrapper""
        resizeHandleComponent={{
          topLeft: (
            <div
              style={{
                position: ""absolute"",
                top: ""0px"",
                left: ""0px"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""nwse-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          top: (
            <div
              style={{
                position: ""absolute"",
                top: ""0px"",
                left: ""50%"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""ns-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          topRight: (
            <div
              style={{
                position: ""absolute"",
                top: ""0px"",
                right: ""0px"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""nesw-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          right: (
            <div
              style={{
                position: ""absolute"",
                top: ""50%"",
                right: ""0px"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""ew-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          bottomRight: (
            <div
              style={{
                position: ""absolute"",
                bottom: ""0px"",
                right: ""0px"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""nwse-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          bottom: (
            <div
              style={{
                position: ""absolute"",
                bottom: ""0px"",
                left: ""50%"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""ns-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          bottomLeft: (
            <div
              style={{
                position: ""absolute"",
                bottom: ""0px"",
                left: ""0px"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""nesw-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
          left: (
            <div
              style={{
                position: ""absolute"",
                top: ""50%"",
                left: ""0px"",
                width: ""10px"",
                height: ""10px"",
                borderRadius: ""50%"",
                backgroundColor: ""white"",
                border: ""2px solid black"",
                cursor: ""ew-resize"",
                boxSizing: ""border-box"",
              }}
            />
          ),
        }}
      >
        <div
          style={{
            width: ""100%"",
            height: ""100%"",
            border: ""2px dashed white"",
            borderRadius: ""5px"",
            zIndex: 9999999999,
            boxSizing: ""border-box"",
          }}
        />
      </Rnd>
    </div>
  );
};

export default ResizableBox;
"
Content\region\layout\CameraToolbar.jsx,Included,application/octet-stream,1001,"import React, { useState, useEffect, useContext } from ""react"";

import * as Toolbar from ""@radix-ui/react-toolbar"";

import { CameraCloseIcon, CameraMoreIcon } from ""../../toolbar/components/SVG"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const CameraToolbar = () => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <Toolbar.Root className=""camera-toolbar"">
      <Toolbar.Button
        className=""CameraToolbarButton""
        onClick={() => {
          setContentState((prevContentState) => ({
            ...prevContentState,
            cameraActive: false,
          }));
          chrome.storage.local.set({ cameraActive: false });
        }}
      >
        <CameraCloseIcon />
      </Toolbar.Button>
      <Toolbar.Button className=""CameraToolbarButton CameraMore"">
        <CameraMoreIcon />
      </Toolbar.Button>
    </Toolbar.Root>
  );
};

export default CameraToolbar;
"
Content\region\layout\CameraWrap.jsx,Included,application/octet-stream,4834,"import React, { useEffect, useContext, useRef, useState } from ""react"";

import { Rnd } from ""react-rnd"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

import CameraToolbar from ""./CameraToolbar"";
import ResizeHandle from ""../components/ResizeHandle"";

const CameraWrap = (props) => {
  const [contentState, setContentState] = React.useContext(contentStateContext);
  const cameraRef = React.useRef();
  const [cx, setCx] = useState(200);
  const [cy, setCy] = useState(200);
  const [w, setW] = useState(200);
  const [h, setH] = useState(200);

  const updateUIPosition = () => {
    const ref =
      props.shadowRef.current.shadowRoot.querySelector("".camera-draggable"");
    const circleCenterX =
      ref.getBoundingClientRect().left + ref.getBoundingClientRect().width / 2;
    const circleCenterY =
      ref.getBoundingClientRect().top + ref.getBoundingClientRect().height / 2;
    const circleRadius = ref.getBoundingClientRect().width / 2;
    const squareBottomRightX =
      ref.getBoundingClientRect().left + ref.getBoundingClientRect().width;
    const squareBottomRightY =
      ref.getBoundingClientRect().top + ref.getBoundingClientRect().height;
    const handle =
      props.shadowRef.current.shadowRoot.querySelector("".camera-resize"");
    const toolbar =
      props.shadowRef.current.shadowRoot.querySelector("".camera-toolbar"");

    // Calculate 'r' using the formula we derived earlier
    const c = Math.sqrt(
      Math.pow(circleCenterX - squareBottomRightX, 2) +
        Math.pow(circleCenterY - squareBottomRightY, 2)
    );
    const a = circleRadius / Math.sqrt(2);
    const r = (c + Math.sqrt(c ** 2 + 16 * a ** 2)) / 4;

    // Calculate the handle position
    const x = r - r / Math.sqrt(2);
    const y = r - r / Math.sqrt(2);

    // Position the handle element to the calculated coordinates
    handle.style.bottom = `${y - handle.getBoundingClientRect().width / 2}px`;
    handle.style.right = `${x - handle.getBoundingClientRect().height / 2}px`;
    toolbar.style.top = `${y - toolbar.getBoundingClientRect().width / 2}px`;
    toolbar.style.left = `${x - toolbar.getBoundingClientRect().height / 2}px`;
  };

  const saveDimensions = () => {
    const ref =
      props.shadowRef.current.shadowRoot.querySelector("".camera-draggable"");

    setContentState((prevContentState) => ({
      ...prevContentState,
      cameraDimensions: {
        size: ref.getBoundingClientRect().width,
        x: ref.getBoundingClientRect().x,
        y: ref.getBoundingClientRect().y,
      },
    }));
    chrome.storage.local.set({
      cameraDimensions: {
        size: ref.getBoundingClientRect().width,
        x: ref.getBoundingClientRect().x,
        y: ref.getBoundingClientRect().y,
      },
    });
  };

  useEffect(() => {
    if (!cameraRef.current) return;
    if (!props.shadowRef.current.shadowRoot.querySelector("".camera-resize""))
      return;
    if (!props.shadowRef.current.shadowRoot.querySelector("".camera-toolbar""))
      return;

    updateUIPosition();
  }, [cameraRef.current]);

  return (
    <div>
      <Rnd
        default={{
          x: contentState.cameraDimensions.x,
          y: contentState.cameraDimensions.y,
          width: contentState.cameraDimensions.size,
          height: contentState.cameraDimensions.size,
        }}
        ref={cameraRef}
        className=""camera-draggable""
        dragHandleClassName=""camera-grab""
        resizeHandleComponent={{
          bottomRight: <ResizeHandle />,
        }}
        minHeight={150}
        minWidth={150}
        enableResizing={{
          bottom: false,
          bottomRight: true,
          bottomLeft: false,
          left: false,
          right: false,
          top: false,
          topRight: false,
          topLeft: false,
        }}
        onResize={(e, direction, ref, delta, position) => {
          updateUIPosition();
        }}
        onResizeStop={(e, direction, ref, delta, position) => {
          saveDimensions();
        }}
        onDragStop={(node, x, y) => {
          saveDimensions();
        }}
        lockAspectRatio={1}
        bounds={""window""}
      >
        <div className=""camera-grab""></div>
        <CameraToolbar />
        <iframe
          style={{
            width: ""100%"",
            height: ""100%"",
            borderRadius: ""50%"",
            outline: ""none"",
            border: ""none"",
            pointerEvents: ""none"",
          }}
          className={contentState.cameraFlipped ? ""camera-flipped"" : """"}
          src={chrome.runtime.getURL(""camera.html"")}
          allow=""camera; microphone""
        ></iframe>
      </Rnd>
    </div>
  );
};

export default CameraWrap;
"
Content\region\Region.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,7284,"import React, { useState, useRef, useContext, useEffect } from ""react"";
import { Rnd } from ""react-rnd"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const ResizableBox = () => {
  const regionRef = useRef(null);
  const parentRef = useRef(null);
  const cropRef = useRef(null);
  const recordingRef = useRef(null);
  const [contentState, setContentState] = useContext(contentStateContext);

  useEffect(() => {
    recordingRef.current = contentState.recording;
  }, [contentState.recording]);

  // Check for contentState.regionDimensions to update the Rnd component width and height
  useEffect(() => {
    if (contentState.recordingType != ""region"") return;
    if (!contentState.customRegion) return;
    if (regionRef.current === null) return;
    if (
      contentState.regionWidth === 0 ||
      contentState.regionWidth === undefined
    )
      return;
    if (
      contentState.regionHeight === 0 ||
      contentState.regionHeight === undefined
    )
      return;
    if (contentState.regionX === undefined) return;
    if (contentState.regionY === undefined) return;
    if (contentState.fromRegion) return;

    // Get parent element dimensions
    const parentWidth = parentRef.current.offsetWidth;
    const parentHeight = parentRef.current.offsetHeight;

    // Calculate maximum size that fits within parent element
    const maxWidth = parentWidth - contentState.regionX;
    const maxHeight = parentHeight - contentState.regionY;
    const newWidth = Math.min(contentState.regionWidth, maxWidth);
    const newHeight = Math.min(contentState.regionHeight, maxHeight);

    // Update content state with new size
    setContentState((prevContentState) => ({
      ...prevContentState,
      regionWidth: newWidth,
      regionHeight: newHeight,
      fromRegion: true,
    }));

    chrome.storage.local.set({
      regionWidth: newWidth,
      regionHeight: newHeight,
    });

    regionRef.current.updateSize({
      width: newWidth,
      height: newHeight,
      x: contentState.regionX,
      y: contentState.regionY,
    });
    setCropTarget();
  }, [
    contentState.recordingType,
    contentState.customRegion,
    contentState.regionWidth,
    contentState.regionHeight,
    contentState.regionX,
    contentState.regionY,
  ]);

  const setCropTarget = async () => {
    const target = await CropTarget.fromElement(cropRef.current);
    setContentState((prevContentState) => ({
      ...prevContentState,
      cropTarget: target,
    }));
  };

  const handleResize = (e, direction, ref, delta, position) => {
    // Get numeric values of width and height
    const width = parseInt(ref.style.width, 10);
    const height = parseInt(ref.style.height, 10);

    // Update content state
    setContentState((prevContentState) => ({
      ...prevContentState,
      regionWidth: width,
      regionHeight: height,
      regionX: position.x,
      regionY: position.y,
      fromRegion: true,
    }));

    chrome.storage.local.set({
      regionWidth: width,
      regionHeight: height,
      regionX: position.x,
      regionY: position.y,
    });
    setCropTarget();
  };

  const handleMove = (e, d) => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      regionX: d.x,
      regionY: d.y,
      fromRegion: true,
    }));
    chrome.storage.local.set({
      regionX: d.x,
      regionY: d.y,
    });
    setCropTarget();
  };

  useEffect(() => {
    setCropTarget();
  }, []);

  return (
    <div
      style={{
        position: ""absolute"",
        top: 0,
        left: 0,
        width: ""100%"",
        height: ""100%"",
        zIndex: -1,
        pointerEvents:
          recordingRef.current ||
          contentState.drawingMode ||
          contentState.blurMode
            ? ""none""
            : ""auto"",
      }}
      className={recordingRef.current ? ""region-recording"" : """"}
      onClick={(e) => {
        // showExtension false, as long as not clicking on the region
        if (
          e.target.className.indexOf(""resize-handle"") === -1 &&
          e.target.className.indexOf(""react-draggable"") === -1 &&
          e.target.className.indexOf(""region-rect"") === -1
        ) {
          // setContentState((prevContentState) => ({
          //   ...prevContentState,
          //   showExtension: false,
          // }));
        }
      }}
      ref={parentRef}
    >
      <div
        style={{
          position: ""absolute"",
          top: 0,
          left: 0,
          width: ""100%"",
          height: ""100%"",
          zIndex: 1,
          pointerEvents:
            recordingRef.current ||
            contentState.drawingMode ||
            contentState.blurMode
              ? ""none""
              : ""auto"",
        }}
      >
        <div className=""box-hole"" />
      </div>
      <Rnd
        ref={regionRef}
        style={{
          position: ""relative"",
          zIndex: 2,
          pointerEvents:
            recordingRef.current ||
            contentState.drawingMode ||
            contentState.blurMode
              ? ""none""
              : ""auto"",
        }}
        default={{
          x: contentState.regionX,
          y: contentState.regionY,
          width: contentState.regionWidth,
          height: contentState.regionHeight,
        }}
        minWidth={50}
        minHeight={50}
        resizeHandleWrapperClass=""resize-handle-wrapper""
        resizeHandleComponent={{
          topLeft: <div className=""resize-handle top-left"" />,
          top: <div className=""resize-handle top"" />,
          topRight: <div className=""resize-handle top-right"" />,
          right: <div className=""resize-handle right"" />,
          bottomRight: <div className=""resize-handle bottom-right"" />,
          bottom: <div className=""resize-handle bottom"" />,
          bottomLeft: <div className=""resize-handle bottom-left"" />,
          left: <div className=""resize-handle left"" />,
        }}
        bounds=""parent""
        onResizeStop={handleResize}
       "
Content\region\styles\layout\_CameraToolbar.scss,Excluded by file type,,0,
Content\region\styles\layout\_CameraWrap.scss,Excluded by file type,,0,
Content\region\styles\_Region.scss,Excluded by file type,,0,
Content\setupTests.js,Included,text/javascript,246,"// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';
"
Content\shortcuts\Shortcuts.jsx,Included,application/octet-stream,2732,"import React, { useState, useEffect, useContext, useRef } from ""react"";

import { useHotkeys } from ""react-hotkeys-hook"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const Shortcuts = ({ shortcuts }) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const contentStateRef = useRef(contentState);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);
  /* For the record, this is the shortcuts object:
	shortcuts: {
      ""start-recording"": ""ctrl+shift+1"",
      ""stop-recording"": ""ctrl+shift+2"",
      ""pause-recording"": ""ctrl+shift+3"",
      ""resume-recording"": ""ctrl+shift+4"",
      ""dismiss-recording"": ""ctrl+shift+5"",
      ""restart-recording"": ""ctrl+shift+6"",
      ""toggle-drawing-mode"": ""ctrl+shift+7"",
    },
	*/

  // Set up all the hotkeys programmatically from the shortcuts object, without using useEffect

  /*
  useHotkeys(shortcuts[""toggle-drawing-mode""], () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      drawingMode: !prevContentState.drawingMode,
    }));
  });
	*/

  // Push to talk (while Alt/Option + Shift + J key is pressed enable microphone, disable on key up)
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (!contentStateRef.current.pushToTalk) return;
      if (event.code === ""KeyU"" && event.altKey && event.shiftKey) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          micActive: true,
        }));

        chrome.storage.local.set({
          micActive: true,
        });

        chrome.runtime.sendMessage({
          type: ""set-mic-active-tab"",
          active: true,
          defaultAudioInput: contentState.defaultAudioInput,
        });
      }
    };

    const handleKeyUp = (event) => {
      if (!contentStateRef.current.pushToTalk) return;
      if (event.code === ""KeyU"" && event.altKey && event.shiftKey) {
        setContentState((prevContentState) => ({
          ...prevContentState,
          micActive: false,
        }));

        chrome.storage.local.set({
          micActive: false,
        });

        chrome.runtime.sendMessage({
          type: ""set-mic-active-tab"",
          active: false,
          defaultAudioInput: contentState.defaultAudioInput,
        });
      }
    };

    window.addEventListener(""keydown"", handleKeyDown);
    window.addEventListener(""keyup"", handleKeyUp);

    return () => {
      window.removeEventListener(""keydown"", handleKeyDown);
      window.removeEventListener(""keyup"", handleKeyUp);
    };
  }, []);

  return <></>;
};

export default Shortcuts;
"
Content\styles\app.css,Excluded by file type,,0,
Content\styles\app.css.map,Truncated to 6000 bytes due to size > 6000,application/octet-stream,35955,"{""version"":3,""sources"":[""_variables.scss"",""app.css"",""../toolbar/styles/layout/_Toolbar.scss"",""../toolbar/styles/layout/_DrawingToolbar.scss"",""../toolbar/styles/layout/_ShapeToolbar.scss"",""../toolbar/styles/components/_Tooltip.scss"",""../toolbar/styles/components/_RadialMenu.scss"",""../toolbar/styles/components/_ColorWheel.scss"",""../toolbar/styles/components/_StrokeWidth.scss"",""../toolbar/styles/components/_Toast.scss"",""../toolbar/styles/_Page.scss"",""../popup/styles/layout/_PopupContainer.scss"",""../popup/styles/layout/_Settings.scss"",""../popup/styles/layout/_VideosTab.scss"",""../popup/styles/layout/_Announcement.scss"",""../popup/styles/layout/_SettingsMenu.scss"",""../popup/styles/components/_Dropdown.scss"",""../popup/styles/components/_Tabs.scss"",""../popup/styles/components/_Switch.scss"",""../popup/styles/components/_VideoItem.scss"",""../popup/styles/components/_MainButton.scss"",""../popup/styles/components/_BackgroundEffects.scss"",""../popup/styles/components/_RegionDimensions.scss"",""../popup/styles/components/_TimeSetter.scss"",""../popup/styles/components/_Tooltip.scss"",""../canvas/styles/layout/_Canvas.scss"",""../camera/styles/layout/_CameraWrap.scss"",""../camera/styles/layout/_CameraToolbar.scss"",""../camera/styles/components/_ResizeHandle.scss"",""../countdown/styles/_Countdown.scss"",""../modal/styles/_Modal.scss"",""../region/styles/_Region.scss"",""../warning/styles/_Warning.scss"",""app.scss""],""names"":[],""mappings"":""AACE;EACE,4BAOU;EANL,uGAAA;EACL,mBAAA;EACA,kBAAA;ACAJ;ADJE;EACE,6BAQU;EAPL,wGAAA;EACL,mBAAA;EACA,kBAAA;ACMJ;ADVE;EACE,2BASU;EARL,sGAAA;EACL,mBAAA;EACA,kBAAA;ACYJ;ADhBE;EACE,gCAUU;EATL,kHAAA;EACL,mBAAA;EACA,kBAAA;ACkBJ;ADTA,WAAA;AAaA,SAAA;AAYA,YAAA;AACA;;;;;;CAAA;AAaA,cAAA;AAMA,cAAA;AAIA,WAAA;AAIA,YAAA;AEjEA,UAAA;AACA;;EAEE,UAAA;ADqCF;;AClCA;EACC,WAAA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,8BAAA;ADqCD;;ACnCA;EACC,+BAAA;ADsCD;;ACnCA;EACC,eAAA;EACA,QAAA;EACA,SAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,0BAAA;EACA,oBAAA;EACA,qBAAA;EACA,UAAA;EACA,2FAAA;ADsCD;;ACpCA;EACC,mBAAA;EACA,YAAA;ADuCD;;ACpCA;EACC,mBAAA;ADuCD;;ACrCA;EAEC,WAAA;EACA,YAAA;ADuCD;;ACrCA;EACC,4DAAA;ADwCD;;ACtCA;EACC,qEAAA;EACA,8CAAA;EACA,kCAAA;ADyCD;;ACvCA;EACC,sBAAA;AD0CD;ACxCC;EACC,qDAAA;AD0CF;;ACrCA;EACE;IAAK,2CAAA;EDyCL;ECxCA;IAAM,4CAAA;ED2CN;EC1CA;IAAM,2CAAA;ED6CN;EC5CA;IAAM,4CAAA;ED+CN;EC9CA;IAAM,6CAAA;EDiDN;EChDA;IAAM,4CAAA;EDmDN;EClDA;IAAM,4CAAA;EDqDN;ECpDA;IAAM,6CAAA;EDuDN;ECtDA;IAAM,2CAAA;EDyDN;ECxDA;IAAO,6CAAA;ED2DP;AACF;ACxDA;EACC;IACC,2CAAA;ED0DA;ECxDD;IACC,4CAAA;ED0DA;ECxDD;IACC,8CAAA;ED0DA;ECxDD;IACC,2CAAA;ED0DA;ECxDD;IACC,6CAAA;ED0DA;ECxDD;IACC,4CAAA;ED0DA;ECxDD;IACC,6CAAA;ED0DA;ECxDD;IACC,6CAAA;ED0DA;ECxDD;IACC,2CAAA;ED0DA;ECxDD;IACC,6CAAA;ED0DA;ECxDD;IACC,4CAAA;ED0DA;AACF;ACvDA;EACC,UAAA;ADyDD;ACvDC;EACC,UAAA;ADyDF;;ACrDA;EACE,aAAA;EACD,mBAAA;EACC,kBAAA;EACD,mHAAA;EACA,2BAAA;EAAA,sBAAA;EACA,uBAAA;EACA,0CAAA;EACA,mBAAA;EACA,YAAA;EACA,kBAAA;EACA,YAAA;EACA,UAAA;EACA,mBFnFyB;AC2I1B;ACtDC;EACC,WAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,gBAAA;EACA,iBAAA;EACA,kBAAA;EACA,SAAA;EACA,QAAA;EACA,mBF/FwB;EEgGxB,oDAAA;EACA,mCAAA;ADwDF;;ACpDA;EACC,qBAAA;ADuDD;;ACrDA;EACC,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,mBAAA;EACA,mBF7GyB;EE8GzB,yCFhIa;EEiIb,yBAAA;EACA,iBAAA;EACA,kBAAA;ADwDD;;ACtDA;EACC,iBAAA;EACA,WAAA;EACA,cFxJoB;EEyJpB,eAAA;EACA,iBAAA;EACA,yBAAA;EACA,sBAAA;ADyDD;;ACtDA;EACC,aAAA;EACA,mBAAA;ADyDD;;ACvDA;EACC,cAAA;EACA,mBAAA;EACA,2BAAA;EACA,kBAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,oBAAA;EACC,cAAA;EACA,mBAAA;EACA,uBAAA;AD0DF;;ACxDA;;;;;EAKC,aAAA;EACA,uBAAA;EACA,mBAAA;EACA,WAAA;EACC,YAAA;EACD,WAAA;EACA,kBAAA;EACC,eAAA;EACA,cAAA;EACD,kBAAA;EACA,8CAAA;EACA,wCAAA;AD2DD;ACzDC;;;;;EACC,cF9LW;AC6Pb;AC5DC;;;;;EACC,YAAA;EACA,8BAAA;EACA,2BAAA;ADkEF;AC7DE;;;;;EACC,yBAAA;ADmEH;;AC/DA;;;;;EAKC,eAAA;EACC,qDAAA;ADkEF;;AChEA;;;;;EAKE,kBAAA;EACA,mDFrLa;ACwPf;;AChEA;EACC,aAAA;EACC,uBAAA;EACD,mBAAA;EACA,cAAA;EACA,kBAAA;ADmED;ACjEC;EACC,cAAA;ADmEF;ACjEC;EACC,oCAAA;ADmEF;ACjEE;EACC,cAAA;ADmEH;AChEE;EACC,8CAAA;EACA,qBAAA;ADkEH;;AC7DA;EACC,aAAA;EACC,uBAAA;EACD,mBAAA;EACA,cAAA;EACA,kBAAA;ADgED;AC9DC;EACC,cAAA;ADgEF;AC9DC;EACC,WAAA;EACA,cAAA;EACA,WAAA;EACA,WAAA;EACA,8BAAA;EACD,sBAAA;EACC,kBAAA;EACA,UAAA;EACA,OAAA;EACA,gBAAA;EACA,2FAAA;EACA,8CAAA;EACA,6BAAA;EACA,2BAAA;EACA,4BAAA;EACA,6BAAA;EACA,UAAA;ADgEF;AC9DC;EACC,mCAAA;ADgEF;AC9DE;EACC,cFhSa;ACgWhB;AC7DE;EACC,8CAAA;EACA,qBAAA;AD+DH;;ACxDC;EACC,iDAAA;EACA,aAAA;EACA,qBAAA;EACA,yCAAA;EACA,yCAAA;EACA,2BAAA;AD2DF;ACxDE;EACC,8CAAA;AD0DH;;ACrDA;EACC,aAAA;EACC,uBAAA;EACD,mBAAA;EACA,cAAA;EACA,kBAAA;ADwDD;ACtDC;EACC,cAAA;ADwDF;ACtDC;EACC,uHF3RiB;EE4RjB,WAAA;ADwDF;ACtDE;EACC,WAAA;ADwDH;;ACjDA;EACE,UAAA;EACD,YAAA;EACC,yBFnVa;EEoVb,aAAA;ADoDF;;ACjDA;EACE,6BAAA;EACA,qBAAA;EACA,oBAAA;EACA,uBAAA;EACA,mBAAA;ADoDF;;AClDA;EACE,6BAAA;EACA,eAAA;ADqDF;;AClDA;EACC,eAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,YAAA;EACA,sBAAA;EACA,0BAAA;EACA,oBAAA;EACA,YAAA;ADqDD;ACnDC;EACC,aAAA;ADqDF;;ACjDA;EACC,kBAAA;EACA,oBFnUa;EEoUb,uBAAA;EAAA,kBAAA;EACA,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,SAAA;EACA,WAAA;EACA,YAAA;EACA,wBAAA;EACA,+BAAA;ADoDD;;AClDA;EACC,eAAA;EACA,cF3XY;EE4XZ,uDAAA;ADqDD;;ACnDA;EACC,kBAAA;ADsDD;;AE5cA;EACC,kCAAA;AF+cD;;AE7cA;EACC,qBAAA;EACA,8BAAA;EACA,gEAAA;AFgdD;;AE9cA;EACC,oCAAA;AFidD;;AE9cA;EACC,UAAA;EACA,oBAAA;EACA,mBAAA;EACA,aAAA;EACC,2BAAA;EAAA,sBAAA;EACD,kBAAA;EACA,mBAAA;EACC,kBAAA;EACA,qCAAA;EACD,kBAAA;EACA,YAAA;EACA,SAAA;EACA,uCAAA;EACA,wBAAA;EACA,mBAAA;EACA,iBAAA;EACA,oHAAA;EACA,wDAAA;AFidD;AE/cC;EACC,WAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,kBAAA;EACA,aAAA;EACA,sBAAA;EACA,kBAAA;EACA,SAAA;EACA,QAAA;EACA,oCAAA;AFidF;AE/cC;EACC,WAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,qCAAA;EACA,kCAAA;UAAA,0BAAA;EACA,4BAAA;EACA,oFAAA;EACA,4EAAA;EACA,uCAAA;EACA,mBAAA;EACA,kBAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;AFidF;AE/cC;EACC,yBAAA;AFidF;;AE7cA;EACC,uBAAA;AFgdD;;AE9cA;EACC,oBAAA;AFidD;AE/cC;EACC,gGAAA;EACA,6EAAA;EACA,kDAAA;AFidF;;AE7cA;EACC,WAAA;EACA,YAAA;EACA,mBAAA;EACA,sCAAA;EACA,kBAAA;AFgdD;;AGriBA;EACC,kBAAA;EACA,aAAA;EACA,mBAAA;EACA,uBAAA;EACC,qCAAA;EACD,WAAA;EACA,YJuCY;EItCZ,UAAA;EACA,YAAA;EACA,wCAAA;EACA,wBAAA;"
Content\styles\app.scss,Excluded by file type,,0,
Content\styles\dist\app.css,Excluded by file type,,0,
Content\styles\_variables.scss,Excluded by file type,,0,
Content\toolbar\components\ColorWheel.jsx,Included,application/octet-stream,2215,"import React, { useRef, useState, useContext } from ""react"";

import Wheel from ""@uiw/react-color-wheel"";
import { hsvaToHex } from ""@uiw/color-convert"";

// Components
import TooltipWrap from ""./TooltipWrap"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const ColorWheel = (props) => {
  const [hsva, setHsva] = React.useState({ h: 200, s: 50, v: 100, a: 1 });
  const [contentState, setContentState] = useContext(contentStateContext);
  const wheelRef = useRef(null);
  const stateRef = useRef();

  stateRef.current = props.fullwheel;

  const handleClick = (e) => {
    if (!props.fullwheel) {
      props.setFullWheel(true);
    }
  };

  return (
    <TooltipWrap
      content={chrome.i18n.getMessage(""moreColorsTooltip"")}
      name=""wheel-trigger""
      override=""tooltip-small""
      hide={props.fullwheel ? ""hide-tooltip"" : """"}
    >
      <div
        className={
          contentState.swatch === 5
            ? ""radial-menu-item-child color-active""
            : ""radial-menu-item-child""
        }
        onClick={handleClick}
        style={
          contentState.swatch === 5
            ? { backgroundColor: contentState.color }
            : {}
        }
        ref={wheelRef}
        tabIndex={props.open ? ""0"" : ""-1""}
      >
        <div className=""color-wheel-input"">
          {contentState.color.toUpperCase()}
        </div>
        <div
          className=""color-preview""
          style={{ backgroundColor: contentState.color }}
        ></div>
        <Wheel
          color={hsva}
          width={100}
          height={100}
          onChange={(color) => {
            setHsva({ ...hsva, ...color.hsva });
            setContentState((prevContentState) => ({
              ...prevContentState,
              color: hsvaToHex({ h: hsva.h, s: hsva.s, v: hsva.v, a: hsva.a }),
              swatch: 5,
            }));
            chrome.storage.local.set({
              color: hsvaToHex({ h: hsva.h, s: hsva.s, v: hsva.v, a: hsva.a }),
              swatch: 5,
            });
          }}
        />
      </div>
    </TooltipWrap>
  );
};

export default ColorWheel;
"
Content\toolbar\components\MicToggle.jsx,Included,application/octet-stream,1993,"import React, { useContext } from ""react"";
import * as Toggle from ""@radix-ui/react-toggle"";

// Components
import TooltipWrap from ""./TooltipWrap"";

import { MicIcon } from ""./SVG"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const MicToggle = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <TooltipWrap
      content={
        contentState.microphonePermission && contentState.micActive
          ? chrome.i18n.getMessage(""disableMicrophoneTooltip"")
          : contentState.microphonePermission && !contentState.micactive
          ? chrome.i18n.getMessage(""enableMicrophoneTooltip"")
          : chrome.i18n.getMessage(""noMicrophonePermissionsTooltip"")
      }
    >
      <div className=""ToolbarToggleWrap"">
        <Toggle.Root
          className=""ToolbarModeItemSingle""
          aria-label=""Toggle microphone""
          pressed={contentState.micActive}
          disabled={
            !contentState.microphonePermission ||
            contentState.defaultAudioInput === ""none""
          }
          onPressedChange={(pressed) => {
            setContentState((prevContentState) => ({
              ...prevContentState,
              micActive: pressed,
            }));

            chrome.storage.local.set({
              micActive: pressed,
            });

            chrome.runtime.sendMessage({
              type: ""set-mic-active-tab"",
              active: pressed,
              defaultAudioInput: contentState.defaultAudioInput,
            });

            // Show toast
            contentState.openToast(
              pressed
                ? chrome.i18n.getMessage(""micOnToast"")
                : chrome.i18n.getMessage(""micOffToast""),
              () => {}
            );
          }}
        >
          <MicIcon />
        </Toggle.Root>
      </div>
    </TooltipWrap>
  );
};

export default MicToggle;
"
Content\toolbar\components\RadialMenu.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,6669,"import React, { useEffect, useState } from ""react"";

import * as Popover from ""@radix-ui/react-popover"";
import * as Tooltip from ""@radix-ui/react-tooltip"";

// Icons
import { EyeDropperIcon } from ""./SVG"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

import * as ToggleGroup from ""@radix-ui/react-toggle-group"";

// Components
import TooltipWrap from ""./TooltipWrap"";
import ColorWheel from ""./ColorWheel"";
import StrokeWeight from ""./StrokeWeight"";

const RadialMenu = (props) => {
  const [contentState, setContentState] = React.useContext(contentStateContext);
  const ref = React.useRef(null);
  const buttonRef = React.useRef(null);
  const radialMenuRef = React.useRef(null);
  const [fullwheel, setFullWheel] = useState(false);
  const [open, setOpen] = useState(false);
  const [eyeDropperActive, setEyeDropperActive] = useState(false);
  const [override, setOverride] = useState("""");

  useEffect(() => {
    // Check if hideUI is set
    if (contentState.hideUI) {
      setOverride(""override"");
    } else {
      setOverride("""");
    }
  }, [contentState.hideUI]);

  // Colors in menu
  const [colors, setColors] = useState([
    { color: ""#FED252"", label: ""Yellow"" },
    { color: ""#4597F7"", label: ""Blue"" },
    { color: ""#F24822"", label: ""Red"" },
    { color: ""#FFFFFF"", label: ""White"" },
    { color: ""#201F1D"", label: ""Black"" },
  ]);

  useEffect(() => {
    if (!open) {
      setFullWheel(false);
    }
  }, [open]);

  const selectColor = () => {
    const eyeDropper = new window.EyeDropper();
    setEyeDropperActive(true);

    eyeDropper
      .open()
      .then((color) => {
        setContentState((prevContentState) => ({
          ...prevContentState,
          color: color.sRGBHex,
          swatch: 5,
        }));
        setEyeDropperActive(false);
      })
      .catch((err) => {
        setEyeDropperActive(false);
      });
  };

  useEffect(() => {
    if (!buttonRef.current) return;
    if (!radialMenuRef.current) return;

    const left =
      buttonRef.current.getBoundingClientRect().left +
      buttonRef.current.getBoundingClientRect().width / 2;
    const top =
      buttonRef.current.getBoundingClientRect().top +
      buttonRef.current.getBoundingClientRect().height / 2;

    radialMenuRef.current.style.left = `${left}px`;
    radialMenuRef.current.style.top = `${top}px`;
  }, [buttonRef, radialMenuRef]);

  return (
    <Popover.Root open={open} onOpenChange={() => setOpen(!open)}>
      <Popover.Trigger as=""div"" ref={ref}>
        <Tooltip.Provider>
          <Tooltip.Root delayDuration={700}>
            <Tooltip.Trigger asChild>
              <div className=""ToolbarButton"" component=""div"" ref={buttonRef}>
                <div
                  className=""ColorPicker""
                  style={{ backgroundColor: contentState.color }}
                ></div>
              </div>
            </Tooltip.Trigger>
            <Tooltip.Portal
              container={
                document.getElementsByClassName(""screenity-shadow-dom"")[0]
              }
            >
              <Tooltip.Content
                className={""TooltipContent"" + "" "" + override}
                style={{
                  display: override === ""override"" ? ""none"" : ""block"",
                }}
              >
                Color and stroke
              </Tooltip.Content>
            </Tooltip.Portal>
          </Tooltip.Root>
        </Tooltip.Provider>
      </Popover.Trigger>
      <Popover.Portal forceMount container={ref.current}>
        <Popover.Content avoidCollisions={false} asChild onOpenAutoFocus>
          <div
            className={fullwheel ? ""radial-menu color-wheel"" : ""radial-menu""}
            ref={radialMenuRef}
            style={{
              position: ""fixed"",
            }}
          >
            <div className=""eyedropper"">
              <TooltipWrap content=""Eyedropper"">
                <div
                  tabIndex={open ? ""0"" : ""-1""}
                  className={
                    eyeDropperActive ? ""eyedropper eye-active"" : ""eyedropper""
                  }
                  onClick={() => {
                    selectColor();
                  }}
                >
                  <EyeDropperIcon />
                </div>
              </TooltipWrap>
            </div>
            <div className=""radial-menu-items"">
              <ToggleGroup.Root
                className=""stroke-weight""
                type=""single""
                value={contentState.strokeWidth}
                onValueChange={(value) => {
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    strokeWidth: value,
                  }));
                }}
              >
                <StrokeWeight open={open} />
                {colors.map((color, index) => {
                  return (
                    <TooltipWrap
                      content={color.label}
                      style={{ backgroundColor: color.color }}
                      name=""radial-menu-item""
                      override=""tooltip-small""
                      key={index}
                    >
                      <div
                        tabIndex={open ? ""0"" : ""-1""}
                        onClick={() => {
                          setContentState((prevContentState) => ({
                            ...prevContentState,
                            color: color.color,
                            swatch: index,
                          }));
                          chrome.storage.local.set({
                            color: color.color,
                            swatch: index,
                          });
                        }}
                        className={
                          contentState.swatch === index
                            ? ""radial-menu-item-child color-active""
                            : ""radial-menu-item-child""
                        }
                      >
         "
Content\toolbar\components\StrokeWeight.jsx,Included,application/octet-stream,2162,"import React from ""react"";

// Icons
import { Stroke1Icon, Stroke2Icon, Stroke3Icon } from ""./SVG"";
// Context
import { contentStateContext } from ""../../context/ContentState"";

// Components
import TooltipWrap from ""./TooltipWrap"";

import * as ToggleGroup from ""@radix-ui/react-toggle-group"";

const StrokeWeight = (props) => {
  const [contentState, setContentState] = React.useContext(contentStateContext);

  return (
    <React.Fragment>
      <TooltipWrap
        name=""radial-menu-item stroke-width-item""
        override=""tooltip-small""
        content={props.open ? chrome.i18n.getMessage(""thickStrokeTooltip"") : """"}
      >
        <span>
          <ToggleGroup.Item value={3} asChild>
            <div
              tabIndex={props.open ? ""0"" : ""-1""}
              className=""radial-menu-item-child""
            >
              <Stroke3Icon className=""stroke-icon"" />
            </div>
          </ToggleGroup.Item>
        </span>
      </TooltipWrap>
      <TooltipWrap
        name=""radial-menu-item stroke-width-item""
        override=""tooltip-small""
        content={
          props.open ? chrome.i18n.getMessage(""mediumStrokeTooltip"") : """"
        }
      >
        <span>
          <ToggleGroup.Item value={2} asChild>
            <div
              tabIndex={props.open ? ""0"" : ""-1""}
              className=""radial-menu-item-child""
            >
              <Stroke2Icon className=""stroke-icon"" />
            </div>
          </ToggleGroup.Item>
        </span>
      </TooltipWrap>
      <TooltipWrap
        name=""radial-menu-item stroke-width-item""
        override=""tooltip-small""
        content={props.open ? chrome.i18n.getMessage(""thinStrokeTooltip"") : """"}
      >
        <span>
          <ToggleGroup.Item value={1} asChild>
            <div
              tabIndex={props.open ? ""0"" : ""-1""}
              className=""radial-menu-item-child""
            >
              <Stroke1Icon className=""stroke-icon"" />
            </div>
          </ToggleGroup.Item>
        </span>
      </TooltipWrap>
    </React.Fragment>
  );
};

export default StrokeWeight;
"
Content\toolbar\components\SVG.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,11946,"import React from ""react"";
import { ReactSVG } from ""react-svg"";

const URL =
  ""chrome-extension://"" + chrome.i18n.getMessage(""@@extension_id"") + ""/assets/"";

const GrabIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/grab-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};
/*

*/

// Convert all to ReactSVG

const StopIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/stop-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const DrawIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/draw-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const PauseIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/pause-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const ResumeIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/resume-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const CursorIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/cursor-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const CommentIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/comment-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const MicIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/mic-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const MoreIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/more-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const RestartIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/restart-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const DiscardIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/discard-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const EyeDropperIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/eyedropper-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const Stroke1Icon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/stroke-1-icon.svg""}
      width={props.width}
      height={props.height}
      className={props.className}
      style={{
        textAlign: ""center"",
        margin: ""auto"",
        display: ""block"",
        width: ""100%"",
        height: ""100%"",
      }}
    />
  );
};

const Stroke2Icon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/stroke-2-icon.svg""}
      width={props.width}
      height={props.height}
      className={props.className}
      style={{
        textAlign: ""center"",
        margin: ""auto"",
        display: ""block"",
        width: ""100%"",
        height: ""100%"",
      }}
    />
  );
};

const Stroke3Icon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/stroke-3-icon.svg""}
      width={props.width}
      height={props.height}
      className={props.className}
      style={{
        textAlign: ""center"",
        margin: ""auto"",
        display: ""block"",
        width: ""100%"",
        height: ""100%"",
      }}
    />
  );
};

const TargetCursorIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/target-cursor-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const HighlightCursorIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/highlight-cursor-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const HideCursorIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/hide-cursor-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const TextIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/text-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const ArrowIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/arrow-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const EraserIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/eraser-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const PenIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/pen-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const ShapeIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/shape-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const SelectIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/select-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const UndoIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/undo-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const RedoIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/redo-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const ImageIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/image-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const TransformIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/transform-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const HighlighterIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/highlighter-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );
};

const RectangleIcon = (props) => {
  return (
    <ReactSVG
      src={URL + ""tool-icons/rectangle-icon.svg""}
      width={props.width}
      height={props.height}
    />
  );"
Content\toolbar\components\Toast.jsx,Included,application/octet-stream,2437,"import React, {
  useState,
  useEffect,
  useContext,
  useCallback,
  useRef,
} from ""react"";

import * as ToastEl from ""@radix-ui/react-toast"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const Toast = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [open, setOpen] = useState(false);
  const [title, setTitle] = useState("""");
  const [trigger, setTrigger] = useState(() => {});
  const triggerRef = useRef(trigger);
  const openRef = useRef(open);
  const contentStateRef = useRef(contentState);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  const openToast = useCallback((title, action) => {
    if (contentStateRef.current.hideUI) return;
    //if (contentState.hideToolbar && contentState.hideUI) return;
    setTitle(title);
    setOpen(true);
    setTrigger(() => action);
  });

  useEffect(() => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      openToast: openToast,
    }));

    return () => {
      setContentState((prevContentState) => ({
        ...prevContentState,
        openToast: null,
      }));
    };
  }, []);

  useEffect(() => {
    openRef.current = open;
  }, [open]);

  useEffect(() => {
    triggerRef.current = trigger;

    return () => {
      triggerRef.current = () => {};
    };
  }, [trigger]);

  return (
    <ToastEl.Provider swipeDirection=""down"" duration={2000}>
      <ToastEl.Root
        className=""ToastRoot""
        open={open}
        onOpenChange={setOpen}
        onEscapeKeyDown={(e) => {
          e.stopPropagation();
          e.preventDefault();
          triggerRef.current();
          setOpen(false);
        }}
      >
        <ToastEl.Title className=""ToastTitle"">{title}</ToastEl.Title>
        <ToastEl.Action
          className=""ToastAction""
          asChild
          altText=""Escape""
          onClick={() => {
            trigger();
          }}
        >
          <button
            className=""Button""
            onClick={(e) => {
              e.stopPropagation();
              trigger();
            }}
          >
            Esc
          </button>
        </ToastEl.Action>
      </ToastEl.Root>
      <ToastEl.Viewport className=""ToastViewport"" />
    </ToastEl.Provider>
  );
};

export default Toast;
"
Content\toolbar\components\TooltipWrap.jsx,Included,application/octet-stream,1727,"import React, { useEffect, useContext, useState } from ""react"";

import * as Tooltip from ""@radix-ui/react-tooltip"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const TooltipWrap = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const classname = props.name ? props.name : """";
  const [override, setOverride] = useState("""");

  useEffect(() => {
    // Check if hideUI is set
    if (contentState.hideUI) {
      setOverride(""override"");
    } else {
      setOverride("""");
    }
  }, [contentState.hideUI]);

  return (
    <div className={classname} style={props.style}>
      {props.content == """" ? (
        <div>{props.children}</div>
      ) : (
        <Tooltip.Provider>
          <Tooltip.Root delayDuration={700} defaultOpen={false}>
            <Tooltip.Trigger asChild>{props.children}</Tooltip.Trigger>
            <Tooltip.Portal
              container={
                document.getElementsByClassName(""screenity-shadow-dom"")[0]
              }
            >
              <Tooltip.Content
                className={
                  ""TooltipContent"" +
                  "" "" +
                  props.override +
                  "" "" +
                  props.hide +
                  "" "" +
                  override
                }
                style={{
                  display: override === ""override"" ? ""none"" : ""block"",
                }}
              >
                {props.content}
              </Tooltip.Content>
            </Tooltip.Portal>
          </Tooltip.Root>
        </Tooltip.Provider>
      )}
    </div>
  );
};

export default TooltipWrap;
"
Content\toolbar\components\ToolTrigger.jsx,Included,application/octet-stream,1264,"import React from ""react"";
import * as Toolbar from ""@radix-ui/react-toolbar"";

// Components
import TooltipWrap from ""./TooltipWrap"";

const ToolTrigger = (props) => {
  const grab = props.grab ? "" grab"" : """";
  const resume = props.resume ? "" resume"" : """";

  return (
    <TooltipWrap content={props.content}>
      {props.type === ""button"" ? (
        <Toolbar.Button
          className={""ToolbarButton"" + grab + resume}
          onClick={props.onClick}
          disabled={props.disabled}
        >
          {props.children}
        </Toolbar.Button>
      ) : props.type === ""mode"" ? (
        <div className=""ToolbarToggleWrap"">
          <Toolbar.ToggleItem
            className=""ToolbarModeItem""
            value={props.value}
            disabled={props.disabled}
          >
            {props.children}
          </Toolbar.ToggleItem>
        </div>
      ) : (
        <div className=""ToolbarToggleWrap"">
          <Toolbar.ToggleItem
            className=""ToolbarToggleItem""
            value={props.value}
            disabled={props.disabled}
          >
            {props.children}
          </Toolbar.ToggleItem>
        </div>
      )}
    </TooltipWrap>
  );
};

export default ToolTrigger;
"
Content\toolbar\layout\BlurToolbar.jsx,Included,application/octet-stream,1404,"import React from ""react"";
import * as Toolbar from ""@radix-ui/react-toolbar"";

// Components
import ToolTrigger from ""../components/ToolTrigger"";

// Icons
import { TransformIcon, TrashIcon } from ""../components/SVG"";

const BlurToolbar = (props) => {
  return (
    <Toolbar.Root
      className={""DrawingToolbar"" + "" "" + props.visible}
      aria-label=""Cursor options""
      tabIndex=""0""
    >
      <Toolbar.ToggleGroup
        type=""single""
        className=""ToolbarToggleGroup""
        value=""target""
      >
        <div className=""ToolbarToggleWrap"">
          <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""target"">
            <TransformIcon />
          </Toolbar.ToggleItem>
        </div>
        <Toolbar.Separator className=""ToolbarSeparator"" />
        <ToolTrigger
          type=""button""
          content={chrome.i18n.getMessage(""clearBlurredElementsTooltip"")}
          onClick={() => {
            // Remove class screenity-blur from all elements
            const blurredElements =
              document.querySelectorAll("".screenity-blur"");
            blurredElements.forEach((element) => {
              element.classList.remove(""screenity-blur"");
            });
          }}
        >
          <TrashIcon />
        </ToolTrigger>
      </Toolbar.ToggleGroup>
    </Toolbar.Root>
  );
};

export default BlurToolbar;
"
Content\toolbar\layout\CursorToolbar.jsx,Included,application/octet-stream,2572,"import React, { useState, useEffect, useContext } from ""react"";
import * as Toolbar from ""@radix-ui/react-toolbar"";
import TooltipWrap from ""../components/TooltipWrap"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

// Icons
import {
  CursorIcon,
  TargetCursorIcon,
  HighlightCursorIcon,
  SpotlightCursorIcon,
  HideCursorIcon,
} from ""../components/SVG"";

const CursorToolbar = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <Toolbar.Root
      className={""DrawingToolbar"" + "" "" + props.visible}
      aria-label=""Cursor options""
      tabIndex=""0""
    >
      <Toolbar.ToggleGroup
        type=""single""
        className=""ToolbarToggleGroup""
        value={contentState.cursorMode}
        onValueChange={(value) => {
          if (value) {
            setContentState((prevContentState) => ({
              ...prevContentState,
              cursorMode: value,
            }));
            props.setMode(false);

            chrome.storage.local.set({
              cursorMode: value,
            });
          }
        }}
      >
        <TooltipWrap content=""Default"">
          <div className=""ToolbarToggleWrap"">
            <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""none"">
              <CursorIcon />
            </Toolbar.ToggleItem>
          </div>
        </TooltipWrap>
        <Toolbar.Separator className=""ToolbarSeparator"" />
        <TooltipWrap content={chrome.i18n.getMessage(""highlightClicksTooltip"")}>
          <div className=""ToolbarToggleWrap"">
            <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""target"">
              <TargetCursorIcon />
            </Toolbar.ToggleItem>
          </div>
        </TooltipWrap>
        <TooltipWrap content={chrome.i18n.getMessage(""highlightCursorTooltip"")}>
          <div className=""ToolbarToggleWrap"">
            <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""highlight"">
              <HighlightCursorIcon />
            </Toolbar.ToggleItem>
          </div>
        </TooltipWrap>
        <TooltipWrap content={chrome.i18n.getMessage(""spotlightCursorTooltip"")}>
          <div className=""ToolbarToggleWrap"">
            <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""spotlight"">
              <SpotlightCursorIcon />
            </Toolbar.ToggleItem>
          </div>
        </TooltipWrap>
      </Toolbar.ToggleGroup>
    </Toolbar.Root>
  );
};

export default CursorToolbar;
"
Content\toolbar\layout\DrawingToolbar.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,6725,"import React, {
  useRef,
  useEffect,
  useCallback,
  useContext,
  useState,
} from ""react"";
import * as Toolbar from ""@radix-ui/react-toolbar"";

// Components
import ToolTrigger from ""../components/ToolTrigger"";
import RadialMenu from ""../components/RadialMenu"";
import ShapeToolbar from ""./ShapeToolbar"";

// Canvas utils
import {
  undoCanvas,
  redoCanvas,
  saveCanvas,
} from ""../../canvas/modules/History"";

// Icons
import {
  DrawIcon,
  EraserIcon,
  ArrowIcon,
  ImageIcon,
  UndoIcon,
  RedoIcon,
  TransformIcon,
  HighlighterIcon,
  TextIcon,
  RectangleIcon,
  TriangleIcon,
  CircleIcon,
  RectangleFilledIcon,
  CircleFilledIcon,
  TriangleFilledIcon,
  TrashIcon,
} from ""../components/SVG"";

// Rewrite imports above with the chrome-extension URL inline

import TooltipWrap from ""../components/TooltipWrap"";
import ImageTool from ""../../canvas/modules/ImageTool"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const DrawingToolbar = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [tool, setTool] = useState("""");

  const imageFileInput = useRef(null);

  useEffect(() => {
    setTool(contentState.tool);
  }, [contentState.tool]);

  const handleImageChange = useCallback(
    (e) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        setContentState((prevContentState) => ({
          ...prevContentState,
          isAddingImage: true,
        }));

        // De-select all objects
        contentState.canvas.discardActiveObject();
        contentState.canvas.requestRenderAll();

        // Make all objects unselectable
        contentState.canvas.forEachObject((obj) => {
          obj.selectable = false;
        });

        const imgTool = ImageTool(
          contentState.canvas,
          e.target.result,
          contentState,
          setContentState,
          saveCanvas
        );

        imageFileInput.current.value = """";

        return () => {
          imgTool.removeEventListeners();
        };
      };

      reader.readAsDataURL(e.target.files[0]);
    },
    [contentState, setContentState, saveCanvas]
  );

  return (
    <Toolbar.Root
      className={""DrawingToolbar"" + "" "" + props.visible}
      aria-label=""Drawing tools""
    >
      <Toolbar.ToggleGroup
        type=""single""
        className=""ToolbarToggleGroup""
        value={tool}
        onValueChange={(value) => {
          if (value)
            setContentState((prevContentState) => ({
              ...prevContentState,
              tool: value,
            }));
        }}
      >
        <ToolTrigger
          type=""toggle""
          value=""select""
          content={chrome.i18n.getMessage(""selectToolTooltip"")}
        >
          <TransformIcon />
        </ToolTrigger>
        <ToolTrigger
          type=""toggle""
          value=""pen""
          content={chrome.i18n.getMessage(""penToolTooltip"")}
        >
          <DrawIcon />
        </ToolTrigger>
        <ToolTrigger
          type=""toggle""
          value=""highlighter""
          content={chrome.i18n.getMessage(""highlighterToolTooltip"")}
        >
          <HighlighterIcon />
        </ToolTrigger>
        <ToolTrigger
          type=""toggle""
          value=""eraser""
          content={chrome.i18n.getMessage(""eraserToolTooltip"")}
        >
          <EraserIcon />
        </ToolTrigger>
        <RadialMenu />
        <ToolTrigger
          type=""toggle""
          value=""text""
          content={chrome.i18n.getMessage(""textToolTooltip"")}
        >
          <TextIcon />
        </ToolTrigger>
        <ShapeToolbar visible={tool === ""shape"" ? ""show-toolbar"" : """"} />
        <ToolTrigger
          type=""toggle""
          value=""shape""
          content={chrome.i18n.getMessage(""shapeToolTooltip"")}
        >
          {contentState.shape === ""rectangle"" && contentState.shapeFill ? (
            <RectangleFilledIcon />
          ) : contentState.shape === ""circle"" && contentState.shapeFill ? (
            <CircleFilledIcon />
          ) : contentState.shape === ""triangle"" && contentState.shapeFill ? (
            <TriangleFilledIcon />
          ) : contentState.shape === ""rectangle"" && !contentState.shapeFill ? (
            <RectangleIcon />
          ) : contentState.shape === ""circle"" && !contentState.shapeFill ? (
            <CircleIcon />
          ) : contentState.shape === ""triangle"" && !contentState.shapeFill ? (
            <TriangleIcon />
          ) : null}
        </ToolTrigger>
        <ToolTrigger
          type=""toggle""
          value=""arrow""
          content={chrome.i18n.getMessage(""arrowToolTooltip"")}
        >
          <ArrowIcon />
        </ToolTrigger>
        <ToolTrigger
          type=""button""
          value=""image""
          content={chrome.i18n.getMessage(""imageToolTooltip"")}
          onClick={(e) => imageFileInput.current.click()}
        >
          <ImageIcon />
          <input
            type=""file""
            id=""file""
            accept=""image/*""
            style={{ display: ""none"" }}
            ref={imageFileInput}
            onChange={handleImageChange}
          />
        </ToolTrigger>
      </Toolbar.ToggleGroup>
      <Toolbar.Separator className=""ToolbarSeparator"" />
      <ToolTrigger
        type=""button""
        content={chrome.i18n.getMessage(""undoTooltip"")}
        disabled={contentState.undoStack.length === 0 ? true : false}
        onClick={() => undoCanvas(contentState, setContentState)}
      >
        <UndoIcon />
      </ToolTrigger>
      <ToolTrigger
        type=""button""
        content={chrome.i18n.getMessage(""redoTooltip"")}
        disabled={contentState.redoStack.length === 0 ? true : false}
        onClick={() => redoCanvas(contentState, setContentState)}
      >
        <RedoIcon />
      </ToolTrigger>
      <ToolTrigger
        type=""button""
        content={chrome.i18n.getMessage(""clearCanvasTooltip"")}
        disabled={
          contentState.canvas
            ? content"
Content\toolbar\layout\ShapeToolbar.jsx,Included,application/octet-stream,3137,"import React, { useEffect, useState, useContext, useRef } from ""react"";

import * as Toolbar from ""@radix-ui/react-toolbar"";
import ToolTrigger from ""../components/ToolTrigger"";

// Icons
import {
  RectangleIcon,
  CircleIcon,
  TriangleIcon,
  RectangleFilledIcon,
  CircleFilledIcon,
  TriangleFilledIcon,
} from ""../components/SVG"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

const ShapeToolbar = (props) => {
  const [contentState, setContentState] = useContext(contentStateContext);

  return (
    <div
      aria-label=""Cursor options""
      tabIndex=""0""
      className={""shapeToolbar "" + props.visible}
    >
      <Toolbar.ToggleGroup
        type=""single""
        className=""ToolbarToggleGroup""
        value={contentState.shape}
        onValueChange={(value) => {
          if (value)
            setContentState((prevContentState) => ({
              ...prevContentState,
              shape: value,
            }));
          chrome.storage.local.set({ shape: value });
        }}
      >
        <div className=""ToolbarToggleWrap"">
          <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""rectangle"">
            {contentState.shapeFill ? (
              <RectangleFilledIcon />
            ) : (
              <RectangleIcon />
            )}
          </Toolbar.ToggleItem>
        </div>
        <div className=""ToolbarToggleWrap"">
          <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""circle"">
            {contentState.shapeFill ? <CircleFilledIcon /> : <CircleIcon />}
          </Toolbar.ToggleItem>
        </div>
        <div className=""ToolbarToggleWrap"">
          <Toolbar.ToggleItem className=""ToolbarToggleItem"" value=""triangle"">
            {contentState.shapeFill ? <TriangleFilledIcon /> : <TriangleIcon />}
          </Toolbar.ToggleItem>
        </div>
      </Toolbar.ToggleGroup>
      <Toolbar.Separator className=""ToolbarSeparator"" />
      <ToolTrigger
        type=""button""
        value=""fill""
        content={chrome.i18n.getMessage(""toggleFillTooltip"")}
        onClick={() => {
          setContentState((prevContentState) => ({
            ...prevContentState,
            shapeFill: !contentState.shapeFill,
          }));
          chrome.storage.local.set({ shapeFill: !contentState.shapeFill });
        }}
      >
        {contentState.shape === ""rectangle"" && contentState.shapeFill ? (
          <RectangleIcon />
        ) : contentState.shape === ""circle"" && contentState.shapeFill ? (
          <CircleIcon />
        ) : contentState.shape === ""triangle"" && contentState.shapeFill ? (
          <TriangleIcon />
        ) : contentState.shape === ""rectangle"" && !contentState.shapeFill ? (
          <RectangleFilledIcon />
        ) : contentState.shape === ""circle"" && !contentState.shapeFill ? (
          <CircleFilledIcon />
        ) : contentState.shape === ""triangle"" && !contentState.shapeFill ? (
          <TriangleFilledIcon />
        ) : null}
      </ToolTrigger>
    </div>
  );
};

export default ShapeToolbar;
"
Content\toolbar\layout\ToolbarWrap.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,17281,"import React, { useLayoutEffect, useEffect, useContext, useRef } from ""react"";
import * as Toolbar from ""@radix-ui/react-toolbar"";

import { Rnd } from ""react-rnd"";

// Layout
import DrawingToolbar from ""./DrawingToolbar"";
import CursorToolbar from ""./CursorToolbar"";
import BlurToolbar from ""./BlurToolbar"";

// Components
import ToolTrigger from ""../components/ToolTrigger"";
import Toast from ""../components/Toast"";

// Context
import { contentStateContext } from ""../../context/ContentState"";

// Icons
import {
  GrabIcon,
  StopIcon,
  DrawIcon,
  PauseIcon,
  ResumeIcon,
  CursorIcon,
  TargetCursorIcon,
  HighlightCursorIcon,
  SpotlightCursorIcon,
  RestartIcon,
  DiscardIcon,
  CameraIcon,
  BlurIcon,
  OnboardingArrow,
  CloseButtonToolbar,
} from ""../components/SVG"";
import MicToggle from ""../components/MicToggle"";

const ToolbarWrap = () => {
  const [contentState, setContentState, t, setT] =
    useContext(contentStateContext);
  const [mode, setMode] = React.useState("""");
  const DragRef = React.useRef(null);
  const ToolbarRef = React.useRef(null);
  const [side, setSide] = React.useState(""ToolbarTop"");
  const [elastic, setElastic] = React.useState("""");
  const [shake, setShake] = React.useState("""");
  const [dragging, setDragging] = React.useState("""");
  const [timer, setTimer] = React.useState(0);
  const [timestamp, setTimestamp] = React.useState(""00:00"");
  const [transparent, setTransparent] = React.useState(false);
  const [forceTransparent, setForceTransparent] = React.useState("""");
  const timeRef = React.useRef("""");

  useEffect(() => {
    if (contentState.toolbarHover && contentState.hideUI) {
      setTransparent(""ToolbarTransparent"");
    } else {
      setTransparent(false);
      setForceTransparent("""");
    }
  }, [contentState.toolbarHover, contentState.hideUI]);

  // If mouse is down and toolbarHover is true, set forceTransparent
  useEffect(() => {
    if (!contentState.toolbarHover) return;
    if (!contentState.shadowRef) return;
    if (!contentState.hideUI) return;
    const handleMouseDown = (e) => {
      if (contentState.toolbarHover && contentState.hideUI) {
        // check if mouse is over toolbar
        if (ToolbarRef.current && ToolbarRef.current.contains(e.target)) return;
        if (
          contentState.shadowRef &&
          (contentState.shadowRef.contains(e.target) ||
            contentState.shadowRef === e.target ||
            contentState.shadowRef === e.target.parentNode)
        )
          return;

        setForceTransparent(""ForceTransparent"");
      }
    };

    const handleMouseUp = (e) => {
      setForceTransparent("""");
    };

    document.addEventListener(""mousedown"", handleMouseDown);
    document.addEventListener(""mouseup"", handleMouseUp);

    return () => {
      document.removeEventListener(""mousedown"", handleMouseDown);
      document.removeEventListener(""mouseup"", handleMouseUp);
    };
  }, [contentState.toolbarHover, contentState.shadowRef, contentState.hideUI]);

  useEffect(() => {
    if (!isNaN(t)) {
      setTimer(t);
      const hours = Math.floor(t / 3600);
      const minutes = Math.floor((t % 3600) / 60);
      const seconds = t % 60;

      // Determine the timestamp format based on the total duration (t)
      let newTimestamp =
        hours > 0
          ? `${hours.toString().padStart(2, ""0"")}:${minutes
              .toString()
              .padStart(2, ""0"")}:${seconds.toString().padStart(2, ""0"")}`
          : `${minutes.toString().padStart(2, ""0"")}:${seconds
              .toString()
              .padStart(2, ""0"")}`;

      // Adjust the width of the time display based on the duration
      if (hours > 0) {
        // Adjust for HH:MM:SS format when hours are present
        timeRef.current.style.width = ""58px""; // You might need to adjust this value based on your actual UI
      } else {
        // Adjust for MM:SS format when there are no hours
        timeRef.current.style.width = ""42px""; // Adjust this value as needed
      }

      setTimestamp(newTimestamp);
    }
  }, [t]);

  useLayoutEffect(() => {
    function setToolbarPosition(e) {
      let xpos = DragRef.current.getDraggablePosition().x;
      let ypos = DragRef.current.getDraggablePosition().y;

      // Width and height of toolbar
      const width = ToolbarRef.current.getBoundingClientRect().width;
      const height = ToolbarRef.current.getBoundingClientRect().height;

      // Keep toolbar positioned relative to the bottom and right of the screen, proportionally
      if (xpos + width + 30 > window.innerWidth) {
        xpos = window.innerWidth - width - 30;
      }
      if (ypos + height - 60 > window.innerHeight) {
        ypos = window.innerHeight - height + 60;
      }

      DragRef.current.updatePosition({ x: xpos, y: ypos });
    }
    window.addEventListener(""resize"", setToolbarPosition);
    setToolbarPosition();
    return () => window.removeEventListener(""resize"", setToolbarPosition);
  }, []);

  const handleChange = (value) => {
    setMode(value);
  };

  const handleDragStart = (e, d) => {
    setDragging(""ToolbarDragging"");
  };

  const handleDrag = (e, d) => {
    // Width and height
    const width = ToolbarRef.current.getBoundingClientRect().width;
    const height = ToolbarRef.current.getBoundingClientRect().height;

    if (d.y < 130) {
      setSide(""ToolbarBottom"");
    } else {
      setSide(""ToolbarTop"");
    }

    if (
      d.x < -25 ||
      d.x + width > window.innerWidth ||
      d.y < 60 ||
      d.y + height - 80 > window.innerHeight
    ) {
      setShake(""ToolbarShake"");
    } else {
      setShake("""");
    }
  };

  const handleDrop = (e, d) => {
    setShake("""");
    setDragging("""");
    let xpos = d.x;
    let ypos = d.y;

    // Width and height
    const width = ToolbarRef.current.getBoundingClientRect().width;
    const height = ToolbarRef.current.getBoundingClientRect().height;

    // Check if toolbar is off screen
    if (d.x < -10) {
      setElastic(""ToolbarElastic"");
      xpos "
Content\toolbar\styles\components\_ColorWheel.scss,Excluded by file type,,0,
Content\toolbar\styles\components\_RadialMenu.scss,Excluded by file type,,0,
Content\toolbar\styles\components\_StrokeWidth.scss,Excluded by file type,,0,
Content\toolbar\styles\components\_Toast.scss,Excluded by file type,,0,
Content\toolbar\styles\components\_Tooltip.scss,Excluded by file type,,0,
Content\toolbar\styles\layout\_DrawingToolbar.scss,Excluded by file type,,0,
Content\toolbar\styles\layout\_ShapeToolbar.scss,Excluded by file type,,0,
Content\toolbar\styles\layout\_Toolbar.scss,Excluded by file type,,0,
Content\toolbar\styles\_Page.scss,Excluded by file type,,0,
Content\toolbar\Toolbar.jsx,Included,application/octet-stream,226,"import React from ""react"";

import ToolbarWrap from ""./layout/ToolbarWrap"";

const Toolbar = () => {
  return (
    <div className=""toolbar-page"">
      <ToolbarWrap />
    </div>
  );
};

export default Toolbar;
"
Content\utils\BlurTool.jsx,Included,application/octet-stream,3953,"import React, {
  useLayoutEffect,
  useState,
  useRef,
  useContext,
  useEffect,
} from ""react"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const BlurTool = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const hoveredElementRef = useRef(null);
  const blurModeRef = useRef(null);
  const [showOutline, setShowOutline] = useState(false);

  useEffect(() => {
    blurModeRef.current = contentState.blurMode;
  }, [contentState.blurMode]);

  useEffect(() => {
    if (!contentState.showExtension) {
      setShowOutline(false);
      // Remove blur from all elements
      const elements = document.querySelectorAll("".screenity-blur"");
      elements.forEach((element) => {
        element.classList.remove(""screenity-blur"");
      });
    }
  }, [contentState.showExtension]);

  useLayoutEffect(() => {
    const handleMouseMove = (event) => {
      if (!blurModeRef.current) {
        setShowOutline(false);
        return;
      }
      const target = event.target;
      if (
        !target.classList.contains(""screenity-outline"") &&
        !target.closest(""#screenity-ui #screenity-ui *"")
      ) {
        hoveredElementRef.current = target;
        setShowOutline(true);
        document.body.style.cursor = ""pointer"";
      } else {
        document.body.style.cursor = ""auto"";
      }
    };

    const handleMouseOut = () => {
      setShowOutline(false);
    };

    const handleMouseDown = (event) => {
      if (!blurModeRef.current) {
        setShowOutline(false);
        return;
      }

      const target = event.target;
      if (target.closest(""#screenity-ui, #screenity-ui *"")) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();
    };

    const handleElementClick = (event) => {
      if (!blurModeRef.current) {
        setShowOutline(false);
        return;
      }

      const target = event.target;
      if (target.closest(""#screenity-ui, #screenity-ui *"")) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();
      target.classList.toggle(""screenity-blur"");
    };

    const handleMouseUp = (event) => {
      if (!blurModeRef.current) {
        setShowOutline(false);
        return;
      }

      const target = event.target;
      if (target.closest(""#screenity-ui, #screenity-ui *"")) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
    };

    document.body.addEventListener(""mouseover"", handleMouseMove, true);
    document.body.addEventListener(""mousedown"", handleMouseDown, true);
    document.body.addEventListener(""mouseout"", handleMouseOut, true);
    document.body.addEventListener(""mouseup"", handleMouseUp, true);
    document.body.addEventListener(""click"", handleElementClick, true);

    return () => {
      document.body.removeEventListener(""mouseover"", handleMouseMove);
      document.body.removeEventListener(""mousedown"", handleMouseDown);
      document.body.removeEventListener(""mouseout"", handleMouseOut);
      document.body.removeEventListener(""mouseup"", handleMouseUp);
      document.body.removeEventListener(""click"", handleElementClick);
    };
  }, []);

  return (
    <div>
      {showOutline && (
        <div
          className=""screenity-outline""
          style={{
            top:
              hoveredElementRef.current.getBoundingClientRect().top +
              window.scrollY +
              ""px"",
            left:
              hoveredElementRef.current.getBoundingClientRect().left +
              window.scrollX +
              ""px"",
            width: hoveredElementRef.current.offsetWidth + ""px"",
            height: hoveredElementRef.current.offsetHeight + ""px"",
          }}
        ></div>
      )}
    </div>
  );
};

export default BlurTool;
"
Content\utils\CursorModes.jsx,Included,application/octet-stream,5104,"import React, { useState, useEffect, useContext, useRef } from ""react"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const CursorModes = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const modeRef = useRef(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    modeRef.current = contentState.cursorMode;
  }, [contentState.cursorMode]);

  const mouseDownHandler = (e) => {
    if (modeRef.current === ""target"") {
      document.querySelector("".cursor-click-target"").style.transform =
        ""translate(-50%, -50%) scale(1)"";
      document.querySelector("".cursor-click-target"").style.opacity = ""1"";
    }
  };

  const mouseUpHandler = (e) => {
    if (modeRef.current === ""target"") {
      document.querySelector("".cursor-click-target"").style.transform =
        ""translate(-50%, -50%) scale(0)"";
      document.querySelector("".cursor-click-target"").style.opacity = ""0"";

      window.setTimeout(() => {
        document.querySelector("".cursor-click-target"").style.transform =
          ""translate(-50%, -50%) scale(1)"";
      }, 350);
    }
  };

  const [lastMousePosition, setLastMousePosition] = useState({ x: 0, y: 0 });
  const lastMouseRef = useRef(lastMousePosition);

  useEffect(() => {
    lastMouseRef.current = lastMousePosition;
  }, [lastMousePosition]);

  const updateCursorPosition = () => {
    const scrollTop = window.scrollY;
    const scrollLeft = window.scrollX;

    const cursorElement =
      modeRef.current === ""target""
        ? document.querySelector("".cursor-click-target"")
        : modeRef.current === ""highlight""
        ? document.querySelector("".cursor-highlight"")
        : document.querySelector("".spotlight"");

    if (cursorElement) {
      cursorElement.style.top = lastMouseRef.current.y + scrollTop + ""px"";
      cursorElement.style.left = lastMouseRef.current.x + scrollLeft + ""px"";
    }
  };

  const mouseMoveHandler = (e) => {
    setLastMousePosition({ x: e.clientX, y: e.clientY });
    updateCursorPosition();
  };

  const scrollHandler = () => {
    updateCursorPosition();
  };

  // Show click target when user clicks anywhere for 1 second, animate scale up and fade out
  useEffect(() => {
    document.addEventListener(""mousedown"", mouseDownHandler);
    document.addEventListener(""mousemove"", mouseMoveHandler);
    document.addEventListener(""mouseup"", mouseUpHandler);
    document.addEventListener(""scroll"", scrollHandler);

    return () => {
      document.removeEventListener(""mousedown"", mouseDownHandler);
      document.removeEventListener(""mousemove"", mouseMoveHandler);
      document.removeEventListener(""mouseup"", mouseUpHandler);
      document.removeEventListener(""scroll"", scrollHandler);
    };
  }, []);

  return (
    <div>
      <div
        className=""cursor-highlight""
        style={{
          display: ""block"",
          visibility:
            contentState.cursorMode === ""highlight"" ? ""visible"" : ""hidden"",
          position: ""absolute"",
          top: 0,
          left: 0,
          width: ""80px"",
          height: ""80px"",
          pointerEvents: ""none"",
          zIndex: 99999999999,
          background: ""yellow"",
          opacity: "".5"",
          transform: ""translate(-50%, -50%)"",
          borderRadius: ""50%"",
          animation: ""none"",
        }}
      ></div>
      <div
        className=""cursor-click-target""
        style={{
          display: ""block"",
          visibility:
            contentState.cursorMode === ""target"" ? ""visible"" : ""hidden"",
          position: ""absolute"",
          top: 0,
          opacity: 0,
          left: 0,
          width: ""40px"",
          height: ""40px"",
          transform: ""translate(-50%, -50%) scale(1)"",
          pointerEvents: ""none"",
          zIndex: 99999999999,
          border: ""3px solid red"",
          transform: ""none"",
          borderRadius: ""50%"",
          animation: ""none"",
          transition:
            ""opacity .5s cubic-bezier(.25,.8,.25,1), transform .35s cubic-bezier(.25,.8,.25,1)"",
        }}
      ></div>
      <div
        className=""spotlight""
        style={{
          position: ""absolute"",
          display: contentState.cursorMode === ""spotlight"" ? ""block"" : ""none"",
          top: mousePosition.y + ""px"",
          left: mousePosition.x + ""px"",
          width: ""100px"",
          height: ""100px"",
          borderRadius: ""50%"",
          boxShadow: ""0 0 0 9999px rgba(0, 0, 0, 0.5)"",
          transform: ""translate(-50%, -50%)"",
          pointerEvents: ""none"",
          zIndex: 99999999999,
        }}
      ></div>
      <style>
        {`
					@keyframes scaleDown {
							from {
									transform: translate(-50%, -50%) scale(1);
									opacity: 1;
							}
							to {
									transform: translate(-50%, -50%) scale(0);
									opacity: 0;
							}
					`}
      </style>
    </div>
  );
};

export default CursorModes;
"
Content\utils\ZoomContainer.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,9338,"import React, { useState, useEffect, useRef, useContext } from ""react"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const ZoomContainer = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [zoomLevel, setZoomLevel] = useState(1);
  const scaleRef = useRef(1);
  const translateXRef = useRef(0);
  const translateYRef = useRef(0);
  const cursorXRef = useRef(0);
  const cursorYRef = useRef(0);
  const isKeyDownRef = useRef(false);
  const isKeyUpRef = useRef(false);
  const zoomSelector = useRef(null);
  const oldPosition = useRef(null);
  const oldWidth = useRef(null);
  const oldHeight = useRef(null);
  const oldOverflow = useRef(null);
  const oldTop = useRef(null);
  const oldLeft = useRef(null);
  const contentStateRef = useRef(contentState);
  const observer = useRef(null);

  useEffect(() => {
    oldPosition.current = document.body.style.position;
    oldWidth.current = document.body.style.width;
    oldHeight.current = document.body.style.height;
    oldOverflow.current = document.body.style.overflow;
    oldTop.current = document.body.style.top;
    oldLeft.current = document.body.style.left;
  }, []);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  const handleKeyDown = (e) => {
    // Alt / Option + Shift + Z
    if (e.code === ""KeyE"" && e.altKey && e.shiftKey) {
      //if (!contentStateRef.current.recording) return;
      if (!contentStateRef.current.zoomEnabled) return;
      if (isKeyDownRef.current) return;
      isKeyDownRef.current = true;
      zoomIn();
    }
  };

  const handleKeyUp = (e) => {
    if (e.code === ""KeyE"" || e.altKey || e.shiftKey) {
      isKeyDownRef.current = false;
      isKeyUpRef.current = true;
      zoomOut();

      setTimeout(() => {
        isKeyUpRef.current = false;
        setTimeout(() => {
          enableScrolling();
        }, 500);
      }, 500);
    }
  };

  const handleMouseMove = (e) => {
    //if (!contentStateRef.current.recording) return;
    if (!contentStateRef.current.zoomEnabled) return;

    const { top, left } = document.documentElement.getBoundingClientRect();

    cursorXRef.current = e.clientX - left;
    cursorYRef.current = e.clientY - top;
    applyTransform();
  };

  const zoomIn = () => {
    scaleRef.current *= 1.5;
    setZoomLevel(scaleRef.current);
    applyTransformWithTransition();
    preventScrolling();
  };

  const zoomOut = () => {
    scaleRef.current = 1;
    translateXRef.current = 0;
    translateYRef.current = 0;
    setZoomLevel(scaleRef.current);
    //applyTransformWithTransition();
    //enableScrolling();
  };

  const applyTransform = () => {
    if (!zoomSelector.current) return;
    //if (!contentStateRef.current.recording) return;
    const { current: scale } = scaleRef;
    const { current: translateX } = translateXRef;
    const { current: translateY } = translateYRef;

    const originX = cursorXRef.current - translateX;
    const originY = cursorYRef.current - translateY;

    zoomSelector.current.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
    zoomSelector.current.style.transformOrigin = `${originX}px ${originY}px`;

    // I also need to apply the transform to the #canvas-wrapper, if it exists
    const canvasWrapper = document.querySelector(""#canvas-wrapper-screenity"");

    // Substract scroll position
    const fixedOriginX = originX - window.scrollX;
    const fixedOriginY = originY - window.scrollY;
    if (canvasWrapper) {
      canvasWrapper.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
      canvasWrapper.style.transformOrigin = `${fixedOriginX}px ${fixedOriginY}px`;
    }

    // Also to #mockup-wrapper
    //const mockupWrapper = document.querySelector(""#mockup-wrapper"");
    //if (mockupWrapper) {
    //  mockupWrapper.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
    //  mockupWrapper.style.transformOrigin = `${originX}px ${originY}px`;
    //}
  };

  const applyTransformWithTransition = () => {
    if (!zoomSelector.current) return;

    zoomSelector.current.style.transition = ""transform 0.5s"";
    if (document.querySelector(""#canvas-wrapper-screenity"")) {
      document.querySelector(""#canvas-wrapper-screenity"").style.transition =
        ""transform 0.5s"";
    }
    //if (document.querySelector(""#mockup-wrapper"")) {
    //  document.querySelector(""#mockup-wrapper"").style.transition =
    //    ""transform 0.5s"";
    //}
    applyTransform();
  };

  const preventScrolling = () => {
    /*
    zoomSelector.current.style.position = ""fixed"";
    zoomSelector.current.style.top = ""0"";
    zoomSelector.current.style.left = ""0"";
    zoomSelector.current.style.overflow = ""hidden"";
    zoomSelector.current.style.width = ""100vw"";
    zoomSelector.current.style.height = ""100vh"";
		*/
  };

  const enableScrolling = () => {
    if (!zoomSelector.current) return;
    zoomSelector.current.style.position = oldPosition.current;
    zoomSelector.current.style.top = oldTop.current;
    zoomSelector.current.style.left = oldLeft.current;
    zoomSelector.current.style.overflow = oldOverflow.current;
    zoomSelector.current.style.width = oldWidth.current;
    zoomSelector.current.style.height = oldHeight.current;
  };

  useEffect(() => {
    window.addEventListener(""keydown"", handleKeyDown);
    window.addEventListener(""keyup"", handleKeyUp);
    window.addEventListener(""mousemove"", handleMouseMove);

    return () => {
      window.removeEventListener(""keydown"", handleKeyDown);
      window.removeEventListener(""keyup"", handleKeyUp);
      window.removeEventListener(""mousemove"", handleMouseMove);
    };
  }, [contentState.zoomEnabled, contentState.showExtension]);

  useEffect(() => {
    if (!contentState.zoomEnabled) return;
    if (!contentState.showPopup) return;

    setTimeout(() => {
      //if (!contentState.recording) return;
      if (document.querySelector(""#scr"
Content\warning\styles\_Warning.scss,Excluded by file type,,0,
Content\warning\Warning.jsx,Included,application/octet-stream,2565,"import React, {
  useState,
  useEffect,
  useContext,
  useCallback,
  useRef,
} from ""react"";

import {
  AudioIcon,
  CameraCloseIcon,
  NotSupportedIcon,
} from ""../toolbar/components/SVG"";

import * as ToastEl from ""@radix-ui/react-toast"";

// Context
import { contentStateContext } from ""../context/ContentState"";

const Warning = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const [open, setOpen] = useState(false);
  const [title, setTitle] = useState(""Record computer audio"");
  const [description, setDescription] = useState("""");
  const [icon, setIcon] = useState(""AudioIcon"");
  const [duration, setDuration] = useState(10000);

  const openWarning = useCallback((title, description, icon, duration) => {
    setTitle(title);
    setDescription(description);
    setIcon(icon);
    setDuration(duration);
    setOpen(true);
  }, []);

  useEffect(() => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      openWarning: openWarning,
    }));

    return () => {
      setContentState((prevContentState) => ({
        ...prevContentState,
        openWarning: null,
      }));
    };
  }, []);

  useEffect(() => {
    if (icon === ""AudioIcon"") {
      if (contentState.recordingType === ""region"") {
        setOpen(false);
      }
    }
  }, [contentState.recordingType]);

  useEffect(() => {
    if (contentState.recording) {
      setOpen(false);
    }
  }, [contentState.recording]);

  return (
    <ToastEl.Provider swipeDirection=""up"" duration={duration}>
      <ToastEl.Root
        className=""warning-root""
        open={open}
        onOpenChange={setOpen}
        onSwipeEnd={() => {
          setOpen(false);
        }}
      >
        <div className=""warning-icon"">
          {icon === ""AudioIcon"" && <AudioIcon />}
          {icon === ""NotSupportedIcon"" && <NotSupportedIcon />}
        </div>
        <div className=""warning-content"">
          <ToastEl.Title className=""warning-title"">{title}</ToastEl.Title>
          <ToastEl.Description className=""warning-description"">
            {description}
          </ToastEl.Description>
        </div>
        <ToastEl.Close
          className=""warning-close""
          onClick={() => {
            setOpen(false);
          }}
        >
          <CameraCloseIcon />
        </ToastEl.Close>
      </ToastEl.Root>
      <ToastEl.Viewport className=""WarningViewport"" />
    </ToastEl.Provider>
  );
};

export default Warning;
"
Content\Wrapper.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,6494,"import React, { useContext, useRef, useEffect } from ""react"";

// Components
import PopupContainer from ""./popup/PopupContainer"";
import Toolbar from ""./toolbar/Toolbar"";
import Camera from ""./camera/Camera"";
import CameraOnly from ""./camera-only/CameraOnly"";
import Canvas from ""./canvas/Canvas"";
import Countdown from ""./countdown/Countdown"";
import Modal from ""./modal/Modal"";
import Warning from ""./warning/Warning"";

import Region from ""./region/Region"";

// Using ShadowDOM
import root from ""react-shadow"";

// Import styles raw to add into the ShadowDOM
// dist?
import styles from ""!raw-loader!./styles/app.css"";

// Utils
import ZoomContainer from ""./utils/ZoomContainer"";
import BlurTool from ""./utils/BlurTool"";
import CursorModes from ""./utils/CursorModes"";

// Context
import { contentStateContext } from ""./context/ContentState"";

const Wrapper = () => {
  const [contentState, setContentState] = useContext(contentStateContext);
  const shadowRef = useRef(null);
  const parentRef = useRef(null);
  const permissionsRef = useRef(null);
  const regionCaptureRef = useRef(null);

  useEffect(() => {
    if (!parentRef.current) return;

    setContentState((prevContentState) => ({
      ...prevContentState,
      parentRef: parentRef.current,
    }));
  }, [parentRef.current]);

  useEffect(() => {
    if (!shadowRef.current) return;
    setContentState((prevContentState) => ({
      ...prevContentState,
      shadowRef: shadowRef.current,
    }));
  }, [shadowRef.current]);

  useEffect(() => {
    if (!regionCaptureRef.current) return;
    setContentState((prevContentState) => ({
      ...prevContentState,
      regionCaptureRef: regionCaptureRef.current,
    }));
  }, [regionCaptureRef.current]);

  useEffect(() => {
    if (contentState.permissionsChecked) return;
    if (!permissionsRef.current) return;
    if (!contentState.showExtension) return;
    if (!contentState.permissionsLoaded) return;

    permissionsRef.current.contentWindow.postMessage(
      {
        type: ""screenity-get-permissions"",
      },
      ""*""
    );

    setContentState((prevContentState) => ({
      ...prevContentState,
      permissionsChecked: true,
    }));
  }, [
    permissionsRef.current,
    contentState.showExtension,
    contentState.permissionsLoaded,
  ]);

  return (
    <div ref={parentRef}>
      {contentState.showExtension && (
        <iframe
          style={{
            // all: ""unset"",
            display: ""none"",
            visibility: ""hidden"",
          }}
          ref={permissionsRef}
          src={chrome.runtime.getURL(""permissions.html"")}
          allow=""camera *; microphone *""
        ></iframe>
      )}
      {contentState.hasOpenedBefore && (
        <iframe
          style={{
            // all: ""unset"",
            display: ""none"",
            visibility: ""hidden"",
          }}
          ref={regionCaptureRef}
          src={chrome.runtime.getURL(""region.html"")}
          allow=""camera *; microphone *; display-capture *""
        ></iframe>
      )}

      {contentState.zoomEnabled && <ZoomContainer />}
      <BlurTool />
      {contentState.showExtension || contentState.recording ? (
        <div>
          {!contentState.recording &&
            !contentState.drawingMode &&
            !contentState.blurMode && (
              <div
                style={{
                  // all: ""unset"",
                  width: ""100%"",
                  height: ""100%"",
                  zIndex: 999999999,
                  pointerEvents: ""all"",
                  position: ""fixed"",
                  background:
                    window.location.href.indexOf(
                      chrome.runtime.getURL(""setup.html"")
                    ) === -1 &&
                    window.location.href.indexOf(
                      chrome.runtime.getURL(""playground.html"")
                    ) === -1 &&
                    !contentState.pendingRecording
                      ? ""rgba(0,0,0,0.15)""
                      : ""rgba(0,0,0,0)"",
                  top: 0,
                  left: 0,
                }}
                onClick={() => {
                  if (
                    window.location.href.indexOf(
                      chrome.runtime.getURL(""setup.html"")
                    ) === -1 &&
                    window.location.href.indexOf(
                      chrome.runtime.getURL(""playground.html"")
                    ) === -1 &&
                    !contentState.pendingRecording &&
                    !contentState.customRegion
                  ) {
                    setContentState((prevContentState) => ({
                      ...prevContentState,
                      showExtension: false,
                      showPopup: false,
                    }));
                  }
                }}
              ></div>
            )}
          <Canvas />
          <CursorModes />
          <root.div
            className=""root-container""
            id=""screenity-root-container""
            style={{
              // all: ""initial"",
              display: ""block"",
              width: ""100%"",
              height: ""100%"",
              position: ""absolute"",
              pointerEvents: ""none"",
              left: ""0px"",
              top: ""0px"",
              zIndex: 9999999999,
            }}
            ref={shadowRef}
          >
            <div className=""container"">
              <Warning />
              {contentState.recordingType === ""region"" &&
                contentState.customRegion && <Region />}
              {shadowRef.current && <Modal shadowRef={shadowRef} />}
              <Countdown />
              {contentState.recordingType != ""camera"" && (
                <Camera shadowRef={shadowRef} />
              )}
              {contentState.recordingType === ""camera"" && (
                <CameraOnly shadowRef={shadowRef} />
              )}
              {!(contentState.hideToolbar && contentState.hideUI) && (
                <Toolbar />
              )}
              {contentS"
Download\Download.jsx,Included,application/octet-stream,2930,"import React, { useState, useCallback, useEffect } from ""react"";

import localforage from ""localforage"";

localforage.config({
  driver: localforage.INDEXEDDB,
  name: ""screenity"",
  version: 1,
});

// Get chunks store
const chunksStore = localforage.createInstance({
  name: ""chunks"",
});

const Download = () => {
  const base64ToUint8Array = (base64) => {
    const dataUrlRegex = /^data:(.*?);base64,/;
    const matches = base64.match(dataUrlRegex);
    if (matches !== null) {
      // Base64 is a data URL
      const mimeType = matches[1];
      const binaryString = atob(base64.slice(matches[0].length));
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return new Blob([bytes], { type: mimeType });
    } else {
      // Base64 is a regular string
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return new Blob([bytes], { type: ""video/webm"" });
    }
  };

  const handleMessage = useCallback((message, sender, sendResponse) => {
    if (message.type === ""download-video"") {
      const base64 = message.base64;
      const blob = base64ToUint8Array(base64);
      const title = message.title.replace(/[\/\\:?~<>|*""]/g, ""_"");
      const url = URL.createObjectURL(blob);

      chrome.downloads
        .download({
          url: url,
          filename: title,
          saveAs: true,
        })
        .then(() => {
          URL.revokeObjectURL(url);
          // Close this tab
          window.close();
        });
    } else if (message.type === ""recover-indexed-db"") {
      // Rewrite in localforage
      const chunkArray = [];
      chunksStore
        .iterate((value, key, iterationNumber) => {
          chunkArray.push(value.chunk);
        })
        .then(() => {
          const blob = new Blob(chunkArray, { type: ""video/webm"" });
          const url = URL.createObjectURL(blob);
          chrome.downloads
            .download({
              url: url,
              filename: ""recovered-video.webm"",
              saveAs: true,
            })
            .then(() => {
              URL.revokeObjectURL(url);
              // Close this tab
              window.close();
            });
        });
    }
  });

  useEffect(() => {
    // chrome on message
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      handleMessage(message);
    });

    return () => {
      chrome.runtime.onMessage.removeListener(
        (message, sender, sendResponse) => {
          handleMessage(message);
        }
      );
    };
  }, []);

  return <div></div>;
};

export default Download;
"
Download\index.html,Included,text/html,386,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Screenity - Video editor</title>
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
  </head>

  <body>
    <div id=""app-container""></div>
    <!-- <script src=""chrome-extension://__MSG_@@extension_id__/assets/vendor/ffmpeg-core.js""></script> -->
  </body>
</html>
"
Download\index.jsx,Included,application/octet-stream,266,"import React from ""react"";
import { render } from ""react-dom"";

import Download from ""./Download"";

// Render at the end of the body of any website
render(<Download />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Editor\index.html,Included,text/html,386,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Screenity - Video editor</title>
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
  </head>

  <body>
    <div id=""app-container""></div>
    <!-- <script src=""chrome-extension://__MSG_@@extension_id__/assets/vendor/ffmpeg-core.js""></script> -->
  </body>
</html>
"
Editor\index.jsx,Included,application/octet-stream,263,"import React from ""react"";
import { render } from ""react-dom"";

import Sandbox from ""./Sandbox"";

// Render at the end of the body of any website
render(<Sandbox />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Editor\Sandbox.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,8678,"import React, { useEffect, useRef } from ""react"";

// Import all the utils
import addAudioToVideo from ""./utils/addAudioToVideo"";
import base64ToBlob from ""./utils/base64toBlob"";
import blobToArrayBuffer from ""./utils/blobToArrayBuffer"";
import cropVideo from ""./utils/cropVideo"";
import cutVideo from ""./utils/cutVideo"";
import fetchFile from ""./utils/fetchFile"";
import generateThumbstrips from ""./utils/generateThumbstrips"";
import getAudio from ""./utils/getAudio"";
import getFrame from ""./utils/getFrame"";
import hasAudio from ""./utils/hasAudio"";
import muteVideo from ""./utils/muteVideo"";
import reencodeVideo from ""./utils/reencodeVideo"";
import toGIF from ""./utils/toGIF"";

const Sandbox = () => {
  const iframeRef = useRef(null);
  const scriptLoaded = useRef(false);
  const triggerLoad = useRef(false);
  const ffmpegInstance = useRef(null);

  const sendMessage = (message) => {
    iframeRef.current.contentWindow.postMessage(message, ""*"");
  };

  const loadFfmpeg = async () => {
    if (!scriptLoaded.current) return;
    if (!triggerLoad.current) return;
    if (ffmpegInstance.current) return;

    try {
      const { createFFmpeg } = FFmpeg;
      // Initialize ffmpeg.js
      ffmpegInstance.current = createFFmpeg({
        log: false,
        progress: (params) => {},
        corePath: ""assets/vendor/ffmpeg-core.js"",
      });
      await ffmpegInstance.current.load();
      sendMessage({ type: ""ffmpeg-loaded"" });
    } catch (error) {
      sendMessage({
        type: ""ffmpeg-load-error"",
        error: JSON.stringify(error),
        fallback: false,
      });
    }
  };

  useEffect(() => {
    const script = document.createElement(""script"");

    script.src = ""assets/vendor/ffmpeg.min.js"";
    script.async = true;

    // On load, set scriptLoaded to true
    script.onload = () => {
      scriptLoaded.current = true;
      loadFfmpeg();
    };

    document.body.appendChild(script);

    return () => {
      document.body.removeChild(script);
    };
  }, []);

  const toBase64 = (blob) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = reject;
    });
  };

  const onMessage = async (message) => {
    if (message.type === ""load-ffmpeg"") {
      triggerLoad.current = true;
      loadFfmpeg();
    } else if (message.type === ""add-audio-to-video"") {
      try {
        const blob = await addAudioToVideo(
          ffmpegInstance.current,
          message.blob,
          message.audio,
          message.duration,
          message.volume,
          message.replaceAudio
        );
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""base64-to-blob"") {
      try {
        const blob = await base64ToBlob(ffmpegInstance.current, message.base64);
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""blob-to-array-buffer"") {
      try {
        const arrayBuffer = await blobToArrayBuffer(
          ffmpegInstance.current,
          message.blob
        );
        sendMessage({ type: ""updated-array-buffer"", arrayBuffer: arrayBuffer });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""crop-video"") {
      try {
        const blob = await cropVideo(ffmpegInstance.current, message.blob, {
          x: message.x,
          y: message.y,
          width: message.width,
          height: message.height,
        });
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
        sendMessage({ type: ""crop-update"" });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""cut-video"") {
      try {
        const blob = await cutVideo(
          ffmpegInstance.current,
          message.blob,
          message.startTime,
          message.endTime,
          message.cut,
          message.duration,
          message.encode
        );
        const base64 = await toBase64(blob);
        sendMessage({
          type: ""updated-blob"",
          base64: base64,
          addToHistory: true,
        });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""fetch-file"") {
      try {
        const blob = await fetchFile(message.url);
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""generate-thumbstrips"") {
      try {
        const blob = await generateThumbstrips(
          ffmpegInstance.current,
          message.blob
        );
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""get-audio"") {
      try {
        const blob = await getAudio(ffmpegInstance.current, message.video);
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""get-frame"") {
      try {
        const blob = await getFrame(
          ffmpegInstance.current,
          message.blob,
      "
Editor\utils\addAudioToVideo.js,Included,text/javascript,2138,"async function addAudioToVideo(
  ffmpeg,
  videoBlob,
  audioBlob,
  videoDuration,
  audioVolume = 1.0,
  replaceAudio = false
) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());
  const audioData = new Uint8Array(await audioBlob.arrayBuffer());

  // Set the input video and audio file names
  ffmpeg.FS(""writeFile"", ""input-video.mp4"", videoData);
  ffmpeg.FS(""writeFile"", ""input-audio.mp3"", audioData);

  // Set the output video file name
  const outputFileName = ""output-with-audio.mp4"";

  // Build FFmpeg command for merging video and audio with volume adjustment
  let ffmpegCommand = [
    ""-i"",
    ""input-video.mp4"",
    ""-i"",
    ""input-audio.mp3"",
    ""-filter_complex"",
    `[0:a]volume=1[a];[1:a]volume=${audioVolume}[b];[a][b]amix=inputs=2:duration=first:dropout_transition=2[v]`,
    ""-map"",
    ""0:v"", // Map the original video stream
    ""-map"",
    ""[v]"", // Map the merged audio
    ""-c:v"",
    ""copy"",
    ""-c:a"",
    ""aac"",
    ""-strict"",
    ""experimental"",
    ""-shortest"",
    outputFileName,
  ];

  if (replaceAudio) {
    // Remove the original audio stream and replace it with the audio from the audio blob
    ffmpegCommand = [
      ""-i"",
      ""input-video.mp4"",
      ""-i"",
      ""input-audio.mp3"",
      ""-filter_complex"",
      ""[0:a]volume=0[a];[1:a]volume=1[b];[a][b]amix=inputs=2:duration=first:dropout_transition=2[v]"",
      ""-map"",
      ""0:v"", // Map the original video stream
      ""-map"",
      ""[v]"", // Map the merged audio
      ""-c:v"",
      ""copy"",
      ""-c:a"",
      ""aac"",
      ""-strict"",
      ""experimental"",
      ""-shortest"",
      outputFileName,
    ];
  }

  // Run FFmpeg to merge video and audio with volume adjustment
  await ffmpeg.run(...ffmpegCommand);

  // Get the merged video data
  const data = ffmpeg.FS(""readFile"", outputFileName);

  // Create a Blob from the merged video data
  const videoWithAudioBlob = new Blob([data.buffer], { type: ""video/mp4"" });

  // Return the video with merged audio Blob
  return videoWithAudioBlob;
}

export default addAudioToVideo;
"
Editor\utils\base64toBlob.js,Included,text/javascript,964,"function base64ToUint8Array(base64) {
  const dataURLRegex = /^data:.+;base64,/;
  if (dataURLRegex.test(base64)) {
    base64 = base64.replace(dataURLRegex, """");
  }

  const binary_string = window.atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);

  for (let i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }

  return bytes;
}

async function base64ToBlob(ffmpeg, base64) {
  const input = base64ToUint8Array(base64);
  ffmpeg.FS(""writeFile"", ""input.webm"", input);

  await ffmpeg.run(
    ""-i"",
    ""input.webm"",
    ""-max_muxing_queue_size"",
    ""512"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    ""output.mp4""
  );

  const data = ffmpeg.FS(""readFile"", ""output.mp4"");
  const videoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

  return videoBlob;
}

export default base64ToBlob;
"
Editor\utils\blobToArrayBuffer.js,Included,text/javascript,457,"async function blobToArrayBuffer(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.result instanceof ArrayBuffer) {
        resolve(reader.result);
      } else {
        reject(new Error(""Failed to convert Blob to ArrayBuffer""));
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(blob);
  });
}

export default blobToArrayBuffer;
"
Editor\utils\cropVideo.js,Included,text/javascript,1078,"async function cropVideo(ffmpeg, videoBlob, cropParameters) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());

  // Set the input video file name
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  // Set the output video file name
  const outputFileName = ""output-cropped.mp4"";

  // Build FFmpeg command for cropping
  const ffmpegCommand = [
    ""-i"",
    ""input.mp4"",
    ""-vf"",
    `crop=${cropParameters.width}:${cropParameters.height}:${cropParameters.x}:${cropParameters.y}`,
    ""-c:a"",
    ""copy"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName,
  ];

  // Run FFmpeg to crop the video
  await ffmpeg.run(...ffmpegCommand);

  // Get the cropped video data
  const data = ffmpeg.FS(""readFile"", outputFileName);

  // Create a Blob from the cropped video data
  const croppedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

  // Return the cropped video Blob
  return croppedVideoBlob;
}

export default cropVideo;
"
Editor\utils\cutVideo.js,Included,text/javascript,3501,"async function cutVideo(ffmpeg, videoBlob, start, end, cut, duration, encode) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());

  // Set the input video file name
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  // Set the output video file name
  const outputFileName = cut ? ""output-cut.mp4"" : ""output-trimmed.mp4"";
  let encodeOptions = [
    ""-c:v"",
    ""copy"",
    ""-c:a"",
    ""copy"",
    ""-reset_timestamps"",
    ""1"",
  ];
  if (encode) {
    encodeOptions = [
      ""-preset"",
      ""superfast"",
      ""-threads"",
      ""0"",
      ""-r"",
      ""30"",
      ""-tune"",
      ""fastdecode"",
    ];
  }

  if (cut) {
    if (start > 0 && end < duration) {
      await ffmpeg.run(
        ""-ss"",
        ""0"",
        ""-i"",
        ""input.mp4"",
        ""-to"",
        start.toString(),
        ...encodeOptions,
        ""part1.mp4""
      );

      // Then, cut the video from the end time to the end
      await ffmpeg.run(
        ""-ss"",
        end.toString(),
        ""-i"",
        ""input.mp4"",
        ""-to"",
        duration.toString(),
        ...encodeOptions,
        ""part2.mp4""
      );

      // Create a text file with the list of input videos
      ffmpeg.FS(""writeFile"", ""input.txt"", ""file 'part1.mp4'\nfile 'part2.mp4'"");

      // Concatenate the two remaining parts
      await ffmpeg.run(
        ""-f"",
        ""concat"",
        ""-safe"",
        ""0"",
        ""-i"",
        ""input.txt"",
        ""-c"",
        ""copy"",
        outputFileName
      );

      // Get the edited video data
      const data = ffmpeg.FS(""readFile"", outputFileName);

      // Create a Blob from the edited video data
      const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

      // Return the edited video Blob
      return editedVideoBlob;
    } else if (start == 0 && end < duration) {
      await ffmpeg.run(
        ""-ss"",
        end.toString(),
        ""-i"",
        ""input.mp4"",
        ""-to"",
        duration.toString(),
        ...encodeOptions,
        outputFileName
      );

      // Get the edited video data
      const data = ffmpeg.FS(""readFile"", outputFileName);

      // Create a Blob from the edited video data
      const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

      // Return the edited video Blob
      return editedVideoBlob;
    } else if (start > 0 && end == duration) {
      await ffmpeg.run(
        ""-ss"",
        ""0"",
        ""-i"",
        ""input.mp4"",
        ""-to"",
        start.toString(),
        ...encodeOptions,
        outputFileName
      );

      // Get the edited video data
      const data = ffmpeg.FS(""readFile"", outputFileName);

      // Create a Blob from the edited video data
      const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

      // Return the edited video Blob
      return editedVideoBlob;
    }
  } else {
    await ffmpeg.run(
      ""-ss"",
      start.toString(),
      ""-i"",
      ""input.mp4"",
      ""-t"",
      (end - start).toString(),
      ...encodeOptions,
      outputFileName
    );

    // Get the edited video data
    const data = ffmpeg.FS(""readFile"", outputFileName);

    // Create a Blob from the edited video data
    const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

    // Return the edited video Blob
    return editedVideoBlob;
  }
}

export default cutVideo;
"
Editor\utils\fetchFile.js,Included,text/javascript,159,"async function fetchFile(url) {
  const response = await fetch(url);
  return new Uint8Array(await response.arrayBuffer());
}

export default fetchFile;
"
Editor\utils\generateThumbstrips.js,Included,text/javascript,1164,"/* generateThumbstrips.js */
async function generateThumbstrips(videoBlob, ffmpeg, frames = 5) {
  // Read video data
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());

  // Write video data to the virtual file system
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  const thumbstrips = [];

  const duration = ffmpeg.getInfo(""duration"");
  const interval = duration / frames;

  for (let i = 0; i < frames; i++) {
    const time = i * interval;
    const outputFileName = `output${i.toString().padStart(3, ""0"")}.jpg`;

    // Use FFmpeg to extract a frame as a JPEG image
    await ffmpeg.run(
      ""-i"",
      ""input.mp4"",
      ""-ss"",
      time.toString(),
      ""-frames:v"",
      ""1"",
      ""-q:v"",
      ""3"",
      outputFileName
    );

    // Read the generated thumbnail image
    const thumbnailData = ffmpeg.FS(""readFile"", outputFileName);

    // Create a Blob from the thumbnail data
    const thumbnailBlob = new Blob([thumbnailData.buffer], {
      type: ""image/jpeg"",
    });

    thumbstrips.push(thumbnailBlob);
  }

  return thumbstrips;
}

export default generateThumbstrips;
"
Editor\utils\getAudio.js,Included,text/javascript,844,"async function getAudio(ffmpeg, videoBlob) {
  try {
    // Set the input video file name
    ffmpeg.FS(""writeFile"", ""input.mp4"", videoBlob);

    // Define the output audio file name
    const outputAudioFileName = ""output-audio.wav"";

    // Run FFmpeg to extract audio from the video
    await ffmpeg.run(
      ""-i"",
      ""input.mp4"",
      ""-q:a"",
      ""0"",
      ""-map"",
      ""a"",
      outputAudioFileName
    );

    // Get the extracted audio data
    const audioData = ffmpeg.FS(""readFile"", outputAudioFileName);

    // Create a Blob from the audio data
    const audioBlob = new Blob([audioData.buffer], { type: ""audio/wav"" });

    // Return the audio Blob
    return audioBlob;
  } catch (error) {
    console.error(""Error extracting audio from video:"", error);
  }
}

export default getAudio;
"
Editor\utils\getFrame.js,Included,text/javascript,950,"/* getFrame.js */
async function getFrame(ffmpeg, videoBlob, time = 0) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());
  // Write video data to a file
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  const outputFileName = ""output.jpg"";

  // Use FFmpeg to extract a frame as a JPEG image
  await ffmpeg.run(
    ""-i"",
    ""input.mp4"",
    ""-ss"",
    time.toString(),
    ""-frames:v"",
    ""1"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName
  );

  // Read the generated frame image
  const frameData = ffmpeg.FS(""readFile"", outputFileName);

  // Create a Blob from the frame data
  const frameBlob = new Blob([frameData.buffer], {
    type: ""image/jpeg"",
  });

  // Clean up
  ffmpeg.FS(""unlink"", ""input.mp4"");
  ffmpeg.FS(""unlink"", outputFileName);

  return frameBlob;
}

export default getFrame;
"
Editor\utils\hasAudio.js,Included,text/javascript,1507,"const hasAudio = async (videoBlob) => {
  const videoElement = document.createElement(""video"");
  videoElement.src = URL.createObjectURL(videoBlob);

  return new Promise(async (resolve, reject) => {
    try {
      videoElement.addEventListener(""loadedmetadata"", async () => {
        try {
          const mediaSource = new MediaSource();
          videoElement.src = URL.createObjectURL(mediaSource);
          await mediaSource.addSourceBuffer(videoBlob.type);

          mediaSource.onsourceopen = () => {
            const audioContext = new AudioContext();
            const source = audioContext.createMediaElementSource(videoElement);

            source.connect(audioContext.destination);
            source.onended = () => {
              // If audio plays and ends, it has audio tracks
              resolve(true);
            };
            source.onerror = () => {
              // If there's an error, it doesn't have audio tracks
              resolve(false);
            };

            // Start playing the video
            videoElement.play();
          };
        } catch (error) {
          resolve(false); // MediaSource or AudioContext not supported
        }
      });

      videoElement.addEventListener(""error"", (error) => {
        reject(error);
      });

      videoElement.load();
    } catch (error) {
      reject(error);
    } finally {
      URL.revokeObjectURL(videoElement.src);
    }
  });
};

export default hasAudio;
"
Editor\utils\muteVideo.js,Included,text/javascript,1006,"async function muteVideo(ffmpeg, videoBlob, start, end) {
  try {
    const videoData = new Uint8Array(await videoBlob.arrayBuffer());

    // Set the input video file name
    ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

    // Set the output video file name
    const outputFileName = ""output.mp4"";

    // Mute the audio in the specified time range
    await ffmpeg.run(
      ""-i"",
      ""input.mp4"",
      ""-af"",
      `volume='if(between(t,${start},${end}),0,1)':eval=frame`,
      ""-c:v"",
      ""copy"",
      ""-c:a"",
      ""aac"",
      outputFileName
    );

    // Get the edited video data
    const data = ffmpeg.FS(""readFile"", outputFileName);

    // Create a Blob from the edited video data
    const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

    // Return the edited video Blob
    return editedVideoBlob;
  } catch (error) {
    console.error(""Error muting video:"", error);
    return null;
  }
}

export default muteVideo;
"
Editor\utils\reencodeVideo.js,Included,text/javascript,596,"async function reencodeVideo(ffmpeg, blob) {
  const videoData = new Uint8Array(await blob.arrayBuffer());
  const outputFileName = ""output.mp4"";
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);
  await ffmpeg.run(
    ""-i"",
    ""input.mp4"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName
  );

  const data = ffmpeg.FS(""readFile"", outputFileName);
  const editedVideoBlob = new Blob([data.buffer], {
    type: ""video/mp4"",
  });
  return editedVideoBlob;
}

export default reencodeVideo;
"
Editor\utils\toGIF.js,Included,text/javascript,578,"async function toGIF(ffmpeg, blob) {
  const videoData = new Uint8Array(await blob.arrayBuffer());
  const outputFileName = ""output.gif"";
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);
  await ffmpeg.run(
    ""-i"",
    ""input.mp4"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName
  );
  const data = ffmpeg.FS(""readFile"", outputFileName);
  const editedVideoBlob = new Blob([data.buffer], {
    type: ""image/gif"",
  });
  return editedVideoBlob;
}

export default toGIF;
"
EditorFallback\index.html,Included,text/html,386,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Screenity - Video editor</title>
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
  </head>

  <body>
    <div id=""app-container""></div>
    <!-- <script src=""chrome-extension://__MSG_@@extension_id__/assets/vendor/ffmpeg-core.js""></script> -->
  </body>
</html>
"
EditorFallback\index.jsx,Included,application/octet-stream,263,"import React from ""react"";
import { render } from ""react-dom"";

import Sandbox from ""./Sandbox"";

// Render at the end of the body of any website
render(<Sandbox />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
EditorFallback\Sandbox.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,7664,"import React, { useEffect, useRef } from ""react"";

// Import all the utils
import addAudioToVideo from ""./utils/addAudioToVideo"";
import base64ToBlob from ""./utils/base64toBlob"";
import blobToArrayBuffer from ""./utils/blobToArrayBuffer"";
import cropVideo from ""./utils/cropVideo"";
import cutVideo from ""./utils/cutVideo"";
import fetchFile from ""./utils/fetchFile"";
import generateThumbstrips from ""./utils/generateThumbstrips"";
import getAudio from ""./utils/getAudio"";
import getFrame from ""./utils/getFrame"";
import hasAudio from ""./utils/hasAudio"";
import muteVideo from ""./utils/muteVideo"";
import reencodeVideo from ""./utils/reencodeVideo"";
import toGIF from ""./utils/toGIF"";

const Sandbox = () => {
  const iframeRef = useRef(null);
  const triggerLoad = useRef(false);
  const ffmpegInstance = useRef(null);

  const sendMessage = (message) => {
    iframeRef.current.contentWindow.postMessage(message, ""*"");
  };

  const loadFfmpeg = async () => {
    sendMessage({ type: ""ffmpeg-load-error"", fallback: true });
  };

  const toBase64 = (blob) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onloadend = () => {
        resolve(reader.result);
      };
      reader.onerror = reject;
    });
  };

  const onMessage = async (message) => {
    if (message.type === ""load-ffmpeg"") {
      triggerLoad.current = true;
      loadFfmpeg();
    } else if (message.type === ""add-audio-to-video"") {
      try {
        const blob = await addAudioToVideo(
          ffmpegInstance.current,
          message.blob,
          message.audio,
          message.duration,
          message.volume,
          message.replaceAudio
        );
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""base64-to-blob"") {
      try {
        const blob = await base64ToBlob(ffmpegInstance.current, message.base64);
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""blob-to-array-buffer"") {
      try {
        const arrayBuffer = await blobToArrayBuffer(
          ffmpegInstance.current,
          message.blob
        );
        sendMessage({ type: ""updated-array-buffer"", arrayBuffer: arrayBuffer });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""crop-video"") {
      try {
        const blob = await cropVideo(ffmpegInstance.current, message.blob, {
          x: message.x,
          y: message.y,
          width: message.width,
          height: message.height,
        });
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
        sendMessage({ type: ""crop-update"" });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""cut-video"") {
      try {
        const blob = await cutVideo(
          ffmpegInstance.current,
          message.blob,
          message.startTime,
          message.endTime,
          message.cut,
          message.duration,
          message.encode
        );
        const base64 = await toBase64(blob);
        sendMessage({
          type: ""updated-blob"",
          base64: base64,
          addToHistory: true,
        });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""fetch-file"") {
      try {
        const blob = await fetchFile(message.url);
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""generate-thumbstrips"") {
      try {
        const blob = await generateThumbstrips(
          ffmpegInstance.current,
          message.blob
        );
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""get-audio"") {
      try {
        const blob = await getAudio(ffmpegInstance.current, message.video);
        const base64 = await toBase64(blob);
        sendMessage({ type: ""updated-blob"", base64: base64 });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""get-frame"") {
      try {
        const blob = await getFrame(
          ffmpegInstance.current,
          message.blob,
          message.time
        );
        sendMessage({ type: ""new-frame"", frame: blob });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""has-audio"") {
      try {
        const audio = await hasAudio(ffmpegInstance.current, message.video);
        sendMessage({ type: ""updated-has-audio"", hasAudio: audio });
      } catch (error) {
        sendMessage({ type: ""ffmpeg-error"", error: JSON.stringify(error) });
      }
    } else if (message.type === ""mute-video"") {
      try {
        const blob = await muteVideo(
          ffmpegInstance.current,
          message.blob,
          message.startTime,
          message.endTime,
          message.duration
        );
        const base64 = await toBase64(blob);
        sendMessage({
          type: ""updated-blob"",
          base64: base64,
          addToHistory: true,
        });
      } catch (error) {
        sendMessage({ typ"
EditorFallback\utils\addAudioToVideo.js,Included,text/javascript,2138,"async function addAudioToVideo(
  ffmpeg,
  videoBlob,
  audioBlob,
  videoDuration,
  audioVolume = 1.0,
  replaceAudio = false
) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());
  const audioData = new Uint8Array(await audioBlob.arrayBuffer());

  // Set the input video and audio file names
  ffmpeg.FS(""writeFile"", ""input-video.mp4"", videoData);
  ffmpeg.FS(""writeFile"", ""input-audio.mp3"", audioData);

  // Set the output video file name
  const outputFileName = ""output-with-audio.mp4"";

  // Build FFmpeg command for merging video and audio with volume adjustment
  let ffmpegCommand = [
    ""-i"",
    ""input-video.mp4"",
    ""-i"",
    ""input-audio.mp3"",
    ""-filter_complex"",
    `[0:a]volume=1[a];[1:a]volume=${audioVolume}[b];[a][b]amix=inputs=2:duration=first:dropout_transition=2[v]`,
    ""-map"",
    ""0:v"", // Map the original video stream
    ""-map"",
    ""[v]"", // Map the merged audio
    ""-c:v"",
    ""copy"",
    ""-c:a"",
    ""aac"",
    ""-strict"",
    ""experimental"",
    ""-shortest"",
    outputFileName,
  ];

  if (replaceAudio) {
    // Remove the original audio stream and replace it with the audio from the audio blob
    ffmpegCommand = [
      ""-i"",
      ""input-video.mp4"",
      ""-i"",
      ""input-audio.mp3"",
      ""-filter_complex"",
      ""[0:a]volume=0[a];[1:a]volume=1[b];[a][b]amix=inputs=2:duration=first:dropout_transition=2[v]"",
      ""-map"",
      ""0:v"", // Map the original video stream
      ""-map"",
      ""[v]"", // Map the merged audio
      ""-c:v"",
      ""copy"",
      ""-c:a"",
      ""aac"",
      ""-strict"",
      ""experimental"",
      ""-shortest"",
      outputFileName,
    ];
  }

  // Run FFmpeg to merge video and audio with volume adjustment
  await ffmpeg.run(...ffmpegCommand);

  // Get the merged video data
  const data = ffmpeg.FS(""readFile"", outputFileName);

  // Create a Blob from the merged video data
  const videoWithAudioBlob = new Blob([data.buffer], { type: ""video/mp4"" });

  // Return the video with merged audio Blob
  return videoWithAudioBlob;
}

export default addAudioToVideo;
"
EditorFallback\utils\base64toBlob.js,Included,text/javascript,964,"function base64ToUint8Array(base64) {
  const dataURLRegex = /^data:.+;base64,/;
  if (dataURLRegex.test(base64)) {
    base64 = base64.replace(dataURLRegex, """");
  }

  const binary_string = window.atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);

  for (let i = 0; i < len; i++) {
    bytes[i] = binary_string.charCodeAt(i);
  }

  return bytes;
}

async function base64ToBlob(ffmpeg, base64) {
  const input = base64ToUint8Array(base64);
  ffmpeg.FS(""writeFile"", ""input.webm"", input);

  await ffmpeg.run(
    ""-i"",
    ""input.webm"",
    ""-max_muxing_queue_size"",
    ""512"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    ""output.mp4""
  );

  const data = ffmpeg.FS(""readFile"", ""output.mp4"");
  const videoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

  return videoBlob;
}

export default base64ToBlob;
"
EditorFallback\utils\blobToArrayBuffer.js,Included,text/javascript,457,"async function blobToArrayBuffer(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.result instanceof ArrayBuffer) {
        resolve(reader.result);
      } else {
        reject(new Error(""Failed to convert Blob to ArrayBuffer""));
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(blob);
  });
}

export default blobToArrayBuffer;
"
EditorFallback\utils\cropVideo.js,Included,text/javascript,1078,"async function cropVideo(ffmpeg, videoBlob, cropParameters) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());

  // Set the input video file name
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  // Set the output video file name
  const outputFileName = ""output-cropped.mp4"";

  // Build FFmpeg command for cropping
  const ffmpegCommand = [
    ""-i"",
    ""input.mp4"",
    ""-vf"",
    `crop=${cropParameters.width}:${cropParameters.height}:${cropParameters.x}:${cropParameters.y}`,
    ""-c:a"",
    ""copy"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName,
  ];

  // Run FFmpeg to crop the video
  await ffmpeg.run(...ffmpegCommand);

  // Get the cropped video data
  const data = ffmpeg.FS(""readFile"", outputFileName);

  // Create a Blob from the cropped video data
  const croppedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

  // Return the cropped video Blob
  return croppedVideoBlob;
}

export default cropVideo;
"
EditorFallback\utils\cutVideo.js,Included,text/javascript,3501,"async function cutVideo(ffmpeg, videoBlob, start, end, cut, duration, encode) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());

  // Set the input video file name
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  // Set the output video file name
  const outputFileName = cut ? ""output-cut.mp4"" : ""output-trimmed.mp4"";
  let encodeOptions = [
    ""-c:v"",
    ""copy"",
    ""-c:a"",
    ""copy"",
    ""-reset_timestamps"",
    ""1"",
  ];
  if (encode) {
    encodeOptions = [
      ""-preset"",
      ""superfast"",
      ""-threads"",
      ""0"",
      ""-r"",
      ""30"",
      ""-tune"",
      ""fastdecode"",
    ];
  }

  if (cut) {
    if (start > 0 && end < duration) {
      await ffmpeg.run(
        ""-ss"",
        ""0"",
        ""-i"",
        ""input.mp4"",
        ""-to"",
        start.toString(),
        ...encodeOptions,
        ""part1.mp4""
      );

      // Then, cut the video from the end time to the end
      await ffmpeg.run(
        ""-ss"",
        end.toString(),
        ""-i"",
        ""input.mp4"",
        ""-to"",
        duration.toString(),
        ...encodeOptions,
        ""part2.mp4""
      );

      // Create a text file with the list of input videos
      ffmpeg.FS(""writeFile"", ""input.txt"", ""file 'part1.mp4'\nfile 'part2.mp4'"");

      // Concatenate the two remaining parts
      await ffmpeg.run(
        ""-f"",
        ""concat"",
        ""-safe"",
        ""0"",
        ""-i"",
        ""input.txt"",
        ""-c"",
        ""copy"",
        outputFileName
      );

      // Get the edited video data
      const data = ffmpeg.FS(""readFile"", outputFileName);

      // Create a Blob from the edited video data
      const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

      // Return the edited video Blob
      return editedVideoBlob;
    } else if (start == 0 && end < duration) {
      await ffmpeg.run(
        ""-ss"",
        end.toString(),
        ""-i"",
        ""input.mp4"",
        ""-to"",
        duration.toString(),
        ...encodeOptions,
        outputFileName
      );

      // Get the edited video data
      const data = ffmpeg.FS(""readFile"", outputFileName);

      // Create a Blob from the edited video data
      const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

      // Return the edited video Blob
      return editedVideoBlob;
    } else if (start > 0 && end == duration) {
      await ffmpeg.run(
        ""-ss"",
        ""0"",
        ""-i"",
        ""input.mp4"",
        ""-to"",
        start.toString(),
        ...encodeOptions,
        outputFileName
      );

      // Get the edited video data
      const data = ffmpeg.FS(""readFile"", outputFileName);

      // Create a Blob from the edited video data
      const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

      // Return the edited video Blob
      return editedVideoBlob;
    }
  } else {
    await ffmpeg.run(
      ""-ss"",
      start.toString(),
      ""-i"",
      ""input.mp4"",
      ""-t"",
      (end - start).toString(),
      ...encodeOptions,
      outputFileName
    );

    // Get the edited video data
    const data = ffmpeg.FS(""readFile"", outputFileName);

    // Create a Blob from the edited video data
    const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

    // Return the edited video Blob
    return editedVideoBlob;
  }
}

export default cutVideo;
"
EditorFallback\utils\fetchFile.js,Included,text/javascript,159,"async function fetchFile(url) {
  const response = await fetch(url);
  return new Uint8Array(await response.arrayBuffer());
}

export default fetchFile;
"
EditorFallback\utils\generateThumbstrips.js,Included,text/javascript,1164,"/* generateThumbstrips.js */
async function generateThumbstrips(videoBlob, ffmpeg, frames = 5) {
  // Read video data
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());

  // Write video data to the virtual file system
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  const thumbstrips = [];

  const duration = ffmpeg.getInfo(""duration"");
  const interval = duration / frames;

  for (let i = 0; i < frames; i++) {
    const time = i * interval;
    const outputFileName = `output${i.toString().padStart(3, ""0"")}.jpg`;

    // Use FFmpeg to extract a frame as a JPEG image
    await ffmpeg.run(
      ""-i"",
      ""input.mp4"",
      ""-ss"",
      time.toString(),
      ""-frames:v"",
      ""1"",
      ""-q:v"",
      ""3"",
      outputFileName
    );

    // Read the generated thumbnail image
    const thumbnailData = ffmpeg.FS(""readFile"", outputFileName);

    // Create a Blob from the thumbnail data
    const thumbnailBlob = new Blob([thumbnailData.buffer], {
      type: ""image/jpeg"",
    });

    thumbstrips.push(thumbnailBlob);
  }

  return thumbstrips;
}

export default generateThumbstrips;
"
EditorFallback\utils\getAudio.js,Included,text/javascript,844,"async function getAudio(ffmpeg, videoBlob) {
  try {
    // Set the input video file name
    ffmpeg.FS(""writeFile"", ""input.mp4"", videoBlob);

    // Define the output audio file name
    const outputAudioFileName = ""output-audio.wav"";

    // Run FFmpeg to extract audio from the video
    await ffmpeg.run(
      ""-i"",
      ""input.mp4"",
      ""-q:a"",
      ""0"",
      ""-map"",
      ""a"",
      outputAudioFileName
    );

    // Get the extracted audio data
    const audioData = ffmpeg.FS(""readFile"", outputAudioFileName);

    // Create a Blob from the audio data
    const audioBlob = new Blob([audioData.buffer], { type: ""audio/wav"" });

    // Return the audio Blob
    return audioBlob;
  } catch (error) {
    console.error(""Error extracting audio from video:"", error);
  }
}

export default getAudio;
"
EditorFallback\utils\getFrame.js,Included,text/javascript,950,"/* getFrame.js */
async function getFrame(ffmpeg, videoBlob, time = 0) {
  const videoData = new Uint8Array(await videoBlob.arrayBuffer());
  // Write video data to a file
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

  const outputFileName = ""output.jpg"";

  // Use FFmpeg to extract a frame as a JPEG image
  await ffmpeg.run(
    ""-i"",
    ""input.mp4"",
    ""-ss"",
    time.toString(),
    ""-frames:v"",
    ""1"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName
  );

  // Read the generated frame image
  const frameData = ffmpeg.FS(""readFile"", outputFileName);

  // Create a Blob from the frame data
  const frameBlob = new Blob([frameData.buffer], {
    type: ""image/jpeg"",
  });

  // Clean up
  ffmpeg.FS(""unlink"", ""input.mp4"");
  ffmpeg.FS(""unlink"", outputFileName);

  return frameBlob;
}

export default getFrame;
"
EditorFallback\utils\hasAudio.js,Included,text/javascript,1507,"const hasAudio = async (videoBlob) => {
  const videoElement = document.createElement(""video"");
  videoElement.src = URL.createObjectURL(videoBlob);

  return new Promise(async (resolve, reject) => {
    try {
      videoElement.addEventListener(""loadedmetadata"", async () => {
        try {
          const mediaSource = new MediaSource();
          videoElement.src = URL.createObjectURL(mediaSource);
          await mediaSource.addSourceBuffer(videoBlob.type);

          mediaSource.onsourceopen = () => {
            const audioContext = new AudioContext();
            const source = audioContext.createMediaElementSource(videoElement);

            source.connect(audioContext.destination);
            source.onended = () => {
              // If audio plays and ends, it has audio tracks
              resolve(true);
            };
            source.onerror = () => {
              // If there's an error, it doesn't have audio tracks
              resolve(false);
            };

            // Start playing the video
            videoElement.play();
          };
        } catch (error) {
          resolve(false); // MediaSource or AudioContext not supported
        }
      });

      videoElement.addEventListener(""error"", (error) => {
        reject(error);
      });

      videoElement.load();
    } catch (error) {
      reject(error);
    } finally {
      URL.revokeObjectURL(videoElement.src);
    }
  });
};

export default hasAudio;
"
EditorFallback\utils\muteVideo.js,Included,text/javascript,1006,"async function muteVideo(ffmpeg, videoBlob, start, end) {
  try {
    const videoData = new Uint8Array(await videoBlob.arrayBuffer());

    // Set the input video file name
    ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);

    // Set the output video file name
    const outputFileName = ""output.mp4"";

    // Mute the audio in the specified time range
    await ffmpeg.run(
      ""-i"",
      ""input.mp4"",
      ""-af"",
      `volume='if(between(t,${start},${end}),0,1)':eval=frame`,
      ""-c:v"",
      ""copy"",
      ""-c:a"",
      ""aac"",
      outputFileName
    );

    // Get the edited video data
    const data = ffmpeg.FS(""readFile"", outputFileName);

    // Create a Blob from the edited video data
    const editedVideoBlob = new Blob([data.buffer], { type: ""video/mp4"" });

    // Return the edited video Blob
    return editedVideoBlob;
  } catch (error) {
    console.error(""Error muting video:"", error);
    return null;
  }
}

export default muteVideo;
"
EditorFallback\utils\reencodeVideo.js,Included,text/javascript,596,"async function reencodeVideo(ffmpeg, blob) {
  const videoData = new Uint8Array(await blob.arrayBuffer());
  const outputFileName = ""output.mp4"";
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);
  await ffmpeg.run(
    ""-i"",
    ""input.mp4"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName
  );

  const data = ffmpeg.FS(""readFile"", outputFileName);
  const editedVideoBlob = new Blob([data.buffer], {
    type: ""video/mp4"",
  });
  return editedVideoBlob;
}

export default reencodeVideo;
"
EditorFallback\utils\toGIF.js,Included,text/javascript,578,"async function toGIF(ffmpeg, blob) {
  const videoData = new Uint8Array(await blob.arrayBuffer());
  const outputFileName = ""output.gif"";
  ffmpeg.FS(""writeFile"", ""input.mp4"", videoData);
  await ffmpeg.run(
    ""-i"",
    ""input.mp4"",
    ""-preset"",
    ""superfast"",
    ""-threads"",
    ""0"",
    ""-r"",
    ""30"",
    ""-tune"",
    ""fastdecode"",
    outputFileName
  );
  const data = ffmpeg.FS(""readFile"", outputFileName);
  const editedVideoBlob = new Blob([data.buffer], {
    type: ""image/gif"",
  });
  return editedVideoBlob;
}

export default toGIF;
"
Permissions\index.html,Included,text/html,175,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title></title>
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
Permissions\index.jsx,Included,application/octet-stream,269,"import React from ""react"";
import { render } from ""react-dom"";

import Recorder from ""./Permissions"";

// Render at the end of the body of any website
render(<Recorder />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Permissions\Permissions.jsx,Included,application/octet-stream,4373,"import React, { useEffect, useState, useRef, useCallback } from ""react"";

const Recorder = () => {
  useEffect(() => {
    window.parent.postMessage(
      {
        type: ""screenity-permissions-loaded"",
      },
      ""*""
    );
  }, []);

  const checkPermissions = async () => {
    // Individually check the camera and microphone permissions using the Permissions API. Then enumerate devices respectively.
    try {
      const cameraPermission = await navigator.permissions.query({
        name: ""camera"",
      });
      const microphonePermission = await navigator.permissions.query({
        name: ""microphone"",
      });

      cameraPermission.onchange = () => {
        checkPermissions();
      };

      microphonePermission.onchange = () => {
        checkPermissions();
      };

      // If the permissions are granted, enumerate devices
      if (
        cameraPermission.state === ""granted"" ||
        microphonePermission.state === ""granted""
      ) {
        enumerateDevices(
          cameraPermission.state === ""granted"",
          microphonePermission.state === ""granted""
        );
      } else {
        // Post message to parent window
        window.parent.postMessage(
          {
            type: ""screenity-permissions"",
            success: false,
            error: err.name,
          },
          ""*""
        );
        // sendResponse({ success: false, error: err.name });
      }
    } catch (err) {
      enumerateDevices();
    }
  };

  // Enumerate devices
  const enumerateDevices = async (camGranted = true, micGranted = true) => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: micGranted,
        video: camGranted,
      });

      const devicesInfo = await navigator.mediaDevices.enumerateDevices();

      let audioinput = [];
      let audiooutput = [];
      let videoinput = [];

      if (micGranted) {
        // Filter by audio input
        audioinput = devicesInfo
          .filter((device) => device.kind === ""audioinput"")
          .map((device) => ({
            deviceId: device.deviceId,
            label: device.label,
          }));

        // Filter by audio output and extract relevant properties
        audiooutput = devicesInfo
          .filter((device) => device.kind === ""audiooutput"")
          .map((device) => ({
            deviceId: device.deviceId,
            label: device.label,
          }));
      }

      if (camGranted) {
        // Filter by video input and extract relevant properties
        videoinput = devicesInfo
          .filter((device) => device.kind === ""videoinput"")
          .map((device) => ({
            deviceId: device.deviceId,
            label: device.label,
          }));
      }

      // Save in Chrome local storage
      chrome.storage.local.set({
        // Set available devices
        audioinput: audioinput,
        audiooutput: audiooutput,
        videoinput: videoinput,
        cameraPermission: camGranted,
        microphonePermission: micGranted,
      });

      // Post message to parent window
      window.parent.postMessage(
        {
          type: ""screenity-permissions"",
          success: true,
          audioinput: audioinput,
          audiooutput: audiooutput,
          videoinput: videoinput,
          cameraPermission: camGranted,
          microphonePermission: micGranted,
        },
        ""*""
      );

      //sendResponse({ success: true, audioinput, audiooutput, videoinput });

      // End the stream
      stream.getTracks().forEach(function (track) {
        track.stop();
      });
    } catch (err) {
      // Post message to parent window
      window.parent.postMessage(
        {
          type: ""screenity-permissions"",
          success: false,
          error: err.name,
        },
        ""*""
      );
      //sendResponse({ success: false, error: err.name });
    }
  };

  const onMessage = (message) => {
    if (message.type === ""screenity-get-permissions"") {
      checkPermissions();
    }
  };

  // Post message listener
  useEffect(() => {
    window.addEventListener(""message"", (event) => {
      onMessage(event.data);
    });
  }, []);

  return <div></div>;
};

export default Recorder;
"
Playground\index.html,Included,text/html,1178,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title>Screenity - Playground</title>
    <style>
      @font-face {
        font-family: Satoshi-Light;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Light.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Medium;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Medium.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Bold;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Bold.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Gloria-Hallelujah;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/GloriaHallelujah-Regular.ttf)
          format(""truetype"");
      }
    </style>
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
Playground\index.jsx,Included,application/octet-stream,257,"import React from ""react"";
import { render } from ""react-dom"";

import Setup from ""./Setup"";

// Render at the end of the body of any website
render(<Setup />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Playground\Setup.jsx,Included,application/octet-stream,3993,"import React, { useEffect, useState } from ""react"";

const Setup = () => {
  useEffect(() => {
    // Inject content script
    const script = document.createElement(""script"");
    script.src = chrome.runtime.getURL(""contentScript.bundle.js"");
    script.async = true;
    document.body.appendChild(script);

    // Also inject CSS
    const style = document.createElement(""link"");
    style.rel = ""stylesheet"";
    style.type = ""text/css"";
    style.href = chrome.runtime.getURL(""assets/fonts/fonts.css"");
    document.body.appendChild(style);

    // Return
    return () => {
      document.body.removeChild(script);
      document.body.removeChild(style);
    };
  }, []);

  return (
    <div className=""setupBackground"">
      <img
        src={chrome.runtime.getURL(""assets/logo-text.svg"")}
        className=""setupLogo""
      />
      <div className=""setupBackgroundSVG""></div>
      <style>
        {`
				body {
					overflow: hidden;
					margin: 0px;
				}

				.setupInfo {
					margin-top: 20px;
				}
				a {
					text-decoration: none!important;
					color: #4C7DE2;
				}
				.setupBackgroundSVG {
					position: absolute;
					top: 0px;
					left: 0px;

					width: 100%;
					height: 100%;
					background: url('` +
          chrome.runtime.getURL(""assets/helper/pattern-svg.svg"") +
          `') repeat;
					background-size: 62px 23.5px;
					animation: moveBackground 138s linear infinite;
				}
				
				@keyframes moveBackground {
					0% {
						background-position: 0 0;
					}
					100% {
						background-position: 100% 0;
					}
				}


				.setupLogo {
					position: absolute;
					bottom: 30px;
					left: 0px;
					right: 0px;
					margin: auto;
					width: 120px;
				}


				.setupBackground {
					background-color: #f5f5f5;
					height: 100vh;
					width: 100vw;
					display: flex;
					justify-content: center;
					align-items: center;
				}

				.setupContainer {
					position: absolute;
					top: 0px;
					left: 0px;
					right: 0px;
					bottom: 0px;
					margin: auto;
					z-index: 999;
					display: flex;
					justify-content: center;
					align-items: center;
					width: 60%;
					height: fit-content;
					background-color: #fff;
					border-radius: 30px;
					padding: 50px 50px;
					gap: 80px;
					font-family: 'Satoshi-Medium', sans-serif;
				}

				.setupImage {
					width: 70%;
					display: flex;
					justify-content: center;
					align-items: center;
				}

				.setupImage img {
					width: 100%;
					border-radius: 30px;
				}

				.setupText {
					width: 50%;
					display: flex;
					flex-direction: column;
					justify-content: left;
					align-items: left;
					text-align: left;
				}

				.setupEmoji {
					font-size: 20px;
					margin-bottom: 10px;
				}

				.setupTitle {
					font-size: 20px;
					font-weight: bold;
					margin-bottom: 10px;
					color: #29292F;
				}

				.setupDescription {
					display: flex;
					flex-direction: column;
					justify-content: center;
					align-items: left;
					margin-top: 10px;
					color: #6E7684;
					font-size: 14px;
				}

				.setupStep {
					margin-bottom: 10px;
					vertical-align: middle;
				}

				.setupStep span {

					align-items: center;
					justify-content: center;
					text-align: center;
					width: 20px;
					height: 20px;
					padding: 2px;
					border-radius: 30px;
					display: inline-flex;
					vertical-align: middle;
					margin-left: 3px;
					margin-right: 3px;
					background-color: #F4F2F2;
				}

				.setupStep img {
					width: 100%;
					text-align: center;
					display: block;
				}

				.center {
					text-align: center!important;
				}
				.setupText.center {
					width: auto!important;
				}
				.setupContainer.center {
					width: 40%!important;
				}
				


				`}
      </style>
    </div>
  );
};

export default Setup;
"
Recorder\index.html,Included,text/html,1109,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <title>Screenity - Recorder</title>
    <style>
      @font-face {
        font-family: Satoshi-Light;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Light.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Medium;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Medium.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Bold;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Bold.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }
      body {
        font-family: Satoshi-Medium;
      }
    </style>
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
Recorder\index.jsx,Included,application/octet-stream,264,"import React from 'react';
import { render } from 'react-dom';

import Recorder from './Recorder';

// Render at the end of the body of any website
render(<Recorder />, window.document.querySelector('#app-container'));

if (module.hot) module.hot.accept();"
Recorder\Recorder.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,22725,"import React, { useEffect, useState, useRef, useCallback } from ""react"";
import localforage from ""localforage"";

import Warning from ""./warning/Warning"";

localforage.config({
  driver: localforage.INDEXEDDB, // or choose another driver
  name: ""screenity"", // optional
  version: 1, // optional
});

// Get chunks store
const chunksStore = localforage.createInstance({
  name: ""chunks"",
});

const Recorder = () => {
  const isRestarting = useRef(false);
  const isFinishing = useRef(false);
  const sentLast = useRef(false);
  const lastTimecode = useRef(0);
  const hasChunks = useRef(false);

  const index = useRef(0);

  const [started, setStarted] = useState(false);

  // Main stream (recording)
  const liveStream = useRef(null);

  // Helper streams
  const helperVideoStream = useRef(null);
  const helperAudioStream = useRef(null);

  // Audio controls, with refs to persist across renders
  const aCtx = useRef(null);
  const destination = useRef(null);
  const audioInputSource = useRef(null);
  const audioOutputSource = useRef(null);
  const audioInputGain = useRef(null);
  const audioOutputGain = useRef(null);

  const recorder = useRef(null);

  const isTab = useRef(false);
  const tabID = useRef(null);
  const tabPreferred = useRef(false);

  const backupRef = useRef(false);

  useEffect(() => {
    chrome.storage.local.get([""backup""], (result) => {
      if (result.backup) {
        backupRef.current = true;
      } else {
        backupRef.current = false;
      }
    });
  }, []);

  async function startRecording() {
    // Check that a recording is not already in progress
    if (recorder.current !== null) return;

    navigator.storage.persist();
    // Check if the stream actually has data in it
    if (helperVideoStream.current.getVideoTracks().length === 0) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: ""No video tracks available"",
      });
      return;
    }

    chunksStore.clear();

    lastTimecode.current = 0;
    hasChunks.current = 0;

    try {
      const { qualityValue } = await chrome.storage.local.get([""qualityValue""]);

      let audioBitsPerSecond = 128000;
      let videoBitsPerSecond = 5000000;

      if (qualityValue === ""4k"") {
        audioBitsPerSecond = 192000;
        videoBitsPerSecond = 40000000;
      } else if (qualityValue === ""1080p"") {
        audioBitsPerSecond = 192000;
        videoBitsPerSecond = 8000000;
      } else if (qualityValue === ""720p"") {
        audioBitsPerSecond = 128000;
        videoBitsPerSecond = 5000000;
      } else if (qualityValue === ""480p"") {
        audioBitsPerSecond = 96000;
        videoBitsPerSecond = 2500000;
      } else if (qualityValue === ""360p"") {
        audioBitsPerSecond = 96000;
        videoBitsPerSecond = 1000000;
      } else if (qualityValue === ""240p"") {
        audioBitsPerSecond = 64000;
        videoBitsPerSecond = 500000;
      }

      // List all mimeTypes
      const mimeTypes = [
        ""video/webm;codecs=avc1"",
        ""video/webm;codecs=vp8,opus"",
        ""video/webm;codecs=vp9,opus"",
        ""video/webm;codecs=vp9"",
        ""video/webm;codecs=vp8"",
        ""video/webm;codecs=h264"",
        ""video/webm"",
      ];

      // Check if the browser supports any of the mimeTypes, make sure to select the first one that is supported from the list
      let mimeType = mimeTypes.find((mimeType) =>
        MediaRecorder.isTypeSupported(mimeType)
      );

      // If no mimeType is supported, throw an error
      if (!mimeType) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""stream-error"",
          why: ""No supported mimeTypes available"",
        });
        return;
      }

      recorder.current = new MediaRecorder(liveStream.current, {
        mimeType: mimeType,
        audioBitsPerSecond: audioBitsPerSecond,
        videoBitsPerSecond: videoBitsPerSecond,
      });
    } catch (err) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: JSON.stringify(err),
      });
      return;
    }

    chrome.storage.local.set({
      recording: true,
      restarting: false,
    });

    isRestarting.current = false;
    index.current = 0;

    try {
      recorder.current.start(3000);
    } catch (err) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: JSON.stringify(err),
      });
      return;
    }

    recorder.current.onstop = (e) => {
      if (isRestarting.current) return;
      setTimeout(() => {
        if (!sentLast.current) {
          chrome.runtime.sendMessage({ type: ""video-ready"" });
          isFinishing.current = false;
        }
      }, 3000);
      isRestarting.current = false;
    };

    const checkMaxMemory = () => {
      try {
        navigator.storage.estimate().then((data) => {
          const minMemory = 26214400;
          // Check if there's enough space to keep recording
          if (data.quota < minMemory) {
            chrome.storage.local.set({
              recording: false,
              restarting: false,
              tabRecordedID: null,
              memoryError: true,
            });
            chrome.runtime.sendMessage({ type: ""stop-recording-tab"" });
          }
        });
      } catch (err) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""stream-error"",
          why: JSON.stringify(err),
        });
      }
    };

    const handleDataAvailable = async (e) => {
      checkMaxMemory();

      if (e.data.size > 0 && (e.timecode != null || e.timecode != undefined)) {
        try {
          const timestamp = e.timecode;
          if (hasChunks.current === false) {
            hasChunks.current = true;
            lastTimecode.current = timestamp;
          } else if (timestamp < lastTimecode.current) {
            // This is a duplicate chunk, ignore it
            return;
          } "
Recorder\warning\Warning.jsx,Included,application/octet-stream,5205,"import React, {
  useState,
  useEffect,
  useContext,
  useCallback,
  useRef,
} from ""react"";

import { ReactSVG } from ""react-svg"";

import * as ToastEl from ""@radix-ui/react-toast"";

const Warning = () => {
  const [open, setOpen] = useState(false);
  const [title, setTitle] = useState(""Record computer audio"");
  const [description, setDescription] = useState("""");
  const [duration, setDuration] = useState(10000);

  const openWarning = useCallback((title, description, duration) => {
    setTitle(title);
    setDescription(description);
    setDuration(duration);
    setOpen(true);
  }, []);

  useEffect(() => {
    // Check if macOS
    const isMac = navigator.userAgent.indexOf(""Mac"") !== -1;
    if (isMac) {
      openWarning(
        chrome.i18n.getMessage(""recordAudioWarningMacTitle""),
        chrome.i18n.getMessage(""recordAudioWarningMacDescription""),
        10000
      );
    } else {
      openWarning(
        chrome.i18n.getMessage(""recordAudioWarningOtherTitle""),
        chrome.i18n.getMessage(""recordAudioWarningOtherDescription""),
        10000
      );
    }
  }, []);

  return (
    <ToastEl.Provider swipeDirection=""down"" duration={duration}>
      <ToastEl.Root
        className=""warning-root""
        open={open}
        onOpenChange={setOpen}
        onSwipeEnd={() => {
          setOpen(false);
        }}
      >
        <div className=""warning-icon"">
          <ReactSVG
            src={chrome.runtime.getURL(""assets/tool-icons/audio-icon.svg"")}
            width={20}
            height={20}
          />
        </div>
        <div className=""warning-content"">
          <ToastEl.Title className=""warning-title"">{title}</ToastEl.Title>
          <ToastEl.Description className=""warning-description"">
            {description}
          </ToastEl.Description>
        </div>
        <ToastEl.Close
          className=""warning-close""
          onClick={() => {
            setOpen(false);
          }}
        >
          <ReactSVG
            src={chrome.runtime.getURL(""assets/camera-icons/close.svg"")}
            width={20}
            height={20}
          />
        </ToastEl.Close>
      </ToastEl.Root>
      <ToastEl.Viewport className=""WarningViewport"" />
      <style>
        {`

				button {
					all: unset;
				}
				.WarningViewport {
					--viewport-padding: 25px;
					position: fixed;
					bottom: 0;
					right: 0;
					left: 0;
					margin: auto !important;
					display: flex;
					flex-direction: column;
					padding: var(--viewport-padding);
					gap: 14px;
					max-width: 100vw;
					width: fit-content;
					list-style: none;
					z-index: 2147483647;
					outline: none;
					pointer-events: all !important;
				}
				
				.warning-root {
					background-color: #29292F;
					color: #FFF;
					border-radius: 30px;
					box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px,
						hsl(206 22% 7% / 20%) 0px 10px 20px -15px;
					padding: 14px 20px;
					display: flex;
					flex-direction: row;
					justify-content: center;
					gap: 8px;
					font-size: 15px;
					line-height: 1.5;
					max-width: 500px;
					overflow: hidden;
					align-items: center;
					text-align: left;
					align-items: flex-start;
				}
				.warning-content {
					display: flex;
					flex-direction: column;
					justify-content: left;
					align-items: flex-start;
					gap: 8px;
					width: 100%;
				}
				.warning-root[data-state=""open""] {
					animation: slideIn2 150ms cubic-bezier(0.16, 1, 0.3, 1);
				}
				.warning-root[data-state=""closed""] {
					animation: hide 100ms ease-in;
				}
				.warning-root[data-swipe=""move""] {
					transform: translateY(var(--radix-toast-swipe-move-y));
				}
				.warning-root[data-swipe=""cancel""] {
					transform: translateY(0);
					transition: transform 200ms ease-out;
				}
				.warning-root[data-swipe=""end""] {
					animation: swipeOut2 100ms ease-out;
				}
				
				@keyframes hide {
					from {
						opacity: 1;
					}
					to {
						opacity: 0 !important;
					}
				}
				
				@keyframes slideIn2 {
					from {
						transform: translateY(calc(100% + var(--viewport-padding)));
					}
					to {
						transform: translateY(0);
					}
				}
				
				@keyframes swipeOut2 {
					from {
						transform: translateY(var(--radix-toast-swipe-end-y));
					}
					to {
						transform: translateY(calc(100% + var(--viewport-padding)));
					}
				}
				
				.warning-title {
					color: #FFF;
					font-family: ""Satoshi-Medium"", sans-serif;
				}
				
				.warning-description {
					color: #FFF;
					opacity: 0.8;
					font-family: ""Satoshi-Medium"", sans-serif;
				}
				
				.ToastAction {
					color: #FFF;
					font-family: ""Satoshi-Medium"", sans-serif;
					text-align: right;
					background-color: #51515f;
					padding: 0px 12px !important;
					height: 24px !important;
					cursor: pointer;
				}
				.warning-close {
					z-index: 999999;
				}
				.warning-close:hover {
					cursor: pointer;
				}
				`}
      </style>
    </ToastEl.Provider>
  );
};

export default Warning;
"
RecorderOffscreen\index.html,Included,text/html,175,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title></title>
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
RecorderOffscreen\index.jsx,Included,application/octet-stream,293,"import React from ""react"";
import { render } from ""react-dom"";

import RecorderOffscreen from ""./RecorderOffscreen"";

// Render at the end of the body of any website
render(<RecorderOffscreen />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
RecorderOffscreen\RecorderOffscreen.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,17720,"import React, { useEffect, useState, useRef, useCallback } from ""react"";
import localforage from ""localforage"";

localforage.config({
  driver: localforage.INDEXEDDB, // or choose another driver
  name: ""screenity"", // optional
  version: 1, // optional
});

// Get chunks store
const chunksStore = localforage.createInstance({
  name: ""chunks"",
});

const RecorderOffscreen = () => {
  const isRestarting = useRef(false);
  const isFinishing = useRef(false);
  const sentLast = useRef(false);
  const index = useRef(0);
  const lastTimecode = useRef(0);
  const hasChunks = useRef(false);

  const [started, setStarted] = useState(false);

  // Main stream (recording)
  const liveStream = useRef(null);

  // Helper streams
  const helperVideoStream = useRef(null);
  const helperAudioStream = useRef(null);

  // Audio controls, with refs to persist across renders
  const aCtx = useRef(null);
  const destination = useRef(null);
  const audioInputSource = useRef(null);
  const audioOutputSource = useRef(null);
  const audioInputGain = useRef(null);
  const audioOutputGain = useRef(null);

  const recorder = useRef(null);

  const isTab = useRef(false);
  const tabID = useRef(null);
  const quality = useRef(""1080p"");
  const fps = useRef(30);
  const backupRef = useRef(false);

  async function startRecording() {
    // Check that a recording is not already in progress
    if (recorder.current !== null) return;
    navigator.storage.persist();
    // Check if the stream actually has data in it
    if (helperVideoStream.current.getVideoTracks().length === 0) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: ""No video tracks available"",
      });
      return;
    }

    chunksStore.clear();

    lastTimecode.current = 0;
    hasChunks.current = 0;

    try {
      const qualityValue = quality.current;

      let audioBitsPerSecond = 128000;
      let videoBitsPerSecond = 5000000;

      if (qualityValue === ""4k"") {
        audioBitsPerSecond = 192000;
        videoBitsPerSecond = 40000000;
      } else if (qualityValue === ""1080p"") {
        audioBitsPerSecond = 192000;
        videoBitsPerSecond = 8000000;
      } else if (qualityValue === ""720p"") {
        audioBitsPerSecond = 128000;
        videoBitsPerSecond = 5000000;
      } else if (qualityValue === ""480p"") {
        audioBitsPerSecond = 96000;
        videoBitsPerSecond = 2500000;
      } else if (qualityValue === ""360p"") {
        audioBitsPerSecond = 96000;
        videoBitsPerSecond = 1000000;
      } else if (qualityValue === ""240p"") {
        audioBitsPerSecond = 64000;
        videoBitsPerSecond = 500000;
      }

      // List all mimeTypes
      const mimeTypes = [
        ""video/webm;codecs=avc1"",
        ""video/webm;codecs=vp8,opus"",
        ""video/webm;codecs=vp9,opus"",
        ""video/webm;codecs=vp9"",
        ""video/webm;codecs=vp8"",
        ""video/webm;codecs=h264"",
        ""video/webm"",
      ];

      // Check if the browser supports any of the mimeTypes, make sure to select the first one that is supported from the list
      let mimeType = mimeTypes.find((mimeType) =>
        MediaRecorder.isTypeSupported(mimeType)
      );

      // If no mimeType is supported, throw an error
      if (!mimeType) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""stream-error"",
          why: ""No supported mimeTypes available"",
        });
        return;
      }

      recorder.current = new MediaRecorder(liveStream.current, {
        mimeType: mimeType,
        audioBitsPerSecond: audioBitsPerSecond,
        videoBitsPerSecond: videoBitsPerSecond,
      });
    } catch (err) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: JSON.stringify(err),
      });
      return;
    }

    isRestarting.current = false;
    index.current = 0;

    // I don't know what the ideal chunk size should be here
    try {
      recorder.current.start(3000);
    } catch (err) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: JSON.stringify(err),
      });
      return;
    }

    recorder.current.onstop = async (e) => {
      if (isRestarting.current) return;

      setTimeout(() => {
        if (!sentLast.current) {
          chrome.runtime.sendMessage({ type: ""video-ready"" });
          isFinishing.current = false;
        }
      }, 3000);

      isRestarting.current = false;
    };

    const checkMaxMemory = () => {
      try {
        navigator.storage.estimate().then((data) => {
          const minMemory = 26214400;
          // Check if there's enough space to keep recording
          if (data.quota < minMemory) {
            chrome.runtime.sendMessage({
              type: ""stop-recording-tab"",
              memoryError: true,
            });
          }
        });
      } catch (err) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""stream-error"",
          why: JSON.stringify(err),
        });
      }
    };

    const handleDataAvailable = async (e) => {
      checkMaxMemory();

      if (e.data.size > 0 && (e.timecode != null || e.timecode != undefined)) {
        try {
          const timestamp = e.timecode;
          if (hasChunks.current === false) {
            hasChunks.current = true;
            lastTimecode.current = timestamp;
          } else if (timestamp < lastTimecode.current) {
            // This is a duplicate chunk, ignore it
            return;
          } else {
            lastTimecode.current = timestamp;
          }

          await chunksStore.setItem(`chunk_${index.current}`, {
            index: index.current,
            chunk: e.data,
            timestamp: timestamp,
          });

          if (backupRef.current) {
            chrome.runtime.sendMessage({
              type: ""write-file"",
              index: index.current,
            });
        "
Region\index.html,Included,text/html,175,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title></title>
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
Region\index.jsx,Included,application/octet-stream,266,"import React from ""react"";
import { render } from ""react-dom"";

import Recorder from ""./Recorder"";

// Render at the end of the body of any website
render(<Recorder />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Region\Recorder.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,20676,"import React, {
  useEffect,
  useState,
  useRef,
  useCallback,
  useContext,
} from ""react"";

import localforage from ""localforage"";

localforage.config({
  driver: localforage.INDEXEDDB, // or choose another driver
  name: ""screenity"", // optional
  version: 1, // optional
});

// Get chunks store
const chunksStore = localforage.createInstance({
  name: ""chunks"",
});

const Recorder = () => {
  const isRestarting = useRef(false);
  const isDismissing = useRef(false);
  const isFinishing = useRef(false);
  const isFinished = useRef(false);
  const sentLast = useRef(false);
  const index = useRef(0);
  const lastTimecode = useRef(0);
  const hasChunks = useRef(false);

  // Main stream (recording)
  const liveStream = useRef(null);

  // Helper streams
  const helperVideoStream = useRef(null);
  const helperAudioStream = useRef(null);

  // Audio controls, with refs to persist across renders
  const aCtx = useRef(null);
  const destination = useRef(null);
  const audioInputSource = useRef(null);
  const audioOutputSource = useRef(null);
  const audioInputGain = useRef(null);
  const audioOutputGain = useRef(null);

  const recorder = useRef(null);

  // Target
  const target = useRef(null);

  // Recording ref
  const recordingRef = useRef();
  const regionRef = useRef();
  const backupRef = useRef(false);

  useEffect(() => {
    window.parent.postMessage(
      {
        type: ""screenity-region-capture-loaded"",
      },
      ""*""
    );
  }, []);

  // Receive post message from parent (this is an iframe)
  useEffect(() => {
    const onMessage = (event) => {
      if (event.data.type === ""crop-target"") {
        target.current = event.data.target;
        regionRef.current = true;
      } else if (event.data.type === ""restart-recording"") {
        restartRecording();
      }
    };
    window.addEventListener(""message"", (event) => {
      onMessage(event);
    });

    return () => {
      window.removeEventListener(""message"", onMessage);
    };
  }, []);

  async function startRecording() {
    // Check that a recording is not already in progress
    if (recorder.current !== null) return;
    navigator.storage.persist();
    isFinishing.current = false;
    sentLast.current = false;
    lastTimecode.current = 0;
    hasChunks.current = 0;
    isFinished.current = false;
    // Check if the stream actually has data in it
    try {
      if (helperVideoStream.current.getVideoTracks().length === 0) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""stream-error"",
          why: ""No video tracks available"",
        });

        // Reload this iframe
        window.location.reload();
        return;
      }
    } catch (err) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: JSON.stringify(err),
      });

      // Reload this iframe
      window.location.reload();
      return;
    }

    chunksStore.clear();

    try {
      const { qualityValue } = await chrome.storage.local.get([""qualityValue""]);

      let audioBitsPerSecond = 128000;
      let videoBitsPerSecond = 5000000;

      if (qualityValue === ""4k"") {
        audioBitsPerSecond = 192000;
        videoBitsPerSecond = 40000000;
      } else if (qualityValue === ""1080p"") {
        audioBitsPerSecond = 192000;
        videoBitsPerSecond = 8000000;
      } else if (qualityValue === ""720p"") {
        audioBitsPerSecond = 128000;
        videoBitsPerSecond = 5000000;
      } else if (qualityValue === ""480p"") {
        audioBitsPerSecond = 96000;
        videoBitsPerSecond = 2500000;
      } else if (qualityValue === ""360p"") {
        audioBitsPerSecond = 96000;
        videoBitsPerSecond = 1000000;
      } else if (qualityValue === ""240p"") {
        audioBitsPerSecond = 64000;
        videoBitsPerSecond = 500000;
      }

      // List all mimeTypes
      const mimeTypes = [
        ""video/webm;codecs=avc1"",
        ""video/webm;codecs=vp8,opus"",
        ""video/webm;codecs=vp9,opus"",
        ""video/webm;codecs=vp9"",
        ""video/webm;codecs=vp8"",
        ""video/webm;codecs=h264"",
        ""video/webm"",
      ];

      // Check if the browser supports any of the mimeTypes, make sure to select the first one that is supported from the list
      let mimeType = mimeTypes.find((mimeType) =>
        MediaRecorder.isTypeSupported(mimeType)
      );

      // If no mimeType is supported, throw an error
      if (!mimeType) {
        chrome.runtime.sendMessage({
          type: ""recording-error"",
          error: ""stream-error"",
          why: ""No supported mimeTypes available"",
        });

        // Reload this iframe
        window.location.reload();
        return;
      }

      recorder.current = new MediaRecorder(liveStream.current, {
        mimeType: mimeType,
        audioBitsPerSecond: audioBitsPerSecond,
        videoBitsPerSecond: videoBitsPerSecond,
      });
    } catch (err) {
      chrome.runtime.sendMessage({
        type: ""recording-error"",
        error: ""stream-error"",
        why: JSON.stringify(err),
      });

      // Reload this iframe
      window.location.reload();
      return;
    }

    chrome.storage.local.set({
      recording: true,
      restarting: false,
    });

    isRestarting.current = false;
    index.current = 0;
    recordingRef.current = true;
    isDismissing.current = false;

    // I don't know what the ideal chunk size should be here
    try {
      recorder.current.start(3000);
    } catch (err) {
      chrome.storage.local.set({
        recording: false,
        restarting: false,
        tabRecordedID: null,
        memoryError: true,
      });
      chrome.runtime.sendMessage({ type: ""stop-recording-tab"" });

      // Reload this iframe
      window.location.reload();
      return;
    }

    recorder.current.onstop = async (e) => {
      regionRef.current = false;
      recordingRef.current = false;
      if (isRestarting.current) return;
      if (!isDismissing.current) {
        set"
Sandbox\components\editor\CropperWrap.jsx,Included,application/octet-stream,2905,"import React, { useState, useEffect, useContext, useRef } from ""react"";
import { CropperRef, Cropper } from ""react-advanced-cropper"";
import ""react-advanced-cropper/dist/style.css"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const CropperWrap = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const [image, setImage] = useState(null);
  const cropperRef = useRef(null);

  useEffect(() => {
    if (!cropperRef.current) return;
    if (!cropperRef.current.getCoordinates()) return;
    if (contentState.fromCropper) return;
    cropperRef.current.setCoordinates({
      top: contentState.top,
      left: contentState.left,
      width: contentState.width,
      height: contentState.height,
    });
    if (contentState.top != cropperRef.current.getCoordinates().top) {
      setContentState((prevState) => ({
        ...prevState,
        top: cropperRef.current.getCoordinates().top,
      }));
    }
    if (contentState.left != cropperRef.current.getCoordinates().left) {
      setContentState((prevState) => ({
        ...prevState,
        left: cropperRef.current.getCoordinates().left,
      }));
    }
    if (contentState.width != cropperRef.current.getCoordinates().width) {
      setContentState((prevState) => ({
        ...prevState,
        width: cropperRef.current.getCoordinates().width,
      }));
    }
    if (contentState.height != cropperRef.current.getCoordinates().height) {
      setContentState((prevState) => ({
        ...prevState,
        height: cropperRef.current.getCoordinates().height,
      }));
    }
  }, [
    contentState.width,
    contentState.height,
    contentState.top,
    contentState.left,
  ]);

  const onChange = (cropper) => {
    if (!cropper) return;
    setContentState((prevState) => ({
      ...prevState,
      top: cropper.getCoordinates().top,
      left: cropper.getCoordinates().left,
      width: cropper.getCoordinates().width,
      height: cropper.getCoordinates().height,
      fromCropper: true,
    }));
  };

  useEffect(() => {
    if (!contentState.blob) return;

    setImage(contentState.frame);
  }, [contentState.frame]);

  return (
    <div>
      <Cropper
        src={image}
        ref={cropperRef}
        onChange={onChange}
        className={""cropper""}
        stencilProps={{
          grid: true,
        }}
        defaultSize={{
          width: contentState.width,
          height: contentState.height,
        }}
        backgroundWrapperClassName=""CropperBackgroundWrapper""
        width={contentState.width}
        height={contentState.height}
        transitions={false}
        style={{ transition: ""none"" }}
      />
    </div>
  );
};

export default CropperWrap;
"
Sandbox\components\editor\Dropdown.jsx,Included,application/octet-stream,5542,"import React, { useEffect, useState, useContext, useRef } from ""react"";

import * as Select from ""@radix-ui/react-select"";

import styles from ""../../styles/edit/_Dropdown.module.scss"";

// Icons
//import DropdownIcon from ""../../public/assets/icons/dropdown.svg"";
//import CheckWhiteIcon from ""../../public/assets/icons/check-white.svg"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const Dropdown = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const [label, setLabel] = useState(""None"");
  const [value, setValue] = useState(""none"");

  // Video presets for Youtube, Instagram, TikTok, etc.
  const presets = [
    {
      name: ""none"",
    },
    {
      name: ""Youtube"",
      label: ""Youtube"",
      width: 1920,
      height: 1080,
    },
    {
      name: ""YoutubeShorts"",
      label: ""Youtube Shorts"",
      width: 1920,
      height: 1080,
    },
    {
      name: ""InstagramPost"",
      label: ""Instagram Post"",
      width: 1080,
      height: 1080,
    },
    {
      name: ""InstagramStory"",
      label: ""Instagram Story"",
      width: 1080,
      height: 1920,
    },
    {
      name: ""TikTok"",
      label: ""TikTok"",
      width: 1080,
      height: 1920,
    },
    {
      name: ""Facebook"",
      label: ""Facebook"",
      width: 1080,
      height: 1080,
    },
    {
      name: ""Twitter"",
      label: ""Twitter"",
      width: 1080,
      height: 1080,
    },
    {
      name: ""Dribbble"",
      label: ""Dribbble"",
      width: 2800,
      height: 2100,
    },
  ];

  useEffect(() => {
    // Update the value when the contentState changes
    setValue(contentState.cropPreset);
    setLabel(
      presets.find((preset) => preset.name === contentState.cropPreset).label
    );

    if (contentState.cropPreset === ""none"") return;
    const preset = presets.find(
      (preset) => preset.name === contentState.cropPreset
    );
    const aspectRatio = preset.width / preset.height;
    const maxWidth = contentState.prevWidth;
    const maxHeight = contentState.prevHeight;

    let width = Math.min(preset.width, maxWidth);
    let height = Math.min(preset.height, maxHeight);

    if (width > maxWidth || height > maxHeight) {
      if (width / height > aspectRatio) {
        width = Math.min(maxWidth, width);
        height = width / aspectRatio;
      } else {
        height = Math.min(maxHeight, height);
        width = height * aspectRatio;
      }
    }

    if (width > maxWidth) {
      width = maxWidth;
      height = width / aspectRatio;
    }

    if (height > maxHeight) {
      height = maxHeight;
      width = height * aspectRatio;
    }

    const left = maxWidth / 2 - width / 2;
    const top = maxHeight / 2 - height / 2;

    setContentState((prevContentState) => ({
      ...prevContentState,
      fromCropper: false,
      width: width,
      height: height,
      left: left,
      top: top,
    }));
  }, [contentState.cropPreset]);

  return (
    <Select.Root
      value={value}
      onValueChange={(newValue) => {
        setValue(newValue);
        setLabel(presets.find((preset) => preset.name === newValue).label);
        setContentState((prevContentState) => ({
          ...prevContentState,
          cropPreset: newValue,
        }));
      }}
    >
      <Select.Trigger className={styles.SelectTrigger} aria-label=""Food"">
        {props.icon && (
          <Select.Icon className={styles.SelectIconType}></Select.Icon>
        )}
        <div className={styles.SelectValue}>
          <Select.Value placeholder=""Select a source"">{label}</Select.Value>
        </div>
        <Select.Icon className={styles.SelectIconDrop}>
          <img src=""/assets/icons/dropdown.svg"" />
        </Select.Icon>
      </Select.Trigger>
      <Select.Portal className={styles.Portal}>
        <Select.Content position=""popper"" className={styles.SelectContent}>
          <Select.ScrollUpButton
            className={styles.SelectScrollButton}
          ></Select.ScrollUpButton>
          <Select.Viewport className={styles.SelectViewport}>
            <Select.Group>
              <SelectItem value=""none"">None</SelectItem>
            </Select.Group>

            <Select.Separator className={styles.SelectSeparator} />
            <Select.Group>
              {presets.map(
                (preset, index) =>
                  preset.name !== ""none"" && (
                    <SelectItem value={preset.name} key={index}>
                      {preset.label}
                    </SelectItem>
                  )
              )}
            </Select.Group>
          </Select.Viewport>
          <Select.ScrollDownButton
            className={styles.SelectScrollButton}
          ></Select.ScrollDownButton>
        </Select.Content>
      </Select.Portal>
    </Select.Root>
  );
};

const SelectItem = React.forwardRef(
  ({ children, className, ...props }, forwardedRef) => {
    return (
      <Select.Item className={styles.SelectItem} {...props} ref={forwardedRef}>
        <Select.ItemText>{children}</Select.ItemText>
        <Select.ItemIndicator className={styles.SelectItemIndicator}>
          <img src=""/assets/icons/check-white.svg"" />
        </Select.ItemIndicator>
      </Select.Item>
    );
  }
);

export default Dropdown;
"
Sandbox\components\editor\Switch.jsx,Included,application/octet-stream,1129,"import React, { useContext, useEffect } from ""react"";
import * as S from ""@radix-ui/react-switch"";

// Styles
import styles from ""../../styles/edit/_Switch.module.scss"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const Switch = () => {
  const [contentState, setContentState] = useContext(ContentStateContext);

  return (
    <form>
      <div className={styles.SwitchRow}>
        <label
          className={styles.Label}
          htmlFor=""replaceAudio""
          style={{ paddingRight: 15 }}
        >
          {chrome.i18n.getMessage(""replaceAudioEditor"")}
        </label>
        <S.Root
          className={styles.SwitchRoot}
          checked={contentState.replaceAudio}
          onCheckedChange={(checked) => {
            setContentState((prevContentState) => ({
              ...prevContentState,
              replaceAudio: checked,
            }));
          }}
        >
          <S.Thumb className={styles.SwitchThumb} />
        </S.Root>
      </div>
    </form>
  );
};

export default Switch;
"
Sandbox\components\editor\Trimmer.jsx,Included,application/octet-stream,3722,"import React, { useRef, useEffect, useState, useContext } from ""react"";
import styles from ""../../styles/edit/_Trimmer.module.scss"";
import WaveformGenerator from ""./Waveform"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const Trimmer = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const trimmerRef = useRef(null);
  const startHandleRef = useRef(null);
  const endHandleRef = useRef(null);
  const isDragging = useRef(false);
  const activeHandle = useRef(null);

  const handleMouseDown = (e, handle) => {
    e.preventDefault();
    isDragging.current = true;
    activeHandle.current = handle;

    document.addEventListener(""mousemove"", handleMouseMove);
    document.addEventListener(""mouseup"", handleMouseUp);
  };

  const handleMouseMove = (e) => {
    if (!isDragging.current) return;

    const trimmerRect = trimmerRef.current.getBoundingClientRect();
    const trimmerWidth = trimmerRect.width;
    const mouseX = e.clientX - trimmerRect.left;
    let newPosition = mouseX / trimmerWidth;

    if (activeHandle.current === ""start"") {
      newPosition += 0;
      const validPosition = Math.max(
        Math.min(newPosition, contentState.end - 0.02),
        0
      );
      setContentState((prevContentState) => ({
        ...prevContentState,
        start: validPosition,
      }));
    } else if (activeHandle.current === ""end"") {
      newPosition -= 0;
      const validPosition = Math.min(
        Math.max(newPosition, contentState.start + 0.02),
        1
      );
      setContentState((prevContentState) => ({
        ...prevContentState,
        end: validPosition,
      }));
    }
  };

  const handleMouseUp = () => {
    isDragging.current = false;
    activeHandle.current = null;

    contentState.addToHistory();

    setContentState((prevContentState) => ({
      ...prevContentState,
      dragInteracted: true,
    }));

    document.removeEventListener(""mousemove"", handleMouseMove);
    document.removeEventListener(""mouseup"", handleMouseUp);
  };

  useEffect(() => {
    // Update the handle positions when the start and end values change
    startHandleRef.current.style.left = `calc(${contentState.start * 100}%)`;
    endHandleRef.current.style.left = `${contentState.end * 100}%`;
  }, [contentState.start, contentState.end]);

  return (
    <div>
      <div className={styles.trimmerContainer} ref={trimmerRef}>
        <div className={styles.trimWrap}>
          <div
            className={styles.leftOverlay}
            style={{ width: `${contentState.start * 100}%` }}
          />
          <div
            className={styles.rightOverlay}
            style={{ width: `${(1 - contentState.end) * 100}%` }}
          />
          <div
            className={styles.trimSection}
            style={{
              width: `${(contentState.end - contentState.start) * 100}%`,
              left: `${contentState.start * 100}%`,
            }}
          />
          <div className={styles.trimmer}>
            <div
              className={`${styles.handle} ${styles.startHandle}`}
              onMouseDown={(e) => handleMouseDown(e, ""start"")}
              ref={startHandleRef}
            />
            <div
              className={`${styles.handle} ${styles.endHandle}`}
              onMouseDown={(e) => handleMouseDown(e, ""end"")}
              ref={endHandleRef}
            />
          </div>
        </div>
        <WaveformGenerator />
      </div>
    </div>
  );
};

export default Trimmer;
"
Sandbox\components\editor\VideoPlayer.jsx,Included,application/octet-stream,4422,"import React, { useContext, useEffect, useState, useRef, useMemo } from ""react"";
import Plyr from ""plyr-react"";
import ""plyr-react/plyr.css"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const VideoPlayer = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const playerRef = useRef(null);
  const [url, setUrl] = useState(null);
  const [source, setSource] = useState(null);
  const [isSet, setIsSet] = useState(false);

  useEffect(() => {
    if (
      playerRef.current &&
      playerRef.current.plyr &&
      contentState.updatePlayerTime
    ) {
      playerRef.current.plyr.currentTime = contentState.time;
    }
  }, [contentState.time]);

  const options = useMemo(
    () => ({
      controls: [""play"", ""mute"", ""captions"", ""settings"", ""pip"", ""fullscreen""],
      ratio: ""16:9"",
      blankVideo:
        ""chrome-extension://"" +
        chrome.i18n.getMessage(""@@extension_id"") +
        ""/assets/blank.mp4"",
      keyboard: {
        global: true,
      },
    }),
    []
  );

  useEffect(() => {
    if (contentState.blob) {
      const objectURL = URL.createObjectURL(contentState.blob);
      setSource({
        type: ""video"",
        sources: [
          {
            src: objectURL,
            type: ""video/mp4"",
          },
        ],
      });
      setUrl(objectURL);

      // if (playerRef.current && playerRef.current.plyr) {
      //   // Check when the video is playing, update the time in real time
      //   playerRef.current.plyr.on(""timeupdate"", () => {
      //     setContentState((prevContentState) => ({
      //       ...prevContentState,
      //       time: playerRef.current.plyr.currentTime,
      //       updatePlayerTime: false,
      //     }));
      //   });
      // }

      return () => {
        URL.revokeObjectURL(objectURL);

        // if (playerRef.current && playerRef.current.plyr) {
        //   playerRef.current.plyr.off(""timeupdate"");
        // }
      };
    }
  }, [contentState.blob, playerRef]);

  useEffect(() => {
    if (playerRef.current && playerRef.current.plyr) {
      // Check when the video is playing, update the time in real time
      playerRef.current.plyr.on(""timeupdate"", () => {
        setContentState((prevContentState) => ({
          ...prevContentState,
          time: playerRef.current.plyr.currentTime,
          updatePlayerTime: false,
        }));
      });
    }

    return () => {
      if (playerRef.current && playerRef.current.plyr) {
        playerRef.current.plyr.off(""timeupdate"");
      }
    };
  }, [playerRef]);

  const handleClick = () => {
    if (isSet) return;
    if (playerRef.current && playerRef.current.plyr) {
      setIsSet(true);
      playerRef.current.plyr.on(""timeupdate"", () => {
        setContentState((prevContentState) => ({
          ...prevContentState,
          time: playerRef.current.plyr.currentTime,
          updatePlayerTime: false,
        }));
      });
    }
  };

  useEffect(() => {
    if (isSet) return;
    const handleKeyPress = (event) => {
      if (playerRef.current && playerRef.current.plyr) {
        setIsSet(true);
        playerRef.current.plyr.on(""timeupdate"", () => {
          setContentState((prevContentState) => ({
            ...prevContentState,
            time: playerRef.current.plyr.currentTime,
            updatePlayerTime: false,
          }));
        });
      }
    };
    window.addEventListener(""keydown"", handleKeyPress);
    return () => {
      window.removeEventListener(""keydown"", handleKeyPress);
    };
  }, [isSet]);

  return (
    <div className=""videoPlayer"">
      <div className=""playerWrap"" onClick={handleClick}>
        {url && (
          <Plyr
            ref={playerRef}
            id=""plyr-player""
            source={source}
            options={options}
          />
        )}
      </div>
      <style>
        {`
					.plyr {
						height: 90%!important;
					}
					@media (max-width: 900px) {
						.videoPlayer {
							height: 100%!important;
							top: 40px!important;
						}
						.playerWrap {
							height: calc(100% - 300px)!important;
						}
					`}
      </style>
    </div>
  );
};

export default VideoPlayer;
"
Sandbox\components\editor\Waveform.jsx,Included,application/octet-stream,5454,"import React, { useContext, useRef, useEffect, useState } from ""react"";
import WaveSurfer from ""wavesurfer.js"";
import styles from ""../../styles/edit/_Waveform.module.scss"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const WaveformGenerator = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const wavesurferRef = useRef(null);
  const waveformContainerRef = useRef(null);
  const customCursorRef = useRef(null);
  const ghostCursorRef = useRef(null);
  const [showGhost, setShowGhost] = useState(false);
  const mouseDown = useRef(false);

  async function blobToArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        if (reader.result instanceof ArrayBuffer) {
          resolve(reader.result);
        } else {
          reject(new Error(""Failed to convert Blob to ArrayBuffer""));
        }
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(blob);
    });
  }

  const loadWaveform = async (blob) => {
    try {
      wavesurferRef.current = WaveSurfer.create({
        container: waveformContainerRef.current,
        waveColor: ""#C4C5CE"",
        progressColor: ""#9596A2"",
        interpolation: ""cubic"",
        height: ""auto"",
        cursorWidth: 0,
      });
      const audioArrayBuffer = await blobToArrayBuffer(blob);

      wavesurferRef.current.loadBlob(
        new Blob([audioArrayBuffer], { type: ""audio/wav"" })
      );

      wavesurferRef.current.on(""seeking"", (currentTime) => {
        const containerRect =
          waveformContainerRef.current.getBoundingClientRect();
        const cursorX =
          containerRect.width *
          (currentTime / wavesurferRef.current.getDuration());
        customCursorRef.current.style.left = `${cursorX}px`;
        setContentState((prevContentState) => ({
          ...prevContentState,
          time: currentTime,
          updatePlayerTime: true,
        }));
      });
    } catch (error) {
      console.error(""Error loading waveform:"", error);
    }
  };

  const handleMouseEnter = () => {
    if (mouseDown.current) return;
    setShowGhost(true);
  };

  const handleMouseMove = (e) => {
    const containerRect = waveformContainerRef.current.getBoundingClientRect();
    const cursorX = e.clientX - containerRect.left;
    const minX = 0;
    const maxX = containerRect.width;
    const cursorStyle = ghostCursorRef.current.style;
    cursorStyle.left = `${cursorX}px`;
  };

  const handleMouseLeave = () => {
    setShowGhost(false);
  };

  const handleMouseDown = (e) => {
    if (waveformContainerRef.current.contains(e.target)) return;
    mouseDown.current = true;
    setShowGhost(false);
  };

  const handleMouseUp = () => {
    mouseDown.current = false;
  };

  useEffect(() => {
    if (!contentState.blob) return;
    loadWaveform(contentState.blob);
    const container = waveformContainerRef.current;
    container.addEventListener(""mouseover"", handleMouseEnter);
    container.addEventListener(""mousemove"", handleMouseMove);
    container.addEventListener(""mouseleave"", handleMouseLeave);
    document.addEventListener(""mousedown"", handleMouseDown);
    document.addEventListener(""mouseup"", handleMouseUp);

    if (wavesurferRef.current) {
      wavesurferRef.current.on(""seek"", (position) => {
        const containerRect =
          waveformContainerRef.current.getBoundingClientRect();
        const cursorX = containerRect.width * position;
        customCursorRef.current.style.left = `${
          cursorX + containerRect.left
        }px`;
      });
    }

    return () => {
      if (wavesurferRef.current) {
        wavesurferRef.current.destroy();
      }
      container.removeEventListener(""mouseenter"", handleMouseEnter);
      container.removeEventListener(""mousemove"", handleMouseMove);
      container.removeEventListener(""mouseleave"", handleMouseLeave);
      document.removeEventListener(""mousedown"", handleMouseDown);
      document.removeEventListener(""mouseup"", handleMouseUp);
    };
  }, [contentState.blob]);

  useEffect(() => {
    if (!contentState.blob) return;
    if (contentState.updatePlayerTime) return;
    if (waveformContainerRef.current === null) return;

    const video = document.createElement(""video"");
    video.preload = ""metadata"";
    video.onloadedmetadata = async () => {
      const containerRect =
        waveformContainerRef.current.getBoundingClientRect();
      const cursorX =
        containerRect.width * (contentState.time / video.duration);
      customCursorRef.current.style.left = `${cursorX}px`;

      URL.revokeObjectURL(video.src);
      video.remove();
    };
    video.src = URL.createObjectURL(contentState.blob);
  }, [contentState.time, contentState.blob, waveformContainerRef.current]);

  return (
    <div style={{ height: ""100%"" }}>
      <div className={styles.cursor} ref={customCursorRef}></div>
      <div
        className={styles.ghostCursor}
        style={showGhost ? { opacity: 1 } : { opacity: 0 }}
        ref={ghostCursorRef}
      ></div>
      <div className={styles.waveform} ref={waveformContainerRef}></div>
    </div>
  );
};

export default WaveformGenerator;
"
Sandbox\components\global\Modal.jsx,Included,application/octet-stream,4498,"import React, { useState, useEffect, useContext, useCallback } from ""react"";
import * as AlertDialog from ""@radix-ui/react-alert-dialog"";

// Context
import { ContentStateContext } from ""../../context/ContentState"";

const Modal = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext);
  const [title, setTitle] = useState(""Test"");
  const [description, setDescription] = useState(""Description here"");
  const [button1, setButton1] = useState(""Submit"");
  const [button2, setButton2] = useState(""Cancel"");
  const [trigger, setTrigger] = useState(() => {});
  const [trigger2, setTrigger2] = useState(() => {});
  const [showModal, setShowModal] = useState(false);
  const [image, setImage] = useState(null);
  const [learnmore, setLearnMore] = useState(null);
  const [learnMoreLink, setLearnMoreLink] = useState(() => {});
  const [colorSafe, setColorSafe] = useState(false);
  const [sideButton, setSideButton] = useState(false);
  const [sideButtonAction, setSideButtonAction] = useState(() => {});

  const openModal = useCallback(
    (
      title,
      description,
      button1,
      button2,
      action,
      action2,
      image = null,
      learnMore = null,
      learnMoreLink = null,
      colorSafe = false,
      sideButton = false,
      sideButtonAction = () => {}
    ) => {
      setTitle(title);
      setDescription(description);
      setButton1(button1);
      setButton2(button2);
      setShowModal(true);
      setTrigger(() => action);
      setTrigger2(() => action2);
      setImage(image);
      setLearnMore(learnMore);
      setLearnMoreLink(() => learnMoreLink);
      setColorSafe(colorSafe);
      setSideButton(sideButton);
      setSideButtonAction(() => sideButtonAction);
    }
  );

  useEffect(() => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      openModal: openModal,
    }));

    return () => {
      setContentState((prevContentState) => ({
        ...prevContentState,
        openModal: null,
      }));
    };
  }, []);

  return (
    <AlertDialog.Root
      open={showModal}
      onOpenChange={(open) => {
        setShowModal(open);
      }}
    >
      <AlertDialog.Trigger asChild />
      <AlertDialog.Portal>
        <AlertDialog.Overlay className=""AlertDialogOverlay"" />
        <AlertDialog.Content className=""AlertDialogContent"">
          <AlertDialog.Title className=""AlertDialogTitle"">
            {title}
          </AlertDialog.Title>
          <AlertDialog.Description className=""AlertDialogDescription"">
            {description}
            {learnmore && "" ""}
            {learnmore && (
              <a
                href=""#""
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  learnMoreLink();
                }}
                target=""_blank""
              >
                {learnmore}
              </a>
            )}
          </AlertDialog.Description>
          {image && (
            <img
              src={image}
              style={{
                width: ""100%"",
                marginBottom: 15,
                marginTop: 5,
                borderRadius: ""15px"",
              }}
            />
          )}
          <div style={{ display: ""flex"", gap: 12, justifyContent: ""flex-end"" }}>
            {sideButton && (
              <button
                className=""SideButtonModal""
                onClick={() => {
                  sideButtonAction();
                  setShowModal(false);
                }}
              >
                {sideButton}
              </button>
            )}
            {button2 && (
              <AlertDialog.Cancel asChild>
                <button className=""Button grey"" onClick={() => trigger2()}>
                  {button2}
                </button>
              </AlertDialog.Cancel>
            )}
            {button1 && (
              <AlertDialog.Action asChild>
                <button
                  className={!colorSafe ? ""Button red"" : ""Button blue""}
                  onClick={() => trigger()}
                >
                  {button1}
                </button>
              </AlertDialog.Action>
            )}
          </div>
        </AlertDialog.Content>
      </AlertDialog.Portal>
    </AlertDialog.Root>
  );
};

export default Modal;
"
Sandbox\components\player\HelpButton.jsx,Included,application/octet-stream,559,"import React, { useContext, useState } from ""react"";
import styles from ""../../styles/player/_HelpButton.module.scss"";

import { ReactSVG } from ""react-svg"";

const HelpButton = () => {
  return (
    <button
      className={styles.HelpButton}
      aria-label=""Help button""
      onClick={() => {
        chrome.runtime.sendMessage({ type: ""open-help"" });
      }}
    >
      <ReactSVG
        src=""/assets/editor/icons/help.svg""
        width=""18px""
        height=""18px""
      />
    </button>
  );
};

export default HelpButton;
"
Sandbox\components\player\ShareModal.jsx,Included,application/octet-stream,1652,"import React, { useContext, useState } from ""react"";

import styles from ""../../styles/player/_ShareModal.module.scss"";

import { ReactSVG } from ""react-svg"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const URL = ""/assets/"";

const ShareModal = ({ showShare, setShowShare }) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  return (
    <div className={styles.modalWrap}>
      <div className={styles.modal}>
        <div
          className={styles.close}
          onClick={() => {
            setShowShare(false);
          }}
        >
          <ReactSVG
            src={URL + ""editor/icons/close-button.svg""}
            width=""16px""
            height=""16px""
          />
        </div>
        <div className={styles.emoji}></div>
        <div className={styles.title}>
          {chrome.i18n.getMessage(""shareModalSandboxTitle"")}
        </div>
        <div className={styles.subtitle}>
          {chrome.i18n.getMessage(""shareModalSandboxDescription"")}
        </div>
        <div
          className={styles.button}
          onClick={() => {
            chrome.runtime.sendMessage({ type: ""join-waitlist"" });
            setShowShare(false);
          }}
        >
          {chrome.i18n.getMessage(""shareModalSandboxButton"")}
        </div>
      </div>
      <div
        className={styles.modalBackground}
        onClick={() => {
          setShowShare(false);
        }}
      ></div>
    </div>
  );
};

export default ShareModal;
"
Sandbox\components\player\Title.jsx,Included,application/octet-stream,3349,"import React, { useContext, useState, useEffect, useRef } from ""react"";

// Styles
import styles from ""../../styles/player/_Title.module.scss"";
const URL = ""/assets/"";

// Icon
import { ReactSVG } from ""react-svg"";

import ShareModal from ""./ShareModal"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const Title = () => {
  const [showShare, setShowShare] = useState(false);
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const inputRef = useRef(null);
  // Show the video title, as a heading by default (multiline), on click show a text input to edit the title
  const [showTitle, setShowTitle] = useState(true);
  const [title, setTitle] = useState(contentState.title);
  const [displayTitle, setDisplayTitle] = useState(contentState.title);

  useEffect(() => {
    setTitle(contentState.title);
    if (contentState.title.length > 80) {
      setDisplayTitle(contentState.title.slice(0, 80) + ""..."");
    } else {
      setDisplayTitle(contentState.title);
    }
  }, [contentState.title]);

  const handleTitleChange = (e) => {
    setTitle(e.target.value);
  };

  const handleTitleClick = () => {
    setShowTitle(false);
  };

  const handleTitleBlur = () => {
    setShowTitle(true);
    setContentState((prevState) => ({
      ...prevState,
      title: title,
    }));
  };

  useEffect(() => {
    if (!showTitle) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [showTitle]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === ""Enter"") {
        setShowTitle(true);
        setContentState((prevState) => ({
          ...prevState,
          title: title,
        }));
      } else if (e.key === ""Escape"") {
        setShowTitle(true);
        setTitle(contentState.title);
      }
    };

    document.addEventListener(""keydown"", handleKeyDown);

    return () => {
      document.removeEventListener(""keydown"", handleKeyDown);
    };
  }, [title]);

  return (
    <div className={styles.TitleParent}>
      {showShare && (
        <ShareModal showShare={showShare} setShowShare={setShowShare} />
      )}
      <div className={styles.TitleWrap}>
        {showTitle ? (
          <>
            <h1 onClick={handleTitleClick}>
              {displayTitle}{"" ""}
              <ReactSVG
                src={URL + ""editor/icons/pencil.svg""}
                className={styles.pencil}
                styles={{ display: ""inline-block"" }}
              />
            </h1>
            <div
              className={styles.shareButton}
              onClick={() => {
                setShowShare(true);
              }}
            >
              <ReactSVG
                src={URL + ""editor/icons/link.svg""}
                className={styles.shareIcon}
              />
              {chrome.i18n.getMessage(""shareSandboxButton"")}
            </div>
          </>
        ) : (
          <input
            type=""text""
            value={title}
            onChange={handleTitleChange}
            onBlur={handleTitleBlur}
            ref={inputRef}
          />
        )}
      </div>
    </div>
  );
};

export default Title;
"
Sandbox\components\player\VideoPlayer.jsx,Included,application/octet-stream,5014,"import React, { useContext, useEffect, useState, useRef, useMemo } from ""react"";
import Plyr from ""plyr-react"";
import ""../../styles/plyr.css"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

// Components
import Title from ""./Title"";

const VideoPlayer = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const playerRef = useRef(null);
  const [url, setUrl] = useState(null);
  const [source, setSource] = useState(null);
  const contentStateRef = useRef(contentState);
  const bannerRef = useRef(null);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  useEffect(() => {
    if (
      playerRef.current &&
      playerRef.current.plyr &&
      contentState.updatePlayerTime
    ) {
      playerRef.current.plyr.currentTime = contentState.time;
    }
  }, [contentState.time]);

  const options = useMemo(
    () => ({
      controls: [
        ""play"",
        ""rewind"",
        ""fast-forward"",
        ""progress"",
        ""current-time"",
        ""duration"",
        ""mute"",
        ""captions"",
        ""settings"",
        ""pip"",
        ""fullscreen"",
      ],
      urls: null,
      ratio: ""16:9"",
      blankVideo:
        ""chrome-extension://"" +
        chrome.i18n.getMessage(""@@extension_id"") +
        ""/assets/blank.mp4"",
      keyboard: {
        global: true,
      },
    }),
    []
  );

  /*
  useEffect(() => {
    if (contentState.blob) {
      const objectURL = URL.createObjectURL(contentState.blob);
      setSource({
        type: ""video"",
        sources: [
          {
            src: objectURL,
            type: ""video/mp4"",
          },
        ],
      });
      setUrl(objectURL);

      return () => {
        URL.revokeObjectURL(objectURL);
      };
    }
  }, [contentState.blob, playerRef]);
	*/

  useEffect(() => {
    if (contentState.webm || contentState.blob) {
      let vid;
      if (contentState.blob) {
        if (bannerRef.current) {
          bannerRef.current.style.display = ""none"";
          bannerRef.current.remove();
        }
        vid = contentState.blob;
      } else if (contentState.webm) {
        vid = contentState.webm;
      }
      const objectURL = URL.createObjectURL(vid);
      setSource({
        type: ""video"",
        sources: [
          {
            src: objectURL,
            type: contentState.blob ? ""video/mp4"" : ""video/webm"",
          },
        ],
      });
      setUrl(objectURL);

      return () => {
        URL.revokeObjectURL(objectURL);
      };
    }
  }, [
    contentState.webm,
    contentState.blob,
    contentState.hasBeenEdited,
    playerRef,
  ]);

  // Use a mutation observer to check if .plyr--video is added to the DOM
  useEffect(() => {
    if (contentStateRef.current.mp4ready || contentStateRef.current.blob)
      return;
    const config = { attributes: true, childList: true, subtree: true };

    const callback = function (mutationsList, observer) {
      for (let mutation of mutationsList) {
        if (
          document.querySelector("".plyr--video"") &&
          !contentStateRef.current.mp4ready &&
          !contentStateRef.current.blob &&
          !bannerRef.current &&
          !contentStateRef.current.noffmpeg &&
          !(
            contentStateRef.current.duration >
              contentStateRef.current.editLimit &&
            !contentStateRef.current.override
          )
        ) {
          bannerRef.current = document.createElement(""div"");
          bannerRef.current.classList.add(""videoBanner"");
          bannerRef.current.innerHTML =
            ""<img src='"" +
            chrome.runtime.getURL(""assets/editor/icons/alert-white.svg"") +
            ""'/> <span>"" +
            chrome.i18n.getMessage(""processingBannerEditor"") +
            ""</span>"";

          document.querySelector("".plyr--video"").appendChild(bannerRef.current);
        }
      }
    };

    const observer = new MutationObserver(callback);
    observer.observe(document.body, config);

    return () => {
      observer.disconnect();

      if (bannerRef.current) {
        bannerRef.current.style.display = ""none"";
        bannerRef.current.remove();
        bannerRef.current = null;
      }
    };
  }, []);

  return (
    <div className=""videoPlayer"">
      <div className=""playerWrap"">
        {url && (
          <Plyr
            ref={playerRef}
            id=""plyr-player""
            source={source}
            options={options}
          />
        )}
        {contentState.mode === ""player"" && <Title />}
      </div>
      <style>
        {`
					@media (max-width: 900px) {
						.videoPlayer {
							position: relative!important;
						}
					}
					`}
      </style>
    </div>
  );
};

export default VideoPlayer;
"
Sandbox\context\ContentState.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,27520,"import React, {
  createContext,
  useContext,
  useState,
  useCallback,
  useRef,
} from ""react"";
import { useEffect } from ""react"";

import fixWebmDuration from ""fix-webm-duration"";
import { default as fixWebmDurationFallback } from ""webm-duration-fix"";

export const ContentStateContext = createContext();

const ContentState = (props) => {
  const videoChunks = useRef([]);
  const makeVideoCheck = useRef(false);
  const chunkCount = useRef(0);

  const defaultState = {
    time: 0,
    editLimit: 420,
    blob: null,
    webm: null,
    originalBlob: null,
    updatePlayerTime: false,
    start: 0, // Add missing properties here
    end: 1,
    trimming: false,
    cutting: false,
    muting: false,
    history: [{}], // Initialize history with a default state
    redoHistory: [],
    undoDisabled: true,
    redoDisabled: true,
    duration: 0,
    mode: ""player"",
    ffmpegLoaded: false,
    frame: null,
    getFrame: null,
    isFfmpegRunning: false,
    reencoding: false,
    prevWidth: 0,
    width: 0,
    prevHeight: 0,
    height: 0,
    top: 0,
    left: 0,
    fromCropper: false,
    base64: null,
    saveDrive: false,
    downloading: false,
    downloadingWEBM: false,
    downloadingGIF: false,
    volume: 1,
    cropPreset: ""none"",
    replaceAudio: false,
    title: null,
    ready: false,
    mp4ready: false,
    saved: false,
    iframeRef: null,
    offline: false,
    updateChrome: false,
    driveEnabled: false,
    hasBeenEdited: false,
    dragInteracted: false,
    noffmpeg: false,
    openModal: null,
    rawBlob: null,
    override: false,
    fallback: false,
    chunkCount: 0,
    chunkIndex: 0,
  };

  const [contentState, setContentState] = useState(defaultState);
  const contentStateRef = useRef(contentState);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  // Check if the user is offline
  // useEffect(() => {
  //   if (!navigator.onLine) {
  //     setContentState((prevState) => ({
  //       ...prevState,
  //       offline: true,
  //     }));
  //   }
  // }, []);

  // Generate a title based on the current time (e.g. Screenity video - Sep 4 2021 10:00 AM)
  useEffect(() => {
    const date = new Date();
    const formattedDate = date.toLocaleString(""en-US"", {
      month: ""short"",
      day: ""numeric"",
      year: ""numeric"",
    });
    setContentState((prevState) => ({
      ...prevState,
      title: `Screenity video - ${formattedDate}`,
    }));
  }, []);

  // Show a popup when attempting to close the tab if the user has not downloaded their video
  useEffect(() => {
    if (!contentState.saved) {
      window.onbeforeunload = function () {
        return true;
      };
    } else {
      window.onbeforeunload = null;
    }
  }, [contentState.saved]);

  const addToHistory = useCallback(() => {
    setContentState((prevState) => ({
      ...prevState,
      history: [...prevState.history, prevState],
      redoHistory: [], // Clear redo history when a new state is added
    }));
  }, [contentState]);

  const undo = useCallback(() => {
    if (contentState.history.length > 1) {
      const previousState =
        contentState.history[contentState.history.length - 2];
      const newHistory = contentState.history.slice(0, -1);
      setContentState((prevState) => ({
        ...prevState,
        ...previousState,
        history: newHistory,
        redoHistory: [contentState, ...contentState.redoHistory],
      }));
    }
  }, [contentState]);

  const redo = useCallback(() => {
    if (contentState.redoHistory.length > 0) {
      const nextState = contentState.redoHistory[0];
      const newRedoHistory = contentState.redoHistory.slice(1);
      setContentState((prevState) => ({
        ...prevState,
        ...nextState,
        history: [...contentState.history, contentState],
        redoHistory: newRedoHistory,
      }));
    }
  }, [contentState]);

  const base64ToUint8Array = (base64) => {
    const dataUrlRegex = /^data:(.*?);base64,/;
    const matches = base64.match(dataUrlRegex);
    if (matches !== null) {
      // Base64 is a data URL
      const mimeType = matches[1];
      const binaryString = atob(base64.slice(matches[0].length));
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return new Blob([bytes], { type: mimeType });
    } else {
      // Base64 is a regular string
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }
  };

  useEffect(() => {
    if (!contentState.blob) return;

    // Get duration of video blob
    const video = document.createElement(""video"");
    video.preload = ""metadata"";
    video.onloadedmetadata = async () => {
      setContentState((prevState) => ({
        ...prevState,
        duration: video.duration,
        width: video.videoWidth,
        height: video.videoHeight,
        prevWidth: video.videoWidth,
        prevHeight: video.videoHeight,
      }));

      URL.revokeObjectURL(video.src);
      video.remove();
    };
    video.src = URL.createObjectURL(contentState.blob);
  }, [contentState.blob]);

  const reconstructVideo = async () => {
    const blob = new Blob(videoChunks.current, {
      type: ""video/webm; codecs=vp8, opus"",
    });

    const { recordingDuration } = await chrome.storage.local.get(
      ""recordingDuration""
    );

    // Check if token is present
    const { token } = await chrome.storage.local.get(""token"");

    let driveEnabled = false;

    if (token && token !== null) {
      driveEnabled = true;
    }

    setContentState((prevState) => ({
      ...prevState,
      rawBlob: blob,
      duration: recordingDuration / 1000,
    }));

    // Check if user is in Windows 10
    const isWindows10 = navigator.userAgent.match(/Windows "
Sandbox\index.html,Included,text/html,974,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <title>Screenity - Video editor</title>
    <style>
      @font-face {
        font-family: Satoshi-Light;
        src: url(/assets/fonts/Satoshi-Light.ttf) format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Medium;
        src: url(/assets/fonts/Satoshi-Medium.ttf) format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Bold;
        src: url(/assets/fonts/Satoshi-Bold.ttf) format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }
    </style>
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
Sandbox\index.jsx,Included,application/octet-stream,365,"import React from ""react"";
import { render } from ""react-dom"";

import Sandbox from ""./Sandbox"";

import ContentState from ""./context/ContentState"";

// Render at the end of the body of any website
render(
  <ContentState>
    <Sandbox />
  </ContentState>,
  window.document.querySelector(""#app-container"")
);

if (module.hot) module.hot.accept();
"
Sandbox\layout\editor\AudioNav.js,Included,text/javascript,2739,"import React, { useContext } from ""react"";
import styles from ""../../styles/edit/_EditorNav.module.scss"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const URL = ""/assets/"";

const AudioNav = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const handleCancel = () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""player"",
      blob: contentState.originalBlob,
      start: 0,
      end: 1,
      width: contentState.prevWidth,
      height: contentState.prevHeight,
      left: 0,
      top: 0,
      fromCropper: false,
    }));
  };

  const handleRevert = () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      blob: contentState.originalBlob,
      start: 0,
      end: 1,
    }));
  };

  const saveChanges = async () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""player"",
      start: 0,
      end: 1,
    }));
  };

  return (
    <div className={styles.editorNav}>
      <div className={styles.navWrap}>
        <div
          className={styles.editorNavLeft}
          onClick={() => {
            chrome.runtime.sendMessage({ type: ""open-home"" });
          }}
        >
          <img src={URL + ""editor/logo.svg""} alt=""Logo"" />
        </div>
        <div className={styles.editorNavCenter}>
          <div className={styles.editorNavTitle}>
            {chrome.i18n.getMessage(""sandboxEditorMainTitle"") + "" ""}{"" ""}
            <span className={styles.beta}>BETA</span>
          </div>
        </div>
        <div className={styles.editorNavRight}>
          <button
            className=""button simpleButton blackButton""
            onClick={handleCancel}
            disabled={contentState.isFfmpegRunning}
          >
            {chrome.i18n.getMessage(""sandboxEditorCancelButton"")}
          </button>
          <button
            className=""button secondaryButton""
            onClick={handleRevert}
            disabled={contentState.isFfmpegRunning}
          >
            {chrome.i18n.getMessage(""sandboxEditorRevertButton"")}
          </button>
          <button
            className=""button primaryButton""
            onClick={saveChanges}
            disabled={contentState.isFfmpegRunning}
          >
            {contentState.cropping
              ? chrome.i18n.getMessage(""sandboxEditorSaveProgressButton"")
              : chrome.i18n.getMessage(""sandboxEditorSaveButton"")}
          </button>
        </div>
      </div>
    </div>
  );
};

export default AudioNav;
"
Sandbox\layout\editor\AudioUI.js,Included,text/javascript,5719,"import React, { useState, useEffect, useContext, useRef } from ""react"";
import styles from ""../../styles/player/_RightPanel.module.scss"";

// Components
import Dropdown from ""../../components/editor/Dropdown"";
import * as Slider from ""@radix-ui/react-slider"";
import Switch from ""../../components/editor/Switch"";

// Icons
const URL = ""/assets/"";

import { ReactSVG } from ""react-svg"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const AudioUI = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const [audio, setAudio] = useState(null);
  const prevBlob = useRef(null);
  const inputRef = useRef(null);

  useEffect(() => {
    if (contentState.blob !== prevBlob.current) {
      prevBlob.current = contentState.blob;
      setAudio(null);
      setContentState((prevContentState) => ({
        ...prevContentState,
        volume: 1,
      }));
    }
  }, []);

  const handleAudio = async (e) => {
    const file = e.target.files[0];
    // Check if the file is an audio file
    if (!file.type.includes(""audio"") || file.size === 0) {
      return;
    }

    contentState.addAudio(contentState.blob, file, contentState.volume);
    setAudio(file);
  };

  const handleVolume = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }
    if (value > 100) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      volume: parseFloat(value) / 100,
    }));
  };

  const updateAudio = async () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      blob: prevBlob.current,
    }));
    contentState.addAudio(prevBlob.current, audio, contentState.volume);
  };

  return (
    <div>
      <div className={styles.section}>
        <div className={styles.sectionTitle}>Audio upload</div>
        <input
          type=""file""
          accept=""audio/*""
          onChange={handleAudio}
          style={{ display: ""none"" }}
          ref={inputRef}
        />
        {!audio && (
          <div
            className={styles.uploadArea}
            onClick={() => inputRef.current.click()}
          >
            <ReactSVG src={URL + ""editor/icons/upload.svg""} />
            <div className={styles.uploadDetails}>
              <div className={styles.uploadText}>
                {chrome.i18n.getMessage(""sandboxAudioDragAndDrop"")}
              </div>
              <div className={styles.uploadDescription}>
                {chrome.i18n.getMessage(""sandboxAudioOrBrowse"")}
              </div>
            </div>
          </div>
        )}
        {audio && (
          <div className={styles.audioDetails}>
            <div className={styles.audioDetailsLeft}>
              <ReactSVG src={URL + ""editor/icons/attachment.svg""} />
            </div>
            <div className={styles.audioDetailsMiddle}>
              <span>{audio.name}</span>
            </div>
            <div className={styles.audioDetailsRight}>
              <ReactSVG
                src={URL + ""editor/icons/cross.svg""}
                onClick={() => {
                  setAudio(null);
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    blob: prevBlob.current,
                  }));
                  inputRef.current.value = null;
                }}
              />
            </div>
          </div>
        )}
      </div>
      <div className={styles.section}>
        <div className={styles.sectionTitle}>
          {chrome.i18n.getMessage(""sandboxAudioSettingsTitle"")}
        </div>
        <div className={styles.inputs}>
          <div className={`${styles.input} ${styles.inputVolume}`}>
            <div className={styles.inputTitle}>
              {chrome.i18n.getMessage(""sandboxAudioVolumeLabel"")}
            </div>
            <input
              type=""text""
              className=""input""
              onChange={(e) => handleVolume(e)}
              value={Math.round(contentState.volume * 100)}
              onBlur={(e) => {
                if (e.target.value === """") {
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    volume: 0,
                  }));
                }
              }}
            />
            <span>%</span>
          </div>
          <Slider.Root
            className={styles.SliderRoot}
            max={100}
            step={1}
            onValueChange={(newValue) => {
              setContentState((prevContentState) => ({
                ...prevContentState,
                // Round to the nearest integer
                volume: Math.round(newValue) / 100,
              }));
            }}
            value={[contentState.volume * 100]}
          >
            <Slider.Track className={styles.SliderTrack}>
              <Slider.Range className={styles.SliderRange} />
            </Slider.Track>
            <Slider.Thumb className={styles.SliderThumb} aria-label=""Volume"" />
          </Slider.Root>
        </div>
        <Switch />
        <button
          className={[""button"", ""primaryButton"", styles.updateButton].join("" "")}
          onClick={updateAudio}
          disabled={contentState.isFfmpegRunning || !audio}
        >
          {chrome.i18n.getMessage(""sandboxAudioUpdateButton"")}
        </button>
      </div>
    </div>
  );
};

export default AudioUI;
"
Sandbox\layout\editor\CropNav.js,Included,text/javascript,2876,"import React, { useContext } from ""react"";
import styles from ""../../styles/edit/_EditorNav.module.scss"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const URL = ""/assets/"";

const CropNav = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const handleCancel = () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""player"",
      blob: contentState.originalBlob,
      start: 0,
      end: 1,
      width: contentState.prevWidth,
      height: contentState.prevHeight,
      left: 0,
      top: 0,
      fromCropper: false,
    }));
  };

  const handleRevert = () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      blob: contentState.originalBlob,
      start: 0,
      end: 1,
      width: contentState.prevWidth,
      height: contentState.prevHeight,
      left: 0,
      top: 0,
      fromCropper: false,
    }));
  };

  const saveChanges = async () => {
    contentState.handleCrop(
      contentState.left,
      contentState.top,
      contentState.width,
      contentState.height
    );
  };

  return (
    <div className={styles.editorNav}>
      <div className={styles.navWrap}>
        <div
          className={styles.editorNavLeft}
          onClick={() => {
            chrome.runtime.sendMessage({ type: ""open-home"" });
          }}
        >
          <img src={URL + ""editor/logo.svg""} alt=""Logo"" />
        </div>
        <div className={styles.editorNavCenter}>
          <div className={styles.editorNavTitle}>
            {chrome.i18n.getMessage(""sandboxEditorMainTitle"") + "" ""}{"" ""}
            <span className={styles.beta}>BETA</span>
          </div>
        </div>
        <div className={styles.editorNavRight}>
          <button
            className=""button simpleButton blackButton""
            onClick={handleCancel}
            disabled={contentState.isFfmpegRunning}
          >
            {chrome.i18n.getMessage(""sandboxEditorCancelButton"")}
          </button>
          <button
            className=""button secondaryButton""
            onClick={handleRevert}
            disabled={contentState.isFfmpegRunning}
          >
            {chrome.i18n.getMessage(""sandboxEditorResetButton"")}
          </button>
          <button
            className=""button primaryButton""
            onClick={saveChanges}
            disabled={contentState.isFfmpegRunning}
          >
            {contentState.cropping
              ? chrome.i18n.getMessage(""sandboxEditorSaveProgressButton"")
              : chrome.i18n.getMessage(""sandboxEditorSaveButton"")}
          </button>
        </div>
      </div>
    </div>
  );
};

export default CropNav;
"
Sandbox\layout\editor\CropUI.js,Included,text/javascript,5973,"import React, { useState, useEffect, useContext } from ""react"";
import styles from ""../../styles/player/_RightPanel.module.scss"";

// Components
import Dropdown from ""../../components/editor/Dropdown"";

import { ReactSVG } from ""react-svg"";

const URL =
  ""chrome-extension://"" + chrome.i18n.getMessage(""@@extension_id"") + ""/assets/"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const CropUI = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const handleWidth = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      width: parseFloat(value),
      cropPreset: ""none"",
      fromCropper: false,
    }));
  };

  const handleHeight = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      height: parseFloat(value),
      cropPreset: ""none"",
      fromCropper: false,
    }));
  };

  const handleTop = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      top: parseFloat(value),
      fromCropper: false,
    }));
  };

  const handleLeft = (e) => {
    let value = e.target.value;
    if (isNaN(value)) {
      return;
    }
    if (value < 0) {
      return;
    }

    setContentState((prevContentState) => ({
      ...prevContentState,
      left: parseFloat(value),
      fromCropper: false,
    }));
  };

  return (
    <div>
      {/*
      <div className={styles.section}>
        <div className={styles.sectionTitle}>Dimensions</div>
        <div className={styles.inputSection}>
          <div className={styles.inputSectionTitle}>Preset</div>
          <Dropdown />
        </div>
      </div>
							*/}

      <div className={styles.alert}>
        <div className={styles.buttonLeft}>
          <ReactSVG src={URL + ""editor/icons/alert.svg""} />
        </div>
        <div className={styles.buttonMiddle}>
          <div className={styles.buttonTitle}>
            {chrome.i18n.getMessage(""croppingInfoTitle"")}
          </div>
          <div className={styles.buttonDescription}>
            {chrome.i18n.getMessage(""videoProcessingLabelDescription"")}
          </div>
        </div>
        <div
          className={styles.buttonRight}
          onClick={() => {
            chrome.runtime.sendMessage({ type: ""upgrade-info"" });
          }}
        >
          {chrome.i18n.getMessage(""learnMoreLabel"")}
        </div>
      </div>
      <div className={styles.section}>
        <div className={styles.sectionTitle}>
          {chrome.i18n.getMessage(""sandboxCropTitle"")}
        </div>
        <div className={styles.inputs}>
          <div className={styles.input}>
            <div className={styles.inputTitle}>
              {chrome.i18n.getMessage(""widthLabel"")}
            </div>
            <input
              type=""text""
              className=""input""
              onChange={(e) => handleWidth(e)}
              onBlur={(e) => {
                if (e.target.value === """") {
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    width: 0,
                  }));
                }
              }}
              value={contentState.width}
            />
            <span>px</span>
          </div>
          <div className={styles.input}>
            <div className={styles.inputTitle}>
              {chrome.i18n.getMessage(""heightLabel"")}
            </div>
            <input
              type=""text""
              className=""input""
              onChange={(e) => handleHeight(e)}
              value={contentState.height}
              onBlur={(e) => {
                if (e.target.value === """") {
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    height: 0,
                  }));
                }
              }}
            />
            <span>px</span>
          </div>
        </div>
        <div className={styles.inputs}>
          <div className={styles.input}>
            <div className={styles.inputTitle}>
              {chrome.i18n.getMessage(""leftLabel"")}
            </div>
            <input
              type=""text""
              className=""input""
              onChange={(e) => handleLeft(e)}
              onBlur={(e) => {
                if (e.target.value === """") {
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    left: 0,
                  }));
                }
              }}
              value={contentState.left}
            />
            <span>px</span>
          </div>
          <div className={styles.input}>
            <div className={styles.inputTitle}>
              {chrome.i18n.getMessage(""topLabel"")}
            </div>
            <input
              type=""text""
              className=""input""
              onChange={(e) => handleTop(e)}
              onBlur={(e) => {
                if (e.target.value === """") {
                  setContentState((prevContentState) => ({
                    ...prevContentState,
                    top: 0,
                  }));
                }
              }}
              value={contentState.top}
            />
            <span>px</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CropUI;
"
Sandbox\layout\editor\Editor.js,Included,text/javascript,1120,"import React, { useState, useEffect, useContext } from ""react"";
import EditorNav from ""./EditorNav"";
import VideoPlayer from ""../../components/editor/VideoPlayer"";
import TrimUI from ""./TrimUI"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

import HelpButton from ""../../components/player/HelpButton"";

const Editor = ({ ffmpeg }) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const handleSeek = (t, updateTime) => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      updatePlayerTime: updateTime,
      time: t,
    }));
  };

  useEffect(() => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      history: [{}],
      redoHistory: [],
    }));
    contentState.addToHistory();
  }, []);

  return (
    <div>
      <EditorNav />
      <VideoPlayer onSeek={handleSeek} />
      <TrimUI blob={contentState.blob} onSeek={handleSeek} />
      <HelpButton />
    </div>
  );
};

export default Editor;
"
Sandbox\layout\editor\EditorNav.js,Included,text/javascript,2645,"import React, { useContext } from ""react"";
import styles from ""../../styles/edit/_EditorNav.module.scss"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const URL = ""/assets/"";

const EditorNav = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  const handleCancel = () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""player"",
      blob: contentState.originalBlob,
      start: 0,
      end: 1,
    }));
  };

  const handleRevert = () => {
    setContentState((prevContentState) => ({
      ...prevContentState,
      blob: contentState.originalBlob,
      start: 0,
      end: 1,
    }));
  };

  const saveChanges = async () => {
    await contentState.handleReencode();
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""player"",
      start: 0,
      end: 1,
    }));
  };

  return (
    <div className={styles.editorNav}>
      <div className={styles.navWrap}>
        <div
          className={styles.editorNavLeft}
          onClick={() => {
            chrome.runtime.sendMessage({ type: ""open-home"" });
          }}
        >
          <img src={URL + ""editor/logo.svg""} alt=""Logo"" />
        </div>
        <div className={styles.editorNavCenter}>
          <div className={styles.editorNavTitle}>
            {chrome.i18n.getMessage(""sandboxEditorMainTitle"")}{"" ""}
            <span className={styles.beta}>BETA</span>
          </div>
        </div>
        <div className={styles.editorNavRight}>
          <button
            className=""button simpleButton blackButton""
            onClick={handleCancel}
            disabled={contentState.isFfmpegRunning}
          >
            {chrome.i18n.getMessage(""sandboxEditorCancelButton"")}
          </button>
          <button
            className=""button secondaryButton""
            onClick={handleRevert}
            disabled={contentState.isFfmpegRunning}
          >
            {chrome.i18n.getMessage(""sandboxEditorRevertButton"")}
          </button>

          <button
            className=""button primaryButton""
            onClick={saveChanges}
            disabled={contentState.isFfmpegRunning}
          >
            {contentState.reencoding
              ? chrome.i18n.getMessage(""sandboxEditorSaveProgressButton"")
              : chrome.i18n.getMessage(""sandboxEditorSaveButton"")}
          </button>
        </div>
      </div>
    </div>
  );
};

export default EditorNav;
"
Sandbox\layout\editor\TrimUI.js,Included,text/javascript,5826,"import React, { useContext, useState, useEffect } from ""react"";
import Trimmer from ""../../components/editor/Trimmer"";
import styles from ""../../styles/edit/_TrimUI.module.scss"";

// Icons
import { ReactSVG } from ""react-svg"";

const URL = ""/assets/"";

const TrimIcon = URL + ""editor/icons/trim.svg"";
const RemoveIcon = URL + ""editor/icons/trash.svg"";
const MuteIcon = URL + ""editor/icons/mute.svg"";
const UndoIcon = URL + ""editor/icons/undo.svg"";
const RedoIcon = URL + ""editor/icons/redo.svg"";
const TimeIcon = URL + ""editor/icons/time.svg"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const TrimUI = (props) => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const [undoDisabled, setUndoDisabled] = useState(true);
  const [redoDisabled, setRedoDisabled] = useState(true);
  const [startTime, setStartTime] = useState(0);
  const [endTime, setEndTime] = useState(0);

  useEffect(() => {
    setStartTime(contentState.start * contentState.duration);
    setEndTime(contentState.end * contentState.duration);
  }, [contentState.duration, contentState.start, contentState.end]);

  useEffect(() => {
    if (contentState.history.length > 2) {
      setUndoDisabled(false);
    } else {
      setUndoDisabled(true);
    }
  }, [contentState.history]);

  useEffect(() => {
    if (contentState.redoHistory.length > 0) {
      setRedoDisabled(false);
    } else {
      setRedoDisabled(true);
    }
  }, [contentState.redoHistory]);

  const toTimeStamp = (time) => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time - minutes * 60);

    if (seconds < 10) {
      return `${minutes}:0${seconds}`;
    } else {
      return `${minutes}:${seconds}`;
    }
  };

  return (
    <div className={styles.trimWrap}>
      <div className={styles.controls}>
        <div className={styles.actions}>
          <button
            className=""button secondaryButton""
            onClick={() => contentState.handleTrim(false)}
            disabled={
              contentState.isFfmpegRunning ||
              (contentState.start === 0 && contentState.end === 1)
            }
          >
            <ReactSVG src={TrimIcon} />
            {contentState.trimming
              ? chrome.i18n.getMessage(""sandboxEditorTrimProgressButton"")
              : chrome.i18n.getMessage(""sandboxEditorTrimButton"")}
          </button>
          <button
            className=""button secondaryButton""
            disabled={
              (contentState.start === 0 && contentState.end === 1) ||
              contentState.isFfmpegRunning
            }
            onClick={() => contentState.handleTrim(true)}
          >
            <ReactSVG src={RemoveIcon} />
            {contentState.cutting
              ? chrome.i18n.getMessage(""sandboxEditorCutProgressButton"")
              : chrome.i18n.getMessage(""sandboxEditorCutButton"")}
          </button>
          <button
            className=""button secondaryButton""
            onClick={() => contentState.handleMute()}
            disabled={contentState.isFfmpegRunning}
          >
            <ReactSVG src={MuteIcon} />
            {contentState.muting
              ? chrome.i18n.getMessage(""sandboxEditorMuteProgressButton"")
              : chrome.i18n.getMessage(""sandboxEditorMuteButton"")}
          </button>
        </div>
        <div className={styles.timeWrap}>
          <ReactSVG src={TimeIcon} />
          <span>{toTimeStamp(startTime) + "" - "" + toTimeStamp(endTime)}</span>
        </div>

        <div className={styles.controlsRight}>
          <button
            className=""button simpleButton""
            onClick={() => contentState.undo()}
            disabled={undoDisabled || contentState.isFfmpegRunning}
          >
            <ReactSVG src={UndoIcon} />
            {chrome.i18n.getMessage(""undoLabel"")}
          </button>
          <button
            className=""button simpleButton""
            onClick={() => contentState.redo()}
            disabled={redoDisabled || contentState.isFfmpegRunning}
          >
            <ReactSVG src={RedoIcon} />
            {chrome.i18n.getMessage(""redoLabel"")}
          </button>
        </div>
      </div>
      <Trimmer />
      {(!contentState.dragInteracted || contentState.duration > 3) && (
        <div className={styles.trimInfo}>
          <div className={styles.trimInfoLeft}>
            <ReactSVG src={URL + ""editor/icons/alert.svg""} />
          </div>
          <div className={styles.trimInfoRight}>
            {chrome.i18n.getMessage(""sandboxEditorTrimInfo"")}
            <div
              className={styles.trimInfoLink}
              onClick={() => {
                chrome.runtime.sendMessage({ type: ""trim-info"" });
              }}
            >
              {chrome.i18n.getMessage(""learnMoreDot"")}
            </div>
          </div>
        </div>
      )}
      {contentState.dragInteracted && contentState.duration <= 3 && (
        <div className={styles.trimInfo}>
          <div className={styles.trimInfoLeft}>
            <ReactSVG src={URL + ""editor/icons/alert.svg""} />
          </div>
          <div className={styles.trimInfoRight}>
            {chrome.i18n.getMessage(""sandboxEditorTooSmallInfo"")}
            <div
              className={styles.trimInfoLink}
              onClick={() => {
                chrome.runtime.sendMessage({ type: ""trim-info"" });
              }}
            >
              {chrome.i18n.getMessage(""learnMoreDot"")}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default TrimUI;
"
Sandbox\layout\player\Content.js,Included,text/javascript,931,"import React, { useContext, useState } from ""react"";
import styles from ""../../styles/player/_Content.module.scss"";

// Components
import VideoPlayer from ""../../components/player/VideoPlayer"";
import CropperWrap from ""../../components/editor/CropperWrap"";
import HelpButton from ""../../components/player/HelpButton"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const Content = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  return (
    <div className={styles.content}>
      <div className={styles.wrap}>
        {contentState.mode === ""audio"" && <VideoPlayer />}
        {contentState.mode === ""player"" && <VideoPlayer />}
        {contentState.mode === ""crop"" && <CropperWrap />}
      </div>
      <HelpButton />
    </div>
  );
};

export default Content;
"
Sandbox\layout\player\Player.js,Included,text/javascript,950,"import React, { useContext, useState } from ""react"";

// Components
import PlayerNav from ""./PlayerNav"";
import CropNav from ""../editor/CropNav"";
import AudioNav from ""../editor/AudioNav"";
import RightPanel from ""./RightPanel"";
import Content from ""./Content"";

import styles from ""../../styles/player/_Player.module.scss"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const Player = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context

  return (
    <div className={styles.layout}>
      {contentState.mode === ""crop"" && <CropNav />}
      {contentState.mode === ""player"" && <PlayerNav />}
      {contentState.mode === ""audio"" && <AudioNav />}
      <div className={styles.content}>
        <Content />
        <RightPanel />
      </div>
    </div>
  );
};

export default Player;
"
Sandbox\layout\player\PlayerNav.js,Included,text/javascript,1812,"import React, { useContext, useRef, useEffect } from ""react"";
import styles from ""../../styles/player/_Nav.module.scss"";
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

// Icons
import { ReactSVG } from ""react-svg"";

const URL = ""/assets/"";

const StarIcon = URL + ""editor/icons/help-nav.svg"";
const HeartIcon = URL + ""editor/icons/heart.svg"";

const PlayerNav = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const contentStateRef = useRef(null);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  return (
    <div className={styles.nav}>
      <div className={styles.navWrap}>
        <div
          onClick={() => {
            chrome.runtime.sendMessage({ type: ""open-home"" });
          }}
          aria-label=""home""
          className={styles.navLeft}
        >
          <img src={URL + ""editor/logo.svg""} alt=""Screenity Logo"" />
        </div>
        <div className={styles.navRight}>
          <button
            className=""button simpleButton blueButton""
            onClick={() => {
              chrome.runtime.sendMessage({ type: ""open-help"" });
            }}
          >
            <ReactSVG src={StarIcon} />
            {chrome.i18n.getMessage(""getHelpNav"")}
          </button>
          <button
            className=""button primaryButton""
            onClick={() => {
              chrome.runtime.sendMessage({ type: ""follow-twitter"" });
            }}
          >
            <ReactSVG src={HeartIcon} />{"" ""}
            {chrome.i18n.getMessage(""followForUpdates"")}
          </button>
        </div>
      </div>
    </div>
  );
};

export default PlayerNav;
"
Sandbox\layout\player\RightPanel.js,Truncated to 6000 bytes due to size > 6000,text/javascript,29600,"import React, { useContext, useEffect, useState, useRef } from ""react"";
import styles from ""../../styles/player/_RightPanel.module.scss"";

import JSZip from ""jszip"";

import { ReactSVG } from ""react-svg"";

const URL =
  ""chrome-extension://"" + chrome.i18n.getMessage(""@@extension_id"") + ""/assets/"";

// Components
import CropUI from ""../editor/CropUI"";
import AudioUI from ""../editor/AudioUI"";

// Context
import { ContentStateContext } from ""../../context/ContentState""; // Import the ContentState context

const RightPanel = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const [webmFallback, setWebmFallback] = useState(false);
  const contentStateRef = useRef(contentState);
  const consoleErrorRef = useRef([]);

  // Override console.error to catch errors from ffmpeg.wasm
  useEffect(() => {
    console.error = (error) => {
      consoleErrorRef.current.push(error);
    };
  }, []);

  useEffect(() => {
    contentStateRef.current = contentState;
  }, [contentState]);

  const saveToDrive = () => {
    //if (contentState.noffmpeg) return;
    setContentState((prevContentState) => ({
      ...prevContentState,
      saveDrive: true,
    }));

    if (contentState.noffmpeg || !contentState.mp4ready || !contentState.blob) {
      chrome.runtime
        .sendMessage({
          type: ""save-to-drive-fallback"",
          title: contentState.title,
        })
        .then((response) => {
          if (response.status === ""ew"") {
            // Cancel saving to drive
            setContentState((prevContentState) => ({
              ...prevContentState,
              saveDrive: false,
            }));
          }
        });
    } else {
      // Blob to base64
      const reader = new FileReader();
      reader.onload = () => {
        const dataUrl = reader.result;
        const base64 = dataUrl.split("","")[1];

        chrome.runtime
          .sendMessage({
            type: ""save-to-drive"",
            base64: base64,
            title: contentState.title,
          })
          .then((response) => {
            if (response.status === ""ew"") {
              // Cancel saving to drive
              setContentState((prevContentState) => ({
                ...prevContentState,
                saveDrive: false,
              }));
            }
          });
      };
      if (
        !contentState.noffmpeg &&
        contentState.mp4ready &&
        contentState.blob
      ) {
        reader.readAsDataURL(contentState.blob);
      } else {
        reader.readAsDataURL(contentState.webm);
      }
    }
  };

  const signOutDrive = () => {
    chrome.runtime.sendMessage({ type: ""sign-out-drive"" });
    setContentState((prevContentState) => ({
      ...prevContentState,
      driveEnabled: false,
    }));
  };

  const handleEdit = () => {
    if (
      contentState.duration > contentState.editLimit &&
      !contentState.override
    )
      return;
    if (!contentState.mp4ready) return;
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""edit"",
      dragInteracted: false,
    }));

    if (!contentState.hasBeenEdited) {
      setContentState((prevContentState) => ({
        ...prevContentState,
        hasBeenEdited: true,
      }));
    }
  };

  const handleCrop = () => {
    if (
      contentState.duration > contentState.editLimit &&
      !contentState.override
    )
      return;
    if (!contentState.mp4ready) return;
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""crop"",
    }));

    if (!contentState.hasBeenEdited) {
      setContentState((prevContentState) => ({
        ...prevContentState,
        hasBeenEdited: true,
      }));
    }
  };

  const handleAddAudio = async () => {
    if (
      contentState.duration > contentState.editLimit &&
      !contentState.override
    )
      return;
    if (!contentState.mp4ready) return;
    setContentState((prevContentState) => ({
      ...prevContentState,
      mode: ""audio"",
    }));

    if (!contentState.hasBeenEdited) {
      setContentState((prevContentState) => ({
        ...prevContentState,
        hasBeenEdited: true,
      }));
    }
  };

  const handleRawRecording = () => {
    if (typeof contentStateRef.current.openModal === ""function"") {
      contentStateRef.current.openModal(
        chrome.i18n.getMessage(""rawRecordingModalTitle""),
        chrome.i18n.getMessage(""rawRecordingModalDescription""),
        chrome.i18n.getMessage(""rawRecordingModalButton""),
        chrome.i18n.getMessage(""sandboxEditorCancelButton""),
        () => {
          const blob = contentStateRef.current.rawBlob;
          const url = window.URL.createObjectURL(blob);
          chrome.downloads.download(
            {
              url: url,
              filename: ""raw-recording.webm"",
            },
            () => {
              window.URL.revokeObjectURL(url);
            }
          );
        },
        () => {}
      );
    }
  };

  const handleTroubleshooting = () => {
    if (typeof contentStateRef.current.openModal === ""function"") {
      contentStateRef.current.openModal(
        chrome.i18n.getMessage(""troubleshootModalTitle""),
        chrome.i18n.getMessage(""troubleshootModalDescription""),
        chrome.i18n.getMessage(""troubleshootModalButton""),
        chrome.i18n.getMessage(""sandboxEditorCancelButton""),
        () => {
          // Need to create a file with the original data, any console logs, and system info
          const userAgent = navigator.userAgent;
          let platformInfo = {};
          chrome.runtime.getPlatformInfo(function (info) {
            platformInfo = info;
            const manifestInfo = chrome.runtime.getManifest().version;
            const blob = contentStateRef.current.rawBlob;

            // Now we need to create a file with all of this data
            const data = {
              userAgent: userAgent,
              platformInfo: platformInfo,
              ma"
Sandbox\Sandbox.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,9116,"import ""./styles/edit/_VideoPlayer.scss"";
import ""./styles/global/_app.scss"";

import React, { useState, useEffect, useRef, useContext } from ""react"";
// Layout
import Editor from ""./layout/editor/Editor"";
import Player from ""./layout/player/Player"";
import Modal from ""./components/global/Modal"";

import HelpButton from ""./components/player/HelpButton"";

// Context
import { ContentStateContext } from ""./context/ContentState""; // Import the ContentState context

const Sandbox = () => {
  const [contentState, setContentState] = useContext(ContentStateContext); // Access the ContentState context
  const parentRef = useRef(null);
  const progress = useRef("""");

  // Check when going offline (listener)
  // useEffect(() => {
  //   window.addEventListener(""offline"", () => {
  //     setContentState((prevState) => ({
  //       ...prevState,
  //       offline: true,
  //     }));
  //   });
  // }, []);

  const getChromeVersion = () => {
    var raw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);

    return raw ? parseInt(raw[2], 10) : false;
  };

  useEffect(() => {
    const MIN_CHROME_VERSION = 110;
    const chromeVersion = getChromeVersion();

    if (chromeVersion && chromeVersion > MIN_CHROME_VERSION) {
      contentState.loadFFmpeg();
    } else {
      setContentState((prevState) => ({
        ...prevState,
        updateChrome: true,
        ffmpeg: true,
      }));
    }
  }, []);

  useEffect(() => {
    if (!contentState.blob || !contentState.ffmpeg) return;
    if (contentState.frame) return;
    contentState.getFrame();
  }, [contentState.blob, contentState.ffmpeg]);

  // Programmatically add custom scrollbars
  useEffect(() => {
    if (!parentRef) return;
    if (!parentRef.current) return;

    // Check if on mac
    const isMac = navigator.platform.toUpperCase().indexOf(""MAC"") >= 0;
    if (isMac) return;

    const parentDiv = parentRef.current;

    const elements = parentDiv.querySelectorAll(""*"");
    elements.forEach((element) => {
      element.classList.add(""screenity-scrollbar"");
    });

    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type === ""childList"") {
          const addedNodes = Array.from(mutation.addedNodes);
          const removedNodes = Array.from(mutation.removedNodes);

          addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              node.classList.add(""screenity-scrollbar"");
            }
          });

          removedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              node.classList.remove(""screenity-scrollbar"");
            }
          });
        }
      }
    });

    observer.observe(parentDiv, { childList: true, subtree: true });

    return () => {
      observer.disconnect();
    };
  }, [parentRef.current]);

  useEffect(() => {
    if (contentState.chunkCount > 0) {
      progress.current = `(${Math.round(
        (contentState.chunkIndex / contentState.chunkCount) * 100
      )}%)`;
    }
  }, [contentState.chunkIndex, contentState.chunkCount]);

  return (
    <div ref={parentRef}>
      <Modal />
      <video></video>
      {/* Render the WaveformGenerator component and pass the ffmpeg instance as a prop */}
      {contentState.ffmpeg &&
        contentState.ready &&
        contentState.mode === ""edit"" && <Editor />}
      {contentState.mode != ""edit"" && contentState.ready && <Player />}
      {!contentState.ready && (
        <div className=""wrap"">
          <img className=""logo"" src=""/assets/logo-text.svg"" />
          <div className=""middle-area"">
            <img src=""/assets/record-tab-active.svg"" />
            <div className=""title"">
              {chrome.i18n.getMessage(""sandboxProgressTitle"") +
                "" "" +
                progress.current}
            </div>
            <div className=""subtitle"">
              {chrome.i18n.getMessage(""sandboxProgressDescription"")}
            </div>
            {typeof contentState.openModal === ""function"" && (
              <div
                className=""button-stop""
                onClick={() => {
                  contentState.openModal(
                    chrome.i18n.getMessage(""havingIssuesModalTitle""),
                    chrome.i18n.getMessage(""havingIssuesModalDescription""),
                    chrome.i18n.getMessage(""restoreRecording""),
                    chrome.i18n.getMessage(""havingIssuesModalButton2""),
                    () => {
                      chrome.runtime.sendMessage({ type: ""restore-recording"" });
                      // chrome.runtime.sendMessage(
                      //   {
                      //     type: ""check-restore"",
                      //   },
                      //   (response) => {
                      //     if (response.restore) {
                      //       chrome.runtime.sendMessage({
                      //         type: ""indexed-db-download"",
                      //       });
                      //     } else {
                      //       alert(chrome.i18n.getMessage(""noRecordingFound""));
                      //     }
                      //   }
                      // );
                    },
                    () => {
                      chrome.runtime.sendMessage({ type: ""report-bug"" });
                    }
                  );
                }}
              >
                {chrome.i18n.getMessage(""havingIssuesButton"")}
              </div>
            )}
          </div>
          <HelpButton />
          <div className=""setupBackgroundSVG""></div>
        </div>
      )}
      <style>
        {`
				
				.wrap {
					overflow: hidden;
				}
				.setupBackgroundSVG {
					position: absolute;
					top: 0px;
					left: 0px;
					width: 100%;
					height: 100%;
					background: url(/assets/helper/pattern-svg.svg) repeat;
					background-size: 62px 23.5px;
					animation: moveBackground 138s linear infinite;
				}
				.button-s"
Sandbox\styles\edit\_Dropdown.module.scss,Excluded by file type,,0,
Sandbox\styles\edit\_EditorNav.module.scss,Excluded by file type,,0,
Sandbox\styles\edit\_Switch.module.scss,Excluded by file type,,0,
Sandbox\styles\edit\_Trimmer.module.scss,Excluded by file type,,0,
Sandbox\styles\edit\_TrimUI.module.scss,Excluded by file type,,0,
Sandbox\styles\edit\_VideoPlayer.scss,Excluded by file type,,0,
Sandbox\styles\edit\_Waveform.module.scss,Excluded by file type,,0,
Sandbox\styles\global\_app.scss,Excluded by file type,,0,
Sandbox\styles\global\_variables.scss,Excluded by file type,,0,
Sandbox\styles\player\_Content.module.scss,Excluded by file type,,0,
Sandbox\styles\player\_HelpButton.module.scss,Excluded by file type,,0,
Sandbox\styles\player\_Nav.module.scss,Excluded by file type,,0,
Sandbox\styles\player\_Player.module.scss,Excluded by file type,,0,
Sandbox\styles\player\_RightPanel.module.scss,Excluded by file type,,0,
Sandbox\styles\player\_ShareModal.module.scss,Excluded by file type,,0,
Sandbox\styles\player\_Title.module.scss,Excluded by file type,,0,
Sandbox\styles\plyr.css,Excluded by file type,,0,
Setup\index.html,Included,text/html,1257,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"" />
    <title>Screenity - First Steps</title>
    <style>
      @font-face {
        font-family: Satoshi-Light;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Light.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Medium;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Medium.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Satoshi-Bold;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/Satoshi-Bold.ttf)
          format(""truetype"");
        font-weight: normal;
        font-style: normal;
      }

      @font-face {
        font-family: Gloria-Hallelujah;
        src: url(chrome-extension://__MSG_@@extension_id__/assets/fonts/GloriaHallelujah-Regular.ttf)
          format(""truetype"");
      }
    </style>
  </head>

  <body>
    <div id=""app-container""></div>
  </body>
</html>
"
Setup\index.jsx,Included,application/octet-stream,257,"import React from ""react"";
import { render } from ""react-dom"";

import Setup from ""./Setup"";

// Render at the end of the body of any website
render(<Setup />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Setup\Setup.jsx,Truncated to 6000 bytes due to size > 6000,application/octet-stream,6931,"import React, { useEffect, useState } from ""react"";

const Setup = () => {
  const [setupComplete, setSetupComplete] = useState(false);

  useEffect(() => {
    // Inject content script
    const script = document.createElement(""script"");
    script.src = chrome.runtime.getURL(""contentScript.bundle.js"");
    script.async = true;
    document.body.appendChild(script);

    // Also inject CSS
    const style = document.createElement(""link"");
    style.rel = ""stylesheet"";
    style.type = ""text/css"";
    style.href = chrome.runtime.getURL(""assets/fonts/fonts.css"");
    document.body.appendChild(style);

    // Return
    return () => {
      document.body.removeChild(script);
      document.body.removeChild(style);
    };
  }, []);

  useEffect(() => {
    chrome.runtime.onMessage.addListener(function (
      request,
      sender,
      sendResponse
    ) {
      if (request.type === ""setup-complete"") {
        setSetupComplete(true);
      }
    });
  }, []);

  return (
    <div className=""setupBackground"">
      {!setupComplete && (
        <div className=""setupContainer"">
          <div className=""setupImage"">
            <img src={chrome.runtime.getURL(""assets/helper/pin.gif"")} />
          </div>
          <div className=""setupText"">
            <div className=""setupEmoji""></div>
            <div className=""setupTitle"">
              {chrome.i18n.getMessage(""setupTitle"")}
            </div>
            <div className=""setupDescription"">
              <div className=""setupStep"">
                {chrome.i18n.getMessage(""setupStep1Before"")}
                <span>
                  <img
                    src={chrome.runtime.getURL(""assets/helper/puzzle.svg"")}
                  />
                </span>
                {chrome.i18n.getMessage(""setupStep1After"")}
              </div>
              <div className=""setupStep"">
                {chrome.i18n.getMessage(""setupStep2Before"")}
                <span>
                  <img src={chrome.runtime.getURL(""assets/helper/pin.svg"")} />
                </span>{"" ""}
                {chrome.i18n.getMessage(""setupStep2After"")}
              </div>
              <div className=""setupStep"">
                {chrome.i18n.getMessage(""setupStep3Before"")}
                <span>
                  <img
                    src={chrome.runtime.getURL(
                      ""assets/helper/mini-screenity.png""
                    )}
                  />
                </span>
                {chrome.i18n.getMessage(""setupStep3After"")}
              </div>
            </div>
          </div>
        </div>
      )}
      {setupComplete && (
        <div className=""setupContainer center"">
          <div className=""setupText center"">
            <div className=""setupEmoji""></div>
            <div className=""setupTitle"">
              {chrome.i18n.getMessage(""setupCompleteTitle"")}
            </div>
            <div className=""setupDescription"">
              {chrome.i18n.getMessage(""setupCompleteDescription"")}
            </div>
          </div>
        </div>
      )}
      <img
        className=""setupLogo""
        src={chrome.runtime.getURL(""assets/logo-text.svg"")}
      />
      <style>
        {`
				body {
					overflow: hidden;
					margin: 0px;
					margin: 0;
	padding: 0;
	min-height: 100%;
		background-color: #F6F7FB!important;
		background: url('` +
          chrome.runtime.getURL(""assets/helper/pattern-svg.svg"") +
          `') repeat;
		background-size: 62px 23.5px;
		animation: moveBackground 138s linear infinite;
		transform: rotate(0deg);
				}

				.setupInfo {
					margin-top: 20px;
				}
				a {
					text-decoration: none!important;
					color: #4C7DE2;
				}
				
				@keyframes moveBackground {
					0% {
						background-position: 0 0;
					}
					100% {
						background-position: 100% 0;
					}
				}


				.setupLogo {
					position: absolute;
					bottom: 30px;
					left: 0px;
					right: 0px;
					margin: auto;
					width: 120px;
				}


				.setupBackground {
					height: 100vh;
					width: 100vw;
					display: flex;
					justify-content: center;
					align-items: center;
				}

				.setupContainer {
					position: absolute;
					top: 0px;
					left: 0px;
					right: 0px;
					bottom: 0px;
					margin: auto;
					z-index: 999;
					display: flex;
					justify-content: center;
					align-items: center;
					width: 60%;
					height: fit-content;
					background-color: #fff;
					border-radius: 30px;
					padding: 50px 50px;
					gap: 80px;
					font-family: 'Satoshi-Medium', sans-serif;
				}

				.setupImage {
					width: 70%;
					display: flex;
					justify-content: center;
					align-items: center;
				}

				.setupImage img {
					width: 100%;
					border-radius: 30px;
				}

				.setupText {
					width: 50%;
					display: flex;
					flex-direction: column;
					justify-content: left;
					align-items: left;
					text-align: left;
				}

				.setupEmoji {
					font-size: 20px;
					margin-bottom: 10px;
				}

				.setupTitle {
					font-size: 20px;
					font-weight: bold;
					margin-bottom: 10px;
					color: #29292F;
					font-family: 'Satoshi-Bold', sans-serif!important;
					letter-spacing: -0.5px;
				}

				.setupDescription {
					display: flex;
					flex-direction: column;
					justify-content: center;
					align-items: left;
					margin-top: 10px;
					color: #6E7684;
					font-size: 14px;
				}

				.setupStep {
					margin-bottom: 10px;
					vertical-align: middle;
				}

				.setupStep span {

					align-items: center;
					justify-content: center;
					text-align: center;
					width: 20px;
					height: 20px;
					padding: 2px;
					border-radius: 30px;
					display: inline-flex;
					vertical-align: middle;
					margin-left: 3px;
					margin-right: 3px;
					background-color: #F4F2F2;
				}

				.setupStep img {
					width: 100%;
					text-align: center;
					display: block;
				}

				.center {
					text-align: center!important;
				}
				.setupText.center {
					width: auto!important;
				}
				.setupContaine"
Waveform\index.html,Included,text/html,213,"<!DOCTYPE html>
<html lang=""en"">
  <head>
    <meta charset=""UTF-8"" />
    <title></title>
  </head>

  <body style=""margin: 0px;overflow: hidden;"">
    <div id=""app-container""></div>
  </body>
</html>
"
Waveform\index.jsx,Included,application/octet-stream,266,"import React from ""react"";
import { render } from ""react-dom"";

import Waveform from ""./Waveform"";

// Render at the end of the body of any website
render(<Waveform />, window.document.querySelector(""#app-container""));

if (module.hot) module.hot.accept();
"
Waveform\Waveform.jsx,Included,application/octet-stream,3862,"import React, { useEffect, useRef } from ""react"";

const Waveform = () => {
  const canvasRef = useRef(null);
  let audioContext;
  let analyser;
  let dataArray;
  let animationFrameId;
  let audioStream;

  useEffect(() => {
    const canvas = canvasRef.current;
    const canvasContext = canvas.getContext(""2d"");

    function initializeAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyser.maxDecibels = -60;
        dataArray = new Float32Array(analyser.fftSize);
        const source = audioContext.createMediaStreamDestination();
        analyser.connect(source);
        audioContext.resume();
        startVisualization();
      }
    }

    function startVisualization() {
      analyser.getFloatTimeDomainData(dataArray);
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasContext.beginPath();
      const sliceWidth = 0.9;
      const waveformHeight = canvas.height;
      const waveformOffset = (canvas.height - waveformHeight) / 2;
      let x = 0;
      let sum = 0;
      let count = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = (dataArray[i] + 1) / 2;
        sum += v;
        count++;
        if (count === 10) {
          const avg = sum / count;
          const y = avg * waveformHeight * 2 + waveformOffset;
          if (i === 0) {
            canvasContext.moveTo(x, y);
          } else {
            canvasContext.lineTo(x, y);
          }
          x += sliceWidth;
          sum = 0;
          count = 0;
        }
      }
      canvasContext.strokeStyle = ""#78C072"";
      canvasContext.stroke();

      animationFrameId = requestAnimationFrame(startVisualization);
    }

    function startVisualization() {
      analyser.getFloatTimeDomainData(dataArray);
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasContext.beginPath();
      const sliceWidth = 0.7;
      const waveformHeight = canvas.height * 0.9;
      const waveformOffset = (canvas.height - waveformHeight) / 2;
      let x = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = (dataArray[i] + 1) / 2;
        const y = v * waveformHeight + waveformOffset;
        if (i === 0) {
          canvasContext.moveTo(x, y);
        } else {
          canvasContext.lineTo(x, y);
        }
        x += sliceWidth;
      }
      canvasContext.strokeStyle = ""#78C072"";
      canvasContext.lineWidth = 1.5;
      canvasContext.stroke();

      animationFrameId = requestAnimationFrame(startVisualization);
    }

    function stopVisualization() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    }

    function startAudioCapture() {
      navigator.mediaDevices
        .getUserMedia({ audio: true, video: false })
        .then((stream) => {
          audioStream = stream;
          initializeAudioContext();
          const audioSource = audioContext.createMediaStreamSource(audioStream);
          audioSource.connect(analyser);
        })
        .catch((error) => {
          console.error(""Error capturing audio:"", error);
        });
    }

    function stopAudioCapture() {
      if (audioStream) {
        const tracks = audioStream.getTracks();
        tracks.forEach((track) => track.stop());
        audioStream = null;
        stopVisualization();
      }
    }

    startAudioCapture();

    return () => {
      stopAudioCapture();
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      width=""324""
      height=""30""
      style={{ background: ""#f5f6fa"" }}
    />
  );
};

export default Waveform;
"
