File: ai\ai.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 6647 bytes
Content:
import frappe

from raven.ai.handler import stream_response
from raven.ai.openai_client import (
	code_interpreter_file_types,
	file_search_file_types,
	get_open_ai_client,
)


def handle_bot_dm(message, bot):
	"""
	 Function to handle direct messages to the bot.

	We need to start a new thread with the message and create a new conversation in OpenAI
	"""

	client = get_open_ai_client()

	# If the message is a poll, send a message to the user that we don't support polls for AI yet

	if message.message_type == "Poll":
		bot.send_message(
			channel_id=message.channel_id,
			text="Sorry, I don't support polls yet. Please send a text message or file.",
		)
		return

	if message.message_type in ["File", "Image"]:

		if message.message_type == "File" and not check_if_bot_has_file_search(bot, message.channel_id):
			return

		# If the file has an "fid" query parameter, we need to remove that from the file_url
		if "fid" in message.file:
			file_url = message.file.split("?fid=")[0]
		else:
			file_url = message.file

		# Upload the file to OpenAI
		file = create_file_in_openai(file_url, message.message_type, client)

		content, attachments = get_content_attachment_for_file(message.message_type, file.id, file_url)

		ai_thread = client.beta.threads.create(
			messages=[
				{
					"role": "user",
					"content": content,
					"metadata": {"user": message.owner, "message": message.name},
					"attachments": attachments,
				}
			],
			metadata={
				"bot": bot.name,
				"channel": message.channel_id,
				"user": message.owner,
				"message": message.name,
			},
		)

	else:
		ai_thread = client.beta.threads.create(
			messages=[
				{
					"role": "user",
					"content": message.content,
					"metadata": {"user": message.owner, "message": message.name},
				}
			],
			metadata={
				"bot": bot.name,
				"channel": message.channel_id,
				"user": message.owner,
				"message": message.name,
			},
		)

	thread_channel = frappe.get_doc(
		{
			"doctype": "Raven Channel",
			"channel_name": message.name,
			"type": "Private",
			"is_thread": 1,
			"is_ai_thread": 1,
			"is_dm_thread": 1,
			"openai_thread_id": ai_thread.id,
			"thread_bot": bot.name,
		}
	).insert()

	# Update the message to mark it as a thread
	message.is_thread = 1
	message.save()
	# nosemgrep We need to commit here since the response will be streamed, and hence might take a while
	frappe.db.commit()

	frappe.publish_realtime(
		"ai_event",
		{
			"text": "Raven AI is thinking...",
			"channel_id": thread_channel.name,
			"bot": bot.name,
		},
		doctype="Raven Channel",
		docname=thread_channel.name,
		after_commit=True,
	)

	stream_response(ai_thread_id=ai_thread.id, bot=bot, channel_id=thread_channel.name)


def handle_ai_thread_message(message, channel):
	"""
	Function to handle messages in an AI thread

	When a new message is sent, we need to send it to the OpenAI API and then stream the response
	"""

	client = get_open_ai_client()

	bot = frappe.get_doc("Raven Bot", channel.thread_bot)

	if message.message_type in ["File", "Image"]:

		file_url = message.file
		if "fid" in file_url:
			file_url = file_url.split("?fid=")[0]

		if message.message_type == "File" and not check_if_bot_has_file_search(bot, channel.name):
			return
		# Upload the file to OpenAI
		try:
			file = create_file_in_openai(file_url, message.message_type, client)
		except Exception as e:
			frappe.log_error("Raven AI Error", frappe.get_traceback())
			bot.send_message(
				channel_id=channel.name,
				text="Sorry, there was an error in processing your file. Please try again.<br/><br/>Error: "
				+ str(e),
			)
			return

		content, attachments = get_content_attachment_for_file(message.message_type, file.id, file_url)

		try:
			client.beta.threads.messages.create(
				thread_id=channel.openai_thread_id,
				role="user",
				content=content,
				metadata={"user": message.owner, "message": message.name},
				attachments=attachments,
			)
		except Exception as e:
			frappe.log_error("Raven AI Error", frappe.get_traceback())
			bot.send_message(
				channel_id=channel.name,
				text="Sorry, there was an error in processing your file. Please try again.<br/><br/>Error: "
				+ str(e),
			)
			return

	else:

		client.beta.threads.messages.create(
			thread_id=channel.openai_thread_id,
			role="user",
			content=message.content,
			metadata={"user": message.owner, "message": message.name},
		)

	frappe.publish_realtime(
		"ai_event",
		{
			"text": "Raven AI is thinking...",
			"channel_id": channel.name,
			"bot": bot.name,
		},
		doctype="Raven Channel",
		docname=channel.name,
	)

	stream_response(ai_thread_id=channel.openai_thread_id, bot=bot, channel_id=channel.name)


def check_if_bot_has_file_search(bot, channel_id):
	"""
	Checks of bot has file search. If not, send a message to the user. If yes, return True
	"""

	if not bot.enable_file_search:
		bot.send_message(
			channel_id=channel_id,
			text="Sorry, your bot does not support file search. Please enable it and try again.",
		)
		return False

	return True


def create_file_in_openai(file_url: str, message_type: str, client):
	"""
	Function to create a file in OpenAI

	We need to upload the file to OpenAI and return the file ID
	"""

	file_doc = frappe.get_doc("File", {"file_url": file_url})
	file_path = file_doc.get_full_path()

	file = client.files.create(
		file=open(file_path, "rb"), purpose="assistants" if message_type == "File" else "vision"
	)

	return file


def get_content_attachment_for_file(message_type: str, file_id: str, file_url: str):

	attachments = None

	if message_type == "File":
		content = f"Uploaded a file. URL of the file is '{file_url}'."

		file_extension = file_url.split(".")[-1].lower()

		if file_extension == "pdf":
			content += (
				" The file is a PDF. If it's not machine readable, you can extract the text via images."
			)

		attachments = []

		if file_extension in code_interpreter_file_types:
			attachments.append(
				{
					"file_id": file_id,
					"tools": [{"type": 
--------------------------------------------------------------------------------

File: ai\functions.py
Comments: Included
Mime Type: text/x-python
Size: 5947 bytes
Content:
import frappe
from frappe import _, client


def get_document(doctype: str, document_id: str):
	"""
	Get a document from the database
	"""
	# Use the frappe.client.get method to get the document with permissions (both read and field level read)
	return client.get(doctype, name=document_id)


def get_documents(doctype: str, document_ids: list):
	"""
	Get documents from the database
	"""
	docs = []
	for document_id in document_ids:
		# Use the frappe.client.get method to get the document with permissions applied
		docs.append(client.get(doctype, name=document_id))
	return docs


def create_document(doctype: str, data: dict, function=None):
	"""
	Create a document in the database
	"""
	if function:
		# Get any default values
		for param in function.parameters:
			if param.default_value:
				# Check if this value was not to be asked by the AI
				if param.do_not_ask_ai:
					data[param.fieldname] = param.default_value

				# Check if the value was not provided
				if not data.get(param.fieldname):
					data[param.fieldname] = param.default_value

	doc = frappe.get_doc({"doctype": doctype, **data})
	doc.insert()
	return {"document_id": doc.name, "message": "Document created", "doctype": doctype}


def create_documents(doctype: str, data: list, function=None):
	"""
	Create documents in the database
	"""
	docs = []
	for item in data:
		docs.append(create_document(doctype, item, function).get("document_id"))

	return {"documents": docs, "message": "Documents created", "doctype": doctype}


def update_document(doctype: str, document_id: str, data: dict, function=None):
	"""
	Update a document in the database
	"""
	if function:
		# Get any default values
		for param in function.parameters:
			if param.default_value:
				# Check if this value was not to be asked by the AI
				if param.do_not_ask_ai:
					data[param.fieldname] = param.default_value

				# Check if the value was not provided
				if not data.get(param.fieldname):
					data[param.fieldname] = param.default_value

	doc = frappe.get_doc(doctype, document_id)
	doc.update(data)
	doc.save()
	return {"document_id": doc.name, "message": "Document updated", "doctype": doctype}


def update_documents(doctype: str, data: dict, function=None):
	"""
	Update documents in the database
	"""
	updated_docs = []
	for document in data:
		document_without_id = document.copy()
		document_id = document_without_id.pop("document_id")
		updated_docs.append(
			update_document(doctype, document_id, document_without_id, function).get("document_id")
		)

	return {"document_ids": updated_docs, "message": "Documents updated", "doctype": doctype}


def delete_document(doctype: str, document_id: str):
	"""
	Delete a document from the database
	"""
	frappe.delete_doc(doctype, document_id)
	return {"document_id": document_id, "message": "Document deleted", "doctype": doctype}


def delete_documents(doctype: str, document_ids: list):
	"""
	Delete documents from the database
	"""
	for document_id in document_ids:
		frappe.delete_doc(doctype, document_id)
	return {"document_ids": document_ids, "message": "Documents deleted", "doctype": doctype}


def submit_document(doctype: str, document_id: str):
	"""
	Submit a document in the database
	"""
	doc = frappe.get_doc(doctype, document_id)
	doc.submit()
	return {
		"document_id": document_id,
		"message": f"{doctype} {document_id} submitted",
		"doctype": doctype,
	}


def cancel_document(doctype: str, document_id: str):
	"""
	Cancel a document in the database
	"""
	doc = frappe.get_doc(doctype, document_id)
	doc.cancel()
	return {
		"document_id": document_id,
		"message": f"{doctype} {document_id} cancelled",
		"doctype": doctype,
	}


def get_amended_document_id(doctype: str, document_id: str):
	"""
	Get the amended document for a given document
	"""
	amended_doc = frappe.db.exists(doctype, {"amended_from": document_id})
	if amended_doc:
		return amended_doc
	else:
		return {"message": f"{doctype} {document_id} is not amended"}


def get_amended_document(doctype: str, document_id: str):
	"""
	Get the amended document for a given document
	"""
	amended_doc = frappe.db.exists(doctype, {"amended_from": document_id})
	if amended_doc:
		return client.get(doctype, name=document_id)
	else:
		return {"message": f"{doctype} {document_id} is not amended", "doctype": doctype}


def attach_file_to_document(doctype: str, document_id: str, file_path: str):
	"""
	Attach a file to a document in the database
	"""
	if not frappe.db.exists(doctype, document_id):
		return {
			"document_id": document_id,
			"message": f"{doctype} with ID {document_id} not found",
			"doctype": doctype,
		}

	file = frappe.get_doc("File", {"file_url": file_path})

	if not file:
		frappe.throw(_("File not found"))

	newFile = frappe.get_doc(
		{
			"doctype": "File",
			"file_url": file_path,
			"attached_to_doctype": doctype,
			"attached_to_name": document_id,
			"folder": file.folder,
			"file_name": file.file_name,
			"is_private": file.is_private,
		}
	)
	newFile.insert()

	return {"document_id": document_id, "message": "File attached", "file_id": newFile.name}


def get_list(doctype: str, filters: dict = None, fields: list = None, limit: int = 20):
	"""
	Get a list of documents from the database
	"""
	if filters is None:
		filters = {}

	if fields is None:
		fields = ["*"]

	else:
		meta = frappe.get_meta(doctype)
		filtered_fields = ["name as document_id"]
		if "title" in fields:
			filtered_fields.append(meta.get_title_field())

		for field in fields:
			if meta.has_field(field) and field not in filtered_fields:
				filtered_fields.append(field)

	# Use the frappe.get_list method to get the list of documents
	return frappe.get_list(doctype, filters=filters, fields=filtered_fields, limit=limit)

--------------------------------------------------------------------------------

File: ai\handler.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 12627 bytes
Content:
import json

import frappe
from openai import AssistantEventHandler
from openai.types.beta.threads import Text
from openai.types.beta.threads.runs import RunStep
from typing_extensions import override

from raven.ai.functions import (
	attach_file_to_document,
	cancel_document,
	create_document,
	create_documents,
	delete_document,
	delete_documents,
	get_amended_document,
	get_document,
	get_documents,
	get_list,
	submit_document,
	update_document,
	update_documents,
)
from raven.ai.openai_client import get_open_ai_client


def stream_response(ai_thread_id: str, bot, channel_id: str):

	client = get_open_ai_client()

	assistant_id = bot.openai_assistant_id

	docs_updated = []

	class EventHandler(AssistantEventHandler):
		@override
		def on_run_step_done(self, run_step: RunStep) -> None:
			details = run_step.step_details
			if details.type == "tool_calls":
				for tool in details.tool_calls:
					if tool.type == "code_interpreter":
						self.publish_event("Running code...")
					if tool.type == "file_search":
						self.publish_event("Searching file contents...")
			else:
				self.publish_event("Raven AI is thinking...")

		@override
		def on_text_done(self, text: Text):
			link_doctype = None
			link_document = None
			if len(docs_updated) == 1:
				link_doctype = docs_updated[0]["doctype"]
				link_document = docs_updated[0]["document_id"]

			file_urls = []

			# Check if there are any annotations with files
			annotations = text.annotations
			for annotation in annotations:
				if annotation.type == "file_path":
					file_path = annotation.file_path
					file_id = file_path.file_id
					file_name = annotation.text.split("/")[-1]
					file_content = client.files.content(file_id)

					file_doc = frappe.get_doc(
						{
							"doctype": "File",
							"file_name": file_name,
							"content": file_content.read(),
							"is_private": True,
						}
					)
					file_doc.insert()
					file_urls.append(
						{
							"url": file_doc.file_url,
							"text": annotation.text,
						}
					)

			if file_urls:
				# If there are amy file URLs, replace the content with the URL and send the file as a separate message
				for file_url in file_urls:
					text.value = text.value.replace(file_url["text"], file_url["url"])

				bot.send_message(
					channel_id=channel_id,
					text=text.value,
					link_doctype=link_doctype,
					link_document=link_document,
					markdown=True,
				)

				for file_url in file_urls:
					bot.send_message(channel_id=channel_id, file=file_url["url"])

			else:
				bot.send_message(
					channel_id=channel_id,
					text=text.value,
					link_doctype=link_doctype,
					link_document=link_document,
					markdown=True,
				)

			frappe.publish_realtime(
				"ai_event_clear",
				{
					"channel_id": channel_id,
				},
				doctype="Raven Channel",
				docname=channel_id,
				after_commit=True,
			)

		@override
		def on_event(self, event):
			# Handle image and file outputs
			if event.event == "thread.message.delta":
				if hasattr(event.data, "delta") and hasattr(event.data.delta, "content"):
					for content in event.data.delta.content:
						if content.type == "image_file":
							# Handle image file
							file_id = content.image_file.file_id
							file = client.files.retrieve(file_id)
							file_content = client.files.content(file_id)

							# Save the file content
							file_doc = frappe.new_doc("File")
							file_doc.file_name = file.filename + ".png"
							file_doc.content = file_content.read()
							file_doc.is_private = True
							file_doc.insert()

							bot.send_message(channel_id=channel_id, file=file_doc.file_url)

			# Handle tool calls
			elif event.event == "thread.run.requires_action":
				run_id = event.data.id
				self.handle_requires_action(event.data, run_id)

		def publish_event(self, text):
			frappe.publish_realtime(
				"ai_event",
				{
					"text": text,
					"channel_id": channel_id,
					"bot": bot.name,
				},
				doctype="Raven Channel",
				docname=channel_id,
			)

		def handle_requires_action(self, data, run_id):
			tool_outputs = []

			for tool in data.required_action.submit_tool_outputs.tool_calls:

				function = None

				try:
					function = frappe.get_cached_doc("Raven AI Function", tool.function.name)
				except frappe.DoesNotExistError:
					tool_outputs.append({"tool_call_id": tool.id, "output": "Function not found"})
					return

				# When calling the function, we need to pass the arguments as named params/json
				# Args is a dictionary of the form {"param_name": "param_value"}

				try:
					args = json.loads(tool.function.arguments)

					# Check the type of function and then call it accordingly

					function_output = {}

					if function.type == "Custom Function":
						function_name = frappe.get_attr(function.function_path)

						if bot.allow_bot_to_write_documents:
							# We can commit to the database if writes are allowed
							if function.pass_parameters_as_json:
								function_output = function_name(args)
							else:
								function_output = function_name(**args)
						else:
							# We need to savepoint and then rollback
							frappe.db.savepoint(run_id + "_" + tool.id)
							if function.pass_parameters_as_json:
								function_output = function_name(args)
							else:
								function_output = function_name(**args)
							frappe.db.rollback(save_point=run_id + "_" + tool.id)

					if function.type == "Get Document":
						self.publish_event(
							"Fetching {} {}...".format(function.reference_doctype, args.get("document_id"))
						)
						function_output = get_document(function.reference_doctype, **args)

					if function.type == "Get Multiple Documents":
						self.publish_event(f"Fetching multiple {function.reference_doctype}s...")
						function_output = get_documents(function.reference_doctype, **args)

					if function.type == "Submit Document":
						self.publish_event(f"Submitting {function.reference_doctype} {args.get('document_id')}...")
						function_output = submit_document(fu
--------------------------------------------------------------------------------

File: ai\openai_client.py
Comments: Included
Mime Type: text/x-python
Size: 1104 bytes
Content:
import frappe
from frappe import _
from openai import OpenAI


def get_open_ai_client():
	"""
	Get the OpenAI client
	"""

	raven_settings = frappe.get_cached_doc("Raven Settings")

	if not raven_settings.enable_ai_integration:
		frappe.throw(_("AI Integration is not enabled"))

	openai_api_key = raven_settings.get_password("openai_api_key")
	openai_organisation_id = (raven_settings.openai_organisation_id or "").strip()
	openai_project_id = (raven_settings.openai_project_id or "").strip()

	client_args = {"api_key": openai_api_key.strip(), "organization": openai_organisation_id}
	if openai_project_id:
		client_args["project"] = openai_project_id

	return OpenAI(**client_args)


def get_openai_models():
	"""
	Get the available OpenAI models
	"""
	client = get_open_ai_client()
	return client.models.list()


code_interpreter_file_types = [
	"pdf",
	"csv",
	"docx",
	"doc",
	"xlsx",
	"pptx",
	"txt",
	"png",
	"jpg",
	"jpeg",
	"md",
	"json",
	"html",
]

file_search_file_types = ["pdf", "csv", "doc", "docx", "json", "txt", "md", "html", "pptx"]

--------------------------------------------------------------------------------

File: api\ai_features.py
Comments: Included
Mime Type: text/x-python
Size: 1818 bytes
Content:
import frappe
import openai

from raven.ai.handler import get_variables_for_instructions


@frappe.whitelist()
def get_instruction_preview(instruction):
	"""
	Function to get the rendered instructions for the bot
	"""
	frappe.has_permission(doctype="Raven Bot", ptype="write", throw=True)

	instructions = frappe.render_template(instruction, get_variables_for_instructions())
	return instructions


@frappe.whitelist()
def get_saved_prompts(bot: str = None):
	"""
	API to get the saved prompt for a user/bot/global
	"""
	or_filters = [["is_global", "=", 1], ["owner", "=", frappe.session.user]]

	prompts = frappe.get_list(
		"Raven Bot AI Prompt", or_filters=or_filters, fields=["name", "prompt", "is_global", "raven_bot"]
	)

	# Order by ones with the given bot
	prompts = sorted(prompts, key=lambda x: x.get("raven_bot") == bot, reverse=True)

	return prompts


@frappe.whitelist()
def get_open_ai_version():
	"""
	API to get the version of the OpenAI Python client
	"""
	frappe.has_permission(doctype="Raven Bot", ptype="read", throw=True)
	return openai.__version__


@frappe.whitelist()
def get_openai_available_models():
	"""
	API to get the available OpenAI models for assistants
	"""
	frappe.has_permission(doctype="Raven Bot", ptype="read", throw=True)
	from raven.ai.openai_client import get_openai_models

	models = get_openai_models()

	valid_prefixes = ["gpt-4", "gpt-3.5", "o1", "o3-mini"]

	# Model should not contain these words
	invalid_models = ["realtime", "transcribe", "search", "audio"]

	compatible_models = []

	for model in models:
		if any(model.id.startswith(prefix) for prefix in valid_prefixes):
			if not any(word in model.id for word in invalid_models):
				compatible_models.append(model.id)

	return compatible_models

--------------------------------------------------------------------------------

File: api\chat.py
Comments: Included
Mime Type: text/x-python
Size: 2339 bytes
Content:
import frappe
from frappe import _

from raven.api.raven_users import get_list
from raven.utils import get_channel_members as get_channel_members_util
from raven.utils import get_workspace_members


@frappe.whitelist(methods=["GET"])
def get_channel_members(channel_id):
	# Check if the user has permission to view the channel
	# fetch all channel members
	# get member details from user table, such as name, full_name, user_image, first_name

	frappe.has_permission("Raven Channel", doc=channel_id, throw=True)

	member_object = {}

	# This is an array
	all_users = get_list()

	# This is a dictionary
	channel_members = get_channel_members_util(channel_id)

	channel_type = frappe.get_cached_value("Raven Channel", channel_id, "type")

	if channel_type == "Open":
		workspace = frappe.get_cached_value("Raven Channel", channel_id, "workspace")
		workspace_members = get_workspace_members(workspace)

		# All workspace members are members of an open channel - merge the workspace members with channel members
		for workspace_member in workspace_members:
			channel_member = channel_members.get(workspace_member, {})
			user_obj = next((u for u in all_users if u.name == workspace_member), None)

			member_object[user_obj.name] = {
				"name": user_obj.name,
				"full_name": user_obj.full_name,
				"user_image": user_obj.user_image,
				"first_name": user_obj.first_name,
				"type": user_obj.type,
				"availability_status": user_obj.availability_status,
				"is_admin": channel_member.get("is_admin", 0),
				"allow_notifications": channel_member.get("allow_notifications", 1),
				"channel_member_name": channel_member.get("name", None),
			}

	else:
		for member in channel_members:
			channel_member = channel_members[member]
			user_obj = next((u for u in all_users if u.name == member), None)

			if user_obj:
				member_object[user_obj.name] = {
					"name": user_obj.name,
					"full_name": user_obj.full_name,
					"user_image": user_obj.user_image,
					"first_name": user_obj.first_name,
					"type": user_obj.type,
					"availability_status": user_obj.availability_status,
					"is_admin": channel_member.is_admin,
					"allow_notifications": channel_member.allow_notifications,
					"channel_member_name": channel_member.name,
				}

	return member_object

--------------------------------------------------------------------------------

File: api\chat_stream.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 8972 bytes
Content:
import datetime

import frappe
from frappe import _
from frappe.query_builder import Order

from raven.utils import track_channel_visit


@frappe.whitelist()
def get_messages(channel_id: str, limit: int = 20, base_message: str | None = None):
	"""
	API to get list of messages for a channel, ordered by creation date (newest first)

	"""

	# Check permission for channel access
	if not frappe.has_permission(doctype="Raven Channel", doc=channel_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this channel"), frappe.PermissionError)

	# Fetch messages for the channel
	if base_message:
		return get_messages_around_base(channel_id, base_message)

	# Cannot use `get_all` as it does not apply the `order_by` clause to multiple fields
	message = frappe.qb.DocType("Raven Message")

	messages = (
		frappe.qb.from_(message)
		.select(
			message.name,
			message.owner,
			message.creation,
			message.modified,
			message.text,
			message.file,
			message.message_type,
			message.message_reactions,
			message.is_reply,
			message.linked_message,
			message._liked_by,
			message.channel_id,
			message.thumbnail_width,
			message.thumbnail_height,
			message.file_thumbnail,
			message.link_doctype,
			message.link_document,
			message.replied_message_details,
			message.content,
			message.is_edited,
			message.is_forwarded,
			message.poll_id,
			message.is_bot_message,
			message.bot,
			message.hide_link_preview,
			message.is_thread,
			message.blurhash,
		)
		.where(message.channel_id == channel_id)
		.orderby(message.creation, order=Order.desc)
		.orderby(message.name, order=Order.desc)
		.limit(limit)
		.run(as_dict=True)
	)

	has_old_messages = False

	# Check if older messages are available
	if len(messages) == limit:
		# Check if there are more messages available
		older_message = frappe.db.get_all(
			"Raven Message",
			pluck="name",
			filters={"channel_id": channel_id, "creation": ("<", messages[-1].creation)},
			order_by="creation desc, name desc",
			limit=1,
		)

		if len(older_message) > 0:
			has_old_messages = True

	track_channel_visit(channel_id=channel_id, commit=True)
	return {
		"messages": messages,
		"has_old_messages": has_old_messages,
		"has_new_messages": False,
	}


def get_messages_around_base(channel_id: str, base_message: str):
	"""
	Get 10 messages before base message and 10 messages after
	"""
	# Fetch older messages for the channel
	from_timestamp = frappe.get_cached_value("Raven Message", base_message, "creation")

	# TODO: Optimize this to use a complex SQL query to fetch around the main message
	older_messages = fetch_older_messages(channel_id, base_message, from_timestamp, 10)
	newer_messages = fetch_newer_messages(
		channel_id, base_message, from_timestamp, 10, include_from_message=True
	)

	combined_messages = newer_messages.get("messages", []) + older_messages.get("messages", [])

	return {
		**older_messages,
		**newer_messages,
		"messages": combined_messages,
		"from_timestamp": from_timestamp,
	}


@frappe.whitelist()
def get_older_messages(channel_id: str, from_message: str, limit: int = 20):
	"""
	API to get older messages for a channel, ordered by creation date (newest first)

	Function is split into two to avoid duplicate perm check and timestamp check
	"""

	# Check permission for channel access
	if not frappe.has_permission(doctype="Raven Channel", doc=channel_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this channel"), frappe.PermissionError)
	# Fetch older messages for the channel
	from_timestamp = frappe.get_cached_value("Raven Message", from_message, "creation")

	return fetch_older_messages(channel_id, from_message, from_timestamp, limit)


def fetch_older_messages(
	channel_id: str, from_message: str, from_timestamp: datetime.datetime, limit: int = 20
):
	# Cannot use `get_all` as it does not apply the `order_by` clause to multiple fields
	message = frappe.qb.DocType("Raven Message")

	messages = (
		frappe.qb.from_(message)
		.select(
			message.name,
			message.owner,
			message.creation,
			message.modified,
			message.text,
			message.file,
			message.message_type,
			message.message_reactions,
			message.is_reply,
			message.linked_message,
			message._liked_by,
			message.channel_id,
			message.thumbnail_width,
			message.thumbnail_height,
			message.file_thumbnail,
			message.link_doctype,
			message.link_document,
			message.replied_message_details,
			message.content,
			message.is_edited,
			message.is_forwarded,
			message.poll_id,
			message.is_bot_message,
			message.bot,
			message.hide_link_preview,
			message.is_thread,
			message.blurhash,
		)
		.where(message.channel_id == channel_id)
		.where(
			(message.creation < from_timestamp)
			| ((message.creation == from_timestamp) & (message.name < from_message))
		)
		.orderby(message.creation, order=Order.desc)
		.orderby(message.name, order=Order.desc)
		.limit(limit)
		.run(as_dict=True)
	)

	has_old_messages = False

	# Check if older messages are available
	if len(messages) == limit:
		# Check if there are more messages available
		older_message = frappe.db.get_all(
			"Raven Message",
			pluck="name",
			filters={
				"channel_id": channel_id,
				"creation": ("<=", messages[-1].creation),
				"name": ["!=", messages[-1].name],
			},
			order_by="creation desc, name desc",
			limit=1,
		)

		if len(older_message) > 0:
			has_old_messages = True

	return {"messages": messages, "has_old_messages": has_old_messages}


@frappe.whitelist()
def get_newer_messages(channel_id: str, from_message: str, limit: int = 20):
	"""
	API to get older messages for a channel, ordered by creation date (newest first)
	"""

	# Check permission for channel access
	if not frappe.has_permission(doctype="Raven Channel", doc=channel_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this channel"), frappe.PermissionError)

	# Fetch older messages for the channel
	from_timestamp = frappe.get_cached_value("Raven Message", from_
--------------------------------------------------------------------------------

File: api\document_link.py
Comments: Included
Mime Type: text/x-python
Size: 3855 bytes
Content:
import frappe
from frappe.custom.doctype.property_setter.property_setter import delete_property_setter
from frappe.desk.utils import slug
from frappe.model import no_value_fields, table_fields
from frappe.utils import get_url


def get_new_app_document_links(doctype, docname):
	"""
	New apps like Frappe CRM etc have a different link.
	"""
	# TODO: Add the other app routes here
	routes = {
		"CRM Lead": "/crm/leads/",
	}

	return routes.get(doctype) + docname if doctype in routes else None


@frappe.whitelist(methods=["GET"])
def get(doctype, docname, with_site_url=True):

	document_link_override = frappe.get_hooks("raven_document_link_override")
	if document_link_override and len(document_link_override) > 0:

		# Loop over all the hooks and return the first non-None value
		for hook in document_link_override:
			link = frappe.get_attr(hook)(doctype, docname)
			if link:
				if with_site_url:
					return get_url() + link
				return link

	if with_site_url:
		return frappe.utils.get_url() + f"/app/{slug(doctype)}/{docname}"

	return f"/app/{slug(doctype)}/{docname}"


@frappe.whitelist(methods=["GET"])
def get_preview_data(doctype, docname):
	preview_fields = []
	meta = frappe.get_meta(doctype)

	preview_fields = [
		field.fieldname
		for field in meta.fields
		if field.in_preview
		and field.fieldtype not in no_value_fields
		and field.fieldtype not in table_fields
	]

	# no preview fields defined, build list from mandatory fields
	if not preview_fields:
		preview_fields = [
			field.fieldname for field in meta.fields if field.reqd and field.fieldtype not in table_fields
		]

	title_field = meta.get_title_field()
	image_field = meta.image_field

	preview_fields.append(title_field)
	preview_fields.append(image_field)
	preview_fields.append("name")

	preview_data = frappe.get_list(doctype, filters={"name": docname}, fields=preview_fields, limit=1)

	if not preview_data:
		return

	preview_data = preview_data[0]

	formatted_preview_data = {
		"preview_image": preview_data.get(image_field),
		"preview_title": preview_data.get(title_field),
		"id": preview_data.get("name"),
		"raven_document_link": get(doctype, docname),
	}

	for key, val in preview_data.items():
		if val and meta.has_field(key) and key not in [image_field, title_field, "name"]:
			formatted_preview_data[meta.get_field(key).label] = frappe.format(
				val,
				meta.get_field(key).fieldtype,
				translated=True,
			)

	return formatted_preview_data


@frappe.whitelist(methods=["POST"])
def update_preview_fields(doctype: str, fields: list[str]):

	meta = frappe.get_meta(doctype)

	existing_preview_fields = [
		field.fieldname
		for field in meta.fields
		if field.in_preview
		and field.fieldtype not in no_value_fields
		and field.fieldtype not in table_fields
	]
	fields_to_remove = set(existing_preview_fields) - set(fields)

	for field in fields_to_remove:
		delete_property_setter(doctype, field_name=field, property="in_preview")

	for field in fields:
		meta_df = meta.get_field(field)
		if not meta_df:
			continue

		delete_property_setter(doctype, field_name=field, property="in_preview")

		# Check if a property setter needs to be created for this field - if the field was already in preview, we don't need to do anything
		is_in_preview_by_default = frappe.db.get_value(
			"DocField", {"parent": doctype, "fieldname": field}, "in_preview"
		)

		if is_in_preview_by_default:
			# No need to create a property setter
			continue

		# create a new property setter
		frappe.make_property_setter(
			{
				"doctype": doctype,
				"doctype_or_field": "DocField",
				"fieldname": field,
				"property": "in_preview",
				"value": "1",
				"property_type": "Check",
			},
			is_system_generated=False,
		)

--------------------------------------------------------------------------------

File: api\events.py
Comments: Included
Mime Type: text/x-python
Size: 2683 bytes
Content:
import frappe
from frappe import _

from raven.utils import get_channel_members


@frappe.whitelist()
def create_event(
	channel: str, subject: str, duration: str, google_calendar: str = None, description: str = None
):
	"""
	Create a new event with Google Meet enabled.
	Once created, send a message to the channel with the event details.
	"""
	# Create a new event
	if isinstance(duration, str):
		duration = int(duration)

	if not google_calendar:
		google_calendar = frappe.get_value(
			"Google Calendar", {"enable": 1, "user": frappe.session.user}, "name"
		)

	if not google_calendar:
		frappe.throw(_("Google Calendar not found for the current user"))

	event = frappe.get_doc(
		{
			"doctype": "Event",
			"subject": subject,
			"starts_on": frappe.utils.now_datetime(),
			"ends_on": frappe.utils.add_to_date(frappe.utils.now_datetime(), minutes=duration),
			"description": description,
			"send_reminder": 0,
		}
	)

	event.save()

	add_participants(event, channel)

	event = update_meeting_details(event, google_calendar)

	# Send a message to the channel
	doc = frappe.get_doc(
		{
			"doctype": "Raven Message",
			"channel_id": channel,
			"text": '<p>To join the meeting, click on the link below: <a href="{0}">{0}</a></p>'.format(
				event.google_meet_link
			),
			"message_type": "Text",
			"hide_link_preview": 1,
			"link_doctype": "Event",
			"link_document": event.name,
		}
	)
	doc.insert()

	return event


def add_participants(event, channel):
	"""
	Add participants to the event and send a message to the channel with the event details.
	"""
	participants = [frappe.session.user]
	channel_type = frappe.get_cached_value("Raven Channel", channel, "type")

	if channel_type == "Open":
		# Only add the current user
		pass

	else:

		members_map = get_channel_members(channel)

		members = list(members_map.keys())

		for member in members:
			if member not in participants:
				participants.append(member)

	for participant in participants:
		contact_name = frappe.db.exists("Contact", {"user": participant})
		if contact_name:
			frappe.get_doc(
				{
					"doctype": "Event Participants",
					"reference_doctype": "Contact",
					"reference_docname": contact_name,
					"email": participant,
					"parent": event.name,
					"parenttype": "Event",
					"parentfield": "event_participants",
				}
			).save()


def update_meeting_details(event, calendar):
	event.reload()
	event.update(
		{
			"sync_with_google_calendar": 1,
			"add_video_conferencing": 1,
			"google_calendar": calendar,
		}
	)
	event.save()
	event.reload()

	return event

--------------------------------------------------------------------------------

File: api\login.py
Comments: Included
Mime Type: text/x-python
Size: 2068 bytes
Content:
import frappe
import frappe.utils
from frappe import _
from frappe.twofactor import two_factor_is_enabled
from frappe.utils.html_utils import get_icon_html
from frappe.utils.oauth import get_oauth2_authorize_url, get_oauth_keys
from frappe.utils.password import get_decrypted_password

no_cache = True


@frappe.whitelist(allow_guest=True)
def get_context():

	redirect_to = frappe.local.request.args.get("redirect-to")
	context = {"provider_logins": []}
	providers = frappe.get_all(
		"Social Login Key",
		filters={"enable_social_login": 1},
		fields=["name", "client_id", "base_url", "provider_name", "icon", "redirect_url"],
		order_by="name",
	)

	for provider in providers:
		client_secret = get_decrypted_password("Social Login Key", provider.name, "client_secret")
		if not client_secret:
			continue

		icon = {"html": "", "src": "", "alt": ""}
		if provider.icon:
			if provider.provider_name == "Custom":
				icon["html"] = get_icon_html(provider.icon, small=True)
			else:
				icon["src"] = provider.icon
				icon["alt"] = provider.provider_name

		if provider.client_id and provider.base_url and get_oauth_keys(provider.name):

			context["provider_logins"].append(
				{
					"name": provider.name,
					"provider_name": provider.provider_name,
					"auth_url": get_oauth2_authorize_url(provider.name, redirect_to),
					"redirect_to": provider.redirect_url,
					"icon": icon,
				}
			)
			context["social_login"] = True

	login_label = [_("Email")]
	if frappe.utils.cint(frappe.get_system_settings("allow_login_using_mobile_number")):
		login_label.append(_("Mobile"))

	if frappe.utils.cint(frappe.get_system_settings("allow_login_using_user_name")):
		login_label.append(_("Username"))

	context["login_label"] = f" {_('/')} ".join(login_label)

	context["login_with_email_link"] = frappe.get_system_settings("login_with_email_link")
	context["two_factor_is_enabled"] = two_factor_is_enabled()
	context["disable_signup"] = frappe.get_website_settings("disable_signup")

	return context

--------------------------------------------------------------------------------

File: api\mentions.py
Comments: Included
Mime Type: text/x-python
Size: 3158 bytes
Content:
import frappe
from frappe.query_builder import Order
from frappe.query_builder.functions import Count


@frappe.whitelist(methods=["POST"])
def get_mentions(limit: int = 10, start: int = 0):
	"""
	Get the messages where the current user is mentioned - ordered by creation date
	Also update the last mention viewed date if the start is 0
	"""

	# Max number of mentions that we will return is 100
	if start >= 100:
		return []

	mention = frappe.qb.DocType("Raven Mention")
	message = frappe.qb.DocType("Raven Message")
	channel = frappe.qb.DocType("Raven Channel")
	channel_member = frappe.qb.DocType("Raven Channel Member")

	query = (
		frappe.qb.from_(mention)
		.select(
			message.name,
			message.channel_id,
			channel.type.as_("channel_type"),
			channel.channel_name,
			channel.workspace,
			channel.is_thread,
			channel.is_direct_message,
			message.creation,
			message.message_type,
			message.owner,
			message.text,
		)
		.left_join(message)
		.on(mention.parent == message.name)
		.left_join(channel)
		.on(message.channel_id == channel.name)
		.left_join(channel_member)
		.on(
			(channel.name == channel_member.channel_id) & (channel_member.user_id == frappe.session.user)
		)
		.where(mention.user == frappe.session.user)
		.where(message.owner != frappe.session.user)
		.where(channel_member.user_id == frappe.session.user)
		.orderby(message.creation, order=Order.desc)
		.limit(limit)
		.offset(start)
	)

	result = query.run(as_dict=True)

	if start == 0:
		frappe.db.set_value(
			"Raven User",
			{"user": frappe.session.user},
			"last_mention_viewed_on",
			frappe.utils.get_datetime(),
			update_modified=False,
		)
	return result


@frappe.whitelist(methods=["GET"])
def get_unread_mention_count():
	"""
	Get the number of mentions for the current user since the last mention viewed date
	"""

	last_mention_viewed_date = frappe.db.get_value(
		"Raven User", {"user": frappe.session.user}, "last_mention_viewed_on"
	)

	if not last_mention_viewed_date:
		# Date when the feature was launched
		last_mention_viewed_date = "2025-02-28 00:00:00"

	mention = frappe.qb.DocType("Raven Mention")
	message = frappe.qb.DocType("Raven Message")
	channel = frappe.qb.DocType("Raven Channel")
	channel_member = frappe.qb.DocType("Raven Channel Member")

	# Join mention with message and message with channel.
	# Only fetch count for where the user is a member of the channel

	query = (
		frappe.qb.from_(mention)
		.select(Count(mention.name).as_("mention_count"))
		.left_join(message)
		.on(mention.parent == message.name)
		.left_join(channel)
		.on(message.channel_id == channel.name)
		.left_join(channel_member)
		.on(
			(channel.name == channel_member.channel_id) & (channel_member.user_id == frappe.session.user)
		)
		.where(mention.user == frappe.session.user)
		.where(channel_member.user_id == frappe.session.user)
		.where(message.creation > last_mention_viewed_date)
		.where(message.owner != frappe.session.user)
	)
	result = query.run(as_dict=True)
	if result:
		return result[0].mention_count
	else:
		return 0

--------------------------------------------------------------------------------

File: api\message_actions.py
Comments: Included
Mime Type: text/x-python
Size: 3228 bytes
Content:
import frappe
from frappe import _


@frappe.whitelist(methods=["GET"])
def get_action_defaults(action_id: str, message_id: str):
	"""
	Get the default values for a message action
	"""

	frappe.has_permission(doctype="Raven Message", doc=message_id, ptype="read", throw=True)
	action = frappe.get_doc("Raven Message Action", action_id)
	message = frappe.get_doc("Raven Message", message_id)

	# Loop through the fields in the action and get the default values from the message
	defaults = {}

	channel_doc = frappe.get_doc("Raven Channel", message.channel_id)
	workspace_id = channel_doc.workspace

	if not workspace_id:
		# Get the last workspace that this user has access to
		workspace_id = frappe.get_last_doc("Raven Workspace", {"user_id": frappe.session.user}).name

	url = frappe.utils.get_url(f"/raven/{workspace_id}")

	if channel_doc.is_thread:
		message_url = url + f"/threads/{message.channel_id}?message_id={message.name}"
	else:
		message_url = url + f"/{message.channel_id}?message_id={message.name}"

	for field in action.fields:
		if not field.default_value:
			continue

		if field.default_value_type == "Static":
			defaults[field.fieldname] = field.default_value

		if field.default_value_type == "Message Field":
			if field.default_value == "message_url":
				val = message_url
			elif field.default_value == "workspace_id":
				val = workspace_id
			else:
				val = message.get(field.default_value)
			if val:
				defaults[field.fieldname] = val

		if field.default_value_type == "Jinja":

			val = frappe.render_template(
				field.default_value, {"message": {"message_url": message_url, **message.as_dict()}}
			)

			if val:
				defaults[field.fieldname] = val

	return defaults


@frappe.whitelist(methods=["POST"])
def execute_action(action_id: str, message_id: str, values: dict):
	"""
	Execute a message action
	"""

	frappe.has_permission(doctype="Raven Message", doc=message_id, ptype="read", throw=True)
	action = frappe.get_doc("Raven Message Action", action_id)
	message = frappe.get_doc("Raven Message", message_id)

	if action.action == "Create Document":
		doc = frappe.get_doc({"doctype": action.document_type, **values})
		doc.insert()

		# Link message to the document if no link exists already
		if not message.link_doctype and not message.link_document:
			message.flags.editing_metadata = True
			message.link_doctype = doc.doctype
			message.link_document = doc.name
			# Ignore permissions to allow editing of the document
			message.save(ignore_permissions=True)

		return {"message": "Document created successfully", "document": doc.name, "doctype": doc.doctype}

	if action.action == "Custom Function":
		# Call the function with the values
		function_name = frappe.get_attr(action.custom_function_path)

		if function_name:
			return function_name(**values)
		else:
			frappe.throw(_("Function {0} not found").format(action.custom_function_path))

	if action.action == "Server Script":
		script = frappe.get_doc("Server Script", action.server_script)
		if script.disabled:
			frappe.throw(_("Server Script {0} is disabled").format(action.server_script))
		script.execute_method()

--------------------------------------------------------------------------------

File: api\notification.py
Comments: Included
Mime Type: text/x-python
Size: 2644 bytes
Content:
from urllib.parse import urlparse

import frappe
from frappe import _
from frappe.frappeclient import FrappeClient


@frappe.whitelist()
def are_push_notifications_enabled() -> bool:
	try:
		return frappe.db.get_single_value("Push Notification Settings", "enable_push_notification_relay")
	except frappe.DoesNotExistError:
		# push notifications are not supported in the current framework version
		return False


@frappe.whitelist(methods=["POST"])
def register_site_on_raven_cloud() -> None:
	"""
	Register the site on Raven Cloud
	"""
	frappe.only_for("System Manager")
	raven_settings = frappe.get_single("Raven Settings")

	if raven_settings.push_notification_service == "Raven":

		client = FrappeClient(
			url=raven_settings.push_notification_server_url,
			api_key=raven_settings.push_notification_api_key,
			api_secret=raven_settings.get_password("push_notification_api_secret"),
		)

		response = client.post_api(
			"raven_cloud.api.notification.register_site",
			params={"site_name": urlparse(frappe.utils.get_url()).hostname},
		)

		raven_settings.config = response.get("config")
		raven_settings.vapid_public_key = response.get("vapid_public_key")
		raven_settings.save()
	else:
		frappe.throw(_("Push notification service is not set to Raven Cloud."))


@frappe.whitelist(methods=["POST"])
def toggle_push_notification_for_channel(member: str, allow_notifications: 0 | 1) -> None:
	if are_push_notifications_enabled():
		member_doc = frappe.get_doc("Raven Channel Member", member)
		if member_doc:
			member_doc.allow_notifications = allow_notifications
			member_doc.save()

			return member_doc
	else:
		frappe.throw(_("Push notifications are not supported in the current framework version"))


@frappe.whitelist(methods=["POST"])
def subscribe(fcm_token: str, environment: str, device_information: str | None = None) -> None:
	"""
	Add the FCM token to the database
	"""

	# Check if the FCM token already exists
	if frappe.db.exists("Raven Push Token", {"fcm_token": fcm_token, "user": frappe.session.user}):
		return

	# Add the FCM token to the database
	frappe.get_doc(
		{
			"doctype": "Raven Push Token",
			"fcm_token": fcm_token,
			"user": frappe.session.user,
			"environment": environment,
			"device_information": device_information,
		}
	).insert()

	return "Subscribed"


@frappe.whitelist(methods=["POST"])
def unsubscribe(fcm_token: str) -> None:
	"""
	Remove the FCM token from the database
	"""

	frappe.db.delete("Raven Push Token", {"fcm_token": fcm_token, "user": frappe.session.user})

	return "Unsubscribed"

--------------------------------------------------------------------------------

File: api\preview_links.py
Comments: Included
Mime Type: text/x-python
Size: 2694 bytes
Content:
import json
import re

import frappe
from linkpreview import Link, LinkGrabber, LinkPreview, link_preview


@frappe.whitelist(methods=["GET"])
def get_preview_link(urls):

	data = {}
	empty_data = {
		"title": "",
		"description": "",
		"image": "",
		"force_title": "",
		"absolute_image": "",
		"site_name": "",
	}
	message_links = []

	if urls and urls != "[]":
		urls = json.loads(urls)

		for url in urls:
			data = frappe.cache().get_value(url)
			if data == None:
				# Don't try to preview insecure links like IP addresses
				# If URL is an IP address, or starts with mailto or tel, don't preview. Just return empty data
				if (
					url.startswith("mailto")
					or url.startswith("tel")
					or re.match(r"http://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.*", url)
					or re.match(r"https://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.*", url)
					or re.match(r"http://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", url)
					or re.match(r"https://\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", url)
				):
					data = empty_data
				else:
					preview = None
					try:
						# If this is a Twitter/X URL, then we need to fetch the preview from the Twitter API
						# This is because the linkpreview library doesn't support Twitter previews with the default bot
						if "twitter.com" in url or "x.com" in url:
							grabber = LinkGrabber()
							content, url_fetched = grabber.get_content(url, headers="imessagebot")
							link = Link(url_fetched, content)
							preview = LinkPreview(link)
						else:
							preview = link_preview(url)
					except Exception:
						preview = None
						pass
					if preview == None:
						data = empty_data
					else:

						# Description might have emojis in them, which comes in with special characters like copyright etc
						# TODO: We need to replace these special characters with the actual emojis

						data = {
							"title": preview.title,
							"description": preview.description,
							"image": preview.image,
							"force_title": preview.force_title,
							"absolute_image": preview.absolute_image,
							"site_name": preview.site_name,
						}
					frappe.cache().set_value(url, data)
			message_links.append(data)

	return message_links


@frappe.whitelist(methods=["POST"])
def hide_link_preview(message_id: str):
	"""
	Remove the preview from the message
	"""
	message = frappe.get_doc("Raven Message", message_id)

	if not message.has_permission():
		frappe.throw("You do not have permission to hide link previews on this message.")

	message.flags.ignore_permissions = True
	message.hide_link_preview = 1
	message.flags.editing_metadata = True
	message.save()

--------------------------------------------------------------------------------

File: api\raven_channel.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 7168 bytes
Content:
import frappe
from frappe import _
from frappe.query_builder import Order

from raven.api.raven_users import get_current_raven_user
from raven.utils import get_channel_members, is_channel_member, track_channel_visit


@frappe.whitelist()
def get_all_channels(hide_archived=True):
	"""
	Fetches all channels where current user is a member - both channels and DMs
	To be used on the web app.
	"""

	if hide_archived == "false":
		hide_archived = False

	# 1. Get "channels" - public, open, private, and DMs
	channels = get_channel_list(hide_archived)

	# 3. For every channel, we need to fetch the peer's User ID (if it's a DM)
	parsed_channels = []
	for channel in channels:
		parsed_channel = {
			**channel,
			"peer_user_id": get_peer_user_id(
				channel.get("name"),
				channel.get("is_direct_message"),
				channel.get("is_self_message"),
			),
		}

		parsed_channels.append(parsed_channel)

	channel_list = [channel for channel in parsed_channels if not channel.get("is_direct_message")]
	dm_list = [channel for channel in parsed_channels if channel.get("is_direct_message")]

	return {"channels": channel_list, "dm_channels": dm_list}


def get_channel_list(hide_archived=False):
	"""
	get List of all channels where current user is a member (all includes public, private, open, and DM channels)
	"""
	channel = frappe.qb.DocType("Raven Channel")
	channel_member = frappe.qb.DocType("Raven Channel Member")

	workspace_member = frappe.qb.DocType("Raven Workspace Member")

	query = (
		frappe.qb.from_(channel)
		.select(
			channel.name,
			channel.channel_name,
			channel.type,
			channel.channel_description,
			channel.is_archived,
			channel.is_direct_message,
			channel.is_self_message,
			channel.creation,
			channel.owner,
			channel.last_message_timestamp,
			channel.last_message_details,
			channel.pinned_messages_string,
			channel.workspace,
			channel_member.name.as_("member_id"),
		)
		.left_join(channel_member)
		.on(
			(channel.name == channel_member.channel_id) & (channel_member.user_id == frappe.session.user)
		)
		.left_join(workspace_member)
		.on(
			(channel.workspace == workspace_member.workspace)
			& (workspace_member.user == frappe.session.user)
		)
		.where(
			((channel.is_direct_message == 1) & (channel_member.user_id == frappe.session.user))
			| (
				(workspace_member.user == frappe.session.user)
				& ((channel.type != "Private") | (channel_member.user_id == frappe.session.user))
			)
		)
		.where(channel.is_thread == 0)
	)

	if hide_archived:
		query = query.where(channel.is_archived == 0)

	query = query.orderby(channel.last_message_timestamp, order=Order.desc)

	return query.run(as_dict=True)


@frappe.whitelist()
def get_channels(hide_archived=False):
	channels = get_channel_list(hide_archived)
	for channel in channels:
		peer_user_id = get_peer_user_id(
			channel.get("name"), channel.get("is_direct_message"), channel.get("is_self_message")
		)
		channel["peer_user_id"] = peer_user_id
		if peer_user_id:
			user_full_name = frappe.get_cached_value("User", peer_user_id, "full_name")
			channel["full_name"] = user_full_name
	return channels


def get_peer_user(channel_id: str, is_direct_message: int, is_self_message: bool = False) -> dict:
	"""
	For a given channel, fetches the peer's member object
	"""
	if is_direct_message == 0:
		return None
	if is_self_message:
		return {
			"user_id": frappe.session.user,
		}

	members = get_channel_members(channel_id)

	for member in members:
		if member != frappe.session.user:
			return members[member]

	return None


def get_peer_user_id(
	channel_id: str, is_direct_message: int, is_self_message: bool = False
) -> str:
	"""
	For a given channel, fetches the user id of the peer
	"""
	peer_user = get_peer_user(channel_id, is_direct_message, is_self_message)
	if peer_user:
		return peer_user.get("user_id")
	return None


@frappe.whitelist(methods=["POST"])
def create_direct_message_channel(user_id):
	"""
	Creates a direct message channel between current user and the user with user_id
	The user_id can be the peer or the user themself
	1. Check if a channel already exists between the two users
	2. If not, create a new channel
	3. Check if the user_id is the current user and set is_self_message accordingly
	"""
	# TODO: this logic might break if the user_id changes
	channel_name = frappe.db.get_value(
		"Raven Channel",
		filters={
			"is_direct_message": 1,
			"channel_name": [
				"in",
				[frappe.session.user + " _ " + user_id, user_id + " _ " + frappe.session.user],
			],
		},
		fieldname="name",
	)
	if channel_name:
		return channel_name
	# create direct message channel with user and current user
	else:
		channel = frappe.get_doc(
			{
				"doctype": "Raven Channel",
				"channel_name": frappe.session.user + " _ " + user_id,
				"is_direct_message": 1,
				"is_self_message": frappe.session.user == user_id,
			}
		)
		channel.insert()
		return channel.name


@frappe.whitelist(methods=["POST"])
def toggle_pinned_channel(channel_id):
	"""
	Toggles the pinned status of the channel
	"""
	raven_user = get_current_raven_user()
	pinned_channels = raven_user.pinned_channels or []

	is_pinned = False
	for pin in pinned_channels:
		if pin.channel_id == channel_id:
			raven_user.remove(pin)
			is_pinned = True
			break

	if not is_pinned:
		raven_user.append("pinned_channels", {"channel_id": channel_id})

	raven_user.save()

	return raven_user


@frappe.whitelist()
def leave_channel(channel_id):
	"""
	Leave a channel
	"""
	members = frappe.get_all(
		"Raven Channel Member",
		filters={"channel_id": channel_id, "user_id": frappe.session.user},
	)

	for member in members:
		frappe.delete_doc("Raven Channel Member", member.name)

	return "Ok"


@frappe.whitelist()
def toggle_pin_message(channel_id, message_id):
	"""
	Toggle pin/unpin a message in a channel.
	"""
	channel = frappe.get_doc("Raven Channel", channel_id)

	# Check if the user is a member of the channel
	if not is_channel_member(channel_id):
		frappe.throw(_("You are not a member of 
--------------------------------------------------------------------------------

File: api\raven_channel_member.py
Comments: Included
Mime Type: text/x-python
Size: 1449 bytes
Content:
import frappe
from frappe import _

from raven.utils import delete_channel_members_cache, get_channel_member, track_channel_visit


@frappe.whitelist()
def remove_channel_member(user_id, channel_id):
	# Get raven channel member name where user_id and channel_id match
	member = get_channel_member(channel_id, user_id)
	# Delete raven channel member
	if member:
		frappe.delete_doc("Raven Channel Member", member["name"])
	else:
		frappe.throw(_("User is not a member of this channel"))

	return True


@frappe.whitelist(methods=["POST"])
def track_visit(channel_id):
	"""
	Track the last visit of the user to the channel.
	This is usually called when the user exits the channel (unmounts the component) after loading the latest messages in it.
	"""
	track_channel_visit(channel_id=channel_id, commit=True)
	return True


@frappe.whitelist(methods=["POST"])
def add_channel_members(channel_id: str, members: list[str]):
	"""
	Add members to a channel
	"""

	# Since this is a bulk operation, we need to disable cache invalidation (will be handled manually) and ignore permissions (since we already have permission to add members)

	for member in members:
		member_doc = frappe.get_doc(
			{"doctype": "Raven Channel Member", "channel_id": channel_id, "user_id": member}
		)
		member_doc.flags.ignore_cache_invalidation = True
		member_doc.insert()

	delete_channel_members_cache(channel_id)
	return True

--------------------------------------------------------------------------------

File: api\raven_message.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 14803 bytes
Content:
import json
from datetime import timedelta

import frappe
from frappe import _
from frappe.query_builder import JoinType, Order
from frappe.query_builder.functions import Coalesce, Count

from raven.api.raven_channel import create_direct_message_channel, get_peer_user_id
from raven.utils import get_channel_member, is_channel_member, track_channel_visit


@frappe.whitelist(methods=["POST"])
def send_message(
	channel_id, text, is_reply=False, linked_message=None, json_content=None, send_silently=False
):
	if is_reply:
		doc = frappe.get_doc(
			{
				"doctype": "Raven Message",
				"channel_id": channel_id,
				"text": text,
				"message_type": "Text",
				"is_reply": is_reply,
				"linked_message": linked_message,
				"json": json_content,
			}
		)
	else:
		doc = frappe.get_doc(
			{
				"doctype": "Raven Message",
				"channel_id": channel_id,
				"text": text,
				"message_type": "Text",
				"json": json_content,
			}
		)

	if send_silently:
		doc.flags.send_silently = True

	doc.insert()
	return doc


@frappe.whitelist()
def fetch_recent_files(channel_id):
	"""
	Fetches recently sent files in a channel
	Check if the user has permission to view the channel
	"""
	if not frappe.has_permission("Raven Channel", doc=channel_id):
		frappe.throw(_("You don't have permission to view this channel"), frappe.PermissionError)
	files = frappe.db.get_all(
		"Raven Message",
		filters={"channel_id": channel_id, "message_type": ["in", ["Image", "File"]]},
		fields=["name", "file", "owner", "creation", "message_type"],
		order_by="creation desc",
		limit_page_length=10,
	)

	return files


def get_messages(channel_id):

	messages = frappe.db.get_all(
		"Raven Message",
		filters={"channel_id": channel_id},
		fields=[
			"name",
			"owner",
			"creation",
			"modified",
			"text",
			"file",
			"message_type",
			"message_reactions",
			"is_reply",
			"linked_message",
			"_liked_by",
			"channel_id",
			"thumbnail_width",
			"thumbnail_height",
			"file_thumbnail",
			"link_doctype",
			"link_document",
			"replied_message_details",
			"content",
			"is_edited",
			"is_thread",
			"is_forwarded",
		],
		order_by="creation asc",
	)

	return messages


@frappe.whitelist()
def save_message(message_id, add=False):
	"""
	Save the message as a bookmark
	"""
	from frappe.desk.like import toggle_like

	toggle_like("Raven Message", message_id, add)

	liked_by = frappe.db.get_value("Raven Message", message_id, "_liked_by")

	frappe.publish_realtime(
		"message_saved",
		{
			"message_id": message_id,
			"liked_by": liked_by,
		},
		user=frappe.session.user,
	)

	return "message saved"


@frappe.whitelist()
def get_pinned_messages(channel_id):

	# check if the user has permission to view the channel
	frappe.has_permission("Raven Channel", doc=channel_id, ptype="read", throw=True)

	pinnedMessagesString = frappe.db.get_value("Raven Channel", channel_id, "pinned_messages_string")
	pinnedMessages = pinnedMessagesString.split("\n") if pinnedMessagesString else []

	return frappe.db.get_all(
		"Raven Message",
		filters={"name": ["in", pinnedMessages]},
		fields=[
			"name",
			"owner",
			"creation",
			"bot",
			"text",
			"file",
			"message_type",
			"message_reactions",
			"_liked_by",
			"channel_id",
			"thumbnail_width",
			"thumbnail_height",
			"file_thumbnail",
			"link_doctype",
			"link_document",
			"replied_message_details",
			"hide_link_preview",
			"is_bot_message",
			"content",
			"is_edited",
			"is_thread",
			"is_forwarded",
		],
		order_by="creation asc",
	)


@frappe.whitelist()
def get_saved_messages():
	"""
	Fetches list of all messages liked by the user
	Check if the user has permission to view the message
	"""

	raven_message = frappe.qb.DocType("Raven Message")
	raven_channel = frappe.qb.DocType("Raven Channel")
	raven_channel_member = frappe.qb.DocType("Raven Channel Member")

	query = (
		frappe.qb.from_(raven_message)
		.join(raven_channel, JoinType.left)
		.on(raven_message.channel_id == raven_channel.name)
		.join(raven_channel_member, JoinType.left)
		.on(raven_channel.name == raven_channel_member.channel_id)
		.select(
			raven_message.name,
			raven_message.owner,
			raven_message.creation,
			raven_message.text,
			raven_message.channel_id,
			raven_message.file,
			raven_message.message_type,
			raven_message.message_reactions,
			raven_message._liked_by,
			raven_channel.workspace,
			raven_message.thumbnail_width,
			raven_message.thumbnail_height,
			raven_message.is_bot_message,
			raven_message.bot,
		)
		.where(raven_message._liked_by.like("%" + frappe.session.user + "%"))
		.where(
			(raven_channel.type.isin(["Open", "Public"]))
			| (raven_channel_member.user_id == frappe.session.user)
		)
		.orderby(raven_message.creation, order=Order.asc)
		.distinct()
	)  # Add DISTINCT keyword to retrieve only unique messages

	messages = query.run(as_dict=True)

	return messages


def parse_messages(messages):

	messages_with_date_header = []
	previous_message = None

	for i in range(len(messages)):
		message = messages[i]
		is_continuation = (
			previous_message
			and message["owner"] == previous_message["owner"]
			and (message["creation"] - previous_message["creation"]) < timedelta(minutes=2)
		)
		message["is_continuation"] = int(bool(is_continuation))

		if i == 0 or message["creation"].date() != previous_message["creation"].date():
			messages_with_date_header.append({"block_type": "date", "data": message["creation"].date()})

		messages_with_date_header.append({"block_type": "message", "data": message})

		previous_message = message

	return messages_with_date_header


def check_permission(channel_id):
	if frappe.get_cached_value("Raven Channel", channel_id, "type") == "Private":
		if is_channel_member(channel_id):
			pass
		elif frappe.session.user == "Administrator":
			pass
		else:
			frappe.throw(_("You don't have permission to view this channel"), frappe.PermissionError)


@frappe.whitelist()
def get_messages_with_dates(channel_id):
	check_permission(channel_id)
	mess
--------------------------------------------------------------------------------

File: api\raven_mobile.py
Comments: Included
Mime Type: text/x-python
Size: 2060 bytes
Content:
import frappe
from frappe.utils.change_log import get_versions


@frappe.whitelist(allow_guest=True)
def get_client_id():
	"""
	API to fetch the client ID, site name (for socket), App name (for display), Raven version and logo. These will be stored on the device
	"""
	app_name = frappe.get_website_settings("app_name") or frappe.get_system_settings("app_name")

	if not app_name or app_name == "Frappe":
		app_name = "Raven"

	all_app_versions = get_versions()

	app_versions = {k: v["version"] for k, v in all_app_versions.items()}
	raven_version = app_versions["raven"]
	frappe_version = app_versions["frappe"]

	return {
		"client_id": frappe.db.get_single_value("Raven Settings", "oauth_client"),
		"system_timezone": frappe.get_system_settings("time_zone"),
		"app_name": app_name,
		"sitename": frappe.local.site,
		"raven_version": raven_version,
		"frappe_version": frappe_version,
		"logo": frappe.db.get_single_value("Navbar Settings", "app_logo")
		or "/assets/raven/raven-logo.png",
	}


# TODO: API to fetch boot information for the app - settings like GIF API key etc.


@frappe.whitelist(methods=["POST"])
def create_oauth_client():
	"""
	API to create an OAuth Client for the mobile app.
	"""
	raven_settings = frappe.get_doc("Raven Settings")
	existing_oauth_client = raven_settings.oauth_client

	if not existing_oauth_client:
		oauth_client = frappe.new_doc("OAuth Client")
	else:
		oauth_client = frappe.get_doc("OAuth Client", existing_oauth_client)

	oauth_client.app_name = "Raven Mobile"
	oauth_client.scopes = "all openid"
	oauth_client.redirect_uris = "raven.thecommit.company:"
	oauth_client.default_redirect_uri = "raven.thecommit.company:"
	oauth_client.grant_type = "Authorization Code"
	oauth_client.response_type = "Code"
	oauth_client.allowed_roles = []
	oauth_client.append("allowed_roles", {"role": "Raven User"})
	oauth_client.save()
	raven_settings.oauth_client = oauth_client.name
	raven_settings.save()
	return {"message": "OAuth Client created successfully"}

--------------------------------------------------------------------------------

File: api\raven_poll.py
Comments: Included
Mime Type: text/x-python
Size: 5061 bytes
Content:
import frappe
from frappe import _


@frappe.whitelist(methods=["POST"])
def create_poll(
	channel_id: str,
	question: str,
	options: list,
	is_multi_choice: bool = None,
	is_anonymous: bool = None,
) -> str:
	"""
	Create a new poll in the Raven Poll doctype.
	"""
	# Check if the current user has access to the channel to create a poll.
	if not frappe.has_permission(doctype="Raven Channel", doc=channel_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this channel"), frappe.PermissionError)

	poll = frappe.get_doc(
		{
			"doctype": "Raven Poll",
			"question": question,
			"is_multi_choice": is_multi_choice,
			"is_anonymous": is_anonymous,
			"channel_id": channel_id,
		}
	)

	for option in options:
		poll.append("options", option)

	poll.insert()

	# Poll message content is the poll question and options separated by a newline. (This would help with the searchability of the poll)
	poll_message_content = f"{question}\n"

	for index, option in enumerate(options):
		poll_message_content += f"{index + 1}. {option['option']}\n"

	# Send a message to the channel with type "poll" and the poll_id.
	message = frappe.get_doc(
		{
			"doctype": "Raven Message",
			"channel_id": channel_id,
			"text": "",
			"content": poll_message_content,
			"message_type": "Poll",
			"poll_id": poll.name,
		}
	)
	message.insert()

	return poll.name


@frappe.whitelist()
def get_poll(message_id):
	"""
	Get the poll data from the Raven Poll doctype.
	(Including the poll options, the number of votes for each option and the total number of votes.)
	"""

	# Check if the current user has access to the message.
	if not frappe.has_permission(doctype="Raven Message", doc=message_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this message"), frappe.PermissionError)

	poll_id = frappe.get_cached_value("Raven Message", message_id, "poll_id")

	poll = frappe.get_cached_doc("Raven Poll", poll_id)

	# Check if the current user has already voted in the poll, if so, return the poll with the user's vote.
	current_user_vote = frappe.get_all(
		"Raven Poll Vote",
		filters={"poll_id": poll_id, "user_id": frappe.session.user},
		fields=["option"],
	)

	if current_user_vote:
		poll.current_user_vote = current_user_vote

	return {"poll": poll, "current_user_votes": current_user_vote}


@frappe.whitelist(methods=["POST"])
def add_vote(message_id, option_id):

	# Check if the current user has access to the message.
	if not frappe.has_permission(doctype="Raven Message", doc=message_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this message"), frappe.PermissionError)

	poll_id = frappe.get_cached_value("Raven Message", message_id, "poll_id")
	is_poll_multi_choice = frappe.get_cached_value("Raven Poll", poll_id, "is_multi_choice")

	if is_poll_multi_choice:
		for option in option_id:
			frappe.get_doc(
				{
					"doctype": "Raven Poll Vote",
					"poll_id": poll_id,
					"option": option,
					"user_id": frappe.session.user,
				}
			).insert()
	else:
		frappe.get_doc(
			{
				"doctype": "Raven Poll Vote",
				"poll_id": poll_id,
				"option": option_id,
				"user_id": frappe.session.user,
			}
		).insert()

	return "Vote added successfully."


@frappe.whitelist(methods=["POST"])
def retract_vote(poll_id):
	# delete all votes by the user for the poll (this takes care of the case where the user has voted for multiple options in the same poll)
	user = frappe.session.user
	votes = frappe.get_all(
		"Raven Poll Vote", filters={"poll_id": poll_id, "user_id": user}, fields=["name"]
	)
	if not votes:
		frappe.throw(_("You have not voted for any option in this poll."))
	else:
		for vote in votes:
			frappe.delete_doc("Raven Poll Vote", vote.name)


@frappe.whitelist()
def get_all_votes(poll_id):

	# Check if the current user has access to the poll
	if not frappe.has_permission(doctype="Raven Poll", doc=poll_id, ptype="read"):
		frappe.throw(_("You do not have permission to access this poll"), frappe.PermissionError)

	poll_doc = frappe.get_cached_doc("Raven Poll", poll_id)

	if poll_doc.is_anonymous:
		frappe.throw(
			_("This poll is anonymous. You do not have permission to access the votes."),
			frappe.PermissionError,
		)
	else:
		# Get all votes for this poll
		votes = frappe.get_all(
			"Raven Poll Vote", filters={"poll_id": poll_id}, fields=["name", "option", "user_id"]
		)

		# Initialize results dictionary
		results = {
			option.name: {"users": [], "count": option.votes} for option in poll_doc.options if option.votes
		}

		# Process votes
		for vote in votes:
			option = vote["option"]
			results[option]["users"].append(vote["user_id"])

		# Calculate total votes
		total_votes = sum(result["count"] for result in results.values())

		# Calculate percentages
		for result in results.values():
			result["percentage"] = (result["count"] / total_votes) * 100

		return results

--------------------------------------------------------------------------------

File: api\raven_users.py
Comments: Included
Mime Type: text/x-python
Size: 4119 bytes
Content:
import json

import frappe
from frappe import _
from frappe.utils.caching import redis_cache


@frappe.whitelist(methods=["GET"])
def get_current_raven_user():
	"""
	Fetches the current user's Raven User profile
	"""

	# Check if the user is a Raven User and has he "Raven User" role
	# If not, then throw an error
	if not frappe.has_permission("Raven User"):
		frappe.throw(
			_(
				"You do not have a <b>Raven User</b> role. Please contact your administrator to add your user profile as a <b>Raven User</b>."
			),
			title=_("Insufficient permissions. Please contact your administrator."),
		)

	return frappe.get_cached_doc("Raven User", {"user": frappe.session.user})


@frappe.whitelist(methods=["POST"])
def update_raven_user(**args):
	"""
	Updates the current user's Raven User profile
	"""

	frappe.get_doc("Raven User", {"user": frappe.session.user}).update(args).save()


@frappe.whitelist()
@frappe.read_only()
def get_list():
	"""
	Fetches list of all users who have the role: Raven User
	"""

	# Check if the user is a Raven User and has he "Raven User" role
	# If not, then throw an error
	if not frappe.has_permission("Raven User"):
		frappe.throw(
			_(
				"You do not have a <b>Raven User</b> role. Please contact your administrator to add your user profile as a <b>Raven User</b>."
			),
			title=_("Insufficient permissions. Please contact your administrator."),
		)

	# Get users is cached since this won't change frequently
	return get_users()


@redis_cache()
def get_users():
	users = frappe.db.get_all(
		"Raven User",
		fields=[
			"full_name",
			"user_image",
			"name",
			"first_name",
			"enabled",
			"type",
			"availability_status",
			"custom_status",
		],
		order_by="full_name",
	)
	return users


@frappe.whitelist()
def is_user_on_leave(user: str):
	"""
	If the user is on leave, return True
	"""
	# Check if FrappeHR is installed
	if not "hrms" in frappe.get_installed_apps():
		return False

	employee = frappe.db.exists("Employee", {"user_id": user})

	if employee:
		# Check if attendance today is marked as "On Leave"
		attendance = frappe.db.exists(
			"Attendance",
			{
				"employee": employee,
				"status": "On Leave",
				"attendance_date": frappe.utils.today(),
				"docstatus": 1,
			},
		)

		if attendance:
			return True

	return False


@frappe.whitelist(methods=["POST"])
def add_users_to_raven(users):

	if isinstance(users, str):
		users = json.loads(users)

	failed_users = []
	success_users = []

	for user in users:
		user_doc = frappe.get_doc("User", user)

		if user_doc.role_profile_name:
			failed_users.append(user_doc)

		elif hasattr(user_doc, "role_profiles") and len(user_doc.role_profiles) > 0:
			failed_users.append(user_doc)
		else:
			user_doc.append("roles", {"role": "Raven User"})
			user_doc.save()
			success_users.append(user_doc)

	return {"success_users": success_users, "failed_users": failed_users}


@frappe.whitelist(methods=["POST"])
def invite_user(email: str, first_name: str = None, last_name: str = None):
	"""
	Invites a user to Raven. If the user exists in Frappe, they are added to Raven.
	"""

	existing_user = frappe.db.exists("User", {"email": email})

	if existing_user:
		user_doc = frappe.get_doc("User", existing_user)
		if user_doc.role_profile_name:
			frappe.throw(_("User has a role profile set. Please set the role to Raven User manually."))

		elif hasattr(user_doc, "role_profiles") and len(user_doc.role_profiles) > 0:
			frappe.throw(_("User has a role profile set. Please set the role to Raven User manually."))

		user_doc.append("roles", {"role": "Raven User"})
		user_doc.save()
		return {"success": True, "message": "User added to Raven"}
	else:
		user_doc = frappe.new_doc("User")
		user_doc.email = email
		user_doc.first_name = first_name
		user_doc.last_name = last_name
		user_doc.send_welcome_email = 1
		user_doc.append("roles", {"role": "Raven User"})
		user_doc.insert()
		return {"success": True, "message": "User added to Raven"}

--------------------------------------------------------------------------------

File: api\reactions.py
Comments: Included
Mime Type: text/x-python
Size: 3404 bytes
Content:
import json

import frappe
from frappe import _

from raven.utils import is_channel_member


@frappe.whitelist(methods=["POST"])
def react(message_id: str, reaction: str, is_custom: bool = False, emoji_name: str = None):
	"""
	API to react/unreact to a message.
	Checks if the user can react to the message
	First checks if the user has already reacted to the message.
	If yes, then unreacts (deletes), else reacts (creates).
	"""

	# PERF: No need for permission checks here.
	# The permission checks are done in the controller method for the doctype

	channel_id = frappe.get_cached_value("Raven Message", message_id, "channel_id")
	channel_type = frappe.get_cached_value("Raven Channel", channel_id, "type")

	if channel_type == "Private":

		if not is_channel_member(channel_id):
			frappe.throw(_("You do not have permission to react to this message"), frappe.PermissionError)

	if is_custom:
		# The reaction is a custom emoji with a URL
		reaction_escaped = emoji_name
	else:
		reaction_escaped = reaction.encode("unicode-escape").decode("utf-8").replace("\\u", "")
	user = frappe.session.user
	existing_reaction = frappe.db.exists(
		"Raven Message Reaction",
		{"message": message_id, "owner": user, "reaction_escaped": reaction_escaped},
	)

	if existing_reaction:
		# Why not use frappe.db.delete?
		# Because frappe won't run the controller method for 'after_delete' if we do so,
		# and we need to calculate the new count of reactions for our message
		frappe.get_doc("Raven Message Reaction", existing_reaction).delete(delete_permanently=True)

	else:
		frappe.get_doc(
			{
				"doctype": "Raven Message Reaction",
				"reaction": reaction,
				"message": message_id,
				"channel_id": channel_id,
				"owner": user,
				"is_custom": is_custom,
				"reaction_escaped": reaction_escaped,
			}
		).insert(ignore_permissions=True)
	return "Ok"


def calculate_message_reaction(message_id, channel_id: str = None):

	reactions = frappe.get_all(
		"Raven Message Reaction",
		fields=["owner", "reaction", "is_custom", "reaction_escaped"],
		filters={"message": message_id},
		order_by="creation",
	)

	total_reactions = {}

	for reaction_item in reactions:
		item_key = reaction_item.reaction_escaped if reaction_item.is_custom else reaction_item.reaction
		if item_key in total_reactions:
			existing_reaction = total_reactions[item_key]
			new_users = existing_reaction.get("users")
			new_users.append(reaction_item.owner)
			total_reactions[item_key] = {
				"count": existing_reaction.get("count") + 1,
				"users": new_users,
				"reaction": reaction_item.reaction,
				"is_custom": reaction_item.is_custom,
			}

		else:
			total_reactions[item_key] = {
				"count": 1,
				"users": [reaction_item.owner],
				"reaction": reaction_item.reaction,
				"is_custom": reaction_item.is_custom,
			}
	frappe.db.set_value(
		"Raven Message",
		message_id,
		"message_reactions",
		json.dumps(total_reactions, indent=4),
		update_modified=False,
	)
	frappe.publish_realtime(
		"message_reacted",
		{
			"channel_id": channel_id,
			"sender": frappe.session.user,
			"message_id": message_id,
			"reactions": json.dumps(total_reactions),
		},
		doctype="Raven Channel",
		docname=channel_id,  # Adding this to automatically add the room for the event via Frappe
		after_commit=False,
	)

--------------------------------------------------------------------------------

File: api\search.py
Comments: Included
Mime Type: text/x-python
Size: 3882 bytes
Content:
import frappe
from pypika import JoinType


@frappe.whitelist()
def get_search_result(
	filter_type,
	search_text=None,
	from_user=None,
	in_channel=None,
	saved=False,
	date=None,
	file_type=None,
	message_type=None,
	channel_type=None,
	my_channel_only=False,
):
	# Define the necessary document types
	channel_member = frappe.qb.DocType("Raven Channel Member")
	channel = frappe.qb.DocType("Raven Channel")
	message = frappe.qb.DocType("Raven Message")
	file_doc = frappe.qb.DocType("File")

	# File extension mappings
	file_extensions = {
		"pdf": "pdf",
		"doc": ["doc", "docx", "odt", "ott", "rtf", "txt", "dot", "dotx", "docm", "dotm", "pages"],
		"ppt": [
			"ppt",
			"pptx",
			"odp",
			"otp",
			"pps",
			"ppsx",
			"pot",
			"potx",
			"pptm",
			"ppsm",
			"potm",
			"ppam",
			"ppa",
			"key",
		],
		"xls": [
			"xls",
			"xlsx",
			"csv",
			"ods",
			"ots",
			"xlsb",
			"xlsm",
			"xlt",
			"xltx",
			"xltm",
			"xlam",
			"xla",
			"numbers",
		],
	}

	# Base query
	query = (
		frappe.qb.from_(message)
		.select(
			message.name,
			message.file,
			message.owner,
			message.creation,
			message.message_type,
			message.channel_id,
			message.text,
			message.content,
			channel.workspace,
		)
		.join(channel, JoinType.left)
		.on(message.channel_id == channel.name)
		.join(channel_member, JoinType.left)
		.on(channel_member.channel_id == message.channel_id)
		.join(file_doc, JoinType.left)
		.on(message.name == file_doc.attached_to_name)
		.where(channel_member.user_id == frappe.session.user)
	)

	if filter_type == "File":
		query = query.where(message.message_type != "Text" or message.message_type != "Poll").distinct()

	if filter_type == "Message":
		query = query.where(message.message_type == "Text").distinct()

	if filter_type == "Channel":
		query = (
			frappe.qb.from_(channel)
			.select(
				channel.name,
				channel.owner,
				channel.creation,
				channel.type,
				channel.channel_name,
				channel.channel_description,
				channel.is_archived,
			)
			.join(channel_member, JoinType.left)
			.on(channel_member.channel_id == channel.name)
			.where(channel.is_direct_message == 0)
			# .where(doctype.is_thread == 0)
			.where((channel.type != "Private") | (channel_member.user_id == frappe.session.user))
			.distinct()
		)

	if search_text:
		if filter_type == "File":
			query = query.where(message.file.like("/private/files/%" + search_text + "%"))
		elif filter_type == "Message":
			query = query.where(message.content.like("%" + search_text + "%"))
		elif filter_type == "Channel":
			query = query.where(channel.channel_name.like("%" + search_text + "%"))

	if from_user:
		query = query.where(message.owner == from_user)

	if in_channel:
		query = query.where(message.channel_id == in_channel)

	if date:
		query = query.where(message.creation > date)

	if message_type:
		query = query.where(message.message_type == message_type)

	if filter_type == "File":
		if file_type:
			if file_type == "image":
				query = query.where(message.message_type == "Image")
			elif file_type == "pdf":
				query = query.where(file_doc.file_type == "pdf")
			else:
				# Get the list of extensions for the given file type
				extensions = file_extensions.get(file_type)
				if extensions:
					query = query.where((file_doc.file_type).isin(extensions))
		else:
			query = query.where(message.message_type.isin(["Image", "File"]))

	if channel_type:
		query = query.where(channel.type == channel_type)

	if my_channel_only == "true":
		query = query.where((channel.type == "Open") | (channel_member.user_id == frappe.session.user))

	if saved == "true":
		query = query.where(message._liked_by.like(f"%{frappe.session.user}%"))

	return query.limit(20).offset(0).run(as_dict=True)

--------------------------------------------------------------------------------

File: api\support_request.py
Comments: Included
Mime Type: text/x-python
Size: 961 bytes
Content:
import json

import frappe
import requests
from frappe import _


@frappe.whitelist(methods=["POST"])
def submit_support_request(
	email,
	ticket_type,
	subject,
	description,
	status="Open",
):
	"""
	Submit a support ticket using Frappe's web form API.
	"""

	payload = {
		"data": json.dumps(
			{
				"raised_by": email,
				"subject": subject,
				"ticket_type": ticket_type,
				"description": description,
				"status": status,
				"doctype": "HD Ticket",
				"web_form_name": "support-ticket",
				"via_customer_portal": 1,
			}
		),
		"web_form": "support-ticket",
	}

	response = requests.post(
		"https://community.ravenapp.cloud/api/method/frappe.website.doctype.web_form.web_form.accept",
		data=payload,
		headers={"Content-Type": "application/x-www-form-urlencoded"},
	)

	if response.status_code == 200:
		return "Ticket submitted successfully"
	else:
		frappe.throw(_("Failed to submit the ticket"))

--------------------------------------------------------------------------------

File: api\test_chat_stream.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 9612 bytes
Content:
import datetime

import frappe
from frappe.tests import IntegrationTestCase

from raven.api.chat_stream import get_messages, get_newer_messages, get_older_messages

CHANNEL_ID = "Public Workspace-test-channel"

EXTRA_TEST_RECORD_DEPENDENCIES = ["Raven Workspace"]


def create_messages():
	"""
	Create test messages in the channel
	Higher the number, newer the message
	"""

	# Create 100 messages
	for i in range(100):
		# Set the creation date of the 50th message the same as the 49th message
		if i == 49:
			creation = datetime.datetime.now() - datetime.timedelta(days=100 - i - 1)
		else:
			creation = datetime.datetime.now() - datetime.timedelta(days=100 - i)
		message = frappe.get_doc(
			{
				"doctype": "Raven Message",
				"name": f"{CHANNEL_ID}-{i}",
				"text": f"Test Message {i}",
				"content": f"Test Message {i}",
				"channel_id": CHANNEL_ID,
				"message_type": "Text",
				"creation": creation,
				"modified": creation,
			}
		)
		message.db_insert()


def create_channel():
	channel_doc = frappe.get_doc(
		{
			"doctype": "Raven Channel",
			"channel_name": "Test Channel",
			"type": "Public",
			"workspace": "Public Workspace",
		}
	)
	channel_doc.flags.do_not_add_member = True
	channel_doc.insert()


class TestChatStream(IntegrationTestCase):
	def setUp(self):
		try:
			frappe.delete_doc("Raven Channel", CHANNEL_ID)
		except frappe.exceptions.DoesNotExistError:
			pass
		frappe.clear_cache(doctype="Raven Message")
		create_channel()
		# Messages are ordered by an index. Greater the index, newer the message.
		# So Test Message 99 is the latest message and Test Message 0 is the oldest
		create_messages()

	def tearDown(self):
		frappe.delete_doc("Raven Channel", CHANNEL_ID)
		# We need to remove this database commit
		frappe.db.commit()  # nosemgrep

	def test_get_messages(self):
		"""
		Chat Stream `get_messages` API
		The API should return the latest 'n' messages in the channel - general, ordered by creation date (newest first)
		It should also return if older messages are available.
		Since the API is being tested without a base message, it should not return newer messages
		"""
		response = get_messages(CHANNEL_ID)
		self.assertEqual(len(response["messages"]), 20)

		# Loop over and check indexes of all messages
		for i, message in enumerate(response["messages"]):
			self.assertEqual(message.text, f"Test Message {99-i}")

		# Check if older messages are available
		self.assertEqual(response["has_old_messages"], True)
		self.assertEqual(response["has_new_messages"], False)

		response = get_messages(CHANNEL_ID, limit=80)
		self.assertEqual(len(response["messages"]), 80)

		# Loop over and check indexes of all messages
		for i, message in enumerate(response["messages"]):
			self.assertEqual(message.text, f"Test Message {99-i}")

		# Check if older messages are available
		self.assertEqual(response["has_old_messages"], True)
		self.assertEqual(response["has_new_messages"], False)

		response = get_messages(CHANNEL_ID, limit=100)
		self.assertEqual(len(response["messages"]), 100)

		# Loop over and check indexes of all messages
		for i, message in enumerate(response["messages"]):
			self.assertEqual(message.text, f"Test Message {99-i}")

		# Check if older/newer messages are available
		self.assertEqual(response["has_old_messages"], False)
		self.assertEqual(response["has_new_messages"], False)

		response = get_messages(CHANNEL_ID, limit=1000)
		self.assertEqual(len(response["messages"]), 100)

		# Loop over and check indexes of all messages
		for i, message in enumerate(response["messages"]):
			self.assertEqual(message.text, f"Test Message {99-i}")

		# Check if older/newer messages are available
		self.assertEqual(response["has_old_messages"], False)
		self.assertEqual(response["has_new_messages"], False)

	def test_get_messages_around_base_mid(self):
		"""
		Chat Stream `get_messages` API with a base message in the middle of the list
		The API should return 10 messages before and 9 after the base message
		"""
		base_message_id = frappe.db.get_value(
			"Raven Message", {"text": "Test Message 50", "channel_id": CHANNEL_ID}, "name"
		)

		response = get_messages(CHANNEL_ID, base_message=base_message_id)

		# We should get 20 messages overall
		self.assertEqual(len(response["messages"]), 20)

		# Check if older messages are available
		self.assertEqual(response["has_old_messages"], True)

		# Check if newer messages are available
		self.assertEqual(response["has_new_messages"], True)

		# Loop over and check indexes of all messages
		for i, message in enumerate(response["messages"]):
			self.assertEqual(message.text, f"Test Message {59-i}")

	def test_get_messages_around_base_with_fewer_new_messages(self):
		"""
		Get messages around a base message with fewer new messages (index 95)
		"""
		base_message_id = frappe.db.get_value(
			"Raven Message", {"text": "Test Message 95", "channel_id": CHANNEL_ID}, "name"
		)
		response = get_messages(CHANNEL_ID, base_message=base_message_id)

		# We should get 15 messages overall
		self.assertEqual(len(response["messages"]), 15)

		# Check if older messages are available
		self.assertEqual(response["has_old_messages"], True)

		# Check if newer messages are available
		self.assertEqual(response["has_new_messages"], False)

		# Loop over and check indexes of all messages
		for i, message in enumerate(response["messages"]):
			self.assertEqual(message.text, f"Test Message {99-i}")

	def test_get_messages_around_base_with_fewer_old_messages(self):
		"""
		Get messages around a base message with fewer old messages (index 5)
		"""
		base_message_id = frappe.db.get_value(
			"Raven Message", {"text": "Test Message 5", "channel_id": CHANNEL_ID}, "name"
		)
		response = get_messages(CHANNEL_ID, base_message=base_message_id)

		# We should get 15 messages overall
		self.assertEqual(len(response["messages"]), 15)

		# Check if older messages are available
		self.assertEqual(response["has_old_messages"], False)

		# Check if newer messages are av
--------------------------------------------------------------------------------

File: api\threads.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 9941 bytes
Content:
import frappe
from frappe import _
from frappe.query_builder import Order
from frappe.query_builder.functions import Coalesce, Count

from raven.api.raven_channel import get_peer_user_id
from raven.utils import get_channel_members, get_thread_reply_count


@frappe.whitelist(methods=["GET"])
def get_number_of_replies(thread_id: str):
	"""
	Get the number of replies in a thread
	"""
	return get_thread_reply_count(thread_id)


@frappe.whitelist(methods=["GET"])
def get_all_threads(
	workspace: str = None,
	content=None,
	channel_id=None,
	is_ai_thread=0,
	start_after=0,
	limit=10,
	only_show_unread=False,
):
	"""
	Get all the threads in which the user is a participant
	(We are not fetching the messages inside a thread here, just the main thread message,
	We will fetch the messages inside a thread when the user clicks on 'View Thread')
	"""

	# Fetch all channels in which is_thread = 1 and the current user is a member

	channel = frappe.qb.DocType("Raven Channel")
	channel_member = frappe.qb.DocType("Raven Channel Member")
	message = frappe.qb.DocType("Raven Message").as_("message")
	thread_messages = frappe.qb.DocType("Raven Message").as_("thread_messages")

	query = (
		frappe.qb.from_(channel)
		.select(
			channel.name,
			channel.workspace,
			channel.last_message_timestamp,
			# channel.last_message_details,
			channel.is_ai_thread,
			channel.is_dm_thread,
			message.name.as_("thread_message_id"),
			message.channel_id,
			message.message_type,
			message.text,
			message.content,
			message.file,
			message.poll_id,
			message.is_bot_message,
			message.bot,
			message.hide_link_preview,
			message.link_doctype,
			message.link_document,
			message.image_height,
			message.image_width,
			message.owner,
			message.creation,
			Count(thread_messages.name).as_("reply_count"),
		)
		.left_join(message)
		.on((message.is_thread == 1) & (message.name == channel.name))
		.left_join(channel_member)
		.on(
			(channel.name == channel_member.channel_id) & (channel_member.user_id == frappe.session.user)
		)
		.left_join(thread_messages)
		.on(channel.name == thread_messages.channel_id)
		.where(channel_member.user_id == frappe.session.user)
		.where(channel.is_thread == 1)
		.where(channel.is_ai_thread == is_ai_thread)
		.limit(limit)
		.offset(start_after)
		.groupby(channel.name)
	)

	if workspace:
		query = query.where((channel.workspace == workspace) | (channel.is_dm_thread == 1))

	if content:
		query = query.where(message.content.like(f"%{content}%"))

	if channel_id and channel_id != "all":
		query = query.where(message.channel_id == channel_id)

	if only_show_unread == True or only_show_unread == "true":
		query = query.where(
			channel.last_message_timestamp > Coalesce(channel_member.last_visit, "2000-11-11")
		)

	query = query.orderby(channel.last_message_timestamp, order=Order.desc)

	# return
	threads = query.run(as_dict=True)

	for thread in threads:
		# Fetch the participants of the thread if it's not an AI thread or a DM thread
		if not thread["is_ai_thread"] and not thread["is_dm_thread"]:
			thread_members = get_channel_members(thread["name"])
			thread["participants"] = [{"user_id": member} for member in thread_members]

	return threads


@frappe.whitelist(methods=["GET"])
def get_other_threads(
	workspace: str = None, content=None, channel_id=None, is_ai_thread=0, start_after=0, limit=10
):
	"""
	Get all the threads in which the user is not a participant, but is a member of the channel
	"""

	channel_member = frappe.qb.DocType("Raven Channel Member")
	thread_channel = frappe.qb.DocType("Raven Channel").as_("thread_channel")
	main_thread_message = frappe.qb.DocType("Raven Message").as_("main_thread_message")
	thread_channel_member = frappe.qb.DocType("Raven Channel Member").as_("thread_channel_member")
	thread_message = frappe.qb.DocType("Raven Message").as_("thread_message")

	# Build the query to get threads where user is not a participant but has access to main channel
	query = (
		frappe.qb.from_(thread_channel)
		.select(
			thread_channel.name,
			thread_channel.workspace,
			thread_channel.last_message_timestamp,
			# thread_channel.last_message_details,
			thread_channel.is_ai_thread,
			thread_channel.is_dm_thread,
			main_thread_message.name.as_("thread_message_id"),
			main_thread_message.channel_id,
			main_thread_message.message_type,
			main_thread_message.text,
			main_thread_message.content,
			main_thread_message.file,
			main_thread_message.poll_id,
			main_thread_message.is_bot_message,
			main_thread_message.bot,
			main_thread_message.hide_link_preview,
			main_thread_message.link_doctype,
			main_thread_message.link_document,
			main_thread_message.image_height,
			main_thread_message.image_width,
			main_thread_message.owner,
			main_thread_message.creation,
			Count(thread_message.name).as_("reply_count"),
		)
		.left_join(main_thread_message)
		.on((main_thread_message.is_thread == 1) & (main_thread_message.name == thread_channel.name))
		.left_join(thread_message)
		.on(thread_channel.name == thread_message.channel_id)
		.left_join(channel_member)
		.on(
			(main_thread_message.channel_id == channel_member.channel_id)
			& (channel_member.user_id == frappe.session.user)
		)
		.left_join(thread_channel_member)
		.on(
			(thread_channel.name == thread_channel_member.channel_id)
			& (thread_channel_member.user_id == frappe.session.user)
		)
		.where(thread_channel.is_thread == 1)
		.where(thread_channel.is_ai_thread == is_ai_thread)
		.where(channel_member.user_id == frappe.session.user)  # User must be member of main channel
		.where(thread_channel_member.user_id.isnull())  # User must NOT be member of thread channel
		.limit(limit)
		.offset(start_after)
		.groupby(thread_channel.name)
	)

	if workspace:
		query = query.where((thread_channel.workspace == workspace) | (thread_channel.is_dm_thread == 1))

	if content:
		query = query.where(main_thread_message.content.like(f"%{content}%"))

	if channel_id and channel_id != "all":
		query = query.where
--------------------------------------------------------------------------------

File: api\upload_file.py
Comments: Included
Mime Type: text/x-python
Size: 5401 bytes
Content:
import base64
import io
from mimetypes import guess_type

import blurhash
import frappe
from frappe import _
from frappe.core.doctype.file.utils import get_local_image
from frappe.handler import upload_file
from frappe.utils.image import optimize_image
from PIL import Image, ImageOps


def upload_JPEG_wrt_EXIF(content, filename, optimize=False):
	"""
	When a user uploads a JPEG file, we need to transpose the image based on the EXIF data.
	This is because the image is rotated when it is uploaded to the server.
	"""
	content_type = guess_type(filename)[0]

	# if file format is JPEG, we need to transpose the image
	if content_type.startswith("image/jpeg"):
		with Image.open(io.BytesIO(content)) as image:
			# transpose the image
			transposed_image = ImageOps.exif_transpose(image)
			#  convert the image to bytes
			buffer = io.BytesIO()
			# save the image to the buffer
			transposed_image.save(buffer, format="JPEG")
			# get the value of the buffer
			buffer = buffer.getvalue()
	else:
		buffer = base64.b64decode(content)

	if optimize:
		buffer = optimize_image(buffer, content_type)

	file_doc = frappe.get_doc(
		{
			"doctype": "File",
			"file_name": filename,
			"content": buffer,
			"attached_to_doctype": "Raven Message",
			"attached_to_name": frappe.form_dict.docname,
			"is_private": 1,
			"attached_to_field": "file",
		}
	).insert()

	return file_doc


@frappe.whitelist()
def upload_file_with_message():
	"""
	When the user uploads a file on Raven, this API is called.
	Along with the file, the user also send additional information: the channel ID
	We need to do two things:

	1. Create a Raven Message Doc
	2. Upload the file
	3. If the file is an image, we need to measure it's dimensions
	4. Store the file URL and the dimensions in the Raven Message Doc
	"""
	fileExt = ["jpg", "JPG", "jpeg", "JPEG", "png", "PNG", "gif", "GIF", "webp", "WEBP"]
	thumbnailExt = ["jpg", "JPG", "jpeg", "JPEG", "png", "PNG"]

	frappe.form_dict.doctype = "Raven Message"
	frappe.form_dict.fieldname = "file"

	if (
		frappe.form_dict.compressImages == "1"
		or frappe.form_dict.compressImages == True
		or frappe.form_dict.compressImages == "true"
	):
		frappe.form_dict.optimize = True
	else:
		frappe.form_dict.optimize = False

	message_doc = frappe.new_doc("Raven Message")
	message_doc.channel_id = frappe.form_dict.channelID
	message_doc.message_type = "File"
	message_doc.text = frappe.form_dict.caption

	# If no caption is provided, use the filename as the caption
	if not frappe.form_dict.caption:
		# Get the filename
		try:
			filename = frappe.request.files["file"].filename
		except Exception:
			filename = "File"
		message_doc.content = filename

	message_doc.is_reply = frappe.form_dict.is_reply
	if message_doc.is_reply == "1" or message_doc.is_reply == 1:
		message_doc.linked_message = frappe.form_dict.linked_message

	message_doc.insert()

	frappe.form_dict.docname = message_doc.name

	# Get the files
	files = frappe.request.files
	# Get the file & content
	if "file" in files:
		file = files["file"]
		filename = file.filename
		"""
        If the file is a JPEG, we need to transpose the image
        Else, we need to upload the file as is
        """
		if filename.endswith(".jpeg") or filename.endswith(".jpg"):
			content = file.stream.read()
			file_doc = upload_JPEG_wrt_EXIF(content, filename, frappe.form_dict.optimize)
		else:
			file_doc = upload_file()

	message_doc.reload()

	message_doc.file = file_doc.file_url

	if file_doc.file_type in fileExt:

		message_doc.message_type = "Image"

		image, filename, extn = get_local_image(file_doc.file_url)
		width, height = image.size

		MAX_WIDTH = 480
		MAX_HEIGHT = 320
		is_landscape = width > height

		# If it's a landscape image, then the thumbnail needs to be 480px wide
		if is_landscape:
			thumbnail_width = min(width, MAX_WIDTH)
			thumbnail_height = int(height * thumbnail_width / width)

		else:
			thumbnail_height = min(height, MAX_HEIGHT)
			thumbnail_width = int(width * thumbnail_height / height)

		image.thumbnail((thumbnail_width, thumbnail_height))

		x_components = 4 if is_landscape else 3
		y_components = 3 if is_landscape else 4

		blurhash_string = blurhash.encode(image, x_components=x_components, y_components=y_components)

		message_doc.blurhash = blurhash_string

		# thumbnail_size = thumbnail_width, thumbnail_height

		# if extn in thumbnailExt:

		# TODO: Generate thumbnail of the image

		# Need to add a provision in Frappe to generate thumbnails for all images - not just public files
		# Generated thumbnail here throws a permissions error when trying to access.
		# thumbnail_url = f"{filename}_small.{extn}"

		# path = os.path.abspath(frappe.get_site_path(thumbnail_url.lstrip("/")))
		# image.thumbnail(thumbnail_size, Image.Resampling.LANCZOS)

		# try:
		#     image.save(path)
		# except OSError:
		#     frappe.msgprint(_("Unable to write file format for {0}").format(path))
		#     thumbnail_url = file_doc.file_url

		message_doc.image_width = width
		message_doc.image_height = height
		# message_doc.file_thumbnail = thumbnail_url
		message_doc.thumbnail_width = thumbnail_width
		message_doc.thumbnail_height = thumbnail_height

	message_doc.save()

	return message_doc

--------------------------------------------------------------------------------

File: api\user_availability.py
Comments: Included
Mime Type: text/x-python
Size: 1249 bytes
Content:
import frappe


def set_user_active():
	# Set the user's session ID in the cache
	frappe.cache().set_value(
		f"user_session_{frappe.session.user}", frappe.session.user, expires_in_sec=900
	)


def set_user_inactive():
	# Remove the user's session ID from the cache
	frappe.cache().delete_key(f"user_session_{frappe.session.user}")


@frappe.whitelist()
def get_active_users():
	# Get all the cache keys that match the pattern 'user_session_*'
	user_session_keys = frappe.cache().get_keys("user_session_*")
	# Decode the keys and split them to get the key name
	decoded_keys = [key.decode("utf-8").split("|")[1] for key in user_session_keys]
	# Get the user IDs from the cache
	user_ids = [frappe.cache().get_value(key) for key in decoded_keys]

	return user_ids


@frappe.whitelist()
def refresh_user_active_state(deactivate=False):
	if isinstance(deactivate, str):
		deactivate = True if deactivate.lower() == "true" else False
	if deactivate:
		set_user_inactive()
	else:
		set_user_active()

	# // nosemgrep This has to be published to all the users
	frappe.publish_realtime(
		"raven:user_active_state_updated",
		{"user": frappe.session.user, "active": not deactivate},
	)  # nosemgrep

	return "ok"

--------------------------------------------------------------------------------

File: api\workspaces.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 6036 bytes
Content:
import frappe
from frappe import _
from frappe.query_builder import JoinType, Order

from raven.utils import delete_channel_members_cache, delete_workspace_members_cache


@frappe.whitelist()
def get_list():
	"""
	Fetches list of all workspaces that the current user is a member of/has access to
	"""
	if not frappe.db.exists("Raven User", {"user": frappe.session.user}):
		frappe.throw(_("You do not have access to Raven."), frappe.PermissionError)

	workspace = frappe.qb.DocType("Raven Workspace")
	workspace_member = frappe.qb.DocType("Raven Workspace Member")

	all_workspaces = (
		frappe.qb.from_(workspace)
		.join(workspace_member, JoinType.left)
		.on(
			(workspace.name == workspace_member.workspace) & (workspace_member.user == frappe.session.user)
		)
		.where((workspace_member.user == frappe.session.user) | (workspace.type == "Public"))
		.select(
			workspace.workspace_name,
			workspace.name,
			workspace.logo,
			workspace.type,
			workspace.description,
			workspace.can_only_join_via_invite,
			workspace_member.name.as_("workspace_member_name"),
			workspace_member.is_admin.as_("is_admin"),
		)
		.orderby(workspace.creation, order=Order.asc)
	)

	return all_workspaces.run(as_dict=True)


@frappe.whitelist()
def join_workspace(workspace: str):
	"""
	Joins a workspace
	"""
	member = frappe.get_doc(
		{"doctype": "Raven Workspace Member", "workspace": workspace, "user": frappe.session.user}
	).insert()

	return member


@frappe.whitelist()
def leave_workspace(workspace: str):
	"""
	Leaves a workspace
	"""
	member = frappe.db.exists(
		"Raven Workspace Member", {"workspace": workspace, "user": frappe.session.user}
	)
	if member:
		member_doc = frappe.get_doc("Raven Workspace Member", member)
		member_doc.delete()

	else:
		frappe.throw(_("You are not a member of this workspace."), frappe.PermissionError)


@frappe.whitelist()
def is_workspace_admin(workspace: str):
	"""
	Checks if the current user is an admin of a workspace
	"""
	workspace_member = frappe.get_doc(
		"Raven Workspace Member", {"workspace": workspace, "user": frappe.session.user}
	)

	if workspace_member and workspace_member.is_admin:
		return True

	return False


@frappe.whitelist()
def can_create_channel(workspace: str):
	"""
	Checks if the current user can create a channel in a workspace
	"""
	workspace_doc = frappe.get_doc("Raven Workspace", workspace)
	if workspace_doc.only_admins_can_create_channels:
		return is_workspace_admin(workspace)

	return True


@frappe.whitelist()
def fetch_workspace_members(workspace: str):
	"""
	Gets all members of a workspace
	"""
	frappe.has_permission("Raven Workspace", doc=workspace, throw=True)
	return frappe.get_all(
		"Raven Workspace Member",
		filters={"workspace": workspace},
		fields=["user", "is_admin", "creation", "name"],
	)


@frappe.whitelist()
def get_workspace_member_count(workspace: str):
	"""
	Gets the number of members in a workspace
	"""
	frappe.has_permission("Raven Workspace", doc=workspace, throw=True)
	return frappe.db.count("Raven Workspace Member", filters={"workspace": workspace})


@frappe.whitelist()
def add_workspace_members(workspace: str, members: list):
	"""
	Adds members to a workspace
	"""
	frappe.has_permission("Raven Workspace", doc=workspace, ptype="write", throw=True)

	# Since this is a bulk operation, we need to disable cache invalidation (will be handled manually) and ignore permissions (since we already have permission to add members)

	for member in members:
		member_doc = frappe.get_doc(
			{"doctype": "Raven Workspace Member", "workspace": workspace, "user": member}
		)
		member_doc.flags.ignore_cache_invalidation = True
		member_doc.insert(ignore_permissions=True)

	delete_workspace_members_cache(workspace)


@frappe.whitelist()
def update_workspace_members(workspace: str, members: list):
	"""
	Updates the members of a workspace
	"""
	# Check if the current user is an admin of the workspace
	if not is_workspace_admin(workspace):
		frappe.throw(_("You are not an admin of this workspace."), frappe.PermissionError)

	# Since we are performing a bulk update, we need to do two things:
	# Do not check for permissions again (since we already have permission to update members)
	# Do not trigger a cache update (since we will do this manually)

	errors = []

	for member in members:
		try:
			is_member = member.get("is_member", 0)
			is_admin = member.get("is_admin", 0)
			user = member.get("user")

			member_id = frappe.db.exists("Raven Workspace Member", {"workspace": workspace, "user": user})

			# If not a member, delete the member
			if not is_member:
				if member_id:
					member_doc = frappe.get_doc("Raven Workspace Member", member_id)
					member_doc.flags.ignore_cache_invalidation = True
					# Delete the member this way to avoid cache invalidation + delete all channel members for this user
					member_doc.delete(ignore_permissions=True)
			# If is_member is True, create or update the member
			else:
				# The user is a member and could be an admin as well
				if member_id:
					member_doc = frappe.get_doc("Raven Workspace Member", member_id)
					member_doc.flags.ignore_cache_invalidation = True
					member_doc.is_admin = is_admin
					member_doc.save(ignore_permissions=True)
				else:
					member_doc = frappe.get_doc(
						{
							"doctype": "Raven Workspace Member",
							"workspace": workspace,
							"user": user,
							"is_admin": is_admin,
						}
					).insert()
		except Exception as e:
			errors.append(f"There was an error updating member {user}: {str(e)}")

	delete_workspace_members_cache(workspace)
	workspace_channels = frappe.get_all("Raven Channel", {"workspace": workspace}, pluck="name")
	for channel in workspace_channels:
		delete_channel_members_cache(channel)

	if errors:
		return {"errors": errors}
	else:
		return {"message": "Members updated successfully"}

--------------------------------------------------------------------------------

File: boot.py
Comments: Included
Mime Type: text/x-python
Size: 1177 bytes
Content:
import frappe


def boot_session(bootinfo):

	raven_settings = frappe.get_single("Raven Settings")

	bootinfo.show_raven_chat_on_desk = raven_settings.show_raven_on_desk

	tenor_api_key = raven_settings.tenor_api_key

	document_link_override = frappe.get_hooks("raven_document_link_override")

	if frappe.session.user and frappe.session.user != "Guest":
		chat_style = frappe.db.get_value("Raven User", frappe.session.user, "chat_style")
	else:
		chat_style = "Simple"

	if document_link_override and len(document_link_override) > 0:
		bootinfo.raven_document_link_override = True

	if tenor_api_key:
		bootinfo.tenor_api_key = tenor_api_key
	else:
		bootinfo.tenor_api_key = "AIzaSyAWkuhLwbMxOlvn_o5fxBke1grUZ7F3ma4"  # should we remove this?

	bootinfo.chat_style = chat_style if chat_style else "Simple"

	bootinfo.push_notification_service = (
		raven_settings.push_notification_service
		if raven_settings.push_notification_service
		else "Frappe Cloud"
	)

	if raven_settings.push_notification_service == "Raven":
		bootinfo.vapid_public_key = raven_settings.vapid_public_key
		bootinfo.firebase_client_config = raven_settings.config

--------------------------------------------------------------------------------

File: config\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: hooks.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 8025 bytes
Content:
from . import __version__ as app_version

app_name = "raven"
app_title = "Raven"
app_publisher = "The Commit Company (Algocode Technologies Pvt. Ltd.)"
app_description = "Messaging Application"
app_email = "support@thecommit.company"
app_license = "AGPLv3"
source_link = "https://github.com/The-Commit-Company/Raven"
app_logo = "/assets/raven/raven-logo.png"
app_logo_url = "/assets/raven/raven-logo.png"

# Includes in <head>
# ------------------

# include js, css files in header of desk.html
app_include_css = "raven.bundle.css"
# app_include_css = "/assets/raven/css/raven.css"
# app_include_js = "/assets/raven/js/raven.js"                 ]
app_include_js = "raven.bundle.js"

add_to_apps_screen = [
	{
		"name": "raven",
		"logo": "/assets/raven/raven-logo.png",
		"title": "Raven",
		"route": "/raven",
		"has_permission": "raven.permissions.check_app_permission",
	}
]


sounds = [
	{
		"name": "raven_notification",
		"src": "/assets/raven/sounds/raven_notification.mp3",
		"volume": 0.2,
	},
]

extend_bootinfo = "raven.boot.boot_session"
# include js, css files in header of web template
# web_include_css = "/assets/raven/css/raven.css"
# web_include_js = "/assets/raven/js/raven.js"

# include custom scss in every website theme (without file extension ".scss")
# website_theme_scss = "raven/public/scss/website"

# include js, css files in header of web form
# webform_include_js = {"doctype": "public/js/doctype.js"}
# webform_include_css = {"doctype": "public/css/doctype.css"}

# include js in page
# page_js = {"page" : "public/js/file.js"}

# include js in doctype views
# doctype_js = {"doctype" : "public/js/doctype.js"}
# doctype_list_js = {"doctype" : "public/js/doctype_list.js"}
# doctype_tree_js = {"doctype" : "public/js/doctype_tree.js"}
# doctype_calendar_js = {"doctype" : "public/js/doctype_calendar.js"}

# Home Pages
# ----------

# application home page (will override Website Settings)
# home_page = "login"

# website user home page (by Role)
# role_home_page = {
# "Role": "home_page"
# }

# Generators
# ----------

# automatically create page for each record of this doctype
# website_generators = ["Web Page"]

# Jinja
# ----------

# add methods and filters to jinja environment
# jinja = {
# "methods": "raven.utils.jinja_methods",
# "filters": "raven.utils.jinja_filters"
# }

# Installation
# ------------

# before_install = "raven.install.before_install"
after_install = "raven.install.after_install"
# after_sync = ""

# Uninstallation
# ------------

# before_uninstall = "raven.uninstall.before_uninstall"
after_uninstall = "raven.uninstall.after_uninstall"

# Desk Notifications
# ------------------
# See frappe.core.notifications.get_notification_config

# notification_config = "raven.notifications.get_notification_config"

# Permissions
# -----------
# Permissions evaluated in scripted ways

# permission_query_conditions = {
# "Event": "frappe.desk.doctype.event.event.get_permission_query_conditions",
# }
#
# has_permission = {
# "Event": "frappe.desk.doctype.event.event.has_permission",
# }

# DocType Class
# ---------------
# Override standard doctype classes

# override_doctype_class = {
# "ToDo": "custom_app.overrides.CustomToDo"
# }

# Document Events
# ---------------
# Hook on document methods and events

doc_events = {
	"*": {
		"after_insert": "raven.raven_integrations.doctype.raven_document_notification.raven_document_notification.run_document_notification",
		"on_update": "raven.raven_integrations.doctype.raven_document_notification.raven_document_notification.run_document_notification",
		"on_trash": "raven.raven_integrations.doctype.raven_document_notification.raven_document_notification.run_document_notification",
		"on_cancel": "raven.raven_integrations.doctype.raven_document_notification.raven_document_notification.run_document_notification",
		"on_submit": "raven.raven_integrations.doctype.raven_document_notification.raven_document_notification.run_document_notification",
	},
	"User": {
		"after_insert": "raven.raven.doctype.raven_user.raven_user.add_user_to_raven",
		"on_update": "raven.raven.doctype.raven_user.raven_user.add_user_to_raven",
		"on_trash": "raven.raven.doctype.raven_user.raven_user.remove_user_from_raven",
	},
	"Department": {
		"after_insert": "raven.raven_integrations.controllers.department.after_insert",
		"on_update": "raven.raven_integrations.controllers.department.on_update",
		"on_trash": "raven.raven_integrations.controllers.department.on_trash",
	},
	"Employee": {
		"after_insert": "raven.raven_integrations.controllers.employee.after_insert",
		"on_update": "raven.raven_integrations.controllers.employee.on_update",
		"on_trash": "raven.raven_integrations.controllers.employee.on_trash",
	},
}

# Scheduled Tasks
# ---------------

# scheduler_events = {
# "all": [
# "raven.tasks.all"
# ],
# "daily": [
# "raven.tasks.daily"
# ],
# "hourly": [
# "raven.tasks.hourly"
# ],
# "weekly": [
# "raven.tasks.weekly"
# ],
# "monthly": [
# "raven.tasks.monthly"
# ],
# }

# Testing
# -------

# before_tests = "raven.install.before_tests"

# Overriding Methods
# ------------------------------
#
# override_whitelisted_methods = {
# "frappe.desk.doctype.event.event.get_events": "raven.event.get_events"
# }
#
# each overriding function accepts a `data` argument;
# generated from the base implementation of the doctype dashboard,
# along with any modifications made in other Frappe apps
# override_doctype_dashboards = {
# "Task": "raven.task.get_dashboard_data"
# }

# exempt linked doctypes from being automatically cancelled
#
# auto_cancel_exempted_doctypes = ["Auto Repeat"]

# Ignore links to specified DocTypes when deleting documents
# -----------------------------------------------------------

ignore_links_on_delete = ["Raven Message"]


# User Data Protection
# --------------------

# user_data_fields = [
# {
# "doctype": "{doctype_1}",
# "filter_by": "{filter_by}",
# "redact_fields": ["{field_1}", "{field_2}"],
# "partial": 1,
# },
# {
# "doctype": "{doc
--------------------------------------------------------------------------------

File: install.py
Comments: Included
Mime Type: text/x-python
Size: 1792 bytes
Content:
import click
import frappe
from frappe.desk.page.setup_wizard.setup_wizard import add_all_roles_to, make_records


def after_install():
	try:
		print("Setting up Raven...")
		add_all_roles_to("Administrator")
		create_raven_user_for_administrator()
		create_general_channel()

		click.secho("Thank you for installing Raven!", fg="green")

	except Exception as e:
		BUG_REPORT_URL = "https://github.com/The-Commit-Company/Raven/issues/new"
		click.secho(
			"Installation for Raven failed due to an error."
			" Please try re-installing the app or"
			f" report the issue on {BUG_REPORT_URL} if not resolved.",
			fg="bright_red",
		)
		raise e


def create_raven_user_for_administrator():

	if not frappe.db.exists("Raven User", {"user": "Administrator"}):
		frappe.get_doc(
			{
				"doctype": "Raven User",
				"user": "Administrator",
				"full_name": "Administrator",
				"type": "User",
			}
		).insert(ignore_permissions=True)


def create_general_channel():
	default_workspace = frappe.get_doc(
		{
			"doctype": "Raven Workspace",
			"workspace_name": "Raven",
			"type": "Public",
		}
	)
	default_workspace.insert(ignore_permissions=True)

	# Make all users a member of this workspace and set them as admins
	users = frappe.get_all("Raven User")
	for user in users:
		try:
			frappe.get_doc(
				{
					"doctype": "Raven Workspace Member",
					"workspace": default_workspace.name,
					"user": user.name,
					"is_admin": True,
				}
			).insert(ignore_permissions=True)
		except Exception as e:
			pass  # nosemgrep

	channel = [
		{
			"doctype": "Raven Channel",
			"name": "general",
			"type": "Open",
			"channel_name": "General",
			"workspace": default_workspace.name,
		}
	]

	make_records(channel)

--------------------------------------------------------------------------------

File: modules.txt
Comments: Included
Mime Type: text/plain
Size: 89 bytes
Content:
Raven
Raven Messaging
Raven Channel Management
Raven Bot
Raven Integrations
Raven AI
--------------------------------------------------------------------------------

File: notification.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 10928 bytes
Content:
import json
from urllib.parse import urlparse

import frappe
from frappe.frappeclient import FrappeClient
from frappe.utils import get_datetime, get_system_timezone
from pytz import timezone, utc


def send_notification_for_message(message):
	"""
	Send a push notification for a message.

	This is called in the "after_response" hook for user initiated requests.
	"""

	raven_settings = frappe.get_cached_doc("Raven Settings")

	if raven_settings.push_notification_service == "Raven":
		send_push_notification_via_raven_cloud(message, raven_settings)

		return

	channel_doc = frappe.get_cached_doc("Raven Channel", message.channel_id)
	if channel_doc.is_direct_message and not channel_doc.is_self_message:
		message.send_notification_for_direct_message()

	else:
		message.send_notification_for_channel_message()


def send_push_notification_via_raven_cloud(message, raven_settings):
	"""
	Send a push notification via the Raven Cloud API
	"""
	channel_doc = frappe.get_cached_doc("Raven Channel", message.channel_id)

	if channel_doc.is_self_message:
		return

	try:

		push_tokens = get_push_tokens_for_channel(message.channel_id)

		mentioned_users = [user.get("user") for user in message.mentions]

		replied_to = None

		if message.linked_message:
			replied_message_details = message.replied_message_details

			if isinstance(replied_message_details, str):
				replied_message_details = json.loads(message.replied_message_details)

			replied_to = replied_message_details.get("owner")

		mentioned_tokens = []
		replied_tokens = []
		final_tokens = []

		# If this is a bot message, then we should not filter out the push tokens of the message owner since we need to send the notification to the owner as well (it's coming from the bot)
		if not message.is_bot_message:
			# Filter out the push tokens of the message owner
			push_tokens = [token for token in push_tokens if token.user != message.owner]

		for token in push_tokens:
			if token.user == replied_to:
				replied_tokens.append(token.fcm_token)
			elif token.user in mentioned_users:
				mentioned_tokens.append(token.fcm_token)
			else:
				final_tokens.append(token.fcm_token)

		# We now need to construct the payload for the push notification

		if not mentioned_tokens and not replied_tokens and not final_tokens:
			return

		messages = []

		channel_name = f" in #{channel_doc.channel_name}"

		if channel_doc.is_thread:
			channel_name = " in thread"

		if channel_doc.is_direct_message:
			channel_name = ""

		content = message.get_notification_message_content()

		message_owner, message_owner_image = message.get_message_owner_details()

		workspace = "" if channel_doc.is_dm_thread else channel_doc.workspace

		url = frappe.utils.get_url() + "/raven/"
		if workspace:
			url += f"{workspace}/"
		else:
			url += "channels/"

		if channel_doc.is_thread:
			url += f"thread/{channel_doc.name}/"
		else:
			url += f"{channel_doc.name}/"

		image = get_image_absolute_url(message_owner_image)

		data = {
			"base_url": frappe.utils.get_url(),
			"sitename": frappe.local.site,
			"message_id": message.name,
			"channel_id": message.channel_id,
			"raven_message_type": message.message_type,
			"channel_type": "DM" if channel_doc.is_direct_message else "Channel",
			"content": message.content,
			"from_user": message.owner,
			"type": "New message",
			"is_thread": "1" if channel_doc.is_thread else "0",
			"creation": get_milliseconds_since_epoch(message.creation),
		}

		if replied_tokens:
			messages.append(
				{
					"tokens": replied_tokens,
					"notification": {"title": f"{message_owner} replied{channel_name}", "body": content},
					"data": data,
					"tag": message.channel_id,
					"click_action": url,
					"image": image,
				}
			)

		if mentioned_tokens:
			messages.append(
				{
					"tokens": mentioned_tokens,
					"notification": {"title": f"{message_owner} mentioned you{channel_name}", "body": content},
					"data": data,
					"tag": message.channel_id,
					"click_action": url,
					"image": image,
				}
			)

		if final_tokens:
			messages.append(
				{
					"tokens": final_tokens,
					"notification": {"title": f"{message_owner}{channel_name}", "body": content},
					"data": data,
					"tag": message.channel_id,
					"click_action": url,
					"image": image,
				}
			)

		make_post_call_for_notification(messages, raven_settings)

	except Exception as e:
		frappe.log_error(title="Raven Cloud Push Notification Error")


def make_post_call_for_notification(messages, raven_settings):
	"""
	Make a post call to the push notification server to send the notification
	"""

	client = FrappeClient(
		url=raven_settings.push_notification_server_url,
		api_key=raven_settings.push_notification_api_key,
		api_secret=raven_settings.get_password("push_notification_api_secret"),
	)

	client.post_api(
		"raven_cloud.api.notification.send",
		params={
			"messages": json.dumps(messages),
			"site_name": urlparse(frappe.utils.get_url()).hostname,
		},
	)


def get_push_tokens_for_channel(channel_id):
	"""
	Gets the push tokens for all the users in the channel
	"""

	def _get_push_tokens_for_channel():

		channel_member = frappe.qb.DocType("Raven Channel Member")
		push_token = frappe.qb.DocType("Raven Push Token")
		raven_user = frappe.qb.DocType("Raven User")

		push_token_query = (
			frappe.qb.from_(push_token)
			.left_join(raven_user)
			.on(raven_user.user == push_token.user)
			.left_join(channel_member)
			.on(channel_member.user_id == raven_user.name)
			.where(channel_member.channel_id == channel_id)
			.where(raven_user.type == "User")
			.where(channel_member.allow_notifications == 1)
			.select(push_token.fcm_token, push_token.user, raven_user.name.as_("raven_user_id"))
		)

		return push_token_query.run(as_dict=True)

	return frappe.cache().hget(
		"raven:push_tokens_for_channel", channel_id, _get_push_tokens_for_channel
	)


def get_push_tokens_for_user(user_id):
	"""
	Gets the push tokens for a user
	"""

	def _get_push_tokens_for_user(user_id):
		re
--------------------------------------------------------------------------------

File: package.json
Comments: Included
Mime Type: application/json
Size: 724 bytes
Content:
{
  "name": "raven-app",
  "version": "2.3.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "AGPL-3.0-only",
  "dependencies": {
    "@tiptap/extension-highlight": "2.5.9",
    "@tiptap/extension-link": "2.5.9",
    "@tiptap/extension-mention": "2.5.9",
    "@tiptap/extension-placeholder": "2.5.9",
    "@tiptap/extension-underline": "2.5.9",
    "@tiptap/pm": "2.5.9",
    "@tiptap/react": "2.5.9",
    "@tiptap/starter-kit": "2.5.9",
    "@tiptap/suggestion": "2.5.9",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "swr": "^2.2.5",
    "tippy.js": "^6.3.7"
  }
}
--------------------------------------------------------------------------------

File: patches\v1_2\create_raven_users.py
Comments: Included
Mime Type: text/x-python
Size: 822 bytes
Content:
import frappe


def execute():
	"""Creating Raven Users for existing users with the "Raven User" role."""

	# In Raven v1.2, we introduced the "Raven User" doctype.
	#  Reference: [#427](https://github.com/The-Commit-Company/Raven/issues/427)
	# This doctype is used to store the user's profile picture and full name.
	# However, existing users with the "Raven User" role will not have a corresponding Raven User record.
	# This patch creates Raven Users for all users with the "Raven User" role.
	users = frappe.get_all(
		"User",
		filters=[["name", "not in", ["Guest"]], ["Has Role", "role", "=", "Raven User"]],
	)

	for user in users:
		if not frappe.db.exists("Raven User", {"user": user.name}):
			raven_user = frappe.new_doc("Raven User")
			raven_user.user = user.name
			raven_user.insert()

--------------------------------------------------------------------------------

File: patches\v1_3\create_raven_message_indexes.py
Comments: Included
Mime Type: text/x-python
Size: 163 bytes
Content:
from raven.raven_messaging.doctype.raven_message.raven_message import on_doctype_update


def execute():
	# Indexing all Raven Messages
	on_doctype_update()

--------------------------------------------------------------------------------

File: patches\v1_3\update_all_messages_to_include_message_content.py
Comments: Included
Mime Type: text/x-python
Size: 770 bytes
Content:
import frappe
from frappe.core.utils import html2text


def execute():
	update_old_messages_to_include_message_content()


def update_old_messages_to_include_message_content():
	"""
	Update all old messages to include message content
	Message content is required for search
	It is basically the message's text content but without any html tags
	(this is done to improve search results)
	This is a one-time operation, not required for new messages
	"""
	messages = frappe.db.get_all("Raven Message", fields=["name", "text", "message_type"])
	for message in messages:
		if message.text:
			cleaned_text = html2text(message.text)
			content = cleaned_text
			frappe.db.set_value("Raven Message", message.name, "content", content)
	frappe.db.commit()

--------------------------------------------------------------------------------

File: patches\v1_3\update_all_messages_to_include_replied_message_content.py
Comments: Included
Mime Type: text/x-python
Size: 1027 bytes
Content:
import datetime
import json

import frappe


def execute():
	"""
	Update all old messages to include it's replied message content
	This is a one-time operation, not required for new messages
	"""
	messages = frappe.db.get_all(
		"Raven Message", fields=["name", "linked_message"], filters={"is_reply": 1}
	)
	for message in messages:
		if message.linked_message:
			details = frappe.db.get_value(
				"Raven Message",
				message.linked_message,
				["text", "content", "file", "message_type", "owner", "creation"],
				as_dict=True,
			)
			frappe.db.set_value(
				"Raven Message",
				message.name,
				"replied_message_details",
				json.dumps(
					{
						"text": details.text,
						"content": details.content,
						"file": details.file,
						"message_type": details.message_type,
						"owner": details.owner,
						"creation": datetime.datetime.strftime(details.creation, "%Y-%m-%d %H:%M:%S"),
					},
					indent=1,
				),
				update_modified=False,
			)
	frappe.db.commit()

--------------------------------------------------------------------------------

File: patches\v1_6\create_raven_channel_member_index.py
Comments: Included
Mime Type: text/x-python
Size: 201 bytes
Content:
from raven.raven_channel_management.doctype.raven_channel_member.raven_channel_member import (
	on_doctype_update,
)


def execute():
	# Indexing all Raven Channel Members
	on_doctype_update()

--------------------------------------------------------------------------------

File: patches\v1_6\migrate_older_raven_users.py
Comments: Included
Mime Type: text/x-python
Size: 326 bytes
Content:
import frappe


def execute():
	"""
	Migrate Raven User to have the "type" field set for older Raven Users
	"""

	users = frappe.get_all("Raven User", filters={"type": ["in", ["", None]]}, pluck="name", limit=5)

	for user in users:
		frappe.db.set_value("Raven User", user, "type", "User")

	frappe.db.commit()

--------------------------------------------------------------------------------

File: patches\v2_0\create_default_company_workspace_mapping.py
Comments: Included
Mime Type: text/x-python
Size: 579 bytes
Content:
import frappe


def execute():
	# Add rows to Raven Settings for the default workspace mapping for all companies
	raven_settings = frappe.get_doc("Raven Settings")

	if not raven_settings.auto_create_department_channel:
		return

	# Get all companies if they exist - check if ERPNext is installed
	if "erpnext" in frappe.get_installed_apps():
		companies = frappe.get_all("Company", pluck="name")

	for company in companies:
		raven_settings.append(
			"company_workspace_mapping", {"company": company, "raven_workspace": "Raven"}
		)

	raven_settings.save()

--------------------------------------------------------------------------------

File: patches\v2_0\create_default_workspace.py
Comments: Included
Mime Type: text/x-python
Size: 965 bytes
Content:
import frappe


def execute():
	"""
	Creating a default workspace for all existing users and channels
	"""
	default_workspace = frappe.get_doc(
		{
			"doctype": "Raven Workspace",
			"workspace_name": "Raven",
			"type": "Public",
		}
	)
	default_workspace.insert(ignore_permissions=True)

	# Make all users a member of this workspace and set them as admins
	users = frappe.get_all("Raven User")
	for user in users:
		frappe.get_doc(
			{
				"doctype": "Raven Workspace Member",
				"workspace": default_workspace.name,
				"user": user.name,
				"is_admin": True,
			}
		).insert(ignore_permissions=True)

	# Make all existing channels a part of this workspace
	channels = frappe.get_all(
		"Raven Channel", filters={"is_direct_message": 0, "is_dm_thread": 0}, fields=["name"]
	)
	for channel in channels:
		frappe.db.set_value(
			"Raven Channel", channel.name, "workspace", default_workspace.name, update_modified=False
		)

--------------------------------------------------------------------------------

File: patches\v2_0\migrate_existing_dm_threads.py
Comments: Included
Mime Type: text/x-python
Size: 846 bytes
Content:
import frappe


def execute():
	"""
	Any thread created in a DM channel needs to have the "is_dm_thread" flag set to true
	"""

	# Find all "is_thread" channels whose linked message belongs to a DM channel

	thread_channel = frappe.qb.DocType("Raven Channel")
	message = frappe.qb.DocType("Raven Message")
	message_channel = frappe.qb.DocType("Raven Channel")

	query = (
		frappe.qb.from_(thread_channel)
		.join(message)
		.on(thread_channel.name == message.name)
		.join(message_channel)
		.on(message.channel_id == message_channel.name)
		.select(thread_channel.name)
		.where(thread_channel.is_thread == 1)
		.where(message_channel.is_direct_message == 1)
	)

	results = query.run(as_dict=True)

	for result in results:
		frappe.db.set_value("Raven Channel", result.name, {"is_dm_thread": 1, "workspace": None})

--------------------------------------------------------------------------------

File: patches.txt
Comments: Included
Mime Type: text/plain
Size: 534 bytes
Content:
[pre_model_sync]

[post_model_sync]
raven.patches.v1_2.create_raven_users
raven.patches.v1_3.create_raven_message_indexes #23
raven.patches.v1_3.update_all_messages_to_include_message_content #2
raven.patches.v1_3.update_all_messages_to_include_replied_message_content #2
raven.patches.v1_6.create_raven_channel_member_index
raven.patches.v1_6.migrate_older_raven_users #2
raven.patches.v2_0.migrate_existing_dm_threads
raven.patches.v2_0.create_default_workspace
raven.patches.v2_0.create_default_company_workspace_mapping
--------------------------------------------------------------------------------

File: permissions.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 13650 bytes
Content:
import frappe

from raven.utils import (
	get_channel_member,
	get_workspace_member,
	is_channel_member,
	is_workspace_member,
)


def check_app_permission():
	"""Check if user has permission to access the app (for showing the app on app screen)"""
	if frappe.session.user == "Administrator":
		return True

	if frappe.db.exists("Raven User", {"user": frappe.session.user}):
		return True

	return False


def raven_user_has_permission(doc, user=None, ptype=None):

	if doc.type == "Bot":
		# Anyone with Raven User role can change the bot details
		if user != "Guest":
			return True
	else:
		# Only the user can change their own details
		if doc.user == user:
			return True
		if ptype == "read":
			return True

	return False


def workspace_has_permission(doc, user=None, ptype=None):
	"""
	1. Only Raven Admins can create a workspace
	2. Only Workspace admins can update/delete a workspace
	3. If the workspace is public, anyone can read
	4. If the workspace is private, only member can read
	"""
	if ptype == "create":
		# Return True since this is checked via the Role in the doctype - only Raven Admins can create a workspace
		return True

	if ptype == "write" or ptype == "delete":
		# Only Workspace admins can update/delete a workspace
		workspace_member = get_workspace_member(doc.name, user)
		if workspace_member and workspace_member.get("is_admin"):
			return True
		else:
			return False

	if ptype == "read":
		if doc.type == "Public":
			return True

		if doc.type == "Private":
			# Check if the user is a member of the workspace
			if is_workspace_member(doc.name, user):
				return True

	return False


def workspace_member_has_permission(doc, user=None, ptype=None):

	# If the workspace is a public workspace, anyone can join
	if ptype == "create":
		workspace_type = frappe.get_cached_value("Raven Workspace", doc.workspace, "type")
		if workspace_type == "Public":
			if user == doc.user:
				return True
			else:
				workspace_member = get_workspace_member(doc.workspace, user)
				if workspace_member and workspace_member.get("is_admin"):
					return True

		if workspace_type == "Private":
			workspace_member = get_workspace_member(doc.workspace, user)
			if workspace_member and workspace_member.get("is_admin"):
				return True

	if ptype == "write":
		workspace_member = get_workspace_member(doc.workspace, user)
		if workspace_member and workspace_member.get("is_admin"):
			return True

	if ptype == "delete":
		if doc.user == user:
			return True
		else:
			workspace_member = get_workspace_member(doc.workspace, user)
			if workspace_member and workspace_member.get("is_admin"):
				return True

	if ptype == "read":
		if doc.user == user:
			return True

		if is_workspace_member(doc.workspace, user):
			return True

	return False


def channel_has_permission(doc, user=None, ptype=None):
	if doc.is_direct_message:
		# Users can create direct message channels
		if ptype == "create":
			return True

		if ptype == "read":
			return is_channel_member(doc.name, user)

	elif doc.is_thread:

		if ptype == "create":
			# Users can create threads in channels they are a member of the main channel in which the thread is created
			main_channel = frappe.get_cached_value("Raven Message", doc.channel_name, "channel_id")

			if is_channel_member(main_channel, user):
				return True

		if ptype == "read":
			main_channel = frappe.get_cached_value("Raven Message", doc.channel_name, "channel_id")
			# Check if the user has read permission to the main channel
			channel_doc = frappe.get_cached_doc("Raven Channel", main_channel)
			return channel_doc.has_permission("read", user=user)

		if ptype == "delete":
			# Only the creator of the thread can delete the thread
			return doc.owner == user

	else:
		# For regular channels
		if ptype == "create":
			# Only workspace admins can create a channel
			workspace_member = get_workspace_member(doc.workspace, user)
			if workspace_member and workspace_member.get("is_admin"):
				return True
			# If the workspace allows any member to create a channel, then the user can create a channel
			if not frappe.db.get_value("Raven Workspace", doc.workspace, "only_admins_can_create_channels"):
				return True

		if ptype == "delete" or ptype == "write":
			# Only channel admins can update or delete a channel
			channel_member = get_channel_member(doc.name, user)
			if channel_member and channel_member.get("is_admin"):
				return True

		if ptype == "read":
			# Check if the channel type is public or open
			if doc.type == "Public" or doc.type == "Open":
				return is_workspace_member(doc.workspace, user)
			else:
				return is_channel_member(doc.name, user)

	return False

	# if doc.type == "Open" or doc.type == "Public":
	# 	# If the channel is public/open, check if the user is a member of the workspace
	# 	if doc.workspace:
	# 		return frappe.db.exists("Raven Workspace Member", {"workspace": doc.workspace, "user": user})
	# 	return True
	# elif doc.type == "Private":
	# 	if doc.is_thread:
	# 		if ptype == "read" or ptype == "create":
	# 			# Only users who are part of the original channel can read the thread
	# 			return frappe.has_permission(doctype="Raven Message", doc=doc.name, ptype="read")

	# 	if frappe.db.exists("Raven Channel Member", {"channel_id": doc.name, "user_id": user}):
	# 		return True
	# 	elif (
	# 		doc.owner == user and frappe.db.count("Raven Channel Member", {"channel_id": doc.name}) <= 0
	# 	):
	# 		return True
	# 	else:
	# 		return False


def channel_member_has_permission(doc, user=None, ptype=None):

	# Allow reads for self and if the user is a member of the channel
	#  They cannot make themselves an admin but this is handled in the controller method
	if doc.user_id == user:
		if ptype == "read" or ptype == "write":
			return True

	if ptype == "read":
		# Other channel members can read the channel member document
		return frappe.db.exists("Raven Channel Member", {"channel_id": doc.channel_id, "user_id": user})

	channel_doc = frappe.get_cached_doc("Raven Ch
--------------------------------------------------------------------------------

File: public\.gitkeep
Comments: Included
Mime Type: application/octet-stream
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\build.json
Comments: Included
Mime Type: application/json
Size: 117 bytes
Content:
{
  "js/raven.min.js": [
    "public/js/timeline_button.js",
    "public/js/templates/send_message.html"
  ]
}

--------------------------------------------------------------------------------

File: public\fonts\CalSans.woff2
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\js\raven.bundle.js
Comments: Included
Mime Type: text/javascript
Size: 847 bytes
Content:
$(document).on('app_ready', function () {
    if (frappe.boot.show_raven_chat_on_desk && frappe.user.has_role("Raven User")) {

        // If on mobile, do not show the chat
        if (frappe.is_mobile()) {
            return;
        }
        let main_section = $(document).find('.main-section');

        // Add bottom padding to the main section
        main_section.css('padding-bottom', '60px');

        let chat_element = $(document.createElement('div'));
        chat_element.addClass('raven-chat');

        main_section.append(chat_element);

        frappe.require("raven_chat.bundle.jsx").then(() => {
            frappe.raven_chat = new frappe.ui.RavenChat({
                wrapper: chat_element,
            });
        });
    }

});
import './templates/send_message.html';
import './timeline_button';

--------------------------------------------------------------------------------

File: public\js\raven_chat\App.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 1906 bytes
Content:
import * as React from "react";
import useBoolean from "./hooks/useBoolean";
import Header from "./components/layout/Header";
import ChannelList from "./components/layout/ChannelList";
import { StartFetchContext } from "./hooks/useStartFetch";
import { SWRConfig } from "swr";
import ChatView from "./components/layout/Chat/ChatView";
import useUnreadCount from "./hooks/useUnreadCount";
import { CurrentChannelContext } from "./hooks/useCurrentChannel";

export function App() {

  const [isOpen, { on, toggle }] = useBoolean(false)

  const [initOpen, setInitOpen] = React.useState(false)

  React.useEffect(() => {
    if (isOpen) {
      setInitOpen(true)
    }
  }, [isOpen])

  const [selectedChannel, setSelectedChannel] = React.useState('')

  const { totalUnread } = useUnreadCount()

  return (
    <StartFetchContext.Provider value={initOpen}>
      <CurrentChannelContext.Provider value={selectedChannel}>
        <SWRConfig value={{
          revalidateOnFocus: false,
          revalidateOnMount: true,
          revalidateOnReconnect: false,
          revalidateIfStale: false,
        }}>
          <div className="raven-container" data-open-state={isOpen}>
            <Header
              on={on}
              toggle={toggle}
              isOpen={isOpen}
              selectedChannel={selectedChannel}
              setSelectedChannel={setSelectedChannel}
              unreadMessageCount={totalUnread} />
            <div className='raven-content-container' data-channel={selectedChannel} data-channel-list-view={selectedChannel ? 'false' : 'true'}>
              <ChannelList isOpen={isOpen} onSelectChannel={setSelectedChannel} />
              <ChatView selectedChannel={selectedChannel} />
            </div>
          </div>
        </SWRConfig>
      </CurrentChannelContext.Provider>
    </StartFetchContext.Provider>
  );
}
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\common\Avatar.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 1513 bytes
Content:
import React from 'react'

const COLORS = ["dark-green", "orange", "pink", "red", "blue", "purple", "yellow", "gray", "green"]


const getHashOfString = (str) => {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash)
    }
    hash = Math.abs(hash)
    return hash
}
const normalizeHash = (hash, min, max) => {
    return Math.floor((hash % (max - min)) + min)
}
export const generateAvatarColor = (id) => {
    const hash = getHashOfString(id || 'random')
    const index = normalizeHash(hash, 0, COLORS.length)
    return COLORS[index]
}

export const getInitials = (name) => {
    if (!name) return ''
    const [firstName, lastName] = name.split(' ')
    return firstName[0] + (lastName?.[0] ?? '')
}
//TODO: isActive is not implemented
const Avatar = ({ user, fallback, isActive }) => {

    const color = generateAvatarColor(user?.full_name)
    return (
        <div>
            {user?.user_image ? <img src={user.user_image} alt={user?.full_name} className='raven-avatar' /> : <span
                style={{
                    backgroundColor: `var(--${color}-avatar-bg)`,
                    color: `var(--${color}-avatar-color)`
                }}
                className='raven-avatar'>
                <span className='placeholder'>
                    {getInitials(user?.full_name ?? fallback)}
                </span>
            </span>}
        </div>
    )
}

export default Avatar
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\common\ChannelIcon.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 1876 bytes
Content:
import React from 'react'

const ChannelIcon = ({ channelType, size = '20', ...props }) => {
    if (channelType === 'Private') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
            {...props}>
            <path d="M12 2C9.243 2 7 4.243 7 7v3H6c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-8c0-1.103-.897-2-2-2h-1V7c0-2.757-2.243-5-5-5zm6 10 .002 8H6v-8h12zm-9-2V7c0-1.654 1.346-3 3-3s3 1.346 3 3v3H9z">
            </path>
        </svg>
    }

    if (channelType === 'Open') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
            {...props}>
            <path d="M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm7.931 9h-2.764a14.67 14.67 0 0 0-1.792-6.243A8.013 8.013 0 0 1 19.931 11zM12.53 4.027c1.035 1.364 2.427 3.78 2.627 6.973H9.03c.139-2.596.994-5.028 2.451-6.974.172-.01.344-.026.519-.026.179 0 .354.016.53.027zm-3.842.7C7.704 6.618 7.136 8.762 7.03 11H4.069a8.013 8.013 0 0 1 4.619-6.273zM4.069 13h2.974c.136 2.379.665 4.478 1.556 6.23A8.01 8.01 0 0 1 4.069 13zm7.381 6.973C10.049 18.275 9.222 15.896 9.041 13h6.113c-.208 2.773-1.117 5.196-2.603 6.972-.182.012-.364.028-.551.028-.186 0-.367-.016-.55-.027zm4.011-.772c.955-1.794 1.538-3.901 1.691-6.201h2.778a8.005 8.005 0 0 1-4.469 6.201z">
            </path>
        </svg>
    }

    return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24"
        {...props}>
        <path d="M16.018 3.815 15.232 8h-4.966l.716-3.815-1.964-.37L8.232 8H4v2h3.857l-.751 4H3v2h3.731l-.714 3.805 1.965.369L8.766 16h4.966l-.714 3.805 1.965.369.783-4.174H20v-2h-3.859l.751-4H21V8h-3.733l.716-3.815-1.965-.37zM14.106 14H9.141l.751-4h4.966l-.752 4z">
        </path>
    </svg>
}

export default ChannelIcon
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\common\ErrorBanner.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 142 bytes
Content:
import React from 'react'

const ErrorBanner = () => {
    return (
        <div>ErrorBanner</div>
    )
}

export default ErrorBanner
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\common\FileExtensionIcon.jsx
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6939 bytes
Content:
import React, { useMemo } from 'react'

// <!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc

const getFileType = (ext) => {
    switch (ext) {
        case 'pdf': return 'pdf'
        case 'doc': return 'word'
        case 'docx': return 'word'
        case 'xls': return 'excel'
        case 'xlsx': return 'excel'
        case 'ppt': return 'powerpoint'
        case 'pptx': return 'powerpoint'
        case 'mp3': return 'audio'
        case 'wav': return 'audio'
        case 'ogg': return 'audio'
        case 'flac': return 'audio'
        case 'mp4': return 'video'
        case 'mkv': return 'video'
        case 'webm': return 'video'
        case 'avi': return 'video'
        case 'mov': return 'video'
        case 'jpeg': return 'image'
        case 'jpg': return 'image'
        case 'png': return 'image'
        default: return 'file'
    }
}
const FileExtensionIcon = ({ ext, size = '20', ...props }) => {

    const fileType = useMemo(() => getFileType(ext), [ext])

    if (fileType === 'pdf') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} {...props} viewBox="0 0 384 512">
            <path d="M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm250.2-143.7c-12.2-12-47-8.7-64.4-6.5-17.2-10.5-28.7-25-36.8-46.3 3.9-16.1 10.1-40.6 5.4-56-4.2-26.2-37.8-23.6-42.6-5.9-4.4 16.1-.4 38.5 7 67.1-10 23.9-24.9 56-35.4 74.4-20 10.3-47 26.2-51 46.2-3.3 15.8 26 55.2 76.1-31.2 22.4-7.4 46.8-16.5 68.4-20.1 18.9 10.2 41 17 55.8 17 25.5 0 28-28.2 17.5-38.7zm-198.1 77.8c5.1-13.7 24.5-29.5 30.4-35-19 30.3-30.4 35.7-30.4 35zm81.6-190.6c7.4 0 6.7 32.1 1.8 40.8-4.4-13.9-4.3-40.8-1.8-40.8zm-24.4 136.6c9.7-16.9 18-37 24.7-54.7 8.3 15.1 18.9 27.2 30.1 35.5-20.8 4.3-38.9 13.1-54.8 19.2zm131.6-5s-5 6-37.3-7.8c35.1-2.6 40.9 5.4 37.3 7.8z" /></svg>
    }
    if (fileType === 'excel') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} {...props} viewBox="0 0 384 512"><path d="M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm212-240h-28.8c-4.4 0-8.4 2.4-10.5 6.3-18 33.1-22.2 42.4-28.6 57.7-13.9-29.1-6.9-17.3-28.6-57.7-2.1-3.9-6.2-6.3-10.6-6.3H124c-9.3 0-15 10-10.4 18l46.3 78-46.3 78c-4.7 8 1.1 18 10.4 18h28.9c4.4 0 8.4-2.4 10.5-6.3 21.7-40 23-45 28.6-57.7 14.9 30.2 5.9 15.9 28.6 57.7 2.1 3.9 6.2 6.3 10.6 6.3H260c9.3 0 15-10 10.4-18L224 320c.7-1.1 30.3-50.5 46.3-78 4.7-8-1.1-18-10.3-18z" /></svg>
    }

    if (fileType === 'word') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} {...props} viewBox="0 0 384 512"><path d="M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm220.1-208c-5.7 0-10.6 4-11.7 9.5-20.6 97.7-20.4 95.4-21 103.5-.2-1.2-.4-2.6-.7-4.3-.8-5.1 .3 .2-23.6-99.5-1.3-5.4-6.1-9.2-11.7-9.2h-13.3c-5.5 0-10.3 3.8-11.7 9.1-24.4 99-24 96.2-24.8 103.7-.1-1.1-.2-2.5-.5-4.2-.7-5.2-14.1-73.3-19.1-99-1.1-5.6-6-9.7-11.8-9.7h-16.8c-7.8 0-13.5 7.3-11.7 14.8 8 32.6 26.7 109.5 33.2 136 1.3 5.4 6.1 9.1 11.7 9.1h25.2c5.5 0 10.3-3.7 11.6-9.1l17.9-71.4c1.5-6.2 2.5-12 3-17.3l2.9 17.3c.1 .4 12.6 50.5 17.9 71.4 1.3 5.3 6.1 9.1 11.6 9.1h24.7c5.5 0 10.3-3.7 11.6-9.1 20.8-81.9 30.2-119 34.5-136 1.9-7.6-3.8-14.9-11.6-14.9h-15.8z" /></svg>
    }

    if (fileType === 'powerpoint') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} {...props} viewBox="0 0 384 512"><path d="M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm72-60V236c0-6.6 5.4-12 12-12h69.2c36.7 0 62.8 27 62.8 66.3 0 74.3-68.7 66.5-95.5 66.5V404c0 6.6-5.4 12-12 12H132c-6.6 0-12-5.4-12-12zm48.5-87.4h23c7.9 0 13.9-2.4 18.1-7.2 8.5-9.8 8.4-28.5 .1-37.8-4.1-4.6-9.9-7-17.4-7h-23.9v52z" /></svg>
    }

    if (fileType === 'audio') {
        return <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" width={size} height={size} {...props}><path d="M369.9 97.9l-83.9-83.9A48 48 0 0 0 252.1 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9a48 48 0 0 0 -14.1-33.9zM332.1 128H256V51.9L332.1 128zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm144-76c0 10.7-12.9 16-20.5 8.5L136 360.5h-28c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h28l35.5-36.9c7.6-7.6 20.5-2.2 20.5 8.5v136zm41.2-47.1c9.1-9.3 9.1-24.1 0-33.4-22.1-22.8 12.2-56.2 34.4-33.5 27.2 27.9 27.2 72.4 0 100.4-21.8 22.4-56.9-10.3-34.4-33.5z" /></svg>
    }

    if (fileType === 'file') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} {...props} viewBox="0 0 384 512"><path d="M288 248v28c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-28c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm-12 72H108c-6.6 0-12 5.4-12 12v28c0 6.6 5.4 12 12 12h168c6.6 0 12-5.4 12-12v-28c0-6.6-5.4-12-12-12zm108-188.1V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V48C0 21.5 21.5 0 48 0h204.1C264.8 0 277 5.1 286 14.1L369.9 98c9 8.9 14.1 21.2 14.1 33.9zm-128-80V128h76.1L256 51.9zM336 464V176H232c-13.3 0-24-10.7-24-24V48H48v416h288z" /></svg>
    }

    if (fileType === 'video') {
        return <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} {...props} viewBox="0 0 384 512"><path d="M369.9 97.9l-83.9-83.9A48 48 0 0 0 252.1 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9a48 48 0 0 0 -14.1-33.9zM332.1 128H256V51.9L332.1 128z
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\ChannelList.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2344 bytes
Content:
import React from 'react'
import useChannelList from '../../hooks/useChannelList'
import useGetUser from '../../hooks/useGetUser'
import Avatar from '../common/Avatar'
import ChannelIcon from '../common/ChannelIcon'
import { useChannelUnreadCount } from '../../hooks/useUnreadCount'

const ChannelList = ({ onSelectChannel }) => {

    const { isLoading, channels, dm_channels } = useChannelList()

    return (
        <div className="raven-channel-list">
            {isLoading && <SkeletonLoader />}
            <h4>Channels</h4>
            {channels?.map(channel => <ChannelListItem key={channel.name} channel={channel} onClick={() => onSelectChannel(channel.name)} />)}
            <h4 style={{ paddingTop: '1rem' }}>Direct Messages</h4>
            {dm_channels?.map(channel => <DMChannelListItem key={channel.name} channel={channel} onClick={() => onSelectChannel(channel.name)} />)}
        </div>
    )
}

export default ChannelList


const SkeletonLoader = () => {

    return <>{Array.from({ length: 17 }).map((_, i) => <div key={i} className="raven-channel-list-item">
        <span className='skeleton'></span>
    </div>)}
    </>

}

const ChannelListItem = ({ channel, onClick }) => {

    const count = useChannelUnreadCount(channel.name)
    return <button className="raven-channel-list-item" onClick={onClick}>
        <div className='channel-label'>
            <span className='raven-channel-icon'>
                <ChannelIcon channelType={channel.channel_type} />
            </span>
            <span className="raven-channel-list-item__name">{channel.channel_name}</span>
        </div>
        <div>
            {count ? <span className="channel-unread-count">{count}</span> : null}
        </div>
    </button>
}

const DMChannelListItem = ({ channel, onClick }) => {

    const user = useGetUser(channel.peer_user_id)

    const count = useChannelUnreadCount(channel.name)

    return <button className="raven-channel-list-item" onClick={onClick}>
        <div className='channel-label'>
            <Avatar user={user} />
            <span className="raven-channel-list-item__name">{user?.full_name}</span>
        </div>
        <div>
            {count ? <span className="channel-unread-count">{count}</span> : null}
        </div>
    </button>
}
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\ChatInput\ChatInput.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2172 bytes
Content:
import React, { useEffect } from 'react'
// import FileUpload from './FileUpload'

const ChatInput = ({ channelID }) => {

    const [text, setText] = React.useState('')
    const sendMessage = () => {

        const content = text.trim()

        if (content.trim().length === 0) return

        frappe.call('raven.api.raven_message.send_message', {
            channel_id: channelID,
            text: content,
            json_content: {
                "content": [
                    {
                        "content": [
                            {
                                "text": content,
                                "type": "text"
                            }
                        ],
                        "type": "paragraph"
                    }
                ],
                "type": "doc"
            },
            is_reply: false,
        }).then(() => {
            setText('')
        })
    }

    return (
        <div className='raven-chat-input'>
            {/* <FileUpload channelID={channelID} /> */}
            <textarea type='text'
                className='form-control'
                rows='1'
                placeholder='Type a message...' value={text} onChange={(e) => setText(e.target.value)} onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                        sendMessage()
                    }
                }} />
            <div>
                <button onClick={sendMessage} className='btn btn-md icon-btn btn-default text-muted send-button'>
                    <svg xmlns="http://www.w3.org/2000/svg" className='icon icon-sm' viewBox="0 0 512 512"><path d="M440 6.5L24 246.4c-34.4 19.9-31.1 70.8 5.7 85.9L144 379.6V464c0 46.4 59.2 65.5 86.6 28.6l43.8-59.1 111.9 46.2c5.9 2.4 12.1 3.6 18.3 3.6 8.2 0 16.3-2.1 23.6-6.2 12.8-7.2 21.6-20 23.9-34.5l59.4-387.2c6.1-40.1-36.9-68.8-71.5-48.9zM192 464v-64.6l36.6 15.1L192 464zm212.6-28.7l-153.8-63.5L391 169.5c10.7-15.5-9.5-33.5-23.7-21.2L155.8 332.6 48 288 464 48l-59.4 387.3z" /></svg>
                </button>
            </div>

        </div>
    )

}

export default ChatInput
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\ChatInput\FileUpload.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 785 bytes
Content:
import React from 'react'

//TODO: This is not working yet
const FileUpload = ({ channelID }) => {

    const onClick = () => {
        new frappe.ui.FileUploader({
            doctype: "Raven Message",
            channelID: channelID,
            // docname: me.d,
            folder: "Home/Attachments",
            method: 'raven.api.upload_file.upload_file_with_message' + channelID,
            on_success(file_doc) {
                // me.attachments.attachment_uploaded(file_doc);
            },
        });
    }
    return <button className='btn btn-xs icon-btn btn-default' onClick={onClick}>
        <svg className="es-icon ml-0 icon-sm">
            <use href="#es-line-attachment"></use>
        </svg>
    </button>
}


export default FileUpload
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\ChatInput\Tiptap.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 450 bytes
Content:
import { Editor, EditorContent, EditorContext, Extension, ReactRenderer, useEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Underline from '@tiptap/extension-underline'
import Highlight from '@tiptap/extension-highlight'
import Link from '@tiptap/extension-link'
import Placeholder from '@tiptap/extension-placeholder'
import Mention from '@tiptap/extension-mention'
import { Plugin } from 'prosemirror-state'
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\ChatView.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 973 bytes
Content:
import React, { useEffect } from 'react'
import ChatInput from './ChatInput/ChatInput'
import MessageStream from './MessageStream/MessageStream'

const ChatView = ({ selectedChannel }) => {

    /**
     * We need to hide the chat interface after a delay if the selected channel is empty
     */
    const [show, setShow] = React.useState(selectedChannel ? true : false)

    useEffect(() => {
        if (!selectedChannel) {
            setTimeout(() => {
                setShow(false)
            }, 300)
        } else {
            setShow(true)
        }
    }, [selectedChannel])


    return (
        <div className={`raven-chat-view`}>
            {show &&
                <div className='raven-chat-view-container'>
                    <MessageStream channelID={selectedChannel} />
                    <ChatInput channelID={selectedChannel} />
                </div>
            }
        </div>
    )
}

export default ChatView
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\MessageRenderer\DateItem.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 480 bytes
Content:
import React from 'react'

const DateItem = ({ date }) => {
    return (
        <div className='raven-date-separator'>
            <div className='raven-date-separator-line'>

            </div>
            <div className='raven-date-separator-text'>
                {moment(date, frappe.defaultDatetimeFormat).format('Do MMMM YYYY')}
            </div>
            <div className='raven-date-separator-line'></div>
        </div>
    )
}

export default DateItem
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\MessageRenderer\MessageItem.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2619 bytes
Content:
import React from 'react'
import useGetUser from '../../../../hooks/useGetUser'
import Avatar from '../../../common/Avatar'
import ImageMessageBlock from './renderers/ImageMessageBlock'
import TiptapRenderer from './renderers/TiptapRenderer'
import FileMessageBlock from './renderers/FileMessageBlock'
const MessageItem = ({ message }) => {

    const { name, owner: userID, creation: timestamp, message_reactions, is_continuation, is_reply, linked_message } = message
    const { user, isActive } = useGetUserDetails(userID)

    const isOwner = frappe.session.user === userID

    return (
        <div style={{ paddingLeft: '4px', paddingRight: '4px  ' }} data-message-id={message.name} className='message-item'>
            <MessageLeftElement message={message} user={user} isActive={isActive} />
            <div>
                <MessageHeader message={message} user={user} />

                {/* Message content goes here */}

                {/* TODO: If it's a reply, then show the linked message */}

                {/* Show message according to type */}
                <MessageContent message={message} user={user} />

                {/** TODO: Show message reactions */}
            </div>
        </div>
    )
}

const useGetUserDetails = (userID) => {

    const user = useGetUser(userID)

    //TODO: Implement useIsUserActive
    // const isActive = useIsUserActive(userID)
    const isActive = false

    return { user, isActive }
}

const MessageLeftElement = ({ message, user, isActive }) => {
    return <div>
        {message.is_continuation ? <div style={{
            width: "1.8rem",
            height: "1.8rem",
        }}></div> :
            <Avatar user={user} isActive={isActive} />
        }
    </div>
}

const MessageHeader = ({ message, user }) => {
    if (message.is_continuation) return null
    return <div className='raven-message-item-header'>
        <span className='raven-message-item-header-name'>{user?.full_name}</span>
        <span className='raven-message-item-header-time'>{moment(message.creation, frappe.defaultDatetimeFormat).format('HH:mm A')}</span>
    </div>
}

const MessageContent = ({ message, user }) => {
    return <div>
        {message.text && <TiptapRenderer message={{
            ...message,
            message_type: 'Text'
        }} />}
        {message.message_type === 'Image' && <ImageMessageBlock message={message} user={user} />}
        {message.message_type === 'File' && <FileMessageBlock message={message} user={user} />}
    </div>
}

export default MessageItem
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\MessageRenderer\renderers\FileMessageBlock.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2087 bytes
Content:
import React, { memo } from 'react'
import { getFileExtension, getFileName, isVideoFile } from '../../../../../utils/operations'
import FileExtensionIcon from '../../../../common/FileExtensionIcon'

const FileMessageBlock = memo(({ message, user }) => {

    const fileExtension = getFileExtension(message.file)

    const fileName = getFileName(message.file)

    const isVideo = isVideoFile(fileExtension)

    const isPDF = fileExtension === 'pdf'

    if (isVideo) {
        return (
            <div
                style={{
                    display: "flex",
                    flexDirection: "column",
                    direction: "column",
                    gap: "4px",
                }}
            >
                <div>
                    <a
                        href={message.file}
                        target="_blank"
                        className="raven-message-image-link"
                        rel="noopener noreferrer"
                    >
                        {fileName}
                    </a>
                </div>
                <div>
                    <video src={message.file} controls width='320' style={{
                        borderRadius: "4px",
                    }}>

                    </video>
                </div>
            </div>
        )
    } else {
        return <div style={{
            display: 'flex',
            paddingTop: '8px',
            paddingBottom: '8px',
            flexDirection: 'row',
            alignContent: 'center',
            gap: '4px',
        }}>
            <FileExtensionIcon ext={fileExtension} size='18' />
            <a href={message.file} target={'_blank'}
                className="raven-message-image-link"
                rel="noopener noreferrer" style={{
                    lineClamp: '1',
                    textOverflow: 'ellipsis',
                    overflow: 'hidden',
                }}>
                {fileName}
            </a>
        </div>
    }


})

export default FileMessageBlock
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\MessageRenderer\renderers\ImageMessageBlock.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2475 bytes
Content:
import React, { memo } from "react";
import { getFileName } from "../../../../../utils/operations";

const ImageMessageBlock = memo(({ message, user }) => {
  const height = Number(message.thumbnail_height ?? "200") / 1.5;
  const width = Number(message.thumbnail_width ?? "300") / 1.5;

  const fileName = getFileName(message.file);

  const openImage = () => {
    let d = new frappe.ui.Dialog({
      title: "Image",
      size: "large",
      fields: [
        {
          fieldname: "image",
          fieldtype: "HTML",
          read_only: 1,
          options: `<div style="margin-left: auto; margin-right: auto; text-align: center;"><img src="${message.file}" style="margin-left: auto; margin-right: auto; max-width: auto; max-height: 70vh;" /></div>`,
        },
      ],
      primary_action_label: "Download",
      primary_action() {
        window.open(message.file, "_blank");
      },
    });

    d.show();
  };

  return (
    <div
      style={{
        display: "flex",
        flexDirection: "column",
        direction: "column",
        gap: "4px",
      }}
    >
      <div>
        <a
          href={message.file}
          target="_blank"
          className="raven-message-image-link"
          rel="noopener noreferrer"
        >
          {fileName}
        </a>
      </div>
      <div
        style={{
          position: "relative",
          height: `${height}px`,
          width: `${width}px`,
        }}
      >
        {/* Absolute positioned skeleton loader */}
        <div
          className="skeleton"
          style={{
            position: "absolute",
            top: "0",
            left: "0",
            height: `${height}px`,
            width: `${width}px`,
            borderRadius: "4px",
          }}
        ></div>

        <img
          src={message.file}
          loading="lazy"
          onClick={openImage}
          alt={`Image file sent by ${message.owner} at ${message.creation}`}
          style={{
            position: "absolute",
            top: "0",
            left: "0",
            cursor: "pointer",
            objectFit: "cover",
            minHeight: `${height}px`,
            minWidth: `${width}px`,
            borderRadius: "4px",
            maxHeight: `${height}px`,
            maxWidth: `${width}px`,
          }}
        />
      </div>
    </div>
  );
});

export default ImageMessageBlock;

--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\MessageRenderer\renderers\TiptapRenderer.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2898 bytes
Content:
import React from 'react'
import { EditorContent, EditorContext, useEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Link from '@tiptap/extension-link'
import Highlight from '@tiptap/extension-highlight'
import Mention from '@tiptap/extension-mention'
import Underline from '@tiptap/extension-underline'
export const CustomUserMention = Mention.extend({
    name: 'userMention',
})

export const CustomChannelMention = Mention.extend({
    name: 'channelMention',
})

const TiptapRenderer = ({ message, isTruncated = false, showLinkPreview = true }) => {

    const editor = useEditor({
        content: message.text,
        editable: false,
        editorProps: {
            attributes: {
                class: isTruncated ? 'line-clamp-3' : '',
            }
        },
        enableCoreExtensions: true,
        extensions: [
            StarterKit.configure({
                heading: false,
                codeBlock: false,
                bold: true,
                blockquote: true,
                italic: true,
                listItem: true,
                paragraph: {
                    HTMLAttributes: {
                        class: ''
                    }
                }
            }),
            Underline,
            Highlight.configure({
                multicolor: true,
                HTMLAttributes: {
                    // style: "background-color: var(--yellow-6); padding: 2px 4px;"
                    // class: 'bg-[var(--yellow-6)] dark:bg-[var(--yellow-11)] px-2 py-1'
                }
            }),
            Link.configure({
                HTMLAttributes: {
                    class: 'break-all'
                },
            }),
            CustomUserMention.configure({
                HTMLAttributes: {
                    class: 'user-mention'
                }
            }),
            //   CustomUnderline,
            //   CodeBlockLowlight.configure({
            //     lowlight
            //   }),
            //   CustomBlockquote,
            //   CustomBold,
            //   CustomUserMention,
            //   CustomLink,
            //   CustomItalic
            // TODO: Add channel mention
            // CustomChannelMention
        ]
    })
    return (
        <div className='raven-tiptap-renderer' style={{
            overflowX: 'hidden',
            width: '100%',
            textOverflow: 'ellipsis',
        }}>
            <EditorContext.Provider value={{ editor }}>
                <EditorContent
                    contentEditable={false}
                    editor={editor}
                    readOnly />
                {/* {showLinkPreview && <LinkPreview isScrolling={isScrolling} />} */}
            </EditorContext.Provider>
        </div>
    )
}

export default TiptapRenderer
--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Chat\MessageStream\MessageStream.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 2307 bytes
Content:
import React, { useLayoutEffect } from "react";
import { fetcher } from "../../../../hooks/useFetch";
import MessageItem from "../MessageRenderer/MessageItem";
import DateItem from "../MessageRenderer/DateItem";
import useSWRSubscription from "swr/subscription";
/** Fetches messages from the backend and renders them */
const MessageStream = ({ channelID }) => {
  const containerRef = React.useRef(null);

  const scrollToBottom = () => {
    const scrollHeight = containerRef.current?.scrollHeight;
    const height = containerRef.current?.clientHeight;
    containerRef.current?.scrollTo({
      top: scrollHeight - height,
      left: 0,
    });
  };

  const { data } = useSWRSubscription(
    `raven.api.raven_message.get_messages_with_dates?channel_id=${channelID}`,
    (key, { next }) => {
      //Initial load
      fetcher(key).then((data) => next(null, data));

      if (channelID) {
        frappe.socketio.doc_subscribe("Raven Channel", channelID);
        frappe.socketio.doc_open("Raven Channel", channelID)
        frappe.realtime.on("message_updated", (event) => {
          if (event.channel_id !== channelID) return
          fetcher(key).then((data) => next(null, data));
        });
      }

      return () => {
        frappe.realtime.off("message_updated");
        frappe.socketio.doc_close("Raven Channel", channelID);
        try {
          frappe.socketio.doc_unsubscribe("Raven Channel", channelID);
        } catch (e) {
          // console.log(e)
        }
      }
    }, { keepPreviousData: true }
  );

  useLayoutEffect(() => {
    // Wait for the content to paint before scrolling
    setTimeout(() => {
      scrollToBottom();
    }, 200);
  }, [scrollToBottom, data]);

  return (
    <div>
      {/* TODO: Add Loading and Error states */}
      <div className="raven-message-stream-container" ref={containerRef}>
        {data?.message.map((message) => {
          if (message.block_type === "date") {
            return <DateItem date={message.data} key={message.data} />;
          } else {
            return (
              <MessageItem message={message.data} key={message.data.name} />
            );
          }
        })}
      </div>
    </div>
  );
};

export default MessageStream;

--------------------------------------------------------------------------------

File: public\js\raven_chat\components\layout\Header.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 4418 bytes
Content:
import * as React from "react";
import useGetChannel from "../../hooks/useGetChannel";
import ChannelIcon from "../common/ChannelIcon";
import Avatar from "../common/Avatar";
import useGetUser from "../../hooks/useGetUser";
/**
 * Header will have the following:
 * - Logo
 * - TODO: Unread message count
 * - Expand button
 */
const Header = ({
    toggle, selectedChannel, isOpen, setSelectedChannel, unreadMessageCount
}) => {

    const closeChannel = () => {
        setSelectedChannel('')
    }

    const toggleRaven = () => {
        closeChannel()
        toggle()
    }

    return <div className="raven-header">
        {selectedChannel ? <ChannelHeader channelID={selectedChannel} onBackClick={closeChannel} /> :
            <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '0.2rem',
            }}>
                <span role='button' className="raven-logo cal-sans" onClick={toggle}>raven</span>

                <a href='/raven' target='_blank' className='btn btn-xs open-raven-button' style={{
                    lineHeight: '1.4rem',
                    // width: "24px",
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    // height: "24px",
                    // marginTop: '0.2rem',
                }} title='Open Raven'>
                    <svg
                        width="18"
                        height="18"
                        // fill='white'
                        viewBox="0 0 24 24"
                        // fill="none"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                            d="M15.6396 7.02527H12.0181V5.02527H19.0181V12.0253H17.0181V8.47528L12.1042 13.3892L10.6899 11.975L15.6396 7.02527Z"
                        // fill="currentColor"
                        />
                        <path
                            d="M10.9819 6.97473H4.98193V18.9747H16.9819V12.9747H14.9819V16.9747H6.98193V8.97473H10.9819V6.97473Z"
                        // fill="currentColor"
                        />
                    </svg>
                </a>
            </div>

        }
        <div>
            {unreadMessageCount ? <span className="raven-unread-count">{unreadMessageCount} unread</span> : null}
            <button className="btn btn-md back-button" onClick={toggleRaven}>
                {isOpen ?
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="m16.192 6.344-4.243 4.242-4.242-4.242-1.414 1.414L10.535 12l-4.242 4.242 1.414 1.414 4.242-4.242 4.243 4.242 1.414-1.414L13.364 12l4.242-4.242z"></path></svg>
                    :
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="m6.293 13.293 1.414 1.414L12 10.414l4.293 4.293 1.414-1.414L12 7.586z"></path></svg>
                }
            </button>
        </div>

    </div>
}

export default Header


const ChannelHeader = ({ channelID, onBackClick }) => {

    const channel = useGetChannel(channelID)

    return <div className="raven-channel-header">
        <button className="btn btn-md back-button" onClick={onBackClick}>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M13.293 6.293 7.586 12l5.707 5.707 1.414-1.414L10.414 12l4.293-4.293z"></path></svg>
        </button>

        {channel?.is_direct_message ? <DMChannelHeader channel={channel} /> :
            <a href={`/raven/channel/${channelID}`} target="_blank" title="Open channel in Raven">
                <ChannelIcon channelType={channel?.channel_type} />
                <span className="raven-channel-header-name cal-sans">{channel?.channel_name ?? channelID}</span>
            </a>

        }
    </div>
}

const DMChannelHeader = ({ channel }) => {

    const user = useGetUser(channel.peer_user_id)
    return <a title="Open channel in Raven" className="raven-dm-channel-header" href={`/raven/channel/${channel.name}`} target="_blank">
        <Avatar user={user} fallback={channel.peer_user_id} />
        <span className="raven-channel-header-name cal-sans">{user?.full_name ?? user?.name}</span>
    </a>

}
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useBoolean.js
Comments: Included
Mime Type: text/javascript
Size: 408 bytes
Content:
import { useState, useCallback } from "react";

const useBoolean = (initialValue = false) => {
    const [value, setValue] = useState(initialValue);

    const toggle = useCallback(() => setValue((v) => !v), []);

    const on = useCallback(() => setValue(true), []);
    const off = useCallback(() => setValue(false), []);

    return [value, { toggle, on, off }];
}

export default useBoolean;
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useChannelList.js
Comments: Included
Mime Type: text/javascript
Size: 645 bytes
Content:
import useSWR from "swr";
import { fetcher } from "./useFetch";
import useStartFetch from "./useStartFetch";

const useChannelList = (isOpen = false) => {
  /** Only fetch channels when Raven is first opened */
  const startFetch = useStartFetch();

  // TODO: Convert to a subscription so that channels are updated in real time
  const { data, isLoading, error } = useSWR(
    startFetch ? "raven.api.raven_channel.get_all_channels" : null,
    fetcher,
  );

  return {
    channels: data?.message?.channels,
    dm_channels: data?.message?.dm_channels,
    isLoading,
    error,
  };
};

export default useChannelList;

--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useCurrentChannel.js
Comments: Included
Mime Type: text/javascript
Size: 233 bytes
Content:
import { createContext, useContext } from "react";

const useCurrentChannel = () => {
    return useContext(CurrentChannelContext);
}

export default useCurrentChannel;

export const CurrentChannelContext = createContext('');
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useFetch.js
Comments: Included
Mime Type: text/javascript
Size: 83 bytes
Content:
import * as React from 'react';

export const fetcher = (api) => frappe.call(api)
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useGetChannel.js
Comments: Included
Mime Type: text/javascript
Size: 725 bytes
Content:
import { useMemo } from "react";
import useChannelList from "./useChannelList";

const useGetChannel = (channelID) => {

    const { channels, dm_channels } = useChannelList()

    const channelDetails = useMemo(() => {
        if (!channelID) {
            return null
        }

        const channel = channels.find(channel => channel.name === channelID)
        if (channel) {
            return channel
        }

        const dm_channel = dm_channels.find(dm_channel => dm_channel.name === channelID)
        if (dm_channel) {
            return dm_channel
        }

        return null
    }, [channels, dm_channels, channelID])

    return channelDetails
}

export default useGetChannel;
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useGetUser.js
Comments: Included
Mime Type: text/javascript
Size: 266 bytes
Content:
import useUserList from "./useUserList"

const useGetUser = (user_id = frappe.session.user) => {

    const { users = [] } = useUserList()

    const user = users?.message?.find(user => user.name === user_id)

    return user
}

export default useGetUser;
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useStartFetch.js
Comments: Included
Mime Type: text/javascript
Size: 362 bytes
Content:
import * as React from "react";

const useStartFetch = () => {
    return React.useContext(StartFetchContext)
}

export default useStartFetch;

/** Context to store whether the Raven chat module has been opened or not.
 * This is so that we can fetch data only when the module is opened.
 */
export const StartFetchContext = React.createContext(false)
--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useUnreadCount.js
Comments: Included
Mime Type: text/javascript
Size: 1137 bytes
Content:
import useSWRSubscription from "swr/subscription";
import { fetcher } from "./useFetch";

const useUnreadCount = () => {
  const { data } = useSWRSubscription(
    "raven.api.raven_message.get_unread_count_for_channels",
    (key, { next }) => {
      //Initial load
      fetcher(key).then((data) => next(null, data));

      frappe.realtime.on("raven:unread_channel_count_updated", (event) => {
        if (event.play_sound && event.sent_by !== frappe.session.user) {
          frappe.utils.play_sound("raven_notification");
        }
        fetcher(key).then((data) => next(null, data));
      });

      return () => frappe.realtime.off("raven:unread_channel_count_updated");
    },
  );

  const totalUnread = data?.message?.reduce((acc, c) => {
    return acc + c.unread_count
  }, 0)

  return {
    channels: data?.message ?? [],
    totalUnread,
  };
};

export const useChannelUnreadCount = (channelID) => {
  const data = useUnreadCount();

  return (
    data?.channels?.find((channel) => channel.name === channelID)
      ?.unread_count ?? 0
  );
};

export default useUnreadCount;

--------------------------------------------------------------------------------

File: public\js\raven_chat\hooks\useUserList.js
Comments: Included
Mime Type: text/javascript
Size: 615 bytes
Content:
import useSWR from "swr"
import { fetcher } from "./useFetch"
import useStartFetch from "./useStartFetch"

const useUserList = () => {

    /** Only fetch users when Raven is first opened */
    const startFetch = useStartFetch()

    const { data, error, isLoading } = useSWR(startFetch ? 'raven.api.raven_users.get_list' : null, fetcher, {
        revalidateOnFocus: false,
        revalidateOnMount: true,
        revalidateOnReconnect: false,
        revalidateIfStale: false,
    })

    return {
        users: data,
        isLoading,
        error
    }
}

export default useUserList;
--------------------------------------------------------------------------------

File: public\js\raven_chat\raven_chat.bundle.jsx
Comments: Included
Mime Type: application/octet-stream
Size: 510 bytes
Content:
import * as React from "react";
import { App } from "./App";
import { createRoot } from "react-dom/client";


class RavenChat {
	constructor({ wrapper }) {
		this.$wrapper = $(wrapper);

		this.init();
	}

	init() {
		this.setup_app();
	}

	setup_app() {
		// create and mount the react app
		const root = createRoot(this.$wrapper.get(0));
		root.render(<App />);
		this.$raven_chat = root;
	}
}

frappe.provide("frappe.ui");
frappe.ui.RavenChat = RavenChat;
export default RavenChat;
--------------------------------------------------------------------------------

File: public\js\raven_chat\utils\operations.js
Comments: Included
Mime Type: text/javascript
Size: 795 bytes
Content:
/* Function to return extension of a file
* @param filename name of the file with extension
* @returns extension
*/
export const getFileExtension = (filename) => {

    const extension = filename?.split('.').pop()?.toLocaleLowerCase() ?? ''
    return extension;
}

export const VIDEO_FORMATS = ['mp4', 'webm']
/**
* Function to check if a file is a video
* @param extension extension of the file
* @returns boolean
*/
export const isVideoFile = (ext) => {

    return VIDEO_FORMATS.includes(ext)
}

/**
* Function to return name of a file name without extension
* @param filename name of the file with extension
* @returns name of the file without extension
*/
export const getFileName = (filename) => {

    const name = filename?.split('/')[3]
    return name;
}
--------------------------------------------------------------------------------

File: public\js\templates\send_message.html
Comments: Included
Mime Type: text/html
Size: 4395 bytes
Content:
<div class="timeline-message-box" style="padding: 2px; overflow: hidden;">
    <div class="message-header"
        style="align-items: flex-start; margin-bottom: 10px; display: flex; flex-direction: column;">
        <div class="actions" style="flex-shrink: 0; display: flex; align-items: center; padding-bottom: 4px; padding-left: 2px;">

            {% if (is_direct_message) { %}
            <span style="font-weight: 500; font-size: 12px;">Direct Message with &nbsp;</span>
            {% } %}

            <a class="action-btn" href="/raven/channel/{{channel_id}}" title="Open {{ channel_name }}" target="_blank"
                style="text-decoration: underline; font-weight: 500; font-size: 12px; margin: 0;">
                {% if (is_direct_message) { %}
                <!-- split the channel_name check the  userID with owner theone which is not same display it's full_name -->
                {%var users = channel_name.split('_') %}
                {% var user_one = users[0].trim()%}
                {% var user_two = users[1].trim()%}
                {% if (user_one === owner) { %}
                {{peer_user}}
                {% } else { %}
                {{peer_user}}
                {% }%}
                {%} else { %}
                {% if(type == "Open"){ %}
                <i class="fa fa-globe"></i>
                {% } else if(type == "Private"){ %}
                <i class="fa fa-lock"></i>
                {% } else if(type == "Public"){ %}
                <i class="fa fa-hashtag"></i>
                {% } %}
                {{ channel_name }}
                {%} %}
            </a>
            <span class="text-muted" style="font-size: 12px; margin-left: 2px;">
                &nbsp;- {{ comment_when(creation) }}
            </span>

        </div>
        <div class="user-info" style="display: flex; align-items: flex-start;">
            <div class="user-avatar" style="flex-shrink: 0;">
            {{ frappe.avatar(owner, "avatar-medium") }}
            </div>
            <div class="user-details"
                style="display: flex; flex-direction: column; align-items: flex-start; margin-left: 8px; width: 90%;">
                <span style="font-weight: bold;">
                    {{ full_name || frappe.user.full_name(owner) }}
                </span>
                <span
                    style="font-weight: normal; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;">
                    {{text}}
                </span>
            </div>
        </div>
        </div>
        {% if (file && file.length) { %}
    <div style="margin-top: 10px">
        <div class="ellipsis flex">
            <a href="{%= encodeURI(file).replace(/#/g, \'%23\') %}" class="text-muted small" target="_blank"
                rel="noopener noreferrer">
                <svg viewBox="0 0 16 16" class="icon icon-xs" xmlns="http://www.w3.org/2000/svg">
                <path
                    d="M14 7.66625L8.68679 12.8875C7.17736 14.3708 4.64151 14.3708 3.13208 12.8875C1.62264 11.4042 1.62264 8.91224 3.13208 7.42892L7.84151 2.80099C8.9283 1.733 10.6189 1.733 11.7057 2.80099C12.7925 3.86897 12.7925 5.53028 11.7057 6.59827L7.35849 10.8109C6.75472 11.4042 5.78868 11.4042 5.24528 10.8109C4.64151 10.2176 4.64151 9.26823 5.24528 8.73424L8.86792 5.17429"
                    stroke="currentColor" stroke-miterlimit="10" stroke-linecap="round" />
                </svg>
            {%= file.split("/").slice(-1)[0] %}
            <svg class="icon icon-xs" style="color: var(--yellow-300)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
                <path fill-rule="evenodd" clip-rule="evenodd"
                    d="M8.077 1.45h-.055a3.356 3.356 0 00-3.387 3.322v.35H3.75a2 2 0 00-2 2v5.391a2 2 0 002 2h8.539a2 2 0 002-2V7.122a2 2 0 00-2-2h-.885v-.285A3.356 3.356 0 008.082 1.45h-.005zm2.327 3.672V4.83a2.356 2.356 0 00-2.33-2.38h-.06a2.356 2.356 0 00-2.38 2.33v.342h4.77zm-6.654 1a1 1 0 00-1 1v5.391a1 1 0 001 1h8.539a1 1 0 001-1V7.122a1 1 0 00-1-1H3.75zm4.27 4.269a.573.573 0 100-1.147.573.573 0 000 1.147zm1.573-.574a1.573 1.573 0 11-3.147 0 1.573 1.573 0 013.147 0z"
                    fill="currentColor" stroke="currentColor"></path>
            </svg>
            </a>
            </div>
    </div>
    {% } %}
</div>
--------------------------------------------------------------------------------

File: public\js\timeline_button.js
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/javascript
Size: 12695 bytes
Content:
// Timeline button for Frappe
$(document).on('app_ready', function () {
  $.each(frappe.boot.user.can_read, function (i, doctype) {
    let buttonAdded = false; // Track if the button has been added

    frappe.ui.form.on(doctype, {
      refresh: function (frm) {
        if (!frm.is_new()) {
          if (frm.footer?.frm?.timeline && !buttonAdded) {
            let send_message_modal = (channels) => {
              if (channels && channels.message && channels.message.length > 0) {
                let channel_id = [];
                let dm_list = [];
                let channel_list = [];

                channels.message.forEach((channel) => {
                  if (channel.is_direct_message) {
                    dm_list.push(channel.full_name);
                    channel_id.push({
                      value: channel.name,
                      name: channel.full_name,
                    });
                  } else {
                    channel_list.push(channel.channel_name);
                    channel_id.push({
                      value: channel.name,
                      name: channel.channel_name,
                    });
                  }
                });

                let setup_attach = () => {
                  const fields = dialog.fields_dict;
                  const attach = $(fields.select_attachments.wrapper);

                  if (!frm.attachments) {
                    frm.attachments = [];
                  }

                  let args = {
                    folder: 'Home/Attachments',
                    on_success: (attachment) => {
                      frm.attachments.push(attachment);
                      render_attachment_rows();
                    },
                  };

                  if (frm) {
                    args = {
                      doctype: frm.doctype,
                      docname: frm.docname,
                      folder: 'Home/Attachments',
                      on_success: (attachment) => {
                        frm.attachments.attachment_uploaded(attachment);
                        render_attachment_rows();
                      },
                    };
                  }

                  $(`
                    <label class="control-label">
                      ${__('Select Attachments')}
                    </label>
                    <div class='attach-list'></div>
                    <p class='add-more-attachments'>
                      <button class='btn btn-xs btn-default'>
                        ${frappe.utils.icon('small-add', 'xs')}&nbsp;
                        ${__('Add Attachment')}
                      </button>
                    </p>
                  `).appendTo(attach.empty());

                  attach
                    .find('.add-more-attachments button')
                    .on('click', () => new frappe.ui.FileUploader(args));
                  render_attachment_rows();
                };

                let render_attachment_rows = (attachment) => {
                  const select_attachments =
                    dialog.fields_dict.select_attachments;
                  const attachment_rows = $(select_attachments.wrapper).find(
                    '.attach-list'
                  );

                  // Clear existing attachments
                  attachment_rows.empty();

                  if (attachment) {
                    attachment_rows.append(
                      get_attachment_row(attachment, true)
                    );
                  } else {
                    let files = [];
                    // Add attachments from form
                    // check if attachment already exists in files array

                    if (frm.attachments && frm.attachments.length) {
                      // files = files.concat(frm.attachments);
                      files = files.concat(
                        frm.attachments.filter((attachment, index, array) => {
                          return !array
                            .slice(0, index)
                            .some(
                              (obj) => obj.file_name === attachment.file_name
                            );
                        })
                      );
                    }
                    if (frm) {
                      files = files.concat(frm.get_files());

                      files = files.filter((attachment, index, array) => {
                        return !array
                          .slice(0, index)
                          .some(
                            (obj) => obj.file_name === attachment.file_name
                          );
                      });
                    }

                    if (files.length) {
                      $.each(files, (i, f) => {
                        if (!f.file_name) return;
                        if (
                          !attachment_rows.find(`[data-file-name="${f.name}"]`)
                            .length
                        ) {
                          f.file_url = frappe.urllib.get_full_url(f.file_url);
                          attachment_rows.append(get_attachment_row(f));
                        }
                      });
                    }
                  }
                };

                let get_attachment_row = (attachment, checked) => {
                  const radioGroupName = 'attachmentRadioGroup';

                  return $(`
                    <p class="flex">
                      <label class="attachment-radio">
                        <input type="radio" name="${radioGroupName}"
                               data-file-name="${attachment.name}" ${checked ? 'checked' : ''
                    }>
                        </input>
                        <span class="ellipsis">${attachment.file_name}</span>
                      </label>
                      &nbsp;
                      <a href="${attachment.file_url
                    }" target="_blank" class="btn-linkF">
                
--------------------------------------------------------------------------------

File: public\manifest\android-chrome-192x192.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\android-chrome-512x512.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\apple-touch-icon.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\browserconfig.xml
Comments: Included
Mime Type: text/xml
Size: 255 bytes
Content:
<?xml version="1.0" encoding="utf-8"?>
<browserconfig>
    <msapplication>
        <tile>
            <square150x150logo src="/mstile-150x150.png"/>
            <TileColor>#da532c</TileColor>
        </tile>
    </msapplication>
</browserconfig>

--------------------------------------------------------------------------------

File: public\manifest\favicon-16x16.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\favicon-32x32.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\favicon-96x96.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\favicon.ico
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\favicon.svg
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\manifest\mstile-150x150.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\raven-logo.png
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\avatar.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\channels.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\chat.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\dateSeparator.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\header.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\message.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\scss\raven.bundle.scss
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: public\sounds\raven_notification.mp3
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_pinned_channels\raven_pinned_channels.json
Comments: Included
Mime Type: application/json
Size: 691 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-04-26 08:15:15.124114",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "channel_id"
 ],
 "fields": [
  {
   "fieldname": "channel_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Channel ID",
   "options": "Raven Channel",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-04-26 08:16:02.277627",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven Pinned Channels",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven\doctype\raven_pinned_channels\raven_pinned_channels.py
Comments: Included
Mime Type: text/x-python
Size: 538 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenPinnedChannels(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		channel_id: DF.Link
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven\doctype\raven_pinned_channels\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_pinned_messages\raven_pinned_messages.json
Comments: Included
Mime Type: application/json
Size: 691 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-10-13 16:40:20.096165",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "message_id"
 ],
 "fields": [
  {
   "fieldname": "message_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Message ID",
   "options": "Raven Message",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-10-13 16:41:54.688859",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven Pinned Messages",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven\doctype\raven_pinned_messages\raven_pinned_messages.py
Comments: Included
Mime Type: text/x-python
Size: 572 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenPinnedMessages(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		message_id: DF.Link
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven\doctype\raven_pinned_messages\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_push_token\raven_push_token.js
Comments: Included
Mime Type: text/javascript
Size: 230 bytes
Content:
// Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Push Token", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven\doctype\raven_push_token\raven_push_token.json
Comments: Included
Mime Type: application/json
Size: 1698 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2025-02-07 14:16:36.666515",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "user",
  "environment",
  "device_information",
  "column_break_wmua",
  "fcm_token"
 ],
 "fields": [
  {
   "fieldname": "user",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "User",
   "options": "User",
   "reqd": 1,
   "search_index": 1
  },
  {
   "default": "Web",
   "fieldname": "environment",
   "fieldtype": "Select",
   "in_list_view": 1,
   "label": "Environment",
   "options": "Web\nMobile",
   "reqd": 1
  },
  {
   "fieldname": "device_information",
   "fieldtype": "Data",
   "label": "Device Information",
   "length": 300
  },
  {
   "fieldname": "column_break_wmua",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "fcm_token",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "FCM Token",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-02-07 15:05:59.524997",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven Push Token",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "if_owner": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven\doctype\raven_push_token\raven_push_token.py
Comments: Included
Mime Type: text/x-python
Size: 3113 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import frappe
from frappe.model.document import Document

from raven.api.notification import are_push_notifications_enabled
from raven.notification import (
	clear_push_tokens_for_channel_cache,
	clear_push_tokens_for_user_cache,
)


class RavenPushToken(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		device_information: DF.Data | None
		environment: DF.Literal["Web", "Mobile"]
		fcm_token: DF.SmallText
		user: DF.Link
	# end: auto-generated types

	def after_insert(self):
		"""
		If the push service is Frappe Cloud and is enabled, then send the token to the Frappe Cloud API
		"""
		self.invalidate_cache()

		push_service = self.get_push_service()

		if push_service == "Frappe Cloud" and are_push_notifications_enabled():
			try:
				from frappe.push_notification import subscribe

				subscribe(self.fcm_token, "raven")
			except ImportError:
				# push notifications are not supported in the current framework version
				pass
			except Exception:
				frappe.log_error("Failed to subscribe to Frappe Cloud push notifications")

	def on_update(self):
		"""
		Invalidate the cache when the push token is updated
		"""
		self.invalidate_cache()

	def on_trash(self):
		"""
		If the push service is Frappe Cloud and is enabled, then delete the token from the Frappe Cloud API
		"""
		self.invalidate_cache()

		push_service = self.get_push_service()

		if push_service == "Frappe Cloud" and are_push_notifications_enabled():
			try:
				from frappe.push_notification import unsubscribe

				unsubscribe(self.fcm_token, "raven")
			except ImportError:
				# push notifications are not supported in the current framework version
				pass
			except Exception:
				frappe.log_error("Failed to unsubscribe from Frappe Cloud push notifications")

	def invalidate_cache(self):
		"""
		We need to invalidate the cache for the user and channels where the user is a member
		"""
		clear_push_tokens_for_user_cache(self.user)
		# Clear the cache for the channel if the user is a member of the channel
		channel_member = frappe.qb.DocType("Raven Channel Member")
		raven_user = frappe.qb.DocType("Raven User")

		query = (
			frappe.qb.from_(channel_member)
			.left_join(raven_user)
			.on(channel_member.user_id == raven_user.name)
			.where(raven_user.user == self.user)
			.select(channel_member.channel_id)
		)

		channel_ids = query.run(as_list=True)

		for channel_id in channel_ids:
			clear_push_tokens_for_channel_cache(channel_id[0])

	def get_push_service(self) -> str:
		"""
		Get the push service from the push service settings
		"""
		push_service = frappe.db.get_single_value("Raven Settings", "push_notification_service")

		if not push_service:
			push_service = "Frappe Cloud"

		return push_service

--------------------------------------------------------------------------------

File: raven\doctype\raven_push_token\test_raven_push_token.py
Comments: Included
Mime Type: text/x-python
Size: 845 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record dependencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class UnitTestRavenPushToken(UnitTestCase):
	"""
	Unit tests for RavenPushToken.
	Use this class for testing individual functions and methods.
	"""

	pass


class IntegrationTestRavenPushToken(IntegrationTestCase):
	"""
	Integration tests for RavenPushToken.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven\doctype\raven_push_token\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_settings\raven_settings.js
Comments: Included
Mime Type: text/javascript
Size: 194 bytes
Content:
// Copyright (c) 2023, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Settings", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven\doctype\raven_settings\raven_settings.json
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/json
Size: 7671 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2023-12-08 03:29:04.723967",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "auto_add_system_users",
  "show_raven_on_desk",
  "integrations_tab",
  "integrations_section",
  "tenor_api_key",
  "ai_section",
  "enable_ai_integration",
  "openai_organisation_id",
  "openai_api_key",
  "openai_project_id",
  "column_break_occp",
  "frappe_hr_tab",
  "auto_create_department_channel",
  "department_channel_type",
  "company_workspace_mapping",
  "attendance_and_leaves_section",
  "show_if_a_user_is_on_leave",
  "raven_mobile_tab",
  "oauth_client",
  "push_notifications_tab",
  "push_notification_service",
  "push_notification_server_url",
  "push_notification_api_key",
  "push_notification_api_secret",
  "config",
  "vapid_public_key",
  "video_calling_tab",
  "livekit_settings_section",
  "enable_video_calling_via_livekit",
  "livekit_url",
  "livekit_api_key",
  "livekit_api_secret"
 ],
 "fields": [
  {
   "default": "1",
   "fieldname": "auto_add_system_users",
   "fieldtype": "Check",
   "label": "Automatically add system users to Raven",
   "permlevel": 1
  },
  {
   "default": "1",
   "fieldname": "show_raven_on_desk",
   "fieldtype": "Check",
   "label": "Show Raven on Desk",
   "permlevel": 1
  },
  {
   "fieldname": "integrations_tab",
   "fieldtype": "Tab Break",
   "label": "Integrations"
  },
  {
   "fieldname": "tenor_api_key",
   "fieldtype": "Data",
   "label": "Tenor API Key",
   "length": 320,
   "permlevel": 1
  },
  {
   "fieldname": "integrations_section",
   "fieldtype": "Section Break"
  },
  {
   "fieldname": "frappe_hr_tab",
   "fieldtype": "Tab Break",
   "label": "Frappe HR"
  },
  {
   "default": "0",
   "description": "If checked, a channel will be created in Raven for each department and employees will be synced with Raven Users.",
   "fieldname": "auto_create_department_channel",
   "fieldtype": "Check",
   "label": "Automatically Create a Channel for each Department"
  },
  {
   "default": "Private",
   "depends_on": "eval:doc.auto_create_department_channel",
   "fieldname": "department_channel_type",
   "fieldtype": "Select",
   "label": "Department Channel Type",
   "options": "Public\nPrivate"
  },
  {
   "fieldname": "attendance_and_leaves_section",
   "fieldtype": "Section Break",
   "label": "Attendance and Leaves"
  },
  {
   "default": "1",
   "fieldname": "show_if_a_user_is_on_leave",
   "fieldtype": "Check",
   "label": "Show if a user is on leave"
  },
  {
   "fieldname": "ai_section",
   "fieldtype": "Section Break",
   "label": "AI"
  },
  {
   "default": "0",
   "fieldname": "enable_ai_integration",
   "fieldtype": "Check",
   "label": "Enable AI Integration"
  },
  {
   "depends_on": "eval:doc.enable_ai_integration;",
   "fieldname": "openai_organisation_id",
   "fieldtype": "Data",
   "label": "OpenAI Organisation ID",
   "mandatory_depends_on": "eval:doc.enable_ai_integration;"
  },
  {
   "depends_on": "eval:doc.enable_ai_integration;",
   "fieldname": "openai_api_key",
   "fieldtype": "Password",
   "label": "OpenAI API Key",
   "mandatory_depends_on": "eval:doc.enable_ai_integration;"
  },
  {
   "depends_on": "eval:doc.enable_ai_integration;",
   "description": "If not set, the integration will use the default project",
   "fieldname": "openai_project_id",
   "fieldtype": "Data",
   "label": "OpenAI Project ID"
  },
  {
   "fieldname": "column_break_occp",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "raven_mobile_tab",
   "fieldtype": "Tab Break",
   "label": "Raven Mobile"
  },
  {
   "fieldname": "oauth_client",
   "fieldtype": "Link",
   "label": "OAuth Client",
   "options": "OAuth Client"
  },
  {
   "depends_on": "eval:doc.auto_create_department_channel",
   "fieldname": "company_workspace_mapping",
   "fieldtype": "Table",
   "label": "Company Workspace Mapping",
   "mandatory_depends_on": "eval:doc.auto_create_department_channel",
   "options": "Raven HR Company Workspace"
  },
  {
   "fieldname": "push_notifications_tab",
   "fieldtype": "Tab Break",
   "label": "Push Notifications"
  },
  {
   "default": "Frappe Cloud",
   "fieldname": "push_notification_service",
   "fieldtype": "Select",
   "label": "Push Notification Service",
   "options": "Frappe Cloud\nRaven"
  },
  {
   "depends_on": "eval: doc.push_notification_service == \"Raven\";",
   "fieldname": "push_notification_server_url",
   "fieldtype": "Data",
   "label": "Push Notification Server URL",
   "length": 300,
   "mandatory_depends_on": "eval: doc.push_notification_service == \"Raven\";"
  },
  {
   "fieldname": "video_calling_tab",
   "fieldtype": "Tab Break",
   "label": "Video Calling"
  },
  {
   "fieldname": "livekit_settings_section",
   "fieldtype": "Section Break",
   "label": "LiveKit Settings"
  },
  {
   "default": "0",
   "fieldname": "enable_video_calling_via_livekit",
   "fieldtype": "Check",
   "label": "Enable Video Calling via LiveKit"
  },
  {
   "depends_on": "eval: doc.enable_video_calling_via_livekit;",
   "fieldname": "livekit_url",
   "fieldtype": "Data",
   "label": "LiveKit URL",
   "length": 300,
   "mandatory_depends_on": "eval: doc.enable_video_calling_via_livekit;"
  },
  {
   "depends_on": "eval: doc.enable_video_calling_via_livekit;",
   "fieldname": "livekit_api_key",
   "fieldtype": "Data",
   "label": "LiveKit API Key",
   "mandatory_depends_on": "eval: doc.enable_video_calling_via_livekit;"
  },
  {
   "depends_on": "eval: doc.enable_video_calling_via_livekit;",
   "fieldname": "livekit_api_secret",
   "fieldtype": "Password",
   "label": "LiveKit API Secret",
   "mandatory_depends_on": "eval: doc.enable_video_calling_via_livekit;"
  },
  {
   "depends_on": "eval: doc.push_notification_service == \"Raven\";",
   "fieldname": "push_notification_api_key",
   "fieldtype": "Data",
   "label": "Push Notification API Key",
   "mandatory_depends_on": "eval: doc.push_notification_service == \"Raven\";"
  },
  {
   
--------------------------------------------------------------------------------

File: raven\doctype\raven_settings\raven_settings.py
Comments: Included
Mime Type: text/x-python
Size: 2569 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document


class RavenSettings(Document):
	# begin: auto-generated types
	# ruff: noqa

	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_integrations.doctype.raven_hr_company_workspace.raven_hr_company_workspace import (
			RavenHRCompanyWorkspace,
		)

		auto_add_system_users: DF.Check
		auto_create_department_channel: DF.Check
		company_workspace_mapping: DF.Table[RavenHRCompanyWorkspace]
		config: DF.SmallText | None
		department_channel_type: DF.Literal["Public", "Private"]
		enable_ai_integration: DF.Check
		enable_video_calling_via_livekit: DF.Check
		livekit_api_key: DF.Data | None
		livekit_api_secret: DF.Password | None
		livekit_url: DF.Data | None
		oauth_client: DF.Link | None
		openai_api_key: DF.Password | None
		openai_organisation_id: DF.Data | None
		openai_project_id: DF.Data | None
		push_notification_api_key: DF.Data | None
		push_notification_api_secret: DF.Password | None
		push_notification_server_url: DF.Data | None
		push_notification_service: DF.Literal["Frappe Cloud", "Raven"]
		show_if_a_user_is_on_leave: DF.Check
		show_raven_on_desk: DF.Check
		tenor_api_key: DF.Data | None
		vapid_public_key: DF.Data | None
	# ruff: noqa
	# end: auto-generated types

	def validate(self):
		if self.auto_create_department_channel:
			if not self.company_workspace_mapping:
				frappe.throw(_("Please map the companies to the workspace before enabling this feature."))

			for row in self.company_workspace_mapping:
				# Check if the company exists since it's a Data field
				if not frappe.db.exists("Company", row.company):
					frappe.throw(f"Company {row.company} does not exist.")

		if self.push_notification_service == "Raven":
			if not self.push_notification_server_url:
				frappe.throw(_("Please enter the Push Notification Server URL"))
			if not self.push_notification_api_key:
				frappe.throw(_("Please enter the Push Notification API Key"))
			if not self.push_notification_api_secret:
				frappe.throw(_("Please enter the Push Notification API Secret"))
		if self.openai_organisation_id:
			self.openai_organisation_id = self.openai_organisation_id.strip()

		if self.openai_project_id:
			self.openai_project_id = self.openai_project_id.strip()

--------------------------------------------------------------------------------

File: raven\doctype\raven_settings\test_raven_settings.py
Comments: Included
Mime Type: text/x-python
Size: 197 bytes
Content:
# Copyright (c) 2023, The Commit Company and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenSettings(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven\doctype\raven_settings\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_user\patches\create_raven_users.py
Comments: Included
Mime Type: text/x-python
Size: 154 bytes
Content:
import frappe


def execute():
	"""Creates Raven User records for all existing users with the Raven User role"""

	# Write your patch here.
	pass

--------------------------------------------------------------------------------

File: raven\doctype\raven_user\patches\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_user\raven_user.js
Comments: Included
Mime Type: text/javascript
Size: 190 bytes
Content:
// Copyright (c) 2023, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven User", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven\doctype\raven_user\raven_user.json
Comments: Included
Mime Type: application/json
Size: 4032 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2023-09-06 14:36:48.631681",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "type",
  "user",
  "bot",
  "enabled",
  "last_mention_viewed_on",
  "column_break_dwio",
  "full_name",
  "first_name",
  "user_image",
  "html_xuuw",
  "pinned_channels_section",
  "pinned_channels",
  "user_status_section",
  "availability_status",
  "custom_status",
  "chat_style_section",
  "chat_style",
  "column_break_xlzh"
 ],
 "fields": [
  {
   "depends_on": "eval: doc.type == 'User'",
   "fieldname": "user",
   "fieldtype": "Link",
   "label": "User",
   "mandatory_depends_on": "eval: doc.type == 'User'",
   "options": "User",
   "unique": 1
  },
  {
   "fetch_from": "user.full_name",
   "fetch_if_empty": 1,
   "fieldname": "full_name",
   "fieldtype": "Data",
   "in_filter": 1,
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Full Name",
   "reqd": 1
  },
  {
   "fetch_from": "user.first_name",
   "fieldname": "first_name",
   "fieldtype": "Data",
   "label": "First Name"
  },
  {
   "fetch_from": ".",
   "fieldname": "user_image",
   "fieldtype": "Attach Image",
   "label": "User Image"
  },
  {
   "default": "1",
   "fieldname": "enabled",
   "fieldtype": "Check",
   "label": "Enabled",
   "read_only_depends_on": "eval: doc.type == \"User\";"
  },
  {
   "fieldname": "html_xuuw",
   "fieldtype": "HTML",
   "options": "<p>To disable the user from accessing Raven, go to \"Users\" and remove the \"Raven User\" role.</p>"
  },
  {
   "fieldname": "type",
   "fieldtype": "Select",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Type",
   "options": "User\nBot",
   "reqd": 1
  },
  {
   "depends_on": "eval: doc.type == 'Bot'",
   "fieldname": "bot",
   "fieldtype": "Link",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Bot",
   "mandatory_depends_on": "eval: doc.type == 'Bot'",
   "options": "Raven Bot",
   "read_only": 1
  },
  {
   "fieldname": "column_break_dwio",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "pinned_channels_section",
   "fieldtype": "Section Break",
   "label": "Pinned Channels"
  },
  {
   "fieldname": "pinned_channels",
   "fieldtype": "Table",
   "options": "Raven Pinned Channels"
  },
  {
   "fieldname": "availability_status",
   "fieldtype": "Select",
   "label": "Availability Status",
   "options": "\nAvailable\nAway\nDo not disturb\nInvisible"
  },
  {
   "fieldname": "custom_status",
   "fieldtype": "Data",
   "label": "Custom Status"
  },
  {
   "fieldname": "user_status_section",
   "fieldtype": "Section Break",
   "label": "User Status"
  },
  {
   "fieldname": "chat_style_section",
   "fieldtype": "Section Break",
   "label": "Chat Layout"
  },
  {
   "fieldname": "chat_style",
   "fieldtype": "Select",
   "label": "Chat Style",
   "options": "Simple\nLeft-Right"
  },
  {
   "fieldname": "column_break_xlzh",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "last_mention_viewed_on",
   "fieldtype": "Datetime",
   "label": "Last Mention Viewed On"
  }
 ],
 "grid_page_length": 50,
 "image_field": "user_image",
 "links": [],
 "modified": "2025-02-28 15:48:53.835541",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven User",
 "naming_rule": "By script",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "select": 1,
   "share": 1,
   "write": 1
  }
 ],
 "row_format": "Dynamic",
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": [],
 "title_field": "full_name"
}
--------------------------------------------------------------------------------

File: raven\doctype\raven_user\raven_user.py
Comments: Included
Mime Type: text/x-python
Size: 5341 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document


class RavenUser(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven.doctype.raven_pinned_channels.raven_pinned_channels import RavenPinnedChannels

		availability_status: DF.Literal["", "Available", "Away", "Do not disturb", "Invisible"]
		bot: DF.Link | None
		chat_style: DF.Literal["Simple", "Left-Right"]
		custom_status: DF.Data | None
		enabled: DF.Check
		first_name: DF.Data | None
		full_name: DF.Data
		last_mention_viewed_on: DF.Datetime | None
		pinned_channels: DF.Table[RavenPinnedChannels]
		type: DF.Literal["User", "Bot"]
		user: DF.Link | None
		user_image: DF.AttachImage | None
	# end: auto-generated types

	def autoname(self):
		if self.type == "Bot":
			self.name = self.bot
		else:
			self.name = self.user

	def before_validate(self):
		if self.user:
			self.type = "User"
		if not self.full_name:
			self.full_name = self.first_name

	def validate(self):
		if self.type == "Bot" and not self.bot:
			frappe.throw(_("Bot is mandatory"))

		if self.type == "User" and not self.user:
			frappe.throw(_("User is mandatory"))

	def before_insert(self):
		if self.type != "Bot":
			self.update_photo_from_user()

	def after_insert(self):
		self.invalidate_user_list_cache()

	def on_update(self):
		self.invalidate_user_list_cache()

	def on_trash(self):
		"""
		Remove the Raven User from all channels
		"""
		frappe.db.delete("Raven Channel Member", {"user_id": self.user})

	def after_delete(self):
		"""
		Remove the Raven User role from the user.
		"""
		if self.user:
			user = frappe.get_doc("User", self.user)
			user.flags.ignore_permissions = True
			user.flags.deleting_raven_user = True
			user.remove_roles("Raven User")
			user.save()

		self.invalidate_user_list_cache()

	def invalidate_user_list_cache(self):

		from raven.api.raven_users import get_users

		get_users.clear_cache()

	def update_photo_from_user(self):
		"""
		We need to create a new File record for the user image and attach it to the Raven User record.
		Why not just copy the URL from the User record? Because the URL is not accessible to the Raven User,
		and Frappe creates a duplicate file in the system (that is public) but does not update the URL in the field.
		"""
		user_image = frappe.db.get_value("User", self.user, "user_image")
		if user_image and not self.user_image:
			image_file = frappe.get_doc(
				{
					"doctype": "File",
					"file_url": user_image,
					"attached_to_doctype": "Raven User",
					"attached_to_name": self.user,
					"attached_to_field": "user_image",
					"is_private": 1,
				}
			).insert(ignore_permissions=True)
			self.user_image = image_file.file_url


def add_user_to_raven(doc, method):
	# called when the user is inserted or updated
	# If the auto-create setting is set to True, check if the user is a System user. If yes, then create a Raven User record for the user.
	# Else, check if the user has a Raven User role. If yes, then create a Raven User record for the user if not already created.

	# If the user is already added to Raven, do nothing.
	if not doc.flags.deleting_raven_user:
		if frappe.db.exists("Raven User", {"user": doc.name}):
			# Check if the role is still present. If not, then inactivate the Raven User record.
			has_raven_role = False
			for role in doc.get("roles"):
				if role.role == "Raven User":
					has_raven_role = True
					break

			if has_raven_role:
				raven_user = frappe.get_doc("Raven User", {"user": doc.name})
				if not doc.full_name:
					raven_user.full_name = doc.first_name
				raven_user.enabled = doc.enabled
				raven_user.save(ignore_permissions=True)
			else:
				raven_user = frappe.get_doc("Raven User", {"user": doc.name})
				if not doc.full_name:
					raven_user.full_name = doc.first_name
				raven_user.enabled = 0
				raven_user.save(ignore_permissions=True)
		else:
			# Raven user does not exist.
			# Only create raven user if it exists in the system.
			if frappe.db.exists("User", doc.name):
				# Check if the user is a system user.
				auto_add = False
				if doc.user_type == "System User":
					auto_add = frappe.db.get_single_value("Raven Settings", "auto_add_system_users")

				if auto_add or "Raven User" in [d.role for d in doc.get("roles")]:
					doc.append("roles", {"role": "Raven User"})
					# Create a Raven User record for the user.
					raven_user = frappe.new_doc("Raven User")
					raven_user.user = doc.name
					if not doc.full_name:
						raven_user.full_name = doc.first_name
					raven_user.enabled = doc.enabled
					raven_user.insert(ignore_permissions=True)


def remove_user_from_raven(doc, method):
	# called when the user is deleted
	# If the user is deleted, then delete the Raven User record for the user.
	if frappe.db.exists("Raven User", {"user": doc.name}):
		raven_user = frappe.get_doc("Raven User", {"user": doc.name})
		raven_user.delete(ignore_permissions=True)

--------------------------------------------------------------------------------

File: raven\doctype\raven_user\test_raven_user.py
Comments: Included
Mime Type: text/x-python
Size: 985 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record depdendencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class TestRavenUser(UnitTestCase):
	"""
	Unit tests for RavenUser.
	Use this class for testing individual functions and methods.
	"""

	pass


class TestRavenUser(IntegrationTestCase):
	"""
	Integration tests for RavenUser.
	Use this class for testing interactions between multiple components.
	"""

	def test_user_name(self):
		user = frappe.get_doc("Raven User", "test@example.com")
		self.assertEqual(user.name, "test@example.com")
		self.assertEqual(user.full_name, "_Test")

--------------------------------------------------------------------------------

File: raven\doctype\raven_user\test_records.json
Comments: Included
Mime Type: application/json
Size: 404 bytes
Content:
[
    {
        "doctype": "Raven User",
        "user": "test@example.com",
        "type": "User",
        "enabled": 1
    },
    {
        "doctype": "Raven User",
        "user": "test1@example.com",
        "type": "User",
        "enabled": 1
    },
    {
        "doctype": "Raven User",
        "user": "test2@example.com",
        "type": "User",
        "enabled": 1
    }
]
--------------------------------------------------------------------------------

File: raven\doctype\raven_user\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace\raven_workspace.js
Comments: Included
Mime Type: text/javascript
Size: 229 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Workspace", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace\raven_workspace.json
Comments: Included
Mime Type: application/json
Size: 2383 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:workspace_name",
 "creation": "2024-10-22 19:44:29.264507",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "workspace_name",
  "type",
  "can_only_join_via_invite",
  "description",
  "column_break_svnf",
  "logo",
  "only_admins_can_create_channels"
 ],
 "fields": [
  {
   "default": "Private",
   "fieldname": "type",
   "fieldtype": "Select",
   "in_list_view": 1,
   "label": "Type",
   "options": "Public\nPrivate",
   "reqd": 1
  },
  {
   "default": "0",
   "fieldname": "can_only_join_via_invite",
   "fieldtype": "Check",
   "label": "Can only join via invite?"
  },
  {
   "fieldname": "column_break_svnf",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "logo",
   "fieldtype": "Attach Image",
   "label": "Logo"
  },
  {
   "fieldname": "workspace_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Workspace Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "fieldname": "description",
   "fieldtype": "Small Text",
   "label": "Description"
  },
  {
   "default": "0",
   "description": "If unchecked, any workspace member can create a channel",
   "fieldname": "only_admins_can_create_channels",
   "fieldtype": "Check",
   "label": "Only allow admins to create channels in the workspace"
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [
  {
   "link_doctype": "Raven Workspace Member",
   "link_fieldname": "workspace"
  }
 ],
 "make_attachments_public": 1,
 "modified": "2025-02-15 17:41:08.057640",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven Workspace",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  },
  {
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  }
 ],
 "quick_entry": 1,
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace\raven_workspace.py
Comments: Included
Mime Type: text/x-python
Size: 1432 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import frappe
from frappe.model.document import Document


class RavenWorkspace(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		can_only_join_via_invite: DF.Check
		description: DF.SmallText | None
		logo: DF.AttachImage | None
		only_admins_can_create_channels: DF.Check
		type: DF.Literal["Public", "Private"]
		workspace_name: DF.Data
	# end: auto-generated types

	def after_insert(self):
		if not frappe.flags.in_patch:
			self.create_member_for_owner()

	def on_trash(self):
		# Delete all members when the workspace is deleted
		frappe.db.delete("Raven Workspace Member", {"workspace": self.name})
		# Delete all channels when the workspace is deleted
		channels = frappe.db.get_all("Raven Channel", {"workspace": self.name})
		for channel in channels:
			# use delete doc to delete the channel ,it's members and messages
			frappe.delete_doc("Raven Channel", channel.name)

	def create_member_for_owner(self):
		member = frappe.new_doc("Raven Workspace Member")
		member.workspace = self.name
		member.user = self.owner
		member.is_admin = True
		member.insert(ignore_permissions=True)

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace\test_raven_workspace.py
Comments: Included
Mime Type: text/x-python
Size: 2176 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record depdendencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class TestRavenWorkspace(UnitTestCase):
	"""
	Unit tests for RavenWorkspace.
	Use this class for testing individual functions and methods.
	"""

	pass


class TestRavenWorkspace(IntegrationTestCase):
	"""
	Integration tests for RavenWorkspace.
	Use this class for testing interactions between multiple components.
	"""

	def test_create_workspace_member_for_owner(self):
		"""
		Test that when a workspace is created, a member is created for the owner.
		"""

		workspace = frappe.get_doc(
			{
				"doctype": "Raven Workspace",
				"workspace_name": "Test Workspace",
				"type": "Public",
			}
		)

		workspace.insert()

		member = frappe.get_doc(
			"Raven Workspace Member", {"workspace": workspace.name, "user": workspace.owner}
		)
		self.assertTrue(member.is_admin)

		workspace.delete()

	def test_delete_workspace(self):
		"""
		Test that when a workspace is deleted, all its members and channels are also deleted.
		"""
		workspace = frappe.get_doc(
			{
				"doctype": "Raven Workspace",
				"workspace_name": "Test Workspace",
				"type": "Public",
			}
		)

		workspace.insert()

		member = frappe.get_doc(
			"Raven Workspace Member", {"workspace": workspace.name, "user": workspace.owner}
		)

		# Create a channel
		channel = frappe.get_doc(
			{
				"doctype": "Raven Channel",
				"channel_name": "Test Channel",
				"workspace": workspace.name,
			}
		)

		channel.insert()

		workspace.delete()

		self.assertRaises(frappe.DoesNotExistError, frappe.get_doc, "Raven Channel", channel.name)
		self.assertRaises(
			frappe.DoesNotExistError, frappe.get_doc, "Raven Workspace Member", member.name
		)

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace\test_records.json
Comments: Included
Mime Type: application/json
Size: 335 bytes
Content:
[
    {
        "doctype": "Raven Workspace",
        "workspace_name": "Public Workspace",
        "owner": "test@example.com",
        "type": "Public"
    },
    {
        "doctype": "Raven Workspace",
        "workspace_name": "Private Workspace",
        "owner": "test@example.com",
        "type": "Private"
    }
]
--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace_member\raven_workspace_member.js
Comments: Included
Mime Type: text/javascript
Size: 236 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Workspace Member", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace_member\raven_workspace_member.json
Comments: Included
Mime Type: application/json
Size: 1707 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2024-10-22 19:46:38.547781",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "user",
  "is_admin",
  "column_break_nuhn",
  "workspace"
 ],
 "fields": [
  {
   "fieldname": "user",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "User",
   "options": "Raven User",
   "reqd": 1
  },
  {
   "fieldname": "column_break_nuhn",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "workspace",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Workspace",
   "options": "Raven Workspace",
   "reqd": 1,
   "search_index": 1
  },
  {
   "default": "0",
   "fieldname": "is_admin",
   "fieldtype": "Check",
   "label": "Is Admin"
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-11-15 13:11:09.674714",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven Workspace Member",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "select": 1,
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "quick_entry": 1,
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace_member\raven_workspace_member.py
Comments: Included
Mime Type: text/x-python
Size: 3175 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document

from raven.utils import delete_channel_members_cache, delete_workspace_members_cache


class RavenWorkspaceMember(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		is_admin: DF.Check
		user: DF.Link
		workspace: DF.Link
	# end: auto-generated types

	def validate(self):
		# Check if the user is already a member of the workspace
		conditions = {"workspace": self.workspace, "user": self.user}

		if self.name:
			conditions["name"] = ["!=", self.name]
		if frappe.db.exists("Raven Workspace Member", conditions):
			frappe.throw(_("User is already a member of the workspace"))

		self.validate_other_admins_exist()

	def validate_other_admins_exist(self):
		"""
		Check if there are other admins in the workspace
		"""
		if self.has_value_changed("is_admin") and not self.is_admin:
			other_admins = frappe.db.count(
				"Raven Workspace Member",
				{"workspace": self.workspace, "is_admin": True, "name": ["!=", self.name]},
			)
			if other_admins == 0:
				frappe.throw(
					_(
						"You cannot delete the last admin of the workspace. Please assign another user as the admin, or delete the workspace instead."
					)
				)

	def after_insert(self):
		self.invalidate_workspace_members_cache()

	def on_update(self):
		self.invalidate_workspace_members_cache()

	def on_trash(self):
		self.check_last_admin()
		self.delete_channel_members_for_user()
		self.invalidate_workspace_members_cache()

	def check_last_admin(self):
		"""
		Check if the user is the last admin of the workspace
		"""
		other_admin = frappe.db.count(
			"Raven Workspace Member",
			{"workspace": self.workspace, "is_admin": True, "name": ["!=", self.name]},
		)
		if other_admin == 0:
			frappe.throw(
				_(
					"You cannot delete the last admin of the workspace. Please assign another user as the admin, or delete the workspace instead."
				)
			)

	def delete_channel_members_for_user(self):
		"""
		Delete all channel members for this user in this workspace
		"""
		workspace_channels = frappe.get_all("Raven Channel", {"workspace": self.workspace}, pluck="name")
		for channel in workspace_channels:
			frappe.db.delete("Raven Channel Member", {"channel_id": channel, "user_id": self.user})
			if not self.flags.ignore_cache_invalidation:
				delete_channel_members_cache(channel)

	def invalidate_workspace_members_cache(self):
		"""
		Invalidate the workspace members cache
		"""
		if not self.flags.ignore_cache_invalidation:
			delete_workspace_members_cache(self.workspace)


def on_doctype_update():
	"""
	Add indexes to Raven Workspace Member table
	"""
	# Index the selector first for faster queries (less rows to sort in the next step)
	frappe.db.add_index("Raven Workspace Member", ["workspace", "user"])

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace_member\test_raven_workspace_member.py
Comments: Included
Mime Type: text/x-python
Size: 855 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record depdendencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class TestRavenWorkspaceMember(UnitTestCase):
	"""
	Unit tests for RavenWorkspaceMember.
	Use this class for testing individual functions and methods.
	"""

	pass


class TestRavenWorkspaceMember(IntegrationTestCase):
	"""
	Integration tests for RavenWorkspaceMember.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven\doctype\raven_workspace_member\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\doctype\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\module_onboarding\raven\raven.json
Comments: Included
Mime Type: application/json
Size: 713 bytes
Content:
{
 "allow_roles": [
  {
   "role": "Raven User"
  }
 ],
 "creation": "2023-12-08 06:50:09.241858",
 "docstatus": 0,
 "doctype": "Module Onboarding",
 "documentation_url": "https://thecommit.company/raven",
 "idx": 0,
 "is_complete": 0,
 "modified": "2025-01-06 19:31:16.034565",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven",
 "owner": "Administrator",
 "steps": [
  {
   "step": "Introduction to Raven"
  },
  {
   "step": "Adding Users to Raven"
  },
  {
   "step": "Review Raven Settings"
  },
  {
   "step": "Access the Web App"
  }
 ],
 "subtitle": "Simple, work messaging tool",
 "success_message": "Raven is setup!",
 "title": "Let's setup Raven"
}
--------------------------------------------------------------------------------

File: raven\onboarding_step\access_the_web_app\access_the_web_app.json
Comments: Included
Mime Type: application/json
Size: 807 bytes
Content:
{
 "action": "Go to Page",
 "action_label": "Go to Raven",
 "callback_message": "To open Raven, click <a href=\"/raven\">here</a>.",
 "callback_title": "Access Raven",
 "creation": "2025-01-06 19:30:54.625335",
 "description": "### Access the web and mobile apps\n\n\nRaven is available at <a href=\"/raven\">**/raven**</a> for both web and mobile. On mobile, Raven can be installed as a PWA.",
 "docstatus": 0,
 "doctype": "Onboarding Step",
 "idx": 0,
 "is_complete": 0,
 "is_single": 0,
 "is_skipped": 0,
 "modified": "2025-01-06 19:30:57.661888",
 "modified_by": "Administrator",
 "name": "Access the Web App",
 "owner": "Administrator",
 "path": "/raven",
 "show_form_tour": 0,
 "show_full_form": 0,
 "title": "It's time. Send a Raven.",
 "validate_action": 1,
 "video_url": ""
}
--------------------------------------------------------------------------------

File: raven\onboarding_step\adding_users_to_raven\adding_users_to_raven.json
Comments: Included
Mime Type: application/json
Size: 700 bytes
Content:
{
 "action": "Update Settings",
 "action_label": "Add Users to Raven",
 "creation": "2023-12-08 06:59:16.143823",
 "description": "## Adding Users\n\nTo access Raven, users need to have the **Raven User** role.\n\nGo to the \"Users\" list and add the role to the users you want on Raven.",
 "docstatus": 0,
 "doctype": "Onboarding Step",
 "idx": 3,
 "is_complete": 0,
 "is_single": 0,
 "is_skipped": 0,
 "modified": "2023-12-08 07:02:54.468980",
 "modified_by": "Administrator",
 "name": "Adding Users to Raven",
 "owner": "Administrator",
 "reference_document": "User",
 "show_form_tour": 0,
 "show_full_form": 0,
 "title": "Add users",
 "validate_action": 0,
 "video_url": ""
}
--------------------------------------------------------------------------------

File: raven\onboarding_step\introduction_to_raven\introduction_to_raven.json
Comments: Included
Mime Type: application/json
Size: 1336 bytes
Content:
{
 "action": "Go to Page",
 "action_label": "Go to Raven",
 "callback_message": "To open Raven, click <a href=\"/raven\">here</a>.",
 "callback_title": "Open Raven",
 "creation": "2023-12-08 06:50:01.432686",
 "description": "## Channels\n\nRaven helps you and your team communicate with each other.\n\nConversation happen in **channels**. \n\nAll users who have access to Raven can view and send messages in **Open** channels. \n\n**Public** channels are visible to everyone, but only members can take send messages in them. Any user can join public channels. \n\n**Private** channels are only visible to members and new members can only be added by the channel admin - which is the creator of the channel. \n\nYou could also send messages to other users privately via **Direct messages** - including yourself!\n\nA user could create as many channels and add as many users as they want to in them. ",
 "docstatus": 0,
 "doctype": "Onboarding Step",
 "idx": 3,
 "is_complete": 0,
 "is_single": 0,
 "is_skipped": 0,
 "modified": "2025-01-05 22:15:53.556516",
 "modified_by": "Administrator",
 "name": "Introduction to Raven",
 "owner": "Administrator",
 "path": "/raven",
 "show_form_tour": 0,
 "show_full_form": 0,
 "title": "Understanding Channels",
 "validate_action": 1,
 "video_url": "https://ravenapp.info"
}
--------------------------------------------------------------------------------

File: raven\onboarding_step\review_raven_settings\review_raven_settings.json
Comments: Included
Mime Type: application/json
Size: 784 bytes
Content:
{
 "action": "Update Settings",
 "action_label": "View Raven Settings",
 "creation": "2023-12-08 07:03:43.811343",
 "description": "## Raven Settings\n\n\n<em>**Automatically adding users to Raven**</em>\n\nTo make it easy for you, the Raven User role is assigned to any user who has access to Desk. If you wish to turn this off, please head to Raven Settings.",
 "docstatus": 0,
 "doctype": "Onboarding Step",
 "idx": 3,
 "is_complete": 0,
 "is_single": 1,
 "is_skipped": 0,
 "modified": "2023-12-08 07:06:36.907853",
 "modified_by": "Administrator",
 "name": "Review Raven Settings",
 "owner": "Administrator",
 "path": "",
 "reference_document": "Raven Settings",
 "show_form_tour": 0,
 "show_full_form": 0,
 "title": "Review Settings",
 "validate_action": 0
}
--------------------------------------------------------------------------------

File: raven\page\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven\workspace\raven\raven.json
Comments: Included
Mime Type: application/json
Size: 4531 bytes
Content:
{
 "app": "raven",
 "charts": [],
 "content": "[{\"id\":\"MKitHAnT4f\",\"type\":\"header\",\"data\":{\"text\":\"<span class=\\\"h4\\\"><a href=\\\"/raven\\\">Raven</a></span>\",\"col\":12}},{\"id\":\"gBy2HFBNf4\",\"type\":\"onboarding\",\"data\":{\"onboarding_name\":\"Raven\",\"col\":12}},{\"id\":\"ZcawYU5brv\",\"type\":\"card\",\"data\":{\"card_name\":\"DocTypes\",\"col\":4}},{\"id\":\"Uox8EFjnuM\",\"type\":\"card\",\"data\":{\"card_name\":\"AI\",\"col\":4}},{\"id\":\"F85-QVSjIb\",\"type\":\"card\",\"data\":{\"card_name\":\"Integrations\",\"col\":4}}]",
 "creation": "2023-06-22 20:12:29.687295",
 "custom_blocks": [],
 "docstatus": 0,
 "doctype": "Workspace",
 "for_user": "",
 "hide_custom": 0,
 "icon": "message-1",
 "idx": 0,
 "is_hidden": 0,
 "label": "Raven",
 "links": [
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "AI",
   "link_count": 4,
   "link_type": "DocType",
   "onboard": 0,
   "type": "Card Break"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Bots",
   "link_count": 0,
   "link_to": "Raven Bot",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Functions",
   "link_count": 0,
   "link_to": "Raven AI Function",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Instruction Templates",
   "link_count": 0,
   "link_to": "Raven Bot Instruction Template",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Saved Prompts",
   "link_count": 0,
   "link_to": "Raven Bot AI Prompt",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "DocTypes",
   "link_count": 8,
   "link_type": "DocType",
   "onboard": 0,
   "type": "Card Break"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Raven Users",
   "link_count": 0,
   "link_to": "Raven User",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Workspaces",
   "link_count": 0,
   "link_to": "Raven Workspace",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Workspace Members",
   "link_count": 0,
   "link_to": "Raven Workspace Member",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Channels",
   "link_count": 0,
   "link_to": "Raven Channel",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Members",
   "link_count": 0,
   "link_to": "Raven Channel Member",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Messages",
   "link_count": 0,
   "link_to": "Raven Message",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Message Reactions",
   "link_count": 0,
   "link_to": "Raven Message Reaction",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Raven Settings",
   "link_count": 0,
   "link_to": "Raven Settings",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Integrations",
   "link_count": 2,
   "link_type": "DocType",
   "onboard": 0,
   "type": "Card Break"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Message Actions",
   "link_count": 0,
   "link_to": "Raven Message Action",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  },
  {
   "hidden": 0,
   "is_query_report": 0,
   "label": "Document Notifications",
   "link_count": 0,
   "link_to": "Raven Document Notification",
   "link_type": "DocType",
   "onboard": 0,
   "type": "Link"
  }
 ],
 "modified": "2024-12-15 19:43:38.989720",
 "modified_by": "Administrator",
 "module": "Raven",
 "name": "Raven",
 "number_cards": [],
 "owner": "Administrator",
 "parent_page": "",
 "public": 1,
 "quick_lists": [],
 "roles": [],
 "sequence_id": 30.0,
 "shortcuts": [],
 "title": "Raven",
 "type": "Workspace"
}
--------------------------------------------------------------------------------

File: raven\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_bot_files\raven_ai_bot_files.json
Comments: Included
Mime Type: application/json
Size: 735 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2025-05-10 18:29:14.415518",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "file"
 ],
 "fields": [
  {
   "fieldname": "file",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "File",
   "options": "Raven AI File Source",
   "reqd": 1
  }
 ],
 "grid_page_length": 50,
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2025-05-10 18:29:34.419381",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven AI Bot Files",
 "owner": "Administrator",
 "permissions": [],
 "row_format": "Dynamic",
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_bot_files\raven_ai_bot_files.py
Comments: Included
Mime Type: text/x-python
Size: 562 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenAIBotFiles(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		file: DF.Link
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_bot_files\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_file_source\raven_ai_file_source.js
Comments: Included
Mime Type: text/javascript
Size: 234 bytes
Content:
// Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven AI File Source", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_file_source\raven_ai_file_source.json
Comments: Included
Mime Type: application/json
Size: 1720 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2025-05-10 16:36:21.445325",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "file_name",
  "file",
  "column_break_duoy",
  "file_type",
  "openai_file_id"
 ],
 "fields": [
  {
   "fieldname": "file_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "File Name",
   "read_only": 1,
   "unique": 1
  },
  {
   "fieldname": "file",
   "fieldtype": "Attach",
   "in_list_view": 1,
   "label": "File",
   "reqd": 1
  },
  {
   "fieldname": "file_type",
   "fieldtype": "Data",
   "label": "File Type",
   "read_only": 1
  },
  {
   "fieldname": "openai_file_id",
   "fieldtype": "Data",
   "label": "OpenAI File ID",
   "read_only": 1
  },
  {
   "fieldname": "column_break_duoy",
   "fieldtype": "Column Break"
  }
 ],
 "grid_page_length": 50,
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-05-12 08:45:43.188440",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven AI File Source",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "row_format": "Dynamic",
 "search_fields": "file_name",
 "show_title_field_in_link": 1,
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": [],
 "title_field": "file_name"
}

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_file_source\raven_ai_file_source.py
Comments: Included
Mime Type: text/x-python
Size: 1483 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import frappe
from frappe.model.document import Document

from raven.ai.openai_client import get_open_ai_client


class RavenAIFileSource(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		file: DF.Attach
		file_name: DF.Data | None
		file_type: DF.Data | None
		openai_file_id: DF.Data | None
	# end: auto-generated types

	def before_validate(self):
		# Populate file_name and file_type from file
		if self.file:
			if not self.file_name:
				self.file_name = self.file.split("/")[-1]
			self.file_type = self.file.split(".")[-1]

	def before_insert(self):
		self.create_file_in_openai()

	def create_file_in_openai(self):
		if not self.file:
			return

		client = get_open_ai_client()

		file_doc = frappe.get_doc("File", {"file_url": self.file})
		file_path = file_doc.get_full_path()

		response = client.files.create(file=open(file_path, "rb"), purpose="assistants")

		self.openai_file_id = response.id

	def after_delete(self):
		if self.openai_file_id:
			try:
				client = get_open_ai_client()
				client.files.delete(self.openai_file_id)
			except Exception as e:
				frappe.log_error(f"Error deleting file from OpenAI: {e}")

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_file_source\test_raven_ai_file_source.py
Comments: Included
Mime Type: text/x-python
Size: 857 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record dependencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class UnitTestRavenAIFileSource(UnitTestCase):
	"""
	Unit tests for RavenAIFileSource.
	Use this class for testing individual functions and methods.
	"""

	pass


class IntegrationTestRavenAIFileSource(IntegrationTestCase):
	"""
	Integration tests for RavenAIFileSource.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_file_source\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function\raven_ai_function.js
Comments: Included
Mime Type: text/javascript
Size: 231 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven AI Function", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function\raven_ai_function.json
Comments: Included
Mime Type: application/json
Size: 3445 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:function_name",
 "beta": 1,
 "creation": "2024-08-23 08:43:26.356348",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "function_name",
  "description",
  "function_path",
  "column_break_tlyz",
  "type",
  "reference_doctype",
  "pass_parameters_as_json",
  "requires_write_permissions",
  "strict",
  "parameters_section",
  "parameters",
  "params",
  "function_definition"
 ],
 "fields": [
  {
   "depends_on": "eval: doc.type == \"Custom Function\";",
   "fieldname": "function_path",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "Function Path"
  },
  {
   "default": "0",
   "depends_on": "eval: doc.type == \"Custom Function\";",
   "description": "If checked, the params will be passed as a JSON object instead of named parameters",
   "fieldname": "pass_parameters_as_json",
   "fieldtype": "Check",
   "label": "Pass parameters as JSON"
  },
  {
   "fieldname": "function_name",
   "fieldtype": "Data",
   "label": "Function Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "fieldname": "type",
   "fieldtype": "Select",
   "label": "Type",
   "options": "Get Document\nGet Multiple Documents\nGet List\nCreate Document\nCreate Multiple Documents\nUpdate Document\nUpdate Multiple Documents\nDelete Document\nDelete Multiple Documents\nSubmit Document\nCancel Document\nGet Amended Document\nCustom Function\nSend Message\nAttach File to Document\nGet Report Result",
   "reqd": 1
  },
  {
   "default": "0",
   "fieldname": "requires_write_permissions",
   "fieldtype": "Check",
   "label": "Requires Write Permissions"
  },
  {
   "fieldname": "params",
   "fieldtype": "JSON",
   "label": "Params"
  },
  {
   "fieldname": "function_definition",
   "fieldtype": "JSON",
   "label": "Function Definition",
   "read_only": 1
  },
  {
   "fieldname": "column_break_tlyz",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "parameters_section",
   "fieldtype": "Section Break",
   "label": "Parameters"
  },
  {
   "fieldname": "description",
   "fieldtype": "Small Text",
   "label": "Description",
   "reqd": 1
  },
  {
   "depends_on": "eval: doc.type != \"Custom Function\"",
   "fieldname": "reference_doctype",
   "fieldtype": "Link",
   "label": "Reference DocType",
   "options": "DocType"
  },
  {
   "fieldname": "parameters",
   "fieldtype": "Table",
   "label": "Parameters",
   "options": "Raven AI Function Params"
  },
  {
   "default": "0",
   "fieldname": "strict",
   "fieldtype": "Check",
   "label": "Strict"
  }
 ],
 "grid_page_length": 50,
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-05-18 17:42:22.628503",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven AI Function",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "row_format": "Dynamic",
 "search_fields": "description",
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function\raven_ai_function.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 12743 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import json

import frappe
from frappe import _, is_whitelisted
from frappe.model.document import Document


class RavenAIFunction(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_ai.doctype.raven_ai_function_params.raven_ai_function_params import (
			RavenAIFunctionParams,
		)

		description: DF.SmallText
		function_definition: DF.JSON | None
		function_name: DF.Data
		function_path: DF.SmallText | None
		parameters: DF.Table[RavenAIFunctionParams]
		params: DF.JSON | None
		pass_parameters_as_json: DF.Check
		reference_doctype: DF.Link | None
		requires_write_permissions: DF.Check
		strict: DF.Check
		type: DF.Literal[
			"Get Document",
			"Get Multiple Documents",
			"Get List",
			"Create Document",
			"Create Multiple Documents",
			"Update Document",
			"Update Multiple Documents",
			"Delete Document",
			"Delete Multiple Documents",
			"Submit Document",
			"Cancel Document",
			"Get Amended Document",
			"Custom Function",
			"Send Message",
			"Attach File to Document",
			"Get Report Result",
		]
	# end: auto-generated types

	def before_validate(self):
		WRITE_PERMISSIONS = [
			"Create Document",
			"Create Multiple Documents",
			"Update Document",
			"Update Multiple Documents",
			"Delete Document",
			"Delete Multiple Documents",
			"Send Message",
			"Attach File to Document",
		]
		if self.type in WRITE_PERMISSIONS:
			self.requires_write_permissions = 1

		READ_PERMISSIONS = [
			"Get Document",
			"Get Multiple Documents",
			"Get Report Result",
			"Get List",
			"Get Amended Document",
		]
		if self.type in READ_PERMISSIONS:
			self.requires_write_permissions = 0

		self.validate_reference_doctype()
		self.validate_fields_for_doctype()
		self.prepare_function_params()

		self.validate_json()

	def validate_reference_doctype(self):
		if not self.reference_doctype:
			if not self.type in [
				"Custom Function",
				"Send Message",
				"Get Report Result",
				"Attach File to Document",
			]:
				frappe.throw(_("Please select a DocType for this function."))

	def validate_fields_for_doctype(self):
		# TODO: Validate fields for the doctype - clean up this code
		if not self.reference_doctype:
			return

		doctype = frappe.get_meta(self.reference_doctype)

		# Loop over the variables and check if the field names are valid
		for param in self.parameters:
			# Check if the fieldname belongs to a child table
			if param.child_table_name:
				child_table = doctype.get_field(param.child_table_name)
				if not child_table:
					frappe.throw(
						_("Child table {0} not found in {1}").format(param.child_table_name, self.reference_doctype)
					)

				# Check if the child table is a valid doctype
				child_meta = frappe.get_meta(child_table.options)
				if not child_meta:
					frappe.throw(_("Child table {0} is not a valid doctype").format(param.child_table_name))

				# Check if the child table variable has a valid name
				docfield = child_meta.get_field(param.fieldname)
				if not docfield:
					frappe.throw(_("Field {0} not found in {1}").format(param.fieldname, child_table.options))
			else:

				field = doctype.get_field(param.fieldname)

				if not field:
					frappe.throw(_("Field {0} not found in {1}").format(param.fieldname, self.reference_doctype))

				if field.fieldtype == "Select":
					if not param.options:
						frappe.throw(_("Options are required for select fields"))

					select_options = field.options.split("\n")
					for option in param.options.split("\n"):
						if option not in select_options:
							frappe.throw(
								_("Option {0} is not valid for field {1} in {2}").format(
									option, param.fieldname, self.reference_doctype
								)
							)

	def prepare_function_params(self):
		"""
		Set the function params based on the type of function and other inputs
		"""
		params = {}
		if self.type == "Get Document":
			params = {
				"type": "object",
				"properties": {
					"document_id": {
						"type": "string",
						"description": f"The ID of the {self.reference_doctype} to get",
					}
				},
				"required": ["document_id"],
				"additionalProperties": False,
			}

		elif self.type == "Get Multiple Documents":
			params = {
				"type": "object",
				"properties": {
					"document_ids": {
						"type": "array",
						"items": {"type": "string"},
						"description": f"The IDs of the {self.reference_doctype}s to get",
					}
				},
				"required": ["document_ids"],
				"additionalProperties": False,
			}

		elif self.type == "Delete Document":
			params = {
				"type": "object",
				"properties": {
					"document_id": {
						"type": "string",
						"description": f"The ID of the {self.reference_doctype} to delete",
					}
				},
				"required": ["document_id"],
				"additionalProperties": False,
			}

		elif self.type == "Delete Multiple Documents":
			params = {
				"type": "object",
				"properties": {
					"document_ids": {
						"type": "array",
						"items": {"type": "string"},
						"description": f"The IDs of the {self.reference_doctype}s to delete",
					}
				},
				"required": ["document_ids"],
				"additionalProperties": False,
			}
		elif self.type == "Submit Document":
			params = {
				"type": "object",
				"properties": {
					"document_id": {
						"type": "string",
						"description": f"The ID of the {self.reference_doctype} to submit",
					}
				},
				"required": ["document_id"],
				"additionalProperties": False,
			}
		elif self.type == "Cancel Document":
			params = {
				"type": "object",
				"properties": {
					"document_id": {
						"type": "string",
						"description": f"The ID of the {self.reference_doctype} to cancel",
					}
				},
				"required": ["document_id"],
				"additionalProperties": False,
			}
--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function\test_raven_ai_function.py
Comments: Included
Mime Type: text/x-python
Size: 233 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenAIFunction(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function_params\raven_ai_function_params.json
Comments: Included
Mime Type: application/json
Size: 1857 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-09-27 19:33:46.149867",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "fieldname",
  "child_table_name",
  "required",
  "do_not_ask_ai",
  "default_value",
  "options",
  "column_break_zwir",
  "type",
  "description"
 ],
 "fields": [
  {
   "fieldname": "fieldname",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Fieldname",
   "reqd": 1
  },
  {
   "default": "0",
   "fieldname": "required",
   "fieldtype": "Check",
   "in_list_view": 1,
   "label": "Required"
  },
  {
   "fieldname": "default_value",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Default Value",
   "mandatory_depends_on": "eval: doc.do_not_ask_ai;"
  },
  {
   "fieldname": "options",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "Options"
  },
  {
   "fieldname": "column_break_zwir",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "description",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "Description",
   "reqd": 1
  },
  {
   "fieldname": "type",
   "fieldtype": "Select",
   "label": "Type",
   "options": "string\ninteger\nnumber\nfloat\nboolean",
   "reqd": 1
  },
  {
   "default": "0",
   "fieldname": "do_not_ask_ai",
   "fieldtype": "Check",
   "label": "Do not ask AI to fill this variable"
  },
  {
   "fieldname": "child_table_name",
   "fieldtype": "Data",
   "label": "Child Table Name"
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-10-01 02:08:27.767802",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven AI Function Params",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function_params\raven_ai_function_params.py
Comments: Included
Mime Type: text/x-python
Size: 823 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenAIFunctionParams(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		child_table_name: DF.Data | None
		default_value: DF.Data | None
		description: DF.SmallText
		do_not_ask_ai: DF.Check
		fieldname: DF.Data
		options: DF.SmallText | None
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		required: DF.Check
		type: DF.Literal["string", "integer", "number", "float", "boolean"]
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_ai_function_params\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_ai_prompt\raven_bot_ai_prompt.js
Comments: Included
Mime Type: text/javascript
Size: 233 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Bot AI Prompt", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_ai_prompt\raven_bot_ai_prompt.json
Comments: Included
Mime Type: application/json
Size: 1777 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "naming_series:",
 "beta": 1,
 "creation": "2024-09-12 18:23:10.771302",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "prompt",
  "naming_series",
  "raven_bot",
  "is_global"
 ],
 "fields": [
  {
   "fieldname": "prompt",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "Prompt",
   "reqd": 1
  },
  {
   "description": "If added, this prompt will only be shown when interacting with the bot",
   "fieldname": "raven_bot",
   "fieldtype": "Link",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Raven Bot",
   "options": "Raven Bot"
  },
  {
   "default": "0",
   "description": "If checked, this prompt will be available to all users on Raven",
   "fieldname": "is_global",
   "fieldtype": "Check",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Is Global"
  },
  {
   "fieldname": "naming_series",
   "fieldtype": "Select",
   "label": "Naming Series",
   "options": "PR-.#####."
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-12-07 23:31:02.087933",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven Bot AI Prompt",
 "naming_rule": "By \"Naming Series\" field",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_ai_prompt\raven_bot_ai_prompt.py
Comments: Included
Mime Type: text/x-python
Size: 599 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenBotAIPrompt(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		is_global: DF.Check
		naming_series: DF.Literal["PR-.#####."]
		prompt: DF.SmallText
		raven_bot: DF.Link | None
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_ai_prompt\test_raven_bot_ai_prompt.py
Comments: Included
Mime Type: text/x-python
Size: 234 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenBotAIPrompt(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_ai_prompt\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_functions\raven_bot_functions.json
Comments: Included
Mime Type: application/json
Size: 1277 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-09-27 16:34:18.404073",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "function",
  "column_break_xuns",
  "type",
  "section_break_osgg",
  "description"
 ],
 "fields": [
  {
   "fieldname": "function",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Function",
   "options": "Raven AI Function",
   "reqd": 1
  },
  {
   "fieldname": "column_break_xuns",
   "fieldtype": "Column Break"
  },
  {
   "fetch_from": "function.type",
   "fieldname": "type",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Type",
   "read_only": 1
  },
  {
   "fieldname": "section_break_osgg",
   "fieldtype": "Section Break"
  },
  {
   "fetch_from": "function.description",
   "fieldname": "description",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "Description",
   "read_only": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-12-07 23:32:14.061972",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven Bot Functions",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_functions\raven_bot_functions.py
Comments: Included
Mime Type: text/x-python
Size: 628 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenBotFunctions(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		description: DF.SmallText | None
		function: DF.Link
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		type: DF.Data | None
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_functions\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_instruction_template\raven_bot_instruction_template.js
Comments: Included
Mime Type: text/javascript
Size: 244 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Bot Instruction Template", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_instruction_template\raven_bot_instruction_template.json
Comments: Included
Mime Type: application/json
Size: 2012 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:template_name",
 "beta": 1,
 "creation": "2024-09-12 18:21:02.235237",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "template_name",
  "dynamic_instructions",
  "instruction"
 ],
 "fields": [
  {
   "fieldname": "template_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Template Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "default": "0",
   "description": "Dynamic Instructions allow you to embed Jinja tags in your instruction to the bot. Hence the instruction would be different based on the user who is calling the bot or the data in your system. These instructions are computed every time the bot is called. Check this if you want to embed things like Employee ID, Company Name etc in your instructions dynamically",
   "fieldname": "dynamic_instructions",
   "fieldtype": "Check",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Dynamic Instructions"
  },
  {
   "description": "You can use Jinja variables here to customize the instruction to the bot at run time if dynamic instructions are enabled.",
   "fieldname": "instruction",
   "fieldtype": "Long Text",
   "in_list_view": 1,
   "label": "Instruction",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-12-07 23:27:51.805208",
 "modified_by": "Administrator",
 "module": "Raven AI",
 "name": "Raven Bot Instruction Template",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_instruction_template\raven_bot_instruction_template.py
Comments: Included
Mime Type: text/x-python
Size: 579 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenBotInstructionTemplate(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		dynamic_instructions: DF.Check
		instruction: DF.LongText
		template_name: DF.Data
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_instruction_template\test_raven_bot_instruction_template.py
Comments: Included
Mime Type: text/x-python
Size: 245 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenBotInstructionTemplate(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_ai\doctype\raven_bot_instruction_template\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\doctype\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_ai\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_bot\doctype\raven_bot\raven_bot.js
Comments: Included
Mime Type: text/javascript
Size: 189 bytes
Content:
// Copyright (c) 2024, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Bot", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_bot\doctype\raven_bot\raven_bot.json
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/json
Size: 6185 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:bot_name",
 "beta": 1,
 "creation": "2024-03-29 20:25:13.529714",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "bot_name",
  "image",
  "raven_user",
  "column_break_lhoo",
  "description",
  "is_standard",
  "module",
  "ai_tab",
  "is_ai_bot",
  "debug_mode",
  "model",
  "reasoning_effort",
  "ai_section",
  "openai_assistant_id",
  "enable_code_interpreter",
  "column_break_khmi",
  "allow_bot_to_write_documents",
  "enable_file_search",
  "section_break_lwkx",
  "instruction",
  "dynamic_instructions",
  "bot_functions",
  "openai_vector_store_id",
  "file_sources"
 ],
 "fields": [
  {
   "fieldname": "description",
   "fieldtype": "Small Text",
   "label": "Description"
  },
  {
   "fieldname": "image",
   "fieldtype": "Attach Image",
   "label": "Image"
  },
  {
   "fieldname": "bot_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Bot Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "default": "0",
   "fieldname": "is_standard",
   "fieldtype": "Check",
   "hidden": 1,
   "label": "Is Standard"
  },
  {
   "fieldname": "module",
   "fieldtype": "Link",
   "hidden": 1,
   "label": "Module",
   "mandatory_depends_on": "eval: doc.is_standard == 1",
   "options": "Module Def"
  },
  {
   "fieldname": "raven_user",
   "fieldtype": "Link",
   "in_standard_filter": 1,
   "label": "Raven User",
   "options": "Raven User",
   "read_only": 1,
   "set_only_once": 1
  },
  {
   "fieldname": "column_break_lhoo",
   "fieldtype": "Column Break"
  },
  {
   "depends_on": "eval: doc.is_ai_bot",
   "fieldname": "ai_section",
   "fieldtype": "Section Break"
  },
  {
   "default": "0",
   "fieldname": "is_ai_bot",
   "fieldtype": "Check",
   "label": "Is AI Bot?"
  },
  {
   "depends_on": "eval: doc.is_ai_bot",
   "documentation_url": "https://platform.openai.com/docs/assistants/overview",
   "fieldname": "openai_assistant_id",
   "fieldtype": "Data",
   "label": "OpenAI Assistant ID"
  },
  {
   "fieldname": "column_break_khmi",
   "fieldtype": "Column Break"
  },
  {
   "default": "0",
   "fieldname": "allow_bot_to_write_documents",
   "fieldtype": "Check",
   "label": "Allow Bot to Write Documents"
  },
  {
   "fieldname": "ai_tab",
   "fieldtype": "Tab Break",
   "label": "AI"
  },
  {
   "fieldname": "section_break_lwkx",
   "fieldtype": "Section Break"
  },
  {
   "depends_on": "eval: doc.is_ai_bot;",
   "description": "You can use Jinja variables here to customize the instruction to the bot at run time if dynamic instructions are enabled.",
   "fieldname": "instruction",
   "fieldtype": "Long Text",
   "label": "Instruction"
  },
  {
   "default": "0",
   "description": "Enable this if you want the bot to be able to read PDF files and scan them.\n\nFile search enables the assistant with knowledge from files that you upload. Once a file is uploaded, the assistant automatically decides when to retrieve content based on user requests.",
   "documentation_url": "https://platform.openai.com/docs/assistants/tools/file-search",
   "fieldname": "enable_file_search",
   "fieldtype": "Check",
   "label": "Enable File Search"
  },
  {
   "default": "0",
   "depends_on": "eval: doc.is_ai_bot;",
   "description": "Dynamic Instructions allow you to embed Jinja tags in your instruction to the bot. Hence the instruction would be different based on the user who is calling the bot or the data in your system. These instructions are computed every time the bot is called. Check this if you want to embed things like Employee ID, Company Name etc in your instructions dynamically",
   "fieldname": "dynamic_instructions",
   "fieldtype": "Check",
   "label": "Dynamic Instructions"
  },
  {
   "depends_on": "eval: doc.is_ai_bot;",
   "fieldname": "bot_functions",
   "fieldtype": "Table",
   "label": "Bot Functions",
   "options": "Raven Bot Functions"
  },
  {
   "default": "0",
   "description": " Enable this if you want the bot to be able to process files like Excel sheets or data from Insights.\n                    <br>\n                    OpenAI Assistants run code in a sandboxed environment (on OpenAI servers) to do this.",
   "documentation_url": "https://platform.openai.com/docs/assistants/tools/code-interpreter",
   "fieldname": "enable_code_interpreter",
   "fieldtype": "Check",
   "label": "Enable Code Interpreter"
  },
  {
   "default": "0",
   "description": "If enabled, stack traces of errors will be sent as messages by the bot ",
   "fieldname": "debug_mode",
   "fieldtype": "Check",
   "label": "Debug Mode"
  },
  {
   "default": "gpt-4o",
   "fieldname": "model",
   "fieldtype": "Data",
   "label": "Model"
  },
  {
   "description": "Only applicable for OpenAI o-series models",
   "fieldname": "reasoning_effort",
   "fieldtype": "Select",
   "label": "Reasoning Effort",
   "options": "low\nmedium\nhigh"
  },
  {
   "fieldname": "file_sources",
   "fieldtype": "Table",
   "label": "File Sources",
   "options": "Raven AI Bot Files"
  },
  {
   "fieldname": "openai_vector_store_id",
   "fieldtype": "Data",
   "label": "OpenAI Vector Store ID",
   "read_only": 1
  }
 ],
 "grid_page_length": 50,
 "image_field": "image",
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-05-10 19:07:45.493080",
 "modified_by": "Administrator",
 "module": "Raven Bot",
 "name": "Raven Bot",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "row_format": "Dynamic",
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}

--------------------------------------------------------------------------------

File: raven_bot\doctype\raven_bot\raven_bot.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 17362 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

import json

import frappe
from frappe import _
from frappe.model.document import Document
from openai import APIConnectionError

from raven.ai.openai_client import (
	code_interpreter_file_types,
	file_search_file_types,
	get_open_ai_client,
)
from raven.utils import get_raven_user


class RavenBot(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_ai.doctype.raven_ai_bot_files.raven_ai_bot_files import RavenAIBotFiles
		from raven.raven_ai.doctype.raven_bot_functions.raven_bot_functions import RavenBotFunctions

		allow_bot_to_write_documents: DF.Check
		bot_functions: DF.Table[RavenBotFunctions]
		bot_name: DF.Data
		debug_mode: DF.Check
		description: DF.SmallText | None
		dynamic_instructions: DF.Check
		enable_code_interpreter: DF.Check
		enable_file_search: DF.Check
		file_sources: DF.Table[RavenAIBotFiles]
		image: DF.AttachImage | None
		instruction: DF.LongText | None
		is_ai_bot: DF.Check
		is_standard: DF.Check
		model: DF.Data | None
		module: DF.Link | None
		openai_assistant_id: DF.Data | None
		openai_vector_store_id: DF.Data | None
		raven_user: DF.Link | None
		reasoning_effort: DF.Literal["low", "medium", "high"]
	# end: auto-generated types

	def validate(self):
		if self.is_ai_bot and not self.instruction:
			frappe.throw(_("Please provide an instruction for this AI Agent."))

		self.validate_functions()

	def validate_functions(self):
		if not self.allow_bot_to_write_documents:
			for f in self.bot_functions:
				needs_write = frappe.db.get_value(
					"Raven AI Function", f.function, "requires_write_permissions"
				)
				if needs_write:
					frappe.throw(
						f"This agent is not allowed to write documents. Please remove the function {f.function} or allow the agent to write documents."
					)

	def on_update(self):
		"""
		When a bot is updated, create/update the Raven User for it

		TODO: Generate JSON files when a Standard Bot is created or updated
		"""
		if self.raven_user:
			raven_user = frappe.get_doc("Raven User", self.raven_user)
			raven_user.type = "Bot"
			raven_user.bot = self.name
			raven_user.full_name = self.bot_name
			raven_user.first_name = self.bot_name
			raven_user.user_image = self.image
			raven_user.enabled = 1
			raven_user.save()
		else:
			raven_user = frappe.new_doc("Raven User")
			raven_user.type = "Bot"
			raven_user.bot = self.name
			raven_user.full_name = self.bot_name
			raven_user.first_name = self.bot_name
			raven_user.user_image = self.image
			raven_user.enabled = 1
			raven_user.save()

			self.db_set("raven_user", raven_user.name)

		if self.is_ai_bot:
			if not self.openai_assistant_id:
				self.create_openai_assistant()
			else:
				self.update_openai_assistant()

	def before_insert(self):
		if self.is_ai_bot and not self.openai_assistant_id:
			self.create_openai_assistant()

	def on_trash(self):
		if self.openai_assistant_id:
			self.delete_openai_assistant()

		if self.raven_user:
			frappe.db.set_value("Raven User", self.raven_user, "bot", None)
			self.db_set("raven_user", None)
			frappe.delete_doc("Raven User", self.raven_user)

	def create_openai_assistant(self):
		# Create an OpenAI Assistant for the bot
		client = get_open_ai_client()

		# Sometimes users face an issue with the OpenAI API returning an error for "model_not_found"
		# This is usually because the user has not added funds to their OpenAI account.
		# We need to show this error to the user if the openAI API returns an error for "model_not_found"

		model = self.model or "gpt-4o"

		reasoning_effort = self.reasoning_effort or "medium"

		try:
			assistant = client.beta.assistants.create(
				instructions=self.instruction,
				model=model,
				name=self.bot_name,
				description=self.description or "",
				tools=self.get_tools_for_assistant(),
				tool_resources=self.get_tool_resources_for_assistant(),
				reasoning_effort=reasoning_effort if model.startswith("o") else None,
			)
			# Update the tools which were activated for the bot
			self.db_set("openai_assistant_id", assistant.id)
			self.check_and_update_enabled_tools(assistant)

		except APIConnectionError as e:
			frappe.throw(
				_(
					"Connection to OpenAI API failed. Please check your Organization ID and API Key for any extra spaces. Error: {0}"
				).format(e)
			)
		except Exception as e:
			if "model_not_found" in str(e):
				frappe.throw(
					_(
						f"<strong>There was an error creating the agent in OpenAI.</strong><br/>It is possible that your OpenAI account does not have enough funds or the model {model} is not available. Please add funds to your OpenAI account and try again.<br><br/>Error: {e}"
					)
				)
			else:
				frappe.throw(str(e))

	def update_openai_assistant(self):
		# Update the OpenAI Assistant for the bot

		# Additional check because it is being used in Raven AI Function
		if not self.is_ai_bot:
			return

		client = get_open_ai_client()

		model = self.model or "gpt-4o"
		reasoning_effort = self.reasoning_effort or "medium"

		try:
			assistant = client.beta.assistants.update(
				self.openai_assistant_id,
				instructions=self.instruction,
				name=self.bot_name,
				description=self.description or "",
				tools=self.get_tools_for_assistant(),
				tool_resources=self.get_tool_resources_for_assistant(),
				model=model,
				reasoning_effort=reasoning_effort if model.startswith("o") else None,
			)
			self.check_and_update_enabled_tools(assistant)
		except Exception as e:
			if "model_not_found" in str(e):
				frappe.throw(
					_(
						f"<strong>There was an error updating the agent in OpenAI.</strong><br/>It is possible that your OpenAI account does not have enough funds or the model {model} is not available. Please check your account and try again.<br><br/>Error: {e}"
					)
				)
			el
--------------------------------------------------------------------------------

File: raven_bot\doctype\raven_bot\test_raven_bot.py
Comments: Included
Mime Type: text/x-python
Size: 192 bytes
Content:
# Copyright (c) 2024, The Commit Company and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenBot(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_bot\doctype\raven_bot\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_bot\doctype\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_bot\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel\raven_channel.js
Comments: Included
Mime Type: text/javascript
Size: 193 bytes
Content:
// Copyright (c) 2023, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Channel", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel\raven_channel.json
Comments: Included
Mime Type: application/json
Size: 5442 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2023-02-12 17:30:30.847618",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "channel_name",
  "channel_description",
  "type",
  "column_break_imbh",
  "is_synced",
  "linked_doctype",
  "linked_document",
  "workspace",
  "section_break_evg4",
  "is_direct_message",
  "is_thread",
  "is_dm_thread",
  "column_break_puci",
  "is_self_message",
  "column_break_ubts",
  "is_archived",
  "section_break_wlnt",
  "last_message_timestamp",
  "column_break_eckt",
  "last_message_details",
  "section_break_acpc",
  "pinned_messages",
  "pinned_messages_string",
  "ai_tab",
  "is_ai_thread",
  "openai_thread_id",
  "thread_bot"
 ],
 "fields": [
  {
   "fieldname": "type",
   "fieldtype": "Select",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Type",
   "options": "Private\nPublic\nOpen",
   "reqd": 1
  },
  {
   "fieldname": "channel_name",
   "fieldtype": "Data",
   "in_filter": 1,
   "in_list_view": 1,
   "in_preview": 1,
   "in_standard_filter": 1,
   "label": "Channel Name",
   "read_only_depends_on": "eval: doc.is_direct_message || doc.is_self_message",
   "reqd": 1
  },
  {
   "default": "0",
   "fieldname": "is_direct_message",
   "fieldtype": "Check",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Is Direct Message",
   "set_only_once": 1
  },
  {
   "default": "0",
   "fieldname": "is_self_message",
   "fieldtype": "Check",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Is Self Message",
   "set_only_once": 1
  },
  {
   "fieldname": "channel_description",
   "fieldtype": "Small Text",
   "label": "Channel Description"
  },
  {
   "fieldname": "column_break_puci",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "section_break_evg4",
   "fieldtype": "Section Break"
  },
  {
   "fieldname": "column_break_ubts",
   "fieldtype": "Column Break"
  },
  {
   "default": "0",
   "fieldname": "is_archived",
   "fieldtype": "Check",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Is Archived"
  },
  {
   "fieldname": "section_break_wlnt",
   "fieldtype": "Section Break"
  },
  {
   "fieldname": "last_message_timestamp",
   "fieldtype": "Datetime",
   "label": "Last Message Timestamp",
   "read_only": 1
  },
  {
   "fieldname": "column_break_eckt",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "last_message_details",
   "fieldtype": "JSON",
   "label": "Last Message Details",
   "read_only": 1
  },
  {
   "fieldname": "column_break_imbh",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "linked_doctype",
   "fieldtype": "Link",
   "label": "Linked DocType",
   "options": "DocType",
   "read_only": 1
  },
  {
   "fieldname": "linked_document",
   "fieldtype": "Dynamic Link",
   "label": "Linked Document",
   "options": "linked_doctype",
   "read_only": 1
  },
  {
   "default": "0",
   "fieldname": "is_synced",
   "fieldtype": "Check",
   "label": "Is Synced",
   "read_only": 1
  },
  {
   "default": "0",
   "fieldname": "is_thread",
   "fieldtype": "Check",
   "label": "Is Thread",
   "read_only": 1
  },
  {
   "fieldname": "ai_tab",
   "fieldtype": "Tab Break",
   "label": "AI"
  },
  {
   "default": "0",
   "fieldname": "is_ai_thread",
   "fieldtype": "Check",
   "in_standard_filter": 1,
   "label": "Is AI Thread",
   "read_only": 1
  },
  {
   "fieldname": "openai_thread_id",
   "fieldtype": "Data",
   "label": "OpenAI Thread ID",
   "read_only": 1
  },
  {
   "fieldname": "thread_bot",
   "fieldtype": "Link",
   "label": "Thread Bot",
   "options": "Raven Bot",
   "read_only": 1
  },
  {
   "fieldname": "section_break_acpc",
   "fieldtype": "Section Break"
  },
  {
   "fieldname": "pinned_messages",
   "fieldtype": "Table",
   "label": "Pinned Messages",
   "options": "Raven Pinned Messages"
  },
  {
   "fieldname": "pinned_messages_string",
   "fieldtype": "Small Text",
   "label": "Pinned Messages String"
  },
  {
   "fieldname": "workspace",
   "fieldtype": "Link",
   "label": "Workspace",
   "options": "Raven Workspace",
   "search_index": 1
  },
  {
   "default": "0",
   "fieldname": "is_dm_thread",
   "fieldtype": "Check",
   "label": "Is DM Thread",
   "read_only": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [
  {
   "link_doctype": "Raven Channel Member",
   "link_fieldname": "channel_id"
  },
  {
   "link_doctype": "Raven Message",
   "link_fieldname": "channel_id"
  }
 ],
 "modified": "2024-12-08 01:24:55.359995",
 "modified_by": "Administrator",
 "module": "Raven Channel Management",
 "name": "Raven Channel",
 "naming_rule": "By script",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  }
 ],
 "search_fields": "type",
 "show_title_field_in_link": 1,
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": [],
 "title_field": "channel_name"
}
--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel\raven_channel.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 7773 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document

from raven.utils import delete_channel_members_cache


class RavenChannel(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven.doctype.raven_pinned_messages.raven_pinned_messages import RavenPinnedMessages

		channel_description: DF.SmallText | None
		channel_name: DF.Data
		is_ai_thread: DF.Check
		is_archived: DF.Check
		is_direct_message: DF.Check
		is_dm_thread: DF.Check
		is_self_message: DF.Check
		is_synced: DF.Check
		is_thread: DF.Check
		last_message_details: DF.JSON | None
		last_message_timestamp: DF.Datetime | None
		linked_doctype: DF.Link | None
		linked_document: DF.DynamicLink | None
		openai_thread_id: DF.Data | None
		pinned_messages: DF.Table[RavenPinnedMessages]
		pinned_messages_string: DF.SmallText | None
		thread_bot: DF.Link | None
		type: DF.Literal["Private", "Public", "Open"]
		workspace: DF.Link | None
	# end: auto-generated types

	def on_trash(self):
		# delete all members when channel is deleted
		frappe.db.delete("Raven Channel Member", {"channel_id": self.name})

		# delete all messages when channel is deleted
		frappe.db.delete("Raven Message", {"channel_id": self.name})

		# delete all reactions when channel is deleted
		frappe.db.delete("Raven Message Reaction", {"channel_id": self.name})

		# Delete the pinned channels
		frappe.db.delete("Raven Pinned Channels", {"channel_id": self.name})

		delete_channel_members_cache(self.name)

		if not self.is_thread:
			# Update the channel list for all users
			frappe.publish_realtime(
				"channel_list_updated",
				{
					"channel_id": self.name,
				},
				room="all",
				after_commit=True,
			)

		# If the channel was a thread, (i.e. a message exists with the same name), remove the 'is_thread' flag from the message
		if self.is_thread and frappe.db.exists("Raven Message", {"name": self.name}):
			message_channel_id = frappe.get_cached_value("Raven Message", self.name, "channel_id")
			frappe.db.set_value("Raven Message", self.name, "is_thread", 0)
			# Update the message which used to be a thread
			frappe.publish_realtime(
				"message_edited",
				{
					"channel_id": message_channel_id,
					"sender": frappe.session.user,
					"message_id": self.name,
					"message_details": {
						"is_thread": 0,
					},
				},
				doctype="Raven Channel",
				docname=message_channel_id,
			)

	def on_update(self):
		if not self.is_thread:
			# Update the channel list for all users
			frappe.publish_realtime(
				"channel_list_updated",
				{
					"channel_id": self.name,
				},
				room="all",
				after_commit=True,
			)

	def after_insert(self):
		"""
		After inserting a channel, we need to check if it is a direct message channel or not.

		If it is a direct message channel, we can add both the users as members.

		If it is a self message channel, we will add only the same user as a member.

		For all other channels, we will add the current user as a member if it is not created by a bot.
		If it is created by a bot, we will add the bot as a member.
		"""
		# add current user as channel member
		if not frappe.flags.in_install and not self.flags.do_not_add_member:

			if self.type in ("Open", "Public") and not self.is_thread:
				# Update the channel list for all users
				frappe.publish_realtime(
					"channel_list_updated",
					{
						"channel_id": self.name,
					},
					room="all",
					after_commit=True,
				)

			if self.is_direct_message == 1:
				# Add both users as members
				raven_users = self.channel_name.split(" _ ")
				unique_raven_users = list(set(raven_users))
				self.add_members(unique_raven_users)
			else:
				# Can ignore permissions here because the user who creates the channel should be an admin of the channel
				frappe.get_doc(
					{
						"doctype": "Raven Channel Member",
						"channel_id": self.name,
						"user_id": frappe.session.user,
						"is_admin": 1,
					}
				).insert(ignore_permissions=True)

	def validate(self):
		# If the user trying to modify the channel is not the owner or channel member, then don't allow
		old_doc = self.get_doc_before_save()

		if self.is_direct_message == 1:
			if old_doc:
				if old_doc.get("channel_name") != self.channel_name:
					frappe.throw(
						_("You cannot change the name of a direct message channel"),
						frappe.ValidationError,
					)

		if not self.is_dm_thread and not self.is_direct_message:
			# If it's not a direct message channel, it needs a workspace
			if not self.workspace:
				frappe.throw(_("You need to specify a workspace for this channel"), frappe.ValidationError)

		if old_doc and old_doc.get("is_archived") != self.is_archived:
			if frappe.db.exists(
				"Raven Channel Member",
				{"channel_id": self.name, "user_id": frappe.session.user, "is_admin": 1},
			):
				pass
			elif frappe.session.user == "Administrator":
				pass
			else:
				frappe.throw(
					_("You don't have permission to archive/unarchive this channel"),
					frappe.PermissionError,
				)
		if not self.flags.is_created_by_bot:
			if self.type == "Private" or self.type == "Public":
				if (
					self.owner == frappe.session.user
					and frappe.db.count("Raven Channel Member", {"channel_id": self.name}) <= 1
				):
					pass
				elif frappe.db.exists(
					"Raven Channel Member", {"channel_id": self.name, "user_id": frappe.session.user}
				):
					pass
				elif frappe.session.user == "Administrator":
					pass
				else:
					frappe.throw(_("You don't have permission to modify this channel"), frappe.PermissionError)

		# Check if this channel exists in the current workspace
		if self.workspace and self.flags.in_insert:
			if frappe.db.exists(
				"Raven Channel", {"channel_name": self.channel_name, "workspace": s
--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel\test_raven_channel.py
Comments: Included
Mime Type: text/x-python
Size: 196 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenChannel(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel\test_records.json
Comments: Included
Mime Type: application/json
Size: 1037 bytes
Content:
[
    {
        "doctype": "Raven Channel",
        "channel_name": "public-workspace-public",
        "workspace": "Public Workspace",
        "type": "Public"
    },
    {
        "doctype": "Raven Channel",
        "channel_name": "public-workspace-private",
        "workspace": "Public Workspace",
        "type": "Private"
    },
    {
        "doctype": "Raven Channel",
        "channel_name": "public-workspace-open",
        "workspace": "Public Workspace",
        "type": "Open"
    },
    {
        "doctype": "Raven Channel",
        "channel_name": "private-workspace-public",
        "workspace": "Private Workspace",
        "type": "Public"
    },
    {
        "doctype": "Raven Channel",
        "channel_name": "private-workspace-private",
        "workspace": "Private Workspace",
        "type": "Private"
    },
    {
        "doctype": "Raven Channel",
        "channel_name": "private-workspace-open",
        "workspace": "Private Workspace",
        "type": "Open"
    }
]
--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel_member\raven_channel_member.js
Comments: Included
Mime Type: text/javascript
Size: 200 bytes
Content:
// Copyright (c) 2023, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Channel Member", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel_member\raven_channel_member.json
Comments: Included
Mime Type: application/json
Size: 2560 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2023-02-12 17:31:23.807704",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "channel_id",
  "user_id",
  "is_admin",
  "last_visit",
  "column_break_adqk",
  "is_synced",
  "linked_doctype",
  "linked_document",
  "notification_settings_section",
  "allow_notifications"
 ],
 "fields": [
  {
   "fieldname": "channel_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Channel",
   "options": "Raven Channel",
   "reqd": 1,
   "search_index": 1
  },
  {
   "fieldname": "user_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "User",
   "options": "Raven User",
   "reqd": 1,
   "search_index": 1
  },
  {
   "default": "0",
   "fieldname": "is_admin",
   "fieldtype": "Check",
   "label": "Is Admin"
  },
  {
   "fetch_if_empty": 1,
   "fieldname": "last_visit",
   "fieldtype": "Datetime",
   "label": "Last Visit",
   "reqd": 1
  },
  {
   "fieldname": "notification_settings_section",
   "fieldtype": "Section Break",
   "label": "Notification Settings"
  },
  {
   "default": "0",
   "fieldname": "allow_notifications",
   "fieldtype": "Check",
   "label": "Allow notifications"
  },
  {
   "fieldname": "column_break_adqk",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "linked_doctype",
   "fieldtype": "Link",
   "label": "Linked DocType",
   "options": "DocType",
   "read_only": 1
  },
  {
   "fieldname": "linked_document",
   "fieldtype": "Dynamic Link",
   "label": "Linked Document",
   "options": "linked_doctype",
   "read_only": 1
  },
  {
   "default": "0",
   "fieldname": "is_synced",
   "fieldtype": "Check",
   "label": "Is Synced",
   "read_only": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-11-29 17:31:35.446387",
 "modified_by": "Administrator",
 "module": "Raven Channel Management",
 "name": "Raven Channel Member",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel_member\raven_channel_member.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 9100 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document

from raven.notification import (
	clear_push_tokens_for_channel_cache,
	subscribe_user_to_topic,
	unsubscribe_user_to_topic,
)
from raven.utils import delete_channel_members_cache


class RavenChannelMember(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		allow_notifications: DF.Check
		channel_id: DF.Link
		is_admin: DF.Check
		is_synced: DF.Check
		last_visit: DF.Datetime
		linked_doctype: DF.Link | None
		linked_document: DF.DynamicLink | None
		user_id: DF.Link
	# end: auto-generated types

	def validate(self):
		if (
			self.has_value_changed("is_admin")
			and not self.flags.in_insert
			and not self.flags.ignore_permissions
		):
			# Check if the user is an existing admin of the channel
			if not frappe.db.exists(
				"Raven Channel Member",
				{"channel_id": self.channel_id, "user_id": frappe.session.user, "is_admin": 1},
			):
				frappe.throw(
					_("You cannot make yourself an admin of a channel. Please ask another admin to do this."),
					frappe.PermissionError,
				)

	def before_insert(self):
		self.last_visit = frappe.utils.now()
		# 1. A user cannot be a member of a channel more than once
		if frappe.db.exists(
			"Raven Channel Member", {"channel_id": self.channel_id, "user_id": self.user_id}
		):
			frappe.throw(_("You are already a member of this channel"), frappe.DuplicateEntryError)
		# if there are no members in the channel, then the member becomes admin
		if frappe.db.count("Raven Channel Member", {"channel_id": self.channel_id}) == 0:
			self.is_admin = 1

		self.allow_notifications = 1

	def after_delete(self):

		member_name = frappe.get_cached_value("Raven User", self.user_id, "full_name")

		current_user_name = frappe.get_cached_value("Raven User", frappe.session.user, "full_name")

		is_thread = self.is_thread()

		if not is_thread:
			# Update the channel list for the user who left the channel
			frappe.publish_realtime(
				"channel_list_updated",
				{
					"channel_id": self.channel_id,
				},
				user=self.user_id,
				after_commit=True,
			)

		# If this was the last member of a private channel, archive the channel
		if (
			frappe.db.count("Raven Channel Member", {"channel_id": self.channel_id}) == 0
			and frappe.db.get_value("Raven Channel", self.channel_id, "type") == "Private"
		):
			frappe.db.set_value("Raven Channel", self.channel_id, "is_archived", 1)

		# If this member was the only admin, then make the next oldest member an admin
		if (
			self.get_admin_count() == 0
			and frappe.db.count("Raven Channel Member", {"channel_id": self.channel_id}) > 0
		):
			first_member = frappe.db.get_value(
				"Raven Channel Member",
				{"channel_id": self.channel_id},
				["name", "user_id"],
				as_dict=1,
				order_by="creation asc",
			)
			frappe.db.set_value("Raven Channel Member", first_member.name, "is_admin", 1)

			first_member_name = frappe.get_cached_value("Raven User", first_member.user_id, "full_name")

			# Add a system message to the channel mentioning the new admin
			frappe.get_doc(
				{
					"doctype": "Raven Message",
					"channel_id": self.channel_id,
					"message_type": "System",
					"text": f"{member_name} was removed by {current_user_name} and {first_member_name} is the new admin of this channel.",
				}
			).insert(ignore_permissions=True)
		else:
			# If the member who left is the current user, then add a system message to the channel mentioning that the user left
			if member_name == current_user_name:
				# Add a system message to the channel mentioning the member who left
				frappe.get_doc(
					{
						"doctype": "Raven Message",
						"channel_id": self.channel_id,
						"message_type": "System",
						"text": f"{member_name} left.",
					}
				).insert(ignore_permissions=True)
			else:
				# Add a system message to the channel mentioning the member who left
				frappe.get_doc(
					{
						"doctype": "Raven Message",
						"channel_id": self.channel_id,
						"message_type": "System",
						"text": f"{current_user_name} removed {member_name}.",
					}
				).insert(ignore_permissions=True)

	def on_trash(self):
		unsubscribe_user_to_topic(self.channel_id, self.user_id)
		self.invalidate_channel_members_cache()

	def check_if_user_is_member(self):
		is_member = True
		channel = frappe.db.get_value("Raven Channel", self.channel_id, ["type", "owner"], as_dict=True)
		if channel.type == "Private":
			# A user can only add members to a private channel if they are themselves member of the channel or if they are the owner of a new channel
			if (
				channel.owner == frappe.session.user
				and frappe.db.count("Raven Channel Member", {"channel_id": self.channel_id}) == 0
			):
				# User is the owner of a channel and there are no members in the channel
				pass
			elif frappe.db.exists(
				"Raven Channel Member",
				{"channel_id": self.channel_id, "user_id": frappe.session.user},
			):
				# User is a member of the channel
				pass
			elif frappe.session.user == "Administrator":
				# User is Administrator
				pass
			else:
				is_member = False
		return is_member

	def after_insert(self):
		"""
		Subscribe the user to the topic if the channel is not a DM
		"""
		is_direct_message = frappe.get_cached_value(
			"Raven Channel", self.channel_id, "is_direct_message"
		)

		is_thread = self.is_thread()

		if not is_thread:
			# Update the channel list for the user who joined the channel
			frappe.publish_realtime(
				"channel_list_updated",
				{
					"channel_id": self.channel_id,
				},
				user=self.user_id,
				after_commit=True,
			)

		if not is_direct_message and self.allow_notifications:
			subscribe_user_to_topic(self.channel_id, self.user_id)

		if not is_direct_message:

			# Send 
--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel_member\test_raven_channel_member.py
Comments: Included
Mime Type: text/x-python
Size: 202 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenChannelMember(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\raven_channel_member\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_channel_management\doctype\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_channel_management\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\controllers\department.py
Comments: Included
Mime Type: text/x-python
Size: 2356 bytes
Content:
import frappe


def after_insert(doc, method):
	"""
	Check if auto creation of Department channel is enabled.
	If yes, then create a new Raven Channel
	"""
	if doc.is_group or doc.disabled:
		return

	channel_type = get_auto_create_department_channel_type()

	if not channel_type:
		return

	department_channel = frappe.new_doc("Raven Channel")

	channel_name = get_channel_name_for_department(doc.name)

	department_channel.channel_name = channel_name
	department_channel.type = channel_type
	department_channel.channel_description = f"Channel for Department - {doc.department_name}"
	department_channel.is_synced = 1
	department_channel.linked_doctype = "Department"
	department_channel.linked_document = doc.name

	# Get the workspace based on the company of the department else use the default workspace
	workspace = frappe.get_all(
		"Raven HR Company Workspace", filters={"company": doc.company}, pluck="raven_workspace", limit=1
	)

	if workspace:
		department_channel.workspace = workspace[0]

		department_channel.insert(ignore_permissions=True)


def on_update(doc, method):
	linked_channels = frappe.get_all(
		"Raven Channel",
		{"linked_doctype": "Department", "linked_document": doc.name},
		pluck="name",
		limit=1,
	)

	channel_name = get_channel_name_for_department(doc.name)

	for channel in linked_channels:
		# Update the description and name if changed
		frappe.db.set_value(
			"Raven Channel",
			channel,
			{
				"channel_name": channel_name,
			},
		)


def on_trash(doc, method):
	frappe.db.delete("Raven Channel", {"linked_doctype": "Department", "linked_document": doc.name})


def get_auto_create_department_channel_type() -> str | None:
	raven_settings = frappe.get_single("Raven Settings")

	if raven_settings.auto_create_department_channel:
		return (
			raven_settings.department_channel_type if raven_settings.department_channel_type else "Private"
		)
	else:
		return None


def get_channel_name_for_department(department):
	channel_name = ""

	prev_character = ""
	for char in department:
		# If there are more than one "-" in a row, replace them
		if char != " " and char != "-":
			channel_name += char
			prev_character = char

		elif prev_character != "-":
			channel_name += "-"
			prev_character = "-"

	return channel_name

--------------------------------------------------------------------------------

File: raven_integrations\controllers\employee.py
Comments: Included
Mime Type: text/x-python
Size: 2840 bytes
Content:
import frappe


def after_insert(doc, method):
	"""
	Create a new Channel Member if a channel for the department exists
	"""

	if not doc.department or not doc.user_id:
		return

	if not is_department_sync_on():
		return

	channel_id = get_channel_for_department(doc.department)

	if not channel_id:
		return

	raven_user_id = get_raven_user_for_user(doc.user_id)

	if not raven_user_id:
		return

	create_channel_member(channel_id=channel_id, raven_user_id=raven_user_id, employee_id=doc.name)


def on_update(doc, method):
	# Check if department has changed.
	# If it has, we need to remove the channel member from the existing department channel
	# And add it to the new department's channel

	if not doc.user_id:
		return

	if not is_department_sync_on():
		return

	if doc.has_value_changed("user_id"):
		# TODO: Create a member for this user_id
		pass

	if doc.has_value_changed("department"):

		raven_user_id = get_raven_user_for_user(doc.user_id)

		if not raven_user_id:
			return

		old_doc = doc.get_doc_before_save()

		if old_doc and old_doc.department:
			# Remove the employee as a member from the channel
			old_channel = get_channel_for_department(old_doc.department)

			if old_channel:
				frappe.db.delete("Raven Channel Member", {"channel_id": old_channel, "user_id": raven_user_id})

		# Create a new Raven Channel Member for employee
		new_channel = get_channel_for_department(doc.department)

		if new_channel:
			create_channel_member(channel_id=new_channel, raven_user_id=raven_user_id, employee_id=doc.name)


def on_trash(doc, method):
	frappe.db.delete(
		"Raven Channel Member", {"linked_doctype": "Employee", "linked_document": doc.name}
	)


def create_channel_member(channel_id, raven_user_id, employee_id):
	channel_member = frappe.get_doc(
		{
			"doctype": "Raven Channel Member",
			"channel_id": channel_id,
			"user_id": raven_user_id,
			"is_synced": 1,
			"linked_doctype": "Employee",
			"linked_document": employee_id,
		}
	)

	channel_member.insert(ignore_permissions=True)


def get_channel_for_department(department):
	# Check if channel exists for the department
	channel = frappe.get_all(
		"Raven Channel",
		{"linked_doctype": "Department", "linked_document": department},
		pluck="name",
		limit=1,
	)

	if len(channel) == 0:
		return None

	return channel[0]


def get_raven_user_for_user(user_id):
	# Check if Raven User exists for the user id
	raven_user = frappe.get_all("Raven User", {"user": user_id}, pluck="name", limit=1)

	if len(raven_user) == 0:
		return None

	return raven_user[0]


def is_department_sync_on():

	raven_settings = frappe.get_single("Raven Settings")

	if raven_settings.auto_create_department_channel:
		return True
	else:
		return False

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification\raven_document_notification.js
Comments: Included
Mime Type: text/javascript
Size: 241 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Document Notification", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification\raven_document_notification.json
Comments: Included
Mime Type: application/json
Size: 3381 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:notification_name",
 "creation": "2024-12-15 17:36:24.825068",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "notification_name",
  "enabled",
  "column_break_hpcq",
  "sender",
  "section_break_vsib",
  "send_alert_on",
  "column_break_rxyz",
  "document_type",
  "do_not_attach_doc",
  "conditions_tab",
  "condition",
  "recipients_tab",
  "recipients",
  "message_content_tab",
  "message"
 ],
 "fields": [
  {
   "fieldname": "notification_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Notification Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "default": "1",
   "fieldname": "enabled",
   "fieldtype": "Check",
   "label": "Enabled"
  },
  {
   "fieldname": "column_break_hpcq",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "section_break_vsib",
   "fieldtype": "Section Break"
  },
  {
   "fieldname": "send_alert_on",
   "fieldtype": "Select",
   "in_list_view": 1,
   "label": "Send Alert On",
   "options": "New Document\nUpdate\nSubmit\nCancel\nDelete",
   "reqd": 1
  },
  {
   "fieldname": "column_break_rxyz",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "document_type",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Document Type",
   "options": "DocType",
   "reqd": 1,
   "search_index": 1
  },
  {
   "fieldname": "conditions_tab",
   "fieldtype": "Tab Break",
   "label": "Conditions"
  },
  {
   "description": "Optional: The alert will be sent if this expression is true",
   "fieldname": "condition",
   "fieldtype": "Code",
   "label": "Condition"
  },
  {
   "fieldname": "recipients_tab",
   "fieldtype": "Tab Break",
   "label": "Recipients"
  },
  {
   "fieldname": "recipients",
   "fieldtype": "Table",
   "label": "Recipients",
   "options": "Raven Document Notification Recipients",
   "reqd": 1
  },
  {
   "fieldname": "message_content_tab",
   "fieldtype": "Tab Break",
   "label": "Message Content"
  },
  {
   "description": "Can be HTML/Markdown/Plain Text. Support Jinja tags",
   "fieldname": "message",
   "fieldtype": "Code",
   "label": "Message",
   "reqd": 1
  },
  {
   "fieldname": "sender",
   "fieldtype": "Link",
   "label": "Sender",
   "options": "Raven Bot",
   "reqd": 1
  },
  {
   "default": "0",
   "description": "If enabled, the message won't have a document preview",
   "fieldname": "do_not_attach_doc",
   "fieldtype": "Check",
   "label": "Do not attach document with message"
  }
 ],
 "grid_page_length": 50,
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-04-13 16:44:11.691220",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Document Notification",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "row_format": "Dynamic",
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification\raven_document_notification.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 8599 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt
from collections import namedtuple

import frappe
from frappe import _
from frappe.model.document import Document
from frappe.utils import nowdate
from frappe.utils.jinja import validate_template
from frappe.utils.safe_exec import get_safe_globals

FORBIDDEN_DOCUMENT_TYPES = frozenset("Raven Message")


class RavenDocumentNotification(Document):
	# begin: auto-generated types
	# ruff: noqa

	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_integrations.doctype.raven_document_notification_recipients.raven_document_notification_recipients import (
			RavenDocumentNotificationRecipients,
		)

		condition: DF.Code | None
		do_not_attach_doc: DF.Check
		document_type: DF.Link
		enabled: DF.Check
		message: DF.Code
		notification_name: DF.Data
		recipients: DF.Table[RavenDocumentNotificationRecipients]
		send_alert_on: DF.Literal["New Document", "Update", "Submit", "Cancel", "Delete"]
		sender: DF.Link
	# ruff: noqa
	# end: auto-generated types

	def validate(self):
		self.validate_condition()
		self.validate_message()
		self.validate_document_type()
		self.validate_recipients()
		frappe.cache().hdel("raven_doc_notifications", self.document_type)

	def validate_condition(self):
		if self.condition:
			temp_doc = frappe.new_doc(self.document_type)
			try:
				frappe.safe_eval(self.condition, None, get_context(temp_doc.as_dict()))
			except Exception:
				frappe.throw(
					_("There was an error while evaluating the condition. Please fix your template.").format(
						self.document_type
					)
				)

	def validate_message(self):
		validate_template(self.message)

	def validate_document_type(self):
		if self.document_type in FORBIDDEN_DOCUMENT_TYPES:
			frappe.throw(_("Notification for an event on {0} is not allowed.").format(self.document_type))

	def validate_recipients(self):
		for recipient in self.recipients:
			if recipient.channel_type == "User":
				if recipient.variable_type == "Static":
					# Check if this user exists in Raven
					if not frappe.db.exists("Raven User", recipient.value):
						frappe.throw(_("User {0} does not exist in Raven.").format(recipient.value))

			elif recipient.channel_type == "Channel":
				if recipient.variable_type == "Static":
					# Check if this channel exists in Raven
					if not frappe.db.exists("Raven Channel", recipient.value):
						frappe.throw(_("Channel {0} does not exist in Raven.").format(recipient.value))

			if recipient.variable_type == "Jinja":
				validate_template(recipient.value)
			if recipient.variable_type == "DocField":
				# Check if the field exists in the document type
				meta = frappe.get_meta(self.document_type)

				has_field = meta.has_field(recipient.value)
				if not has_field:
					if recipient.value == "owner" or recipient.value == "modified_by":
						has_field = True

				if not has_field:
					frappe.throw(
						_("Field {0} does not exist in {1}.").format(recipient.value, self.document_type)
					)

	def on_update(self):
		frappe.cache().hdel("raven_doc_notifications", self.document_type)

	def on_trash(self):
		frappe.cache().hdel("raven_doc_notifications", self.document_type)

	def send_notification(self, context, link_doctype, link_document):

		bot = frappe.get_doc("Raven Bot", self.sender)

		channels, users = self.get_recipients(context)

		message = frappe.render_template(self.message, context)

		for channel in channels:
			bot.send_message(
				channel_id=channel,
				text=message,
				link_doctype=link_doctype if not self.do_not_attach_doc else None,
				link_document=link_document if not self.do_not_attach_doc else None,
				markdown=True,
				notification_name=self.name,
			)

		for user in users:
			bot.send_direct_message(
				user_id=user,
				text=message,
				link_doctype=link_doctype if not self.do_not_attach_doc else None,
				link_document=link_document if not self.do_not_attach_doc else None,
				markdown=True,
				notification_name=self.name,
			)

	def get_recipients(self, context):
		"""
		Loops through all the recipients and returns the list of users and channels
		"""
		users = []
		channels = []

		def resolve_recipient(recipient):
			if recipient.variable_type == "Static":
				return recipient.value
			elif recipient.variable_type == "Jinja":
				return frappe.render_template(recipient.value, context)
			elif recipient.variable_type == "DocField":
				return context.get("doc", {}).get(recipient.value)
			else:
				frappe.throw(_("Invalid recipient variable type: {0}").format(recipient.variable_type))

		for recipient in self.recipients:
			resolved_id = resolve_recipient(recipient)
			if resolved_id:
				if recipient.channel_type == "User":
					users.append(resolved_id)
				elif recipient.channel_type == "Channel":
					channels.append(resolved_id)

		return channels, users


doctypes_to_be_ignored = [
	"Raven Document Notification",
	"Version",
	"Comment",
	"DocType",
	"Module Def",
	"Custom Field",
]


def run_document_notification(doc, method):
	"""
	Evaluate if a notification should be sent for the document.
	Enqueues the notifications to be sent on Raven
	"""
	if doc.doctype in doctypes_to_be_ignored:
		return

	if (
		frappe.flags.in_import
		or frappe.flags.in_patch
		or frappe.flags.in_install
		or frappe.flags.in_uninstall
	):
		return

	def _get_notifications():
		"""Returns all enabled notifications for the document type"""
		notifications = frappe.get_all(
			"Raven Document Notification",
			filters={"document_type": doc.doctype, "enabled": 1},
			fields=["name", "send_alert_on", "condition"],
		)
		return notifications

	raven_notifications = frappe.cache().hget(
		"raven_doc_notifications", doc.doctype, _get_notifications
	)

	if not raven_notifications:
		# No notifications found for the document type
		return

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification\test_raven_document_notification.py
Comments: Included
Mime Type: text/x-python
Size: 890 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record depdendencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class UnitTestRavenDocumentNotification(UnitTestCase):
	"""
	Unit tests for RavenDocumentNotification.
	Use this class for testing individual functions and methods.
	"""

	pass


class IntegrationTestRavenDocumentNotification(IntegrationTestCase):
	"""
	Integration tests for RavenDocumentNotification.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification_recipients\raven_document_notification_recipients.json
Comments: Included
Mime Type: application/json
Size: 1063 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-12-15 17:44:18.087743",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "channel_type",
  "variable_type",
  "value"
 ],
 "fields": [
  {
   "fieldname": "channel_type",
   "fieldtype": "Select",
   "in_list_view": 1,
   "label": "Channel Type",
   "options": "Channel\nUser",
   "reqd": 1
  },
  {
   "fieldname": "variable_type",
   "fieldtype": "Select",
   "in_list_view": 1,
   "label": "Variable Type",
   "options": "Static\nDocField\nJinja",
   "reqd": 1
  },
  {
   "fieldname": "value",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Value",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-12-15 17:45:47.706896",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Document Notification Recipients",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification_recipients\raven_document_notification_recipients.py
Comments: Included
Mime Type: text/x-python
Size: 690 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenDocumentNotificationRecipients(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		channel_type: DF.Literal["Channel", "User"]
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		value: DF.Data
		variable_type: DF.Literal["Static", "DocField", "Jinja"]
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_document_notification_recipients\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_hr_company_workspace\raven_hr_company_workspace.json
Comments: Included
Mime Type: application/json
Size: 907 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-12-06 23:59:09.259014",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "company",
  "raven_workspace"
 ],
 "fields": [
  {
   "description": "Link to the company",
   "fieldname": "company",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Company",
   "reqd": 1
  },
  {
   "fieldname": "raven_workspace",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Raven Workspace",
   "options": "Raven Workspace",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-12-07 00:00:43.077659",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven HR Company Workspace",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_hr_company_workspace\raven_hr_company_workspace.py
Comments: Included
Mime Type: text/x-python
Size: 601 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenHRCompanyWorkspace(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		company: DF.Data
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		raven_workspace: DF.Link
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_hr_company_workspace\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_incoming_webhook\raven_incoming_webhook.js
Comments: Included
Mime Type: text/javascript
Size: 364 bytes
Content:
// Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

frappe.ui.form.on("Raven Incoming Webhook", {
	refresh(frm) {
		const url = new URL(`/api/method/raven.webhook/${frm.doc.name}`, window.location.origin);
		frm.set_value("webhook_url", url.toString());
	},
});

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_incoming_webhook\raven_incoming_webhook.json
Comments: Included
Mime Type: application/json
Size: 1659 bytes
Content:
{
 "actions": [],
 "creation": "2025-04-09 16:52:43.811064",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "webhook_url",
  "section_break_ygew",
  "channel_id",
  "column_break_guju",
  "bot"
 ],
 "fields": [
  {
   "fieldname": "webhook_url",
   "fieldtype": "Read Only",
   "label": "Webhook URL"
  },
  {
   "fieldname": "section_break_ygew",
   "fieldtype": "Section Break"
  },
  {
   "fieldname": "column_break_guju",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "bot",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Bot",
   "options": "Raven User",
   "reqd": 1
  },
  {
   "fieldname": "channel_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Channel ID",
   "options": "Raven Channel",
   "reqd": 1
  }
 ],
 "grid_page_length": 50,
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-04-09 17:50:42.984484",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Incoming Webhook",
 "naming_rule": "By script",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "select": 1,
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "select": 1,
   "share": 1,
   "write": 1
  }
 ],
 "quick_entry": 1,
 "row_format": "Dynamic",
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": [],
 "title_field": "channel_id"
}

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_incoming_webhook\raven_incoming_webhook.py
Comments: Included
Mime Type: text/x-python
Size: 2660 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import secrets
from typing import TYPE_CHECKING, TypedDict

import frappe
from frappe.model.document import Document
from frappe.utils import md_to_html
from werkzeug import Response

if TYPE_CHECKING:
	from raven.raven_messaging.doctype.raven_message.raven_message import RavenMessage


class RavenIncomingWebhook(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		bot: DF.Link
		channel_id: DF.Link
		webhook_url: DF.ReadOnly | None
	# end: auto-generated types

	def autoname(self):
		self.name = f"{secrets.token_urlsafe(3 * 16)[:64]}"


@frappe.whitelist(allow_guest=True, methods=["POST", "GET"])
def handle_incoming_webhook(*args, **kwargs):
	if frappe.request.method == "GET":
		frappe.response.http_status_code = 400
		return "POST request expected"

	# Extract the last part of the path. This is the ID of the incoming webhook.
	if frappe.request.path.startswith("/api/method/"):
		webhook_id = str(frappe.request.path.strip("/").rsplit("/", maxsplit=1)[-1])
	else:
		frappe.response.http_status_code = 400
		return "invalid webhook url"

	if not frappe.db.exists("Raven Incoming Webhook", webhook_id):
		frappe.response.http_status_code = 404
		return "webhook not found"

	# Check input
	if not frappe.request.is_json:
		frappe.response.http_status_code = 400
		return "json expected"
	if not isinstance(frappe.request.json, dict):
		frappe.response.http_status_code = 400
		return "dict expected"

	# Parse payload
	data = _parse_webhook_data(frappe.request.json)

	incoming_webhook: "RavenIncomingWebhook" = frappe.get_doc("Raven Incoming Webhook", webhook_id)  # type: ignore
	message: "RavenMessage" = frappe.new_doc("Raven Message")  # type: ignore

	message.bot = incoming_webhook.bot
	message.channel_id = incoming_webhook.channel_id
	message.text = data["content"]
	message.is_bot_message = True
	message.flags.ignore_permissions = True
	message.save()

	return Response("ok", status=201)


def _parse_webhook_data(raw_data: dict):
	data: incoming_webhook_payload_t = {
		"content": "",
	}

	content = str(raw_data.get("content") or "")
	content = md_to_html(content) or ""
	data["content"] = content.rstrip("\n")

	if not data["content"]:
		data["content"] = "<p></p>"

	return data


class incoming_webhook_payload_t(TypedDict, total=True):
	content: str

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_incoming_webhook\test_raven_incoming_webhook.py
Comments: Included
Mime Type: text/x-python
Size: 901 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# For license information, please see license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record dependencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class UnitTestRavenIncomingWebhook(UnitTestCase):
	"""
	Unit tests for RavenIncomingWebhook.
	Use this class for testing individual functions and methods.
	"""

	pass


class IntegrationTestRavenIncomingWebhook(IntegrationTestCase):
	"""
	Integration tests for RavenIncomingWebhook.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_incoming_webhook\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action\raven_message_action.js
Comments: Included
Mime Type: text/javascript
Size: 234 bytes
Content:
// Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Message Action", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action\raven_message_action.json
Comments: Included
Mime Type: application/json
Size: 3263 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2024-10-16 11:06:04.587296",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "action_name",
  "enabled",
  "column_break_tbnt",
  "action",
  "document_type",
  "custom_function_path",
  "server_script",
  "dialog_properties_tab",
  "title",
  "description",
  "success_message",
  "fields_tab",
  "fields"
 ],
 "fields": [
  {
   "description": "Shown on the dialog",
   "fieldname": "title",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Title",
   "reqd": 1
  },
  {
   "fieldname": "description",
   "fieldtype": "Small Text",
   "label": "Description"
  },
  {
   "fieldname": "column_break_tbnt",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "action",
   "fieldtype": "Select",
   "label": "Action",
   "options": "Create Document\nCustom Function\nServer Script",
   "reqd": 1
  },
  {
   "depends_on": "eval: doc.action == \"Create Document\";",
   "fieldname": "document_type",
   "fieldtype": "Link",
   "label": "Document Type",
   "mandatory_depends_on": "eval: doc.action == \"Create Document\";",
   "options": "DocType"
  },
  {
   "fieldname": "success_message",
   "fieldtype": "Small Text",
   "label": "Success Message"
  },
  {
   "default": "1",
   "fieldname": "enabled",
   "fieldtype": "Check",
   "label": "Enabled"
  },
  {
   "fieldname": "action_name",
   "fieldtype": "Data",
   "label": "Action Name",
   "reqd": 1
  },
  {
   "depends_on": "eval: doc.action == \"Custom Function\";",
   "fieldname": "custom_function_path",
   "fieldtype": "Small Text",
   "label": "Custom Function Path",
   "mandatory_depends_on": "eval: doc.action == \"Custom Function\";"
  },
  {
   "fieldname": "fields_tab",
   "fieldtype": "Tab Break",
   "label": "Fields"
  },
  {
   "fieldname": "fields",
   "fieldtype": "Table",
   "label": "Fields",
   "options": "Raven Message Action Fields"
  },
  {
   "fieldname": "dialog_properties_tab",
   "fieldtype": "Tab Break",
   "label": "Dialog Properties"
  },
  {
   "fieldname": "server_script",
   "fieldtype": "Link",
   "label": "Server Script",
   "options": "Server Script"
  }
 ],
 "grid_page_length": 50,
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-03-10 23:03:38.680632",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Message Action",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "row_format": "Dynamic",
 "search_fields": "action_name",
 "show_title_field_in_link": 1,
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": [],
 "title_field": "action_name"
}
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action\raven_message_action.py
Comments: Included
Mime Type: text/x-python
Size: 2522 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

import frappe
from frappe import _, is_whitelisted
from frappe.model.document import Document


class RavenMessageAction(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_integrations.doctype.raven_message_action_fields.raven_message_action_fields import (
			RavenMessageActionFields,
		)

		action: DF.Literal["Create Document", "Custom Function", "Server Script"]
		action_name: DF.Data
		custom_function_path: DF.SmallText | None
		description: DF.SmallText | None
		document_type: DF.Link | None
		enabled: DF.Check
		fields: DF.Table[RavenMessageActionFields]
		server_script: DF.Link | None
		success_message: DF.SmallText | None
		title: DF.Data
	# end: auto-generated types

	def validate(self):

		self.validate_action_type()
		self.validate_custom_function_path()
		self.validate_server_script()
		self.validate_doctype_fields()

	def validate_action_type(self):
		if self.action == "Create Document":
			if not self.document_type:
				frappe.throw(_("Document Type is required."))
		elif self.action == "Custom Function":
			if not self.custom_function_path:
				frappe.throw(_("Function Path is required."))
		elif self.action == "Server Script":
			if not self.server_script:
				frappe.throw(_("Server Script is required."))

	def validate_custom_function_path(self):
		if self.action == "Custom Function":
			f = frappe.get_attr(self.custom_function_path)
			if not f:
				frappe.throw(_("Function {0} not found.").format(self.custom_function_path))

			is_whitelisted(f)

	def validate_server_script(self):
		if self.action == "Server Script":
			script = frappe.get_doc("Server Script", self.server_script)
			if script.script_type != "API":
				frappe.throw(_("Server Script must be of type API."))
			if script.disabled:
				frappe.throw(_("Server Script {0} is disabled.").format(self.server_script))

	def validate_doctype_fields(self):
		if self.action == "Create Document":
			doctype = frappe.get_meta(self.document_type)
			for param in self.fields:
				field = doctype.get_field(param.fieldname)

				if not field:
					frappe.throw(_("Field {0} not found in {1}").format(param.fieldname, self.document_type))

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action\test_raven_message_action.py
Comments: Included
Mime Type: text/x-python
Size: 847 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record depdendencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class TestRavenMessageAction(UnitTestCase):
	"""
	Unit tests for RavenMessageAction.
	Use this class for testing individual functions and methods.
	"""

	pass


class TestRavenMessageAction(IntegrationTestCase):
	"""
	Integration tests for RavenMessageAction.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action_fields\raven_message_action_fields.json
Comments: Included
Mime Type: application/json
Size: 1963 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-10-16 11:17:20.935886",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "fieldname",
  "label",
  "helper_text",
  "is_required",
  "column_break_gsrk",
  "type",
  "options",
  "default_values_section",
  "default_value_type",
  "default_value"
 ],
 "fields": [
  {
   "fieldname": "fieldname",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Fieldname",
   "reqd": 1
  },
  {
   "fieldname": "label",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Label",
   "reqd": 1
  },
  {
   "fieldname": "helper_text",
   "fieldtype": "Data",
   "label": "Helper Text",
   "length": 300
  },
  {
   "fieldname": "default_value",
   "fieldtype": "Small Text",
   "label": "Default Value"
  },
  {
   "fieldname": "column_break_gsrk",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "type",
   "fieldtype": "Select",
   "in_list_view": 1,
   "label": "Type",
   "options": "Data\nNumber\nSelect\nLink\nDate\nTime\nDatetime\nSmall Text\nCheckbox",
   "reqd": 1
  },
  {
   "fieldname": "options",
   "fieldtype": "Small Text",
   "label": "Options"
  },
  {
   "default": "0",
   "fieldname": "is_required",
   "fieldtype": "Check",
   "label": "Is Required?"
  },
  {
   "fieldname": "default_values_section",
   "fieldtype": "Section Break",
   "label": "Default Values"
  },
  {
   "fieldname": "default_value_type",
   "fieldtype": "Select",
   "label": "Default Value Type",
   "options": "Static\nMessage Field\nJinja"
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-10-16 11:22:03.745105",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Message Action Fields",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action_fields\raven_message_action_fields.py
Comments: Included
Mime Type: text/x-python
Size: 909 bytes
Content:
# Copyright (c) 2024, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenMessageActionFields(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		default_value: DF.SmallText | None
		default_value_type: DF.Literal["Static", "Message Field", "Jinja"]
		fieldname: DF.Data
		helper_text: DF.Data | None
		is_required: DF.Check
		label: DF.Data
		options: DF.SmallText | None
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		type: DF.Literal[
			"Data", "Number", "Select", "Link", "Date", "Time", "Datetime", "Small Text", "Checkbox"
		]
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_message_action_fields\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_scheduler_event\raven_scheduler_event.js
Comments: Included
Mime Type: text/javascript
Size: 201 bytes
Content:
// Copyright (c) 2024, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Scheduler Event", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_scheduler_event\raven_scheduler_event.json
Comments: Included
Mime Type: application/json
Size: 2508 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:event_name",
 "creation": "2024-02-23 13:05:16.692071",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "event_name",
  "disabled",
  "event_frequency",
  "cron_expression",
  "bot",
  "column_break_pjem",
  "send_to",
  "channel",
  "dm",
  "content",
  "scheduler_event_id"
 ],
 "fields": [
  {
   "fieldname": "event_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "default": "0",
   "fieldname": "disabled",
   "fieldtype": "Check",
   "label": "Disabled"
  },
  {
   "fieldname": "event_frequency",
   "fieldtype": "Select",
   "label": "Event Frequency",
   "options": "Every Day\nEvery Day of the week\nDate of the month\nCron"
  },
  {
   "fieldname": "cron_expression",
   "fieldtype": "Data",
   "label": "CRON Expression"
  },
  {
   "description": "This Bot will be used to send the message.",
   "fieldname": "bot",
   "fieldtype": "Link",
   "label": "Bot",
   "options": "Raven Bot",
   "reqd": 1
  },
  {
   "fieldname": "send_to",
   "fieldtype": "Select",
   "label": "Send to",
   "options": "Channel\nDM"
  },
  {
   "depends_on": "eval: doc.send_to === \"Channel\"",
   "fieldname": "channel",
   "fieldtype": "Link",
   "label": "Channel",
   "options": "Raven Channel",
   "reqd": 1
  },
  {
   "depends_on": "eval: doc.send_to === \"DM\"",
   "fieldname": "dm",
   "fieldtype": "Link",
   "label": "DM",
   "mandatory_depends_on": "eval: doc.send_to === \"DM\"",
   "options": "Raven Channel"
  },
  {
   "fieldname": "content",
   "fieldtype": "Small Text",
   "label": "Content",
   "reqd": 1
  },
  {
   "fieldname": "scheduler_event_id",
   "fieldtype": "Link",
   "label": "Scheduler Event ID",
   "options": "Server Script"
  },
  {
   "fieldname": "column_break_pjem",
   "fieldtype": "Column Break"
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-12-07 23:15:03.384652",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Scheduler Event",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_scheduler_event\raven_scheduler_event.py
Comments: Included
Mime Type: text/x-python
Size: 2895 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe.model.document import Document


class RavenSchedulerEvent(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		bot: DF.Link
		channel: DF.Link
		content: DF.SmallText
		cron_expression: DF.Data | None
		disabled: DF.Check
		dm: DF.Link | None
		event_frequency: DF.Literal["Every Day", "Every Day of the week", "Date of the month", "Cron"]
		event_name: DF.Data
		scheduler_event_id: DF.Link | None
		send_to: DF.Literal["Channel", "DM"]
	# end: auto-generated types

	def before_save(self):
		"""
		1. If the 'scheduler_event_id' is not set, create a Server Script of type 'Scheduler Event' and set the 'scheduler_event_id' to the name of the Server Script.
		"""
		if not self.scheduler_event_id:
			self.scheduler_event_id = self.create_scheduler_event()
		else:
			server_script = frappe.get_doc("Server Script", self.scheduler_event_id)
			server_script.cron_format = self.cron_expression
			server_script.script = self.get_scheduler_event_script()
			server_script.save()

	def on_update(self):
		"""
		1. If the 'scheduler_event_id' is set, and the 'disabled' field is updated, update the 'disabled' field of the Server Script of type 'Scheduler Event' with the name 'scheduler_event_id'.
		"""
		if self.scheduler_event_id:
			server_script = frappe.get_doc("Server Script", self.scheduler_event_id)
			server_script.disabled = self.disabled
			server_script.save()

	def on_trash(self):
		"""
		1. If the 'scheduler_event_id' is set, delete the Server Script of type 'Scheduler Event' with the name 'scheduler_event_id'.
		"""
		if self.scheduler_event_id:
			frappe.db.delete("Server Script", self.scheduler_event_id)

	def create_scheduler_event(self):
		"""
		Create a Server Script of type 'Scheduler Event' and set the 'scheduler_event_id' to the name of the Server Script.
		"""
		server_script = frappe.get_doc(
			{
				"doctype": "Server Script",
				"script_type": "Scheduler Event",
				"name": self.event_name,
				"disabled": 0,
				"event_frequency": "Cron",
				"cron_format": self.cron_expression,
				"script": self.get_scheduler_event_script(),
			}
		)
		server_script.insert()
		return server_script.name

	def get_scheduler_event_script(self):
		"""
		Get the script for the Scheduler Event
		"""
		# bot = frappe.get_doc('Raven Bot', self.bot)
		# bot.send_message(self.channel, {'text': self.content})
		# return code snippet with bot & content as values
		script = f"""
bot = frappe.get_doc('Raven Bot', '{self.bot}')\n
bot.send_message('{self.channel}', '{self.content}')
"""
		return script

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_scheduler_event\test_raven_scheduler_event.py
Comments: Included
Mime Type: text/x-python
Size: 203 bytes
Content:
# Copyright (c) 2024, The Commit Company and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenSchedulerEvent(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_scheduler_event\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_webhook\raven_webhook.js
Comments: Included
Mime Type: text/javascript
Size: 193 bytes
Content:
// Copyright (c) 2024, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Webhook", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_webhook\raven_webhook.json
Comments: Included
Mime Type: application/json
Size: 5525 bytes
Content:
{
 "actions": [],
 "autoname": "prompt",
 "creation": "2024-02-23 13:21:14.329211",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "sb_doc_events",
  "enabled",
  "trigger_webhook_on_condition",
  "channel_id",
  "user",
  "channel_type",
  "condition",
  "cb_condition",
  "webhook_trigger",
  "conditions_on",
  "html_condition",
  "sb_webhook",
  "request_url",
  "timeout",
  "is_dynamic_url",
  "cb_webhook",
  "sb_security",
  "enable_security",
  "webhook_secret",
  "sb_webhook_headers",
  "webhook_headers",
  "sb_webhook_data",
  "webhook_data",
  "webhook"
 ],
 "fields": [
  {
   "fieldname": "sb_doc_events",
   "fieldtype": "Section Break",
   "label": "Doc Events"
  },
  {
   "default": "1",
   "fieldname": "enabled",
   "fieldtype": "Check",
   "label": "Enabled"
  },
  {
   "depends_on": "eval:doc.conditions_on === 'Custom'",
   "description": "The webhook will be triggered if this expression is true",
   "fieldname": "condition",
   "fieldtype": "Small Text",
   "label": "Condition",
   "mandatory_depends_on": "eval:doc.conditions_on === 'Custom'"
  },
  {
   "fieldname": "cb_condition",
   "fieldtype": "Column Break"
  },
  {
   "depends_on": "eval:doc.conditions_on === 'Custom'",
   "fieldname": "html_condition",
   "fieldtype": "HTML",
   "options": "<p><strong>Condition Examples:</strong></p>\n<pre>doc.status==\"Open\"<br>doc.due_date==nowdate()<br>doc.total &gt; 40000\n</pre>"
  },
  {
   "fieldname": "sb_webhook",
   "fieldtype": "Section Break",
   "label": "Webhook Request"
  },
  {
   "fieldname": "request_url",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Request URL",
   "reqd": 1
  },
  {
   "default": "5",
   "description": "The number of seconds until the request expires",
   "fieldname": "timeout",
   "fieldtype": "Int",
   "label": "Request Timeout",
   "reqd": 1
  },
  {
   "default": "0",
   "description": "On checking this option, URL will be treated like a jinja template string",
   "fieldname": "is_dynamic_url",
   "fieldtype": "Check",
   "label": "Is Dynamic URL?"
  },
  {
   "fieldname": "cb_webhook",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "sb_security",
   "fieldtype": "Section Break",
   "label": "Webhook Security"
  },
  {
   "default": "0",
   "fieldname": "enable_security",
   "fieldtype": "Check",
   "label": "Enable Security"
  },
  {
   "depends_on": "eval:doc.enable_security == 1",
   "fieldname": "webhook_secret",
   "fieldtype": "Password",
   "label": "Webhook Secret"
  },
  {
   "fieldname": "sb_webhook_headers",
   "fieldtype": "Section Break",
   "label": "Webhook Headers"
  },
  {
   "fieldname": "webhook_headers",
   "fieldtype": "Table",
   "label": "Headers",
   "options": "Webhook Header"
  },
  {
   "fieldname": "sb_webhook_data",
   "fieldtype": "Section Break",
   "label": "Webhook Data"
  },
  {
   "depends_on": "eval: !doc.request_structure || doc.request_structure == \"Form URL-Encoded\"",
   "fieldname": "webhook_data",
   "fieldtype": "Table",
   "label": "Data",
   "options": "Webhook Data"
  },
  {
   "fieldname": "webhook_trigger",
   "fieldtype": "Select",
   "label": "Webhook Trigger",
   "options": "Message Sent\nMessage Edited\nMessage Deleted\nMessage Reacted On\nChannel Created\nChannel Deleted\nChannel Member Added\nChannel Member Deleted\nUser Added\nUser Deleted",
   "reqd": 1,
   "set_only_once": 1
  },
  {
   "default": "0",
   "fieldname": "trigger_webhook_on_condition",
   "fieldtype": "Check",
   "label": "Trigger Webhook on Condition"
  },
  {
   "depends_on": "eval:doc.trigger_webhook_on_condition===1",
   "fieldname": "conditions_on",
   "fieldtype": "Select",
   "label": "Conditions On",
   "mandatory_depends_on": "eval:doc.trigger_webhook_on_condition===1",
   "options": "\nChannel\nUser\nChannel Type\nCustom"
  },
  {
   "depends_on": "eval:doc.conditions_on === 'Channel'",
   "fieldname": "channel_id",
   "fieldtype": "Link",
   "label": "Channel",
   "mandatory_depends_on": "eval:doc.conditions_on === 'Channel'",
   "options": "Raven Channel"
  },
  {
   "depends_on": "eval:doc.conditions_on === 'User'",
   "fieldname": "user",
   "fieldtype": "Link",
   "label": "User",
   "mandatory_depends_on": "eval:doc.conditions_on === 'User'",
   "options": "Raven User"
  },
  {
   "depends_on": "eval:doc.conditions_on ==='Channel Type'",
   "fieldname": "channel_type",
   "fieldtype": "Select",
   "label": "Channel Type",
   "mandatory_depends_on": "eval:doc.conditions_on ==='Channel Type'",
   "options": "\nPublic\nPrivate\nOpen\nDM\nSelf Message"
  },
  {
   "fieldname": "webhook",
   "fieldtype": "Link",
   "hidden": 1,
   "label": "Webhook",
   "options": "Webhook"
  }
 ],
 "links": [
  {
   "link_doctype": "Webhook Request Log",
   "link_fieldname": "webhook"
  }
 ],
 "modified": "2024-02-23 18:29:18.230912",
 "modified_by": "Administrator",
 "module": "Raven Integrations",
 "name": "Raven Webhook",
 "naming_rule": "Set by user",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": [],
 "track_changes": 1
}
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_webhook\raven_webhook.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 7757 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document


class RavenWebhook(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.integrations.doctype.webhook_data.webhook_data import WebhookData
		from frappe.integrations.doctype.webhook_header.webhook_header import WebhookHeader
		from frappe.types import DF

		channel_id: DF.Link | None
		channel_type: DF.Literal["", "Public", "Private", "Open", "DM", "Self Message"]
		condition: DF.SmallText | None
		conditions_on: DF.Literal["", "Channel", "User", "Channel Type", "Custom"]
		enable_security: DF.Check
		enabled: DF.Check
		is_dynamic_url: DF.Check
		request_url: DF.Data
		timeout: DF.Int
		trigger_webhook_on_condition: DF.Check
		user: DF.Link | None
		webhook: DF.Link | None
		webhook_data: DF.Table[WebhookData]
		webhook_headers: DF.Table[WebhookHeader]
		webhook_secret: DF.Password | None
		webhook_trigger: DF.Literal[
			"Message Sent",
			"Message Edited",
			"Message Deleted",
			"Message Reacted On",
			"Channel Created",
			"Channel Deleted",
			"Channel Member Added",
			"Channel Member Deleted",
			"User Added",
			"User Deleted",
		]
	# end: auto-generated types

	def before_insert(self):
		# 1. Check if webhook name is unique
		webhook = frappe.get_all("Raven Webhook", filters={"name": self.name})
		if webhook:
			frappe.throw(_("Webhook name already exists"))

	def validate(self):
		# 1. Check if webhook_data and webhook_headers are unique

		webhook_data_keys = [data.key for data in self.webhook_data]
		webhook_header_keys = [data.key for data in self.webhook_headers]
		if len(webhook_data_keys) != len(set(webhook_data_keys)):
			frappe.throw(_("Webhook Data keys should be unique"))
		if len(webhook_header_keys) != len(set(webhook_header_keys)):
			frappe.throw(_("Webhook Headers keys should be unique"))

	def before_save(self):
		# 1. Check if webhook ID is exists
		# 2. If exist then update the webhook
		# 3. If not exist then create the webhook

		# 1. Check if webhook ID is exists
		if self.webhook:
			# 2. Update the webhook
			self.update_webhook()

		else:
			# 3. Create the webhook
			self.create_webhook()

	def on_trash(self):
		# Delete the webhook
		if self.webhook:
			frappe.db.delete("Webhook", self.webhook)

	def create_webhook(self):
		# Create a new webhook

		doctype, event = self.get_doctype_and_event()
		conditions = self.get_conditions()
		webhook_doc = frappe.new_doc("Webhook")
		webhook_doc.name = self.name
		webhook_doc.request_url = self.request_url
		webhook_doc.is_dynamic_url = self.is_dynamic_url
		webhook_doc.timeout = self.timeout
		webhook_doc.enable_security = self.enable_security
		webhook_doc.webhook_secret = self.webhook_secret
		webhook_doc.request_method = "POST"
		webhook_doc.request_structure = "Form URL-Encoded"
		self.set_webhook_data_and_headers(webhook_doc)
		webhook_doc.webhook_doctype = doctype
		webhook_doc.webhook_docevent = event
		webhook_doc.condition = conditions
		webhook_doc.insert()
		self.webhook = webhook_doc.name

	def update_webhook(self):
		# Update the webhook

		conditions = self.get_conditions()
		webhook_doc = frappe.get_doc("Webhook", self.webhook)
		webhook_doc.request_url = self.request_url
		webhook_doc.is_dynamic_url = self.is_dynamic_url
		webhook_doc.timeout = self.timeout
		webhook_doc.enable_security = self.enable_security
		webhook_doc.webhook_secret = self.webhook_secret
		webhook_doc.condition = conditions
		self.set_webhook_data_and_headers(webhook_doc)
		webhook_doc.save()

	def set_webhook_data_and_headers(self, webhook_doc):
		"""
		Set the webhook data and headers
		"""
		# get the existing webhook data and headers keys
		webhook_data_keys = [data.key for data in webhook_doc.webhook_data]
		webhook_header_keys = [data.key for data in webhook_doc.webhook_headers]

		# remove the existing webhook data and headers
		# which are not in the current webhook data and headers
		# and append the new webhook data and headers
		for data in self.webhook_data:
			if data.key not in webhook_data_keys:
				webhook_doc.append(
					"webhook_data",
					{
						"key": data.key,
						"fieldname": data.fieldname,
					},
				)

		for data in self.webhook_headers:
			if data.key not in webhook_header_keys:
				webhook_doc.append(
					"webhook_headers",
					{
						"key": data.key,
						"value": data.value,
					},
				)

	def get_doctype_and_event(self):
		doctypes_and_events = [
			{
				"label": "Message Sent",
				"doctype": "Raven Message",
				"event": "after_insert",
			},
			{"label": "Message Edited", "doctype": "Raven Message", "event": "on_update"},
			{"label": "Message Deleted", "doctype": "Raven Message", "event": "on_trash"},
			{"label": "Message Reacted On", "doctype": "Raven Message Reaction", "event": "after_insert"},
			{"label": "Channel Created", "doctype": "Raven Channel", "event": "after_insert"},
			{"label": "Channel Deleted", "doctype": "Raven Channel", "event": "on_trash"},
			{
				"label": "Member Added to the Channel",
				"doctype": "Raven Channel Member",
				"event": "after_insert",
			},
			{
				"label": "Member Deleted from the Channel",
				"doctype": "Raven Channel Member",
				"event": "on_trash",
			},
			{"label": "User Added", "doctype": "Raven User", "event": "after_insert"},
			{"label": "User Deleted", "doctype": "Raven User", "event": "on_trash"},
		]
		doctype, event = None, None
		for doctype_and_event in doctypes_and_events:
			if self.webhook_trigger == doctype_and_event["label"]:
				doctype = doctype_and_event["doctype"]
				event = doctype_and_event["event"]
				break
		return doctype, event

	def get_conditions(self):
		# Get the conditions for the webhook
		doctype, event = self.get_doctype_and_event()
		if self.trigger_webhook_on_condition:
			if se
--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_webhook\test_raven_webhook.py
Comments: Included
Mime Type: text/x-python
Size: 196 bytes
Content:
# Copyright (c) 2024, The Commit Company and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenWebhook(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_integrations\doctype\raven_webhook\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\doctype\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_integrations\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_custom_emoji\raven_custom_emoji.js
Comments: Included
Mime Type: text/javascript
Size: 232 bytes
Content:
// Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Custom Emoji", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_custom_emoji\raven_custom_emoji.json
Comments: Included
Mime Type: application/json
Size: 1642 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "field:emoji_name",
 "creation": "2025-01-04 03:06:50.669037",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "image",
  "emoji_name",
  "keywords"
 ],
 "fields": [
  {
   "fieldname": "image",
   "fieldtype": "Attach Image",
   "label": "Image",
   "reqd": 1
  },
  {
   "fieldname": "emoji_name",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Emoji Name",
   "reqd": 1,
   "unique": 1
  },
  {
   "fieldname": "keywords",
   "fieldtype": "Data",
   "label": "Keywords"
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-01-04 03:09:49.286615",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Custom Emoji",
 "naming_rule": "By fieldname",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "if_owner": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  },
  {
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven Admin",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "creation",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_custom_emoji\raven_custom_emoji.py
Comments: Included
Mime Type: text/x-python
Size: 556 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenCustomEmoji(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		emoji_name: DF.Data
		image: DF.AttachImage
		keywords: DF.Data | None
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_custom_emoji\test_raven_custom_emoji.py
Comments: Included
Mime Type: text/x-python
Size: 853 bytes
Content:
# Copyright (c) 2025, The Commit Company (Algocode Technologies Pvt. Ltd.) and Contributors
# See license.txt

# import frappe
from frappe.tests import IntegrationTestCase, UnitTestCase

# On IntegrationTestCase, the doctype test records and all
# link-field test record dependencies are recursively loaded
# Use these module variables to add/remove to/from that list
EXTRA_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]
IGNORE_TEST_RECORD_DEPENDENCIES = []  # eg. ["User"]


class UnitTestRavenCustomEmoji(UnitTestCase):
	"""
	Unit tests for RavenCustomEmoji.
	Use this class for testing individual functions and methods.
	"""

	pass


class IntegrationTestRavenCustomEmoji(IntegrationTestCase):
	"""
	Integration tests for RavenCustomEmoji.
	Use this class for testing interactions between multiple components.
	"""

	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_custom_emoji\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_mention\raven_mention.json
Comments: Included
Mime Type: application/json
Size: 643 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-02-23 16:51:44.622372",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "user"
 ],
 "fields": [
  {
   "fieldname": "user",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "User",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-02-23 16:55:14.344577",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Mention",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_mention\raven_mention.py
Comments: Included
Mime Type: text/x-python
Size: 525 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenMention(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		user: DF.Data
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_mention\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message\raven_message.js
Comments: Included
Mime Type: text/javascript
Size: 193 bytes
Content:
// Copyright (c) 2023, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Message", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message\raven_message.json
Comments: Included
Mime Type: application/json
Size: 5054 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2023-02-12 17:29:25.498988",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "channel_id",
  "text",
  "json",
  "message_reactions",
  "is_reply",
  "linked_message",
  "replied_message_details",
  "column_break_wvje",
  "is_thread",
  "message_type",
  "content",
  "file",
  "image_width",
  "image_height",
  "blurhash",
  "file_thumbnail",
  "thumbnail_width",
  "thumbnail_height",
  "link_doctype",
  "link_document",
  "is_edited",
  "is_forwarded",
  "mentions",
  "poll_id",
  "is_bot_message",
  "bot",
  "hide_link_preview",
  "notification"
 ],
 "fields": [
  {
   "fieldname": "channel_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Channel ID",
   "options": "Raven Channel",
   "reqd": 1,
   "search_index": 1
  },
  {
   "fieldname": "text",
   "fieldtype": "Long Text",
   "label": "Text"
  },
  {
   "fieldname": "json",
   "fieldtype": "JSON",
   "label": "JSON"
  },
  {
   "fieldname": "file",
   "fieldtype": "Attach",
   "label": "File"
  },
  {
   "fieldname": "message_type",
   "fieldtype": "Select",
   "label": "Message Type",
   "options": "Text\nImage\nFile\nPoll\nSystem"
  },
  {
   "fieldname": "message_reactions",
   "fieldtype": "JSON",
   "label": "Message Reactions"
  },
  {
   "default": "0",
   "fieldname": "is_reply",
   "fieldtype": "Check",
   "label": "Is Reply"
  },
  {
   "fieldname": "linked_message",
   "fieldtype": "Link",
   "label": "Replied Message ID",
   "options": "Raven Message"
  },
  {
   "fieldname": "file_thumbnail",
   "fieldtype": "Attach",
   "label": "File Thumbnail"
  },
  {
   "fieldname": "image_width",
   "fieldtype": "Data",
   "label": "Image Width"
  },
  {
   "fieldname": "image_height",
   "fieldtype": "Data",
   "label": "Image Height"
  },
  {
   "fieldname": "thumbnail_width",
   "fieldtype": "Data",
   "label": "Thumbnail Width"
  },
  {
   "fieldname": "thumbnail_height",
   "fieldtype": "Data",
   "label": "Thumbnail Height"
  },
  {
   "fieldname": "link_doctype",
   "fieldtype": "Link",
   "label": "Link Doctype",
   "options": "DocType"
  },
  {
   "fieldname": "link_document",
   "fieldtype": "Dynamic Link",
   "label": "Link Document",
   "options": "link_doctype",
   "search_index": 1
  },
  {
   "default": "0",
   "fieldname": "is_bot_message",
   "fieldtype": "Check",
   "label": "Is Bot Message"
  },
  {
   "depends_on": "eval: doc.is_bot_message == 1",
   "fieldname": "bot",
   "fieldtype": "Link",
   "label": "Bot",
   "mandatory_depends_on": "eval: doc.is_bot_message == 1",
   "options": "Raven User"
  },
  {
   "fieldname": "content",
   "fieldtype": "Long Text",
   "label": "Content",
   "read_only": 1
  },
  {
   "default": "0",
   "fieldname": "is_edited",
   "fieldtype": "Check",
   "label": "Is Edited"
  },
  {
   "fieldname": "column_break_wvje",
   "fieldtype": "Column Break"
  },
  {
   "fieldname": "replied_message_details",
   "fieldtype": "JSON",
   "label": "Replied Message Details"
  },
  {
   "fieldname": "mentions",
   "fieldtype": "Table",
   "label": "Mentions",
   "options": "Raven Mention"
  },
  {
   "fieldname": "poll_id",
   "fieldtype": "Link",
   "label": "Poll ID",
   "options": "Raven Poll",
   "unique": 1
  },
  {
   "default": "0",
   "fieldname": "hide_link_preview",
   "fieldtype": "Check",
   "label": "Hide link preview"
  },
  {
   "default": "0",
   "fieldname": "is_forwarded",
   "fieldtype": "Check",
   "label": "Is Forwarded"
  },
  {
   "default": "0",
   "description": "This message starts a thread",
   "fieldname": "is_thread",
   "fieldtype": "Check",
   "label": "Is Thread"
  },
  {
   "description": "Linked to the notification that triggered this message",
   "fieldname": "notification",
   "fieldtype": "Data",
   "label": "Notification",
   "read_only": 1
  },
  {
   "fieldname": "blurhash",
   "fieldtype": "Small Text",
   "label": "Blurhash"
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-05-01 21:10:41.094172",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Message",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "select": 1,
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "if_owner": 1,
   "print": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  },
  {
   "read": 1,
   "role": "Raven User"
  }
 ],
 "row_format": "Dynamic",
 "search_fields": "text",
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message\raven_message.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 20857 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# For license information, please see license.txt
import datetime
import json

import frappe
from bs4 import BeautifulSoup
from frappe import _
from frappe.model.document import Document
from frappe.utils import get_datetime, get_system_timezone
from pytz import timezone, utc

from raven.ai.ai import handle_ai_thread_message, handle_bot_dm
from raven.api.raven_channel import get_peer_user
from raven.notification import (
	send_notification_for_message,
	send_notification_to_topic,
	send_notification_to_user,
)
from raven.utils import refresh_thread_reply_count, track_channel_visit


class RavenMessage(Document):
	# begin: auto-generated types
	# ruff: noqa

	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_messaging.doctype.raven_mention.raven_mention import RavenMention

		blurhash: DF.SmallText | None
		bot: DF.Link | None
		channel_id: DF.Link
		content: DF.LongText | None
		file: DF.Attach | None
		file_thumbnail: DF.Attach | None
		hide_link_preview: DF.Check
		image_height: DF.Data | None
		image_width: DF.Data | None
		is_bot_message: DF.Check
		is_edited: DF.Check
		is_forwarded: DF.Check
		is_reply: DF.Check
		is_thread: DF.Check
		json: DF.JSON | None
		link_doctype: DF.Link | None
		link_document: DF.DynamicLink | None
		linked_message: DF.Link | None
		mentions: DF.Table[RavenMention]
		message_reactions: DF.JSON | None
		message_type: DF.Literal["Text", "Image", "File", "Poll", "System"]
		notification: DF.Data | None
		poll_id: DF.Link | None
		replied_message_details: DF.JSON | None
		text: DF.LongText | None
		thumbnail_height: DF.Data | None
		thumbnail_width: DF.Data | None
	# ruff: noqa
	# end: auto-generated types

	def before_validate(self):

		if not self.is_new() and not self.flags.is_ai_streaming:
			# this is not a new message, so it's a previous message being edited
			old_doc = self.get_doc_before_save()
			if old_doc.text != self.text:
				self.is_edited = True

		self.parse_html_content()

	def parse_html_content(self):
		"""
		Parse the HTML content to do the following:
		1. Extract all user mentions
		2. Remove empty trailing paragraphs
		3. Extract the text content
		4. TODO: Extract all links
		"""
		if not self.text:
			return
		if self.message_type == "System":
			return

		soup = BeautifulSoup(self.text, "html.parser")
		self.remove_empty_trailing_paragraphs(soup)
		self.extract_mentions(soup)

		text_content = soup.get_text(" ", strip=True)

		if not text_content:
			# Check if the content has a GIF
			for img in soup.find_all("img"):
				if "media.tenor.com" in img.get("src"):
					text_content = "Sent a GIF"
					break

		self.content = text_content

		if not self.content and self.link_doctype and self.link_document:
			self.content = f"{self.link_doctype} - {self.link_document}"

	def extract_mentions(self, soup):
		"""
		Extract all user mentions from the HTML content
		"""
		self.mentions = []
		unique_mentions = set()
		for d in soup.find_all("span", attrs={"data-type": "userMention"}):
			mention_id = d.get("data-id")
			if mention_id and mention_id not in unique_mentions:
				self.append("mentions", {"user": mention_id})

				frappe.publish_realtime(
					"raven_mention",
					{
						"channel_id": self.channel_id,
						"user_id": mention_id,
					},
					user=mention_id,
					after_commit=True,
				)
				unique_mentions.add(mention_id)

	def remove_empty_trailing_paragraphs(self, soup):
		"""
		Remove p, br tags that are at the end with no content
		"""
		all_tags = soup.find_all(True)
		all_tags.reverse()
		for tag in all_tags:
			if tag.name in ["br", "p"] and not tag.contents:
				tag.extract()
			else:
				break
		self.text = str(soup)

	def validate(self):
		"""
		1. If there is a linked message, the linked message should be in the same channel
		"""
		self.validate_linked_message()
		"""
		2. If the message is of type Poll, the poll_id should be set
		"""
		self.validate_poll_id()

	def validate_linked_message(self):
		"""
		If there is a linked message, the linked message should be in the same channel
		"""
		if self.linked_message:
			if (
				frappe.get_cached_value("Raven Message", self.linked_message, "channel_id") != self.channel_id
			):
				frappe.throw(_("Linked message should be in the same channel"))

	def validate_poll_id(self):
		"""
		If the message is of type Poll, the poll_id should be set
		"""
		if self.message_type == "Poll" and not self.poll_id:
			frappe.throw(_("Poll ID is mandatory for a poll message"))

	def before_insert(self):
		"""
		If the message is a reply, update the replied_message_details field
		"""
		if self.is_reply and self.linked_message:
			details = frappe.db.get_value(
				"Raven Message",
				self.linked_message,
				["text", "content", "file", "message_type", "owner", "creation"],
				as_dict=True,
			)
			self.replied_message_details = {
				"text": details.text,
				"content": details.content,
				"file": details.file,
				"message_type": details.message_type,
				"owner": details.owner,
				"creation": datetime.datetime.strftime(details.creation, "%Y-%m-%d %H:%M:%S"),
			}

	def after_insert(self):
		if self.message_type != "System":
			last_message_details = self.set_last_message_timestamp()
			self.publish_unread_count_event(last_message_details)

		if self.message_type == "Text":
			self.handle_ai_message()

		self.send_push_notification()

	def handle_ai_message(self):

		# If the message was sent by a bot, do not call the function
		if self.is_bot_message:
			return

		# If AI Integration is not enabled, do not call the function
		raven_settings = frappe.get_cached_doc("Raven Settings")
		if not raven_settings.enable_ai_integration:
			return

		# Check if this channel is an AI Thread channel

		channel_doc = frappe.get_cached_doc("Raven Channel", self.channel_id)

		is_ai_thread = channel_doc.is_ai_thread
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message\test_raven_message.py
Comments: Included
Mime Type: text/x-python
Size: 196 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenMessage(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message_reaction\raven_message_reaction.js
Comments: Included
Mime Type: text/javascript
Size: 202 bytes
Content:
// Copyright (c) 2023, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Message Reaction", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message_reaction\raven_message_reaction.json
Comments: Included
Mime Type: application/json
Size: 1723 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "autoname": "hash",
 "creation": "2023-05-08 12:00:26.094736",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "reaction",
  "reaction_escaped",
  "message",
  "channel_id",
  "is_custom"
 ],
 "fields": [
  {
   "fieldname": "reaction",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Reaction",
   "reqd": 1
  },
  {
   "fieldname": "message",
   "fieldtype": "Link",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Message",
   "options": "Raven Message",
   "reqd": 1,
   "search_index": 1
  },
  {
   "fieldname": "reaction_escaped",
   "fieldtype": "Data",
   "in_list_view": 1,
   "label": "Reaction Escaped",
   "search_index": 1
  },
  {
   "fieldname": "channel_id",
   "fieldtype": "Link",
   "label": "Channel ID",
   "options": "Raven Channel"
  },
  {
   "default": "0",
   "fieldname": "is_custom",
   "fieldtype": "Check",
   "label": "Is Custom"
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2025-01-04 04:43:58.861388",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Message Reaction",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "delete": 1,
   "email": 1,
   "export": 1,
   "if_owner": 1,
   "print": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1,
   "write": 1
  }
 ],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message_reaction\raven_message_reaction.py
Comments: Included
Mime Type: text/x-python
Size: 918 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# For license information, please see license.txt

import json

import frappe
from frappe.model.document import Document

from raven.api.reactions import calculate_message_reaction


class RavenMessageReaction(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		channel_id: DF.Link | None
		is_custom: DF.Check
		message: DF.Link
		reaction: DF.Data
		reaction_escaped: DF.Data | None
	# end: auto-generated types

	def after_insert(self):
		# Update the count for the current reaction
		calculate_message_reaction(self.message, self.channel_id)

	def after_delete(self):
		# Update the count for the current reaction
		calculate_message_reaction(self.message, self.channel_id)

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message_reaction\test_raven_message_reaction.py
Comments: Included
Mime Type: text/x-python
Size: 204 bytes
Content:
# Copyright (c) 2023, The Commit Company and contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenMessageReaction(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_message_reaction\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll\raven_poll.js
Comments: Included
Mime Type: text/javascript
Size: 190 bytes
Content:
// Copyright (c) 2024, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Poll", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll\raven_poll.json
Comments: Included
Mime Type: application/json
Size: 2380 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-03-22 15:55:33.483101",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "section_break_poll_question",
  "question",
  "section_break_poll_options",
  "options",
  "section_break_poll_settings",
  "is_anonymous",
  "is_multi_choice",
  "is_disabled",
  "section_break_poll_votes",
  "total_votes"
 ],
 "fields": [
  {
   "fieldname": "section_break_poll_question",
   "fieldtype": "Section Break",
   "label": "Poll Question"
  },
  {
   "fieldname": "question",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "label": "Question",
   "reqd": 1
  },
  {
   "fieldname": "section_break_poll_options",
   "fieldtype": "Section Break",
   "label": "Poll Options"
  },
  {
   "fieldname": "options",
   "fieldtype": "Table",
   "label": "Options",
   "options": "Raven Poll Option",
   "reqd": 1
  },
  {
   "fieldname": "section_break_poll_settings",
   "fieldtype": "Section Break",
   "label": "Poll Settings"
  },
  {
   "default": "0",
   "fieldname": "is_anonymous",
   "fieldtype": "Check",
   "label": "Is Anonymous"
  },
  {
   "default": "0",
   "fieldname": "is_multi_choice",
   "fieldtype": "Check",
   "label": "Is Multi Choice"
  },
  {
   "default": "0",
   "fieldname": "is_disabled",
   "fieldtype": "Check",
   "label": "Is Disabled"
  },
  {
   "fieldname": "section_break_poll_votes",
   "fieldtype": "Section Break",
   "label": "Poll Votes"
  },
  {
   "fieldname": "total_votes",
   "fieldtype": "Int",
   "label": "Total Votes",
   "non_negative": 1,
   "read_only": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-03-31 18:33:08.676465",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Poll",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "if_owner": 1,
   "read": 1,
   "role": "Raven User"
  },
  {
   "create": 1,
   "read": 1,
   "role": "Raven User"
  }
 ],
 "show_title_field_in_link": 1,
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": [],
 "title_field": "question"
}
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll\raven_poll.py
Comments: Included
Mime Type: text/x-python
Size: 1150 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe.model.document import Document


class RavenPoll(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		from raven.raven_messaging.doctype.raven_poll_option.raven_poll_option import RavenPollOption

		is_anonymous: DF.Check
		is_disabled: DF.Check
		is_multi_choice: DF.Check
		options: DF.Table[RavenPollOption]
		question: DF.SmallText
		total_votes: DF.Int
	# end: auto-generated types

	def before_validate(self):
		# Total_votes is the sum of all votes in the poll per user
		poll_votes = frappe.get_all(
			"Raven Poll Vote", filters={"poll_id": self.name}, fields=["user_id"], group_by="user_id"
		)

		# count the number of unique users who voted
		self.total_votes = len(poll_votes) if poll_votes else 0

	def on_trash(self):
		# Delete all poll votes
		frappe.db.delete("Raven Poll Vote", {"poll_id": self.name})

	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll\test_raven_poll.py
Comments: Included
Mime Type: text/x-python
Size: 1272 bytes
Content:
# Copyright (c) 2024, The Commit Company and Contributors
# See license.txt

import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenPoll(FrappeTestCase):
	# 1. Only the poll creator is allowed to view the poll in the Raven Poll list view.

	# 2. Only the poll creator is allowed to edit the poll.

	# 3. Only the poll creator is allowed to delete the poll.

	# 4. Only the poll creator is allowed to disable (close) the poll.

	# 5. All users who are part of the channel wherein the poll was created should be allowed to vote on the poll.

	# 6. If poll has option to allow multiple choices (is_multi_choice is checked), users should be allowed to vote on multiple options.
	# But each user should be allowed to vote only once on each option.

	# 7. If poll is not multi-choice, users should be allowed to vote only once.

	# 8. Users should not be able to edit or delete votes cast by other users/themselves but can view votes if the poll is not anonymous.

	# 9. If the poll is anonymous (is_anonymous is checked), all users including the poll creator should not be able to access Raven Poll
	# Vote list view for that poll.

	# 10. If poll is closed (is_disabled is checked), no more votes should be allowed.

	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_option\raven_poll_option.json
Comments: Included
Mime Type: application/json
Size: 1052 bytes
Content:
{
 "actions": [],
 "autoname": "hash",
 "creation": "2024-03-22 15:51:21.979190",
 "default_view": "List",
 "doctype": "DocType",
 "editable_grid": 1,
 "engine": "InnoDB",
 "field_order": [
  "section_break_poll_option",
  "option",
  "votes"
 ],
 "fields": [
  {
   "fieldname": "section_break_poll_option",
   "fieldtype": "Section Break",
   "label": "Poll Option"
  },
  {
   "fieldname": "option",
   "fieldtype": "Small Text",
   "in_list_view": 1,
   "in_standard_filter": 1,
   "label": "Option",
   "reqd": 1
  },
  {
   "fieldname": "votes",
   "fieldtype": "Int",
   "in_list_view": 1,
   "label": "Votes",
   "non_negative": 1,
   "read_only": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "istable": 1,
 "links": [],
 "modified": "2024-03-31 18:33:28.158318",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Poll Option",
 "naming_rule": "Random",
 "owner": "Administrator",
 "permissions": [],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_option\raven_poll_option.py
Comments: Included
Mime Type: text/x-python
Size: 552 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

# import frappe
from frappe.model.document import Document


class RavenPollOption(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		option: DF.SmallText
		parent: DF.Data
		parentfield: DF.Data
		parenttype: DF.Data
		votes: DF.Int
	# end: auto-generated types

	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_option\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_vote\raven_poll_vote.js
Comments: Included
Mime Type: text/javascript
Size: 195 bytes
Content:
// Copyright (c) 2024, The Commit Company and contributors
// For license information, please see license.txt

// frappe.ui.form.on("Raven Poll Vote", {
// 	refresh(frm) {

// 	},
// });

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_vote\raven_poll_vote.json
Comments: Included
Mime Type: application/json
Size: 1733 bytes
Content:
{
 "actions": [],
 "allow_rename": 1,
 "creation": "2024-03-22 16:02:03.878821",
 "doctype": "DocType",
 "engine": "InnoDB",
 "field_order": [
  "section_break_user",
  "user_id",
  "section_break_poll",
  "poll_id",
  "section_break_vote",
  "option"
 ],
 "fields": [
  {
   "fieldname": "section_break_user",
   "fieldtype": "Section Break",
   "label": "User"
  },
  {
   "fieldname": "user_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "User",
   "options": "Raven User",
   "reqd": 1
  },
  {
   "fieldname": "section_break_poll",
   "fieldtype": "Section Break",
   "label": "Poll"
  },
  {
   "fieldname": "poll_id",
   "fieldtype": "Link",
   "in_list_view": 1,
   "label": "Poll",
   "options": "Raven Poll",
   "reqd": 1
  },
  {
   "fieldname": "section_break_vote",
   "fieldtype": "Section Break",
   "label": "Vote"
  },
  {
   "fieldname": "option",
   "fieldtype": "Data",
   "label": "Option",
   "reqd": 1
  }
 ],
 "index_web_pages_for_search": 1,
 "links": [],
 "modified": "2024-04-08 13:32:30.594728",
 "modified_by": "Administrator",
 "module": "Raven Messaging",
 "name": "Raven Poll Vote",
 "owner": "Administrator",
 "permissions": [
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "System Manager",
   "share": 1,
   "write": 1
  },
  {
   "create": 1,
   "delete": 1,
   "email": 1,
   "export": 1,
   "if_owner": 1,
   "print": 1,
   "read": 1,
   "report": 1,
   "role": "Raven User",
   "share": 1
  },
  {
   "read": 1,
   "role": "Raven User"
  }
 ],
 "sort_field": "modified",
 "sort_order": "DESC",
 "states": []
}
--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_vote\raven_poll_vote.py
Comments: Included
Mime Type: text/x-python
Size: 2038 bytes
Content:
# Copyright (c) 2024, The Commit Company and contributors
# For license information, please see license.txt

import frappe
from frappe import _
from frappe.model.document import Document


class RavenPollVote(Document):
	# begin: auto-generated types
	# This code is auto-generated. Do not modify anything in this block.

	from typing import TYPE_CHECKING

	if TYPE_CHECKING:
		from frappe.types import DF

		option: DF.Data
		poll_id: DF.Link
		user_id: DF.Link
	# end: auto-generated types

	def before_insert(self):
		# check if the poll is still open
		poll = frappe.get_cached_doc("Raven Poll", self.poll_id)
		if poll.is_disabled:
			frappe.throw(_("This poll is closed."))

		# check if the option is valid
		if not frappe.db.exists(
			"Raven Poll Option",
			{
				"parent": self.poll_id,
				"name": self.option,
			},
		):
			frappe.throw(_("Invalid option selected."))

		# check if the user has already voted for this option in this poll
		if frappe.db.exists(
			"Raven Poll Vote",
			{
				"poll_id": self.poll_id,
				"user_id": self.user_id,
				"option": self.option,
			},
		):
			frappe.throw(_("You have already voted for this option."))

	def validate(self):
		# Check if the user_id is the same as the logged in user
		if self.user_id != frappe.session.user:
			frappe.throw(_("You can only vote for yourself."))

	def after_insert(self):
		update_poll_votes(self.poll_id)

	def after_delete(self):
		update_poll_votes(self.poll_id)


def update_poll_votes(poll_id):
	poll = frappe.get_cached_doc("Raven Poll", poll_id)
	# get votes for each option
	poll_votes = frappe.get_all(
		"Raven Poll Vote",
		filters={"poll_id": poll_id},
		fields=["option", "count(name) as votes"],
		group_by="option",
	)

	# update the votes for each option in the poll
	for option in poll.options:
		option.votes = 0
		for vote in poll_votes:
			if option.name == vote.option:
				option.votes = vote.votes
				break

	poll.save(ignore_permissions=True)

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_vote\test_raven_poll_vote.py
Comments: Included
Mime Type: text/x-python
Size: 197 bytes
Content:
# Copyright (c) 2024, The Commit Company and Contributors
# See license.txt

# import frappe
from frappe.tests.utils import FrappeTestCase


class TestRavenPollVote(FrappeTestCase):
	pass

--------------------------------------------------------------------------------

File: raven_messaging\doctype\raven_poll_vote\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\doctype\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: raven_messaging\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: templates\pages\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: templates\pages\__pycache__\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: templates\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: tests\test_permissions.py
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/x-python
Size: 40331 bytes
Content:
import frappe
from frappe.tests import IntegrationTestCase

from raven.api.raven_channel import create_direct_message_channel
from raven.api.threads import create_thread

EXTRA_TEST_RECORD_DEPENDENCIES = ["User", "Raven User"]


class TestPermissions(IntegrationTestCase):
	def setUp(self):

		# test is a Raven Admin, test1 and test 3 are Raven Users, test2 is neither

		user = frappe.get_doc("User", "test@example.com")
		user.add_roles("Raven Admin")
		user.add_roles("Raven User")

		user1 = frappe.get_doc("User", "test1@example.com")
		user1.add_roles("Raven User")
		user1.remove_roles("Raven Admin")

		user2 = frappe.get_doc("User", "test2@example.com")
		user2.remove_roles("Raven Admin")
		user2.remove_roles("Raven User")

		user3 = frappe.get_doc("User", "test3@example.com")
		user3.add_roles("Raven User")

	def tearDown(self):
		# Reset the user
		frappe.db.rollback()
		frappe.set_user("Administrator")
		frappe.clear_cache()

	def create_test_workspace(self, workspace_type="Public", only_admins_can_create_channels=False):
		test_workspace = frappe.get_doc(
			{
				"doctype": "Raven Workspace",
				"workspace_name": "Test Workspace",
				"type": workspace_type,
				"only_admins_can_create_channels": only_admins_can_create_channels,
			}
		)
		return test_workspace

	def create_test_channel(
		self, channel_type="Open", workspace_name="Test Workspace", channel_name="test-channel"
	):
		test_channel = frappe.get_doc(
			{
				"doctype": "Raven Channel",
				"channel_name": channel_name,
				"type": channel_type,
				"workspace": workspace_name,
			}
		)
		return test_channel

	def create_test_message(self, channel_id):
		test_message = frappe.get_doc(
			{
				"doctype": "Raven Message",
				"channel_id": channel_id,
				"message_type": "Text",
				"message": "Test Message",
			}
		)
		return test_message

	def test_workspace_create_permissions(self):

		# CREATE: Raven Admin can create a workspace, but other users cannot
		frappe.set_user("test@example.com")

		test_workspace = self.create_test_workspace()
		test_workspace.insert()
		self.assertEqual(test_workspace.name, "Test Workspace")

		frappe.set_user("test1@example.com")
		with self.assertRaises(frappe.PermissionError):
			test_workspace.insert()

		frappe.set_user("test2@example.com")
		with self.assertRaises(frappe.PermissionError):
			test_workspace.insert()

	def test_workspace_update_permissions(self):
		# UPDATE: Workspace admins can update/delete workspaces but not other users

		frappe.set_user("test@example.com")

		test_workspace = self.create_test_workspace()
		test_workspace.insert()

		test_workspace.reload()

		test_workspace.can_only_join_via_invite = 1
		test_workspace.save()

		self.assertEqual(test_workspace.can_only_join_via_invite, 1)

		frappe.set_user("test1@example.com")
		test_workspace.can_only_join_via_invite = 0
		with self.assertRaises(frappe.PermissionError):
			test_workspace.save()

		# Add test1 as a workspace member
		test_workspace_member = frappe.get_doc(
			{
				"doctype": "Raven Workspace Member",
				"workspace": test_workspace.name,
				"user": "test1@example.com",
			}
		)
		test_workspace_member.insert(ignore_permissions=True)

		# Since test1 is now a member, but not an admin, they cannot update the workspace

		frappe.set_user("test1@example.com")
		test_workspace.can_only_join_via_invite = 0

		with self.assertRaises(frappe.PermissionError):
			test_workspace.save()

		# Now make test1 an admin
		frappe.set_user("test@example.com")
		test_workspace_member.is_admin = 1
		test_workspace_member.save(ignore_permissions=True)

		# test1 should now be able to update the workspace
		frappe.set_user("test1@example.com")
		test_workspace.can_only_join_via_invite = 0
		test_workspace.save()

		self.assertEqual(test_workspace.can_only_join_via_invite, 0)

	def test_workspace_read_permissions(self):
		# READ: Public workspaces are readable by all Raven Users, private workspaces are readable only by members

		frappe.set_user("test@example.com")
		test_workspace = self.create_test_workspace(workspace_type="Public")
		test_workspace.insert()

		self.assertEqual(test_workspace.name, "Test Workspace")

		frappe.set_user("test1@example.com")
		# test1 should be able to read the workspace
		self.assertTrue(frappe.has_permission(test_workspace, ptype="read"))

		# test2 should not be able to read the workspace
		frappe.set_user("test2@example.com")
		self.assertFalse(frappe.has_permission(test_workspace, ptype="read"))

		frappe.set_user("test@example.com")
		test_workspace.type = "Private"
		test_workspace.save()

		# Test1 is not a member of the private workspace, so they cannot read it
		frappe.set_user("test1@example.com")
		self.assertFalse(frappe.has_permission(test_workspace, ptype="read"))

		# Make test1 a member of the private workspace
		test_workspace_member = frappe.get_doc(
			{
				"doctype": "Raven Workspace Member",
				"workspace": test_workspace.name,
				"user": "test1@example.com",
			}
		)
		test_workspace_member.insert(ignore_permissions=True)

		self.assertTrue(frappe.has_permission(test_workspace, ptype="read"))

		# Test2 is not a Raven User, so they cannot read the workspace
		frappe.set_user("test2@example.com")
		self.assertFalse(frappe.has_permission(test_workspace, ptype="read"))

	def test_workspace_member_create_permissions(self):
		"""
		If it's a public workspace, any Raven User can join the workspace

		If it's a private workspace, only workspace admins can add members
		"""

		frappe.set_user("test@example.com")
		test_workspace = self.create_test_workspace(workspace_type="Public")
		test_workspace.insert()

		# TESTS for a public workspace
		# Test user is an admin of the workspace

		# It's a public workspace, so any Raven User can join the workspace
		# Test1 should be able to join the workspace
		frappe.set_user("test1@example.com")

		test1_workspace_member = frappe.get_doc(
			{
				"doctype": "Raven Workspace Member",
				"user": "test1@example.com",
				"wo
--------------------------------------------------------------------------------

File: tests\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 51 bytes
Content:
global_test_dependencies = ["User", "Raven User"]

--------------------------------------------------------------------------------

File: uninstall.py
Comments: Included
Mime Type: text/x-python
Size: 362 bytes
Content:
import frappe


def after_uninstall():
	remove_standard_navbar_items()


def remove_standard_navbar_items():

	frappe.db.delete(
		"Navbar Item",
		{"item_label": "Raven", "is_standard": 1, "item_type": "Route", "route": "/raven"},
	)
	# This will run in a post uninstall hook hence needs to be committed manually
	frappe.db.commit()  # nosemgrep

--------------------------------------------------------------------------------

File: utils.py
Comments: Included
Mime Type: text/x-python
Size: 5359 bytes
Content:
import frappe

from raven.notification import clear_push_tokens_for_channel_cache


def track_channel_visit(channel_id, user=None, commit=False, publish_event_for_user=False):
	"""
	Track the last visit of the user to the channel.
	If the user is not a member of the channel, create a new member record
	"""

	if not user:
		user = frappe.session.user

	# Get the channel member record
	channel_member = get_channel_member(channel_id, user)

	now = frappe.utils.now()

	if channel_member:
		# Update the last visit
		frappe.db.set_value("Raven Channel Member", channel_member["name"], "last_visit", now)

	# Else if the user is not a member of the channel and the channel is open, create a new member record
	elif frappe.get_cached_value("Raven Channel", channel_id, "type") == "Open":
		frappe.get_doc(
			{
				"doctype": "Raven Channel Member",
				"channel_id": channel_id,
				"user_id": frappe.session.user,
				"last_visit": now,
			}
		).insert()

	# Need to commit the changes to the database if the request is a GET request
	if commit:
		frappe.db.commit()  # nosempgrep

	if publish_event_for_user:
		frappe.publish_realtime(
			"raven:unread_channel_count_updated",
			{"channel_id": channel_id, "sent_by": frappe.session.user, "last_message_timestamp": now},
			user=user,
		)


# Workspace Members
def get_workspace_members(workspace_id: str):
	"""
	Gets all members of a workspace from the cache
	"""
	cache_key = f"raven:workspace_members:{workspace_id}"

	data = frappe.cache().get_value(cache_key)
	if data:
		return data

	members = frappe.db.get_all(
		"Raven Workspace Member",
		filters={"workspace": workspace_id},
		fields=["name", "user", "is_admin"],
	)

	data = {member.user: member for member in members}
	frappe.cache().set_value(cache_key, data)
	return data


def delete_workspace_members_cache(workspace_id: str):
	cache_key = f"raven:workspace_members:{workspace_id}"
	frappe.cache().delete_value(cache_key)


def get_workspace_member(workspace_id: str, user: str = None) -> dict:
	"""
	Get the workspace member ID
	"""
	if not user:
		user = frappe.session.user

	return get_workspace_members(workspace_id).get(user, None)


def is_workspace_member(workspace_id: str, user: str = None) -> bool:
	"""
	Check if a user is a member of a workspace
	"""
	if not user:
		user = frappe.session.user

	all_members = get_workspace_members(workspace_id)

	return user in all_members


def get_channel_members(channel_id: str):
	"""
	Gets all members of a channel from the cache as a map - also includes the type of the user
	"""
	cache_key = f"raven:channel_members:{channel_id}"

	data = frappe.cache().get_value(cache_key)
	if data:
		return data

	raven_channel_member = frappe.qb.DocType("Raven Channel Member")
	raven_user = frappe.qb.DocType("Raven User")

	query = (
		frappe.qb.from_(raven_channel_member)
		.join(raven_user)
		.on(raven_channel_member.user_id == raven_user.name)
		.select(
			raven_channel_member.name,
			raven_channel_member.user_id,
			raven_channel_member.is_admin,
			raven_channel_member.allow_notifications,
			raven_user.type,
		)
		.where(raven_channel_member.channel_id == channel_id)
	)

	members = query.run(as_dict=True)

	data = {member.user_id: member for member in members}
	frappe.cache().set_value(cache_key, data)
	return data


def delete_channel_members_cache(channel_id: str, clear_push_tokens=True):
	"""
	Delete the channel members cache and clear the push tokens for the channel if the flag is set to True

	By default, the push tokens are cleared when the channel members cache is deleted
	"""
	cache_key = f"raven:channel_members:{channel_id}"
	frappe.cache().delete_value(cache_key)

	if clear_push_tokens:
		clear_push_tokens_for_channel_cache(channel_id)

	frappe.publish_realtime(
		"channel_members_updated",
		{"channel_id": channel_id},
		room="all",
		after_commit=True,
	)


def get_channel_member(channel_id: str, user: str = None) -> dict:
	"""
	Get the channel member ID
	"""

	if not user:
		user = frappe.session.user

	all_members = get_channel_members(channel_id)

	return all_members.get(user, None)


def is_channel_member(channel_id: str, user: str = None) -> bool:
	"""
	Check if a user is a member of a channel
	"""
	if not user:
		user = frappe.session.user

	return user in get_channel_members(channel_id)


def get_raven_user(user_id: str) -> str:
	"""
	Get the Raven User ID of a user
	"""
	# TODO: Run this via cache
	return frappe.db.get_value("Raven User", {"user": user_id}, "name")


def get_thread_reply_count(thread_id: str) -> int:
	"""
	Get the number of replies in a thread
	"""
	return frappe.cache().hget(
		"raven:thread_reply_count",
		thread_id,
		lambda: frappe.db.count("Raven Message", {"channel_id": thread_id}),
	)


def refresh_thread_reply_count(thread_id: str):
	"""
	Refresh the thread reply count
	"""
	new_count = frappe.db.count("Raven Message", {"channel_id": thread_id})
	frappe.cache().hset("raven:thread_reply_count", thread_id, new_count)

	return new_count


def clear_thread_reply_count_cache(thread_id: str):
	"""
	Clear the thread reply count cache
	"""
	frappe.cache().hdel("raven:thread_reply_count", thread_id)

--------------------------------------------------------------------------------

File: www\raven.py
Comments: Included
Mime Type: text/x-python
Size: 3325 bytes
Content:
import json
import re

import frappe
import frappe.sessions
from frappe import _
from frappe.utils.telemetry import capture

no_cache = 1

SCRIPT_TAG_PATTERN = re.compile(r"\<script[^<]*\</script\>")
CLOSING_SCRIPT_TAG_PATTERN = re.compile(r"</script\>")


def get_context(context):
	csrf_token = frappe.sessions.get_csrf_token()
	# Manually commit the CSRF token here
	frappe.db.commit()  # nosemgrep

	if frappe.session.user == "Guest":
		boot = frappe.website.utils.get_boot_data()
	else:
		try:
			boot = frappe.sessions.get()
		except Exception as e:
			raise frappe.SessionBootFailed from e

	boot["push_relay_server_url"] = frappe.conf.get("push_relay_server_url")

	# add server_script_enabled in boot
	if "server_script_enabled" in frappe.conf:
		enabled = frappe.conf.server_script_enabled
	else:
		enabled = True
	boot["server_script_enabled"] = enabled

	boot_json = frappe.as_json(boot, indent=None, separators=(",", ":"))
	boot_json = SCRIPT_TAG_PATTERN.sub("", boot_json)

	boot_json = CLOSING_SCRIPT_TAG_PATTERN.sub("", boot_json)
	boot_json = json.dumps(boot_json)

	context.update(
		{"build_version": frappe.utils.get_build_version(), "boot": boot_json, "csrf_token": csrf_token}
	)

	app_name = frappe.get_website_settings("app_name") or frappe.get_system_settings("app_name")

	if app_name and app_name != "Frappe":
		context["app_name"] = app_name + " | " + "Raven"

	else:
		context["app_name"] = "Raven"

	favicon = frappe.get_website_settings("favicon")

	context["icon_96"] = favicon or "/assets/raven/manifest/favicon-96x96.png"
	context["apple_touch_icon"] = favicon or "/assets/raven/manifest/apple-touch-icon.png"
	context["mask_icon"] = favicon or "/assets/raven/manifest/safari-pinned-tab.svg"
	context["favicon_svg"] = favicon or "/assets/raven/manifest/favicon.svg"
	context["favicon_ico"] = favicon or "/assets/raven/manifest/favicon.ico"
	context["sitename"] = boot.get("sitename")

	if frappe.session.user != "Guest":
		capture("active_site", "raven")

		context[
			"preload_links"
		] = """
			<link rel="preload" href="/api/method/frappe.auth.get_logged_user" as="fetch" crossorigin="use-credentials">
			<link rel="preload" href="/api/method/raven.api.workspaces.get_list" as="fetch" crossorigin="use-credentials">
			<link rel="preload" href="/api/method/raven.api.raven_users.get_list" as="fetch" crossorigin="use-credentials">
			<link rel="preload" href="/api/method/raven.api.raven_channel.get_all_channels?hide_archived=false" as="fetch" crossorigin="use-credentials">
			"""
	else:
		context["preload_links"] = ""

	return context


@frappe.whitelist(methods=["POST"], allow_guest=True)
def get_context_for_dev():
	if not frappe.conf.developer_mode:
		frappe.throw(_("This method is only meant for developer mode"))
	return json.loads(get_boot())


def get_boot():
	try:
		boot = frappe.sessions.get()
	except Exception as e:
		raise frappe.SessionBootFailed from e

	boot["push_relay_server_url"] = frappe.conf.get("push_relay_server_url")
	boot_json = frappe.as_json(boot, indent=None, separators=(",", ":"))
	boot_json = SCRIPT_TAG_PATTERN.sub("", boot_json)

	boot_json = CLOSING_SCRIPT_TAG_PATTERN.sub("", boot_json)
	boot_json = json.dumps(boot_json)

	return boot_json

--------------------------------------------------------------------------------

File: www\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: www\__pycache__\__init__.py
Comments: Included
Mime Type: text/x-python
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: yarn.lock
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: __init__.py
Comments: Included
Mime Type: text/x-python
Size: 168 bytes
Content:
__version__ = "2.3.0"

from raven.raven_integrations.doctype.raven_incoming_webhook.raven_incoming_webhook import (  # noqa
	handle_incoming_webhook as webhook,
)

--------------------------------------------------------------------------------

