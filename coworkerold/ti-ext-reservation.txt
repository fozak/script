File: .editorconfig
Comments: Included
Mime Type: application/octet-stream
Size: 249 bytes
Content:
root = true

[*]
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true
indent_style = space
indent_size = 4

[*.md]
trim_trailing_whitespace = false

[*.{yml,yaml,json,scss,css}]
indent_size = 2

--------------------------------------------------------------------------------

File: .gitignore
Comments: Included
Mime Type: text/plain
Size: 212 bytes
Content:
.DS_Store
.idea
.php_cs
.php_cs.cache
.phpunit.result.cache
.phpunit.cache
/build
composer.lock
coverage
phpunit.xml
psalm.xml
/vendor
.php-cs-fixer.cache
node_modules/
npm-debug.log
yarn-error.log
--------------------------------------------------------------------------------

File: composer.json
Comments: Included
Mime Type: application/json
Size: 2188 bytes
Content:
{
  "name": "tastyigniter/ti-ext-reservation",
  "type": "tastyigniter-package",
  "description": "Provides a simple booking form to accept table reservations.",
  "license": "MIT",
  "authors": [
    {
      "name": "Sam Poyigi",
      "email": "sam@sampoyigi.com"
    }
  ],
  "require": {
    "tastyigniter/core": "^v4.0",
    "tastyigniter/ti-ext-automation": "^v4.0",
    "tastyigniter/ti-ext-local": "^v4.0"
  },
  "require-dev": {
    "larastan/larastan": "^3.0",
    "laravel/pint": "^1.2",
    "pestphp/pest-plugin-laravel": "^3.0",
    "rector/rector": "^2.0",
    "sampoyigi/testbench": "^1.0"
  },
  "autoload": {
    "psr-4": {
      "Igniter\\Reservation\\": "src/"
    }
  },
  "autoload-dev": {
    "psr-4": {
      "Igniter\\Reservation\\Tests\\": "tests/"
    }
  },
  "extra": {
    "tastyigniter-extension": {
      "code": "igniter.reservation",
      "name": "Reservation",
      "icon": {
        "class": "fa fa-calendar",
        "backgroundColor": "#8C1243",
        "color": "#FFF"
      },
      "homepage": "https://tastyigniter.com/marketplace/item/igniter-reservation"
    },
    "branch-alias": {
      "dev-master": "4.0.x-dev"
    }
  },
  "minimum-stability": "dev",
  "prefer-stable": true,
  "config": {
    "allow-plugins": {
      "pestphp/pest-plugin": true,
      "php-http/discovery": true,
      "composer/installers": true
    },
    "sort-packages": true
  },
  "scripts": {
    "test:lint": "vendor/bin/pint --test --ansi",
    "test:lint-fix": "vendor/bin/pint --ansi",
    "test:refactor": "vendor/bin/rector process --dry-run --ansi",
    "test:refactor-fix": "vendor/bin/rector process --ansi",
    "test:static": "vendor/bin/phpstan analyse --memory-limit=1056M --ansi",
    "test:static-fix": "vendor/bin/phpstan --generate-baseline --memory-limit=1056M --ansi",
    "test:pest": "vendor/bin/pest",
    "test:coverage": "vendor/bin/pest --coverage --exactly=100 --compact",
    "test:type-coverage": "vendor/bin/pest --type-coverage --min=100",
    "test": [
      "@test:lint",
      "@test:refactor",
      "@test:static",
      "@test:coverage"
    ]
  }
}

--------------------------------------------------------------------------------

File: database\migrations\2022_09_15_000300_create_dining_areas_sections_tables_add_columns_table.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6759 bytes
Content:
<?php

declare(strict_types=1);

use Igniter\Reservation\Models\DiningTable;
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public static $diningTables;

    public function up(): void
    {
        if (Schema::hasTable('dining_areas')) {
            return;
        }

        Schema::create('dining_areas', function(Blueprint $table): void {
            $table->engine = 'InnoDB';
            $table->bigIncrements('id');
            $table->unsignedBigInteger('location_id');
            $table->string('name');
            $table->string('description')->nullable();
            $table->longText('floor_plan')->nullable();
            $table->timestamps();
        });

        Schema::create('dining_sections', function(Blueprint $table): void {
            $table->engine = 'InnoDB';
            $table->bigIncrements('id');
            $table->unsignedBigInteger('location_id')->index();
            $table->string('name');
            $table->string('description')->nullable();
            $table->string('color')->nullable();
            $table->integer('priority')->default(0);
            $table->boolean('is_enabled')->default(0);
            $table->timestamps();
        });

        $this->createLocationDiningAreas();

        Schema::create('dining_tables', function(Blueprint $table): void {
            $table->engine = 'InnoDB';
            $table->bigIncrements('id');
            $table->unsignedBigInteger('dining_area_id')->index();
            $table->unsignedBigInteger('dining_section_id')->nullable()->index();
            $table->unsignedBigInteger('parent_id')->nullable()->index();
            $table->string('name');
            $table->string('shape')->nullable();
            $table->integer('min_capacity')->default(0);
            $table->integer('max_capacity')->default(0);
            $table->integer('extra_capacity')->default(0);
            $table->boolean('is_combo')->default(0);
            $table->boolean('is_enabled')->default(0);
            $table->integer('nest_left')->nullable();
            $table->integer('nest_right')->nullable();
            $table->integer('priority')->default(0);
            $table->longText('seat_layout')->nullable();
            $table->timestamps();
        });

        $this->copyTablesIntoDiningTables();

        if (!Schema::hasColumn('reservation_tables', 'dining_table_id')) {
            rescue(fn() => Schema::table('reservation_tables', function(Blueprint $table): void {
                $table->dropUnique(['reservation_id', 'table_id']);
            }));

            Schema::table('reservation_tables', function(Blueprint $table): void {
                $table->unsignedBigInteger('dining_table_id')->nullable()->after('reservation_id');
                $table->unique(['reservation_id', 'dining_table_id']);
            });
        }

        $this->setDiningTableIdOnReservationTables();

        (new DiningTable)->fixBrokenTreeQuietly();
    }

    public function down(): void
    {
        Schema::dropIfExists('dining_sections');
        Schema::dropIfExists('dining_tables');
        Schema::dropIfExists('dining_areas');
    }

    protected function createLocationDiningAreas(): void
    {
        if (!DB::table('tables')->count()) {
            return;
        }

        DB::table('locations')->get()->each(function($location): void {
            DB::table('dining_areas')->insertGetId([
                'name' => 'Default',
                'location_id' => $location->location_id,
                'created_at' => $location->created_at,
                'updated_at' => $location->updated_at,
            ]);
        });
    }

    protected function copyTablesIntoDiningTables(): void
    {
        if (!DB::table('tables')->count()) {
            return;
        }

        $diningAreas = DB::table('dining_areas')->pluck('id', 'location_id');

        DB::table('tables')->get()->each(function($table) use ($diningAreas): void {
            DB::table('locationables')
                ->where('locationable_type', 'tables')
                ->where('locationable_id', $table->table_id)
                ->get()->each(function($locationable) use ($diningAreas, $table): void {
                    $diningTableId = DB::table('dining_tables')->insertGetId([
                        'dining_area_id' => $diningAreaId = array_get($diningAreas, $locationable->location_id),
                        'name' => $table->table_name,
                        'shape' => 'rectangle',
                        'min_capacity' => $table->min_capacity,
                        'max_capacity' => $table->max_capacity,
                        'extra_capacity' => $table->extra_capacity,
                        'is_enabled' => $table->table_status,
                        'priority' => (int)$table->priority,
                        'created_at' => $table->created_at,
                        'updated_at' => $table->updated_at,
                    ]);

                    self::$diningTables[$diningTableId] = [
                        'table_id' => $table->table_id,
                        'location_id' => $locationable->location_id,
                        'dining_table_id' => $diningTableId,
                        'dining_area_id' => $diningAreaId,
                    ];
                });
        });
    }

    protected function setDiningTableIdOnReservationTables(): void
    {
        DB::table('reservation_tables')
            ->join('reservations', 'reservation_tables.reservation_id', '=', 'reservations.reservation_id')
            ->select('reservation_tables.reservation_id', 'reservation_tables.table_id', 'reservations.location_id')
            ->get()->each(function($reservationTable): void {
                if (!$diningTable = $this->findDiningTable($reservationTable)) {
                    return;
                }

        
--------------------------------------------------------------------------------

File: database\migrations\2023_07_01_000500_copy_location_options_to_settings.php
Comments: Included
Mime Type: application/octet-stream
Size: 1650 bytes
Content:
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    protected array $items = [
        'booking' => [
            'offer_reservation' => 'is_enabled',
            'limit_guests' => 'limit_guests',
            'limit_guests_count' => 'limit_guests_count',
            'reservation_time_interval' => 'time_interval',
            'reservation_stay_time' => 'stay_time',
            'auto_allocate_table' => 'auto_allocate_table',
            'min_reservation_advance_time' => 'min_advance_time',
            'max_reservation_advance_time' => 'max_advance_time',
            'reservation_cancellation_timeout' => 'cancellation_timeout',
        ],
    ];

    public function up(): void
    {
        DB::table('locations')->get()->each(function($location): void {
            foreach ($this->items as $code => $keys) {
                $values = DB::table('location_options')
                    ->where('location_id', $location->location_id)
                    ->whereIn('item', array_keys($keys))
                    ->pluck('value', 'item')
                    ->all();

                foreach ($values as $key => $value) {
                    $values[$keys[$key]] = $value;
                    unset($values[$key]);
                }

                DB::table('location_settings')->insert([
                    'location_id' => $location->location_id,
                    'item' => $code,
                    'data' => json_encode($values),
                ]);
            }
        });
    }
};

--------------------------------------------------------------------------------

File: database\migrations\2025_03_29_164012_remove_table_id_foreign_key.php
Comments: Included
Mime Type: application/octet-stream
Size: 535 bytes
Content:
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('reservations', function(Blueprint $table): void {
            $table->dropForeignKeyIfExists('reservations_table_id_foreign');
            $table->dropIndexIfExists('reservations_table_id_foreign');
        });
    }

    public function down(): void {}
};

--------------------------------------------------------------------------------

File: database\migrations\2025_04_03_164012_make_telephone_on_reservations_nullable.php
Comments: Included
Mime Type: application/octet-stream
Size: 460 bytes
Content:
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('reservations', function(Blueprint $table): void {
            $table->unsignedBigInteger('telephone')->nullable()->change();
        });
    }

    public function down(): void {}
};

--------------------------------------------------------------------------------

File: database\migrations\2025_05_15_164012_make_telephone_on_reservations_string.php
Comments: Included
Mime Type: application/octet-stream
Size: 452 bytes
Content:
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::table('reservations', function(Blueprint $table): void {
            $table->string('telephone', 40)->nullable()->change();
        });
    }

    public function down(): void {}
};

--------------------------------------------------------------------------------

File: docs\index.md
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: LICENSE.md
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: phpstan-baseline.neon
Comments: Included
Mime Type: application/octet-stream
Size: 2007 bytes
Content:
parameters:
	ignoreErrors:
		-
			message: '#^Parameter \#1 \$model of method Illuminate\\Database\\Eloquent\\Relations\\BelongsTo\<Illuminate\\Database\\Eloquent\\Model,Illuminate\\Database\\Eloquent\\Model\>\:\:associate\(\) expects Illuminate\\Database\\Eloquent\\Model\|int\|string\|null, Illuminate\\Contracts\\Auth\\Authenticatable\|null given\.$#'
			identifier: argument.type
			count: 1
			path: src/Classes/BookingManager.php

		-
			message: '#^Method Igniter\\Flame\\Database\\Builder\:\:whereBetweenReservationDateTime\(\) invoked with 2 parameters, 0\-1 required\.$#'
			identifier: arguments.count
			count: 1
			path: src/Listeners/MaxGuestSizePerTimeslotReached.php

		-
			message: '#^Call to an undefined method Illuminate\\Support\\Carbon\:\:diffInRealMinutes\(\)\.$#'
			identifier: method.notFound
			count: 1
			path: src/Models/Reservation.php

		-
			message: '#^Parameter \#1 \$callback of method Illuminate\\Support\\Collection\<int,Igniter\\Reservation\\Models\\Reservation\>\:\:transform\(\) expects callable\(Igniter\\Reservation\\Models\\Reservation, int\)\: Igniter\\Reservation\\Models\\Reservation, Closure\(Igniter\\Reservation\\Models\\Reservation\)\: array given\.$#'
			identifier: argument.type
			count: 1
			path: src/Models/Reservation.php

		-
			message: '#^Relation ''tables'' is not found in Igniter\\Reservation\\Models\\Reservation model\.$#'
			identifier: larastan.relationExistence
			count: 1
			path: src/Models/Reservation.php

		-
			message: '#^Call to an undefined method Illuminate\\Database\\Eloquent\\Model\:\:fireEvent\(\)\.$#'
			identifier: method.notFound
			count: 1
			path: src/Models/Scopes/DiningTableScope.php

		-
			message: '#^Method Illuminate\\Database\\Eloquent\\Builder\<Illuminate\\Database\\Eloquent\\Model\>\:\:whereBetweenReservationDateTime\(\) invoked with 2 parameters, 0\-1 required\.$#'
			identifier: arguments.count
			count: 1
			path: src/Models/Scopes/ReservationScope.php

--------------------------------------------------------------------------------

File: phpstan.neon.dist
Comments: Included
Mime Type: application/octet-stream
Size: 282 bytes
Content:
includes:
    - ./vendor/larastan/larastan/extension.neon
    - phpstan-baseline.neon

parameters:
    level: 5
    paths:
        - database/
        - src/
        - resources/
    ignoreErrors:
        - '#PHPDoc tag @var#'
        - identifier: generics.notGeneric

--------------------------------------------------------------------------------

File: phpunit.xml.dist
Comments: Included
Mime Type: application/octet-stream
Size: 1007 bytes
Content:
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/10.1/phpunit.xsd" backupGlobals="false"
         bootstrap="vendor/autoload.php" colors="true" processIsolation="false" stopOnFailure="false"
         cacheDirectory=".phpunit.cache" backupStaticProperties="false">
    <testsuites>
        <testsuite name="Reservation Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
    <coverage/>
    <php>
        <env name="APP_ENV" value="testing"/>
        <env name="APP_KEY" value="base64:YzE5YjR2b3hrem1ucmdmc2Fkbm92NW1veHBkMWdpa3k="/>
        <env name="DB_CONNECTION" value="mysql"/>
        <env name="DB_DATABASE" value="testbench"/>
        <env name="DB_USERNAME" value="forge"/>
    </php>
    <source>
        <include>
            <directory suffix=".php">./src</directory>
        </include>
    </source>
</phpunit>

--------------------------------------------------------------------------------

File: pint.json
Comments: Included
Mime Type: application/json
Size: 950 bytes
Content:
{
  "rules": {
    "method_chaining_indentation": true,
    "logical_operators": true,
    "simplified_null_return": false,
    "cast_spaces": false,
    "no_unreachable_default_argument_value": false,
    "no_alternative_syntax": false,
    "not_operator_with_successor_space": false,
    "no_trailing_comma_in_list_call": false,
    "phpdoc_summary": false,
    "braces": false,
    "self_accessor": false,
    "phpdoc_separation": false,
    "phpdoc_align": false,
    "no_trailing_comma_in_singleline": false,
    "phpdoc_trim_consecutive_blank_line_separation": true,
    "blank_line_before_statement": {
      "statements": [
        "declare",
        "return",
        "throw",
        "try"
      ]
    },
    "single_blank_line_at_eof": false,
    "single_space_around_construct": false,
    "function_declaration": {
      "closure_function_spacing": "none",
      "closure_fn_spacing": "none"
    }
  }
}

--------------------------------------------------------------------------------

File: README.md
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: rector.php
Comments: Included
Mime Type: application/octet-stream
Size: 1119 bytes
Content:
<?php

declare(strict_types=1);

use Rector\CodingStyle\Rector\Catch_\CatchExceptionNameMatchingTypeRector;
use Rector\CodingStyle\Rector\ClassMethod\NewlineBeforeNewAssignSetRector;
use Rector\Config\RectorConfig;
use Rector\TypeDeclaration\Rector\ClassMethod\ReturnNeverTypeRector;
use Rector\TypeDeclaration\Rector\ClassMethod\ReturnTypeFromStrictNewArrayRector;
use Rector\TypeDeclaration\Rector\StmtsAwareInterface\DeclareStrictTypesRector;

return RectorConfig::configure()
    ->withPaths([
        __DIR__.'/database',
        __DIR__.'/src',
        __DIR__.'/tests',
    ])
    ->withImportNames(removeUnusedImports: true)
    ->withRules([
        DeclareStrictTypesRector::class,
    ])
    ->withSkip([
        CatchExceptionNameMatchingTypeRector::class,
        ReturnNeverTypeRector::class,
        ReturnTypeFromStrictNewArrayRector::class,
        NewlineBeforeNewAssignSetRector::class,
    ])
    ->withPhpSets(php83: true)
    ->withPreparedSets(
        deadCode: true,
        codeQuality: true,
        codingStyle: true,
        typeDeclarations: true,
    );

--------------------------------------------------------------------------------

File: resources\css\floorplanner.css
Comments: Excluded by file type
Mime Type: 
Size: 0 bytes
Content:

--------------------------------------------------------------------------------

File: resources\js\floorplanner.js
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: text/javascript
Size: 16715 bytes
Content:
+function ($) {
    "use strict";

    var FloorPlanner = function (element, options) {
        this.options = options
        this.$container = $(element)

        this.computedStyle = window.getComputedStyle(document.documentElement)
        this.options.textOptions.fontFamily = this.computedStyle.getPropertyValue('--bs-font-sans-serif')
        this.options.textOptions.fill = this.computedStyle.getPropertyValue('--bs-body-color')

        this.$container.addClass('initialized')

        this.stage = null
        this.layer = null
        this.transformer = null
        this.transformerOptions = {}
        this.zoom = 1

        this.init()
        this.initKonva()
    }

    FloorPlanner.prototype.init = function () {
        this.$container.on('click', '[data-floor-planner-control]', $.proxy(this.onControlClick, this))
        $('[data-control="form-tabs"] [data-bs-toggle="tab"]').on('shown.bs.tab', $.proxy(this.initKonva, this))
    }

    FloorPlanner.prototype.initKonva = function () {
        var self = this,
            $el = this.$container.find(this.options.canvasSelector)

        if (this.stage || this.$container.is(':hidden'))
            return

        this.stage = new Konva.Stage({
            container: $el[0],
            width: $el.width() - this.options.tableVerticalPadding,
            height: this.options.canvasHeight,
            draggable: true,
        })

        this.layer = new Konva.Layer()
        this.stage.add(this.layer)

        this.createTables()

        this.stage.on('click', $.proxy(this.onClickStage, this))
            .on('mouseenter', function () {
                self.stage.container().style.cursor = 'grab';
            })
            .on('mouseleave', function () {
                self.stage.container().style.cursor = 'default';
            })
            .on('dragend', function () {
                self.saveState()
            })

        this.loadState()

        this.layer.draw()
    }

    FloorPlanner.prototype.saveState = function () {
        var state = {stage: {}, groups: []}

        if (this.options.alias === undefined)
            return

        state.stage.x = this.stage.x()
        state.stage.y = this.stage.y()
        state.stage.scaleX = this.stage.scaleX()
        state.stage.scaleY = this.stage.scaleY()

        this.layer.getChildren(function (node) {
            return node.getClassName() === 'Group';
        }).forEach(function (group) {
            state.groups.push({
                id: group.id(),
                x: group.x(),
                y: group.y(),
                rotation: group.rotation(),
            })
        })

        $.request(this.options.alias + '::onSaveState', {
            data: {state: JSON.stringify(state)},
        })
    }

    FloorPlanner.prototype.loadState = function () {
        try {
            var state = JSON.parse(this.$container.find(this.options.dataInputSelector).val())
        } catch (ex) {
            return
        }

        if (!state)
            return

        this.stage.x(state.stage.x)
        this.stage.y(state.stage.y)
        this.stage.scaleX(state.stage.scaleX)
        this.stage.scaleY(state.stage.scaleY)

        if (!state.groups)
            return

        state.groups.forEach(function (groupState) {
            var group = this.layer.findOne('#' + groupState.id)
            if (group) {
                group.x(groupState.x)
                group.y(groupState.y)
                group.rotation(groupState.rotation)
            }
        }, this)
    }

    FloorPlanner.prototype.createTables = function () {
        var self = this,
            count = 1

        for (var i = 0; i < this.options.diningTables.length; i++) {
            var diningTable = this.options.diningTables[i],
                group = new Konva.Group({
                    id: 'group-' + diningTable.id,
                    x: diningTable.seatLayout ? diningTable.seatLayout.x : this.options.seatWidth * count,
                    y: diningTable.seatLayout ? diningTable.seatLayout.y : this.options.seatWidth * count,
                    rotation: diningTable.seatLayout ? diningTable.seatLayout.rotation : 0,
                    draggable: !this.options.previewMode,
                })

            if (diningTable.shape === 'round') {
                this.applyRoundLayout(diningTable)
            } else {
                this.applyRectLayout(diningTable)
            }

            this.createTable(diningTable, group)
            this.createTableInfo(diningTable, group)

            group.on('click', $.proxy(this.onClickShape, this))
                .on('mouseenter', function () {
                    self.stage.container().style.cursor = 'pointer';
                })
                .on('mouseleave', function () {
                    self.stage.container().style.cursor = 'grab';
                })
                .on('transformend', function () {
                    self.saveState()
                })

            this.layer.add(group)
            ++count
        }
    }

    FloorPlanner.prototype.applyRectLayout = function (diningTable) {
        var width, height, seats = {},
            seatCapacity = diningTable.capacity

        width = height = this.options.seatWidth

        if (seatCapacity === 2) {
            seats.top = seats.bottom = 1
        } else if (seatCapacity === 4) {
            seats.top = seats.bottom = seats.left = seats.right = 1
        } else if (seatCapacity > 2) {
            if ((seatCapacity % 2) === 0) {
                seats.left = seats.right = 1
                seats.top = seats.bottom = (seatCapacity - 2) / 2;
            } else {
                seats.left = 1;
                seats.top = seats.bottom = (seatCapacity - 1) / 2;
            }

            width = (this.options.seatWidth * seats.top) + (this.options.seatSpacing * (seats.top - 1))
        } else {
            seats.left = 1;
        }

        diningTable.shapeLayout = {
            id: 'table-' + di
--------------------------------------------------------------------------------

File: resources\lang\en\default.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 14724 bytes
Content:
<?php

return [
    'text_tab_reservations' => 'Reservations',

    'text_title' => 'Reservations',
    'text_form_name' => 'Reservation',
    'text_tab_general' => 'Reservation',
    'text_tab_restaurant' => 'Restaurant',
    'text_status_history' => 'Status History',
    'text_empty' => 'There are no reservations available.',
    'text_filter_assignee' => 'View all assignees',
    'text_filter_dining_area' => 'View all dining areas',
    'text_filter_date' => 'View all reservation dates',
    'text_filter_time' => 'View all reservation times',
    'text_filter_search' => 'Search by id, location, guest number, status, customer or table name.',
    'text_guest' => 'Guest',
    'text_no_booking' => 'No Bookings',
    'text_no_table' => 'No Table',
    'text_restaurant' => 'Location',
    'text_unassigned' => 'Yet to be Assigned',
    'text_assigned_to_self' => 'Assigned To Me',
    'text_assigned_to_others' => 'Assigned To Other User',
    'text_customer' => 'Customer',
    'text_view_calendar' => 'Calendar View',
    'text_view_list' => 'List View',
    'text_view_floor_plan' => 'Floor Plan View',
    'text_title_cancel' => 'Cancel Order',
    'text_charts_reservations' => 'Reservations',
    'text_total_reservation' => 'Total Reservations',
    'text_total_reserved_guest' => 'Total Guests',
    'text_total_completed_reservation' => 'Total Reservations Completed',
    'text_total_reserved_table' => 'Total Table(s) Reserved',

    'button_assign_table' => 'Assign Table',
    'text_heading' => 'Recent Reservations',
    'text_view_heading' => 'My Reservation View',
    'text_setting_reservation' => 'Reservation',
    'help_setting_reservation' => 'Configure reservation settings',

    'text_permission_group' => 'Reservation',
    'text_permission_reservations' => 'Manage reservations',
    'text_permission_delete_reservations' => 'Delete reservations',
    'text_permission_assign_reservations' => 'Assign reservations',
    'text_permission_assign_reservation_tables' => 'Ability to assign tables to reservations',
    'text_permission_dining_areas' => 'Create, edit and delete dining areas and tables',

    'text_booking_title' => 'Reserve A Table',
    'text_success_heading' => 'Reservation Confirmation',
    'text_time_heading' => 'Select Time',
    'text_reservation' => 'My Reservation',
    'text_reservation_schedule' => 'Reservation',
    'text_heading_success' => 'Reservation Confirmed',
    'text_find_msg' => 'Please use the form below to find a table to reserve',
    'text_time_msg' => 'Available reservation time slots on %s for %s guests',
    'text_no_time_slot' => '<span class="text-danger">No reservation time slot available, please go back to check your table details.</span>',
    'text_location_closed' => 'Sorry, but we\'re closed, come back during opening hours',
    'text_date_format' => '%D, %M %j, %Y',
    'text_person' => 'person',
    'text_people' => 'people',
    'text_mail_reservation' => 'Reservation email to customer',
    'text_mail_reservation_alert' => 'Reservation alert to admin',
    'text_mail_reservation_update' => 'Reservation status update email to customer',
    'text_side_menu_tables' => 'Dining Areas',
    'text_side_menu_reservation' => 'Reservations',
    'text_tab_title_reservation' => 'Reservation',

    'text_subject' => 'Table Reserved - %s!',
    'text_greetings' => 'Thank You %s,',
    'text_success_message' => 'Your reservation at %s has been booked for %s on %s.<br />Thanks for reserving with us online!',

    'label_status' => 'Status',
    'label_location' => 'Location',
    'label_guest_num' => 'Number of guests',
    'label_date' => 'Date',
    'label_time' => 'Time',
    'label_occasion' => 'Occasion',
    'label_select' => '- please select -',
    'label_reservation_id' => 'Reservation ID',
    'label_customer_name' => 'Customer Name',
    'label_guest' => 'Guest Number',
    'label_reservation_date' => 'Reservation Date',
    'label_reservation_time' => 'Reservation Time',
    'label_reservation_date_time' => 'Reservation Date Time',
    'label_reservation_duration' => 'Reservation Duration',
    'label_date_added' => 'Date Added',
    'label_date_modified' => 'Date Modified',
    'label_send_confirmation' => 'Send reservation confirmation',
    'label_user_agent' => 'User Agent',
    'label_ip_address' => 'IP Address',
    'label_assign_staff' => 'Assign User',
    'label_restaurant_name' => 'Restaurant Name',
    'label_restaurant_address' => 'Restaurant Address',
    'label_table_name' => 'Table Name',
    'label_table_capacity' => 'Table Maximum Capacity',
    'label_table_min_capacity' => 'Table Minimum Capacity',
    'label_first_name' => 'First Name',
    'label_last_name' => 'Last Name',
    'label_customer_telephone' => 'Telephone',
    'label_default_reservation_status' => 'Default Reservation Status',
    'label_confirmed_reservation_status' => 'Confirmed Reservation Status',
    'label_canceled_reservation_status' => 'Canceled Reservation Status',
    'label_reservation_email' => 'Send Reservation Confirmation/Alert Email',
    'label_cancel_reason' => 'Reason for cancellation',

    'label_email' => 'Email Address',
    'label_confirm_email' => 'Confirm Email Address',
    'label_telephone' => 'Telephone',
    'label_comment' => 'Special Requests',

    'label_offer_reservation' => 'Offer Reservations',
    'label_reservation_time_interval' => 'Reservation Time Interval',
    'label_reservation_stay_time' => 'Reservation Stay Time',
    'label_min_reservation_advance_time' => 'Min. Advance Reservation Time',
    'label_max_reservation_advance_time' => 'Max. Advance Reservation Time',
    'label_min_reservation_guest_num' => 'Min. Reservation Guest Size',
    'label_max_reservation_guest_num' => 'Max. Reservation Guest Size',
    'label_reservation_include_start_time' => 'Include Start Time in Reservation Timeslots',
    'label_auto_allocate_table' => 'Automatically Assign Tables To Reservations',
    'label_reservation_cancella
--------------------------------------------------------------------------------

File: resources\models\bookingsettings.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6610 bytes
Content:
<?php

return [
    'form' => [
        'fields' => [
            'is_enabled' => [
                'label' => 'lang:igniter.reservation::default.label_offer_reservation',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 1,
                'type' => 'switch',
                'span' => 'left',
            ],
            'auto_allocate_table' => [
                'label' => 'lang:igniter.reservation::default.label_auto_allocate_table',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 1,
                'type' => 'switch',
                'span' => 'right',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'time_interval' => [
                'label' => 'lang:igniter.reservation::default.label_reservation_time_interval',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 15,
                'type' => 'number',
                'span' => 'left',
                'comment' => 'lang:igniter.reservation::default.help_reservation_time_interval',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'stay_time' => [
                'label' => 'lang:igniter.reservation::default.label_reservation_stay_time',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 45,
                'type' => 'number',
                'span' => 'right',
                'comment' => 'lang:igniter.reservation::default.help_reservation_stay_time',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'min_guest_count' => [
                'label' => 'lang:igniter.reservation::default.label_min_reservation_guest_num',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 2,
                'type' => 'number',
                'span' => 'left',
                'comment' => 'lang:igniter.reservation::default.help_min_reservation_guest_num',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'max_guest_count' => [
                'label' => 'lang:igniter.reservation::default.label_max_reservation_guest_num',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 20,
                'type' => 'number',
                'span' => 'right',
                'comment' => 'lang:igniter.reservation::default.help_max_reservation_guest_num',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'min_advance_time' => [
                'label' => 'lang:igniter.reservation::default.label_min_reservation_advance_time',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 2,
                'type' => 'number',
                'span' => 'left',
                'comment' => 'lang:igniter.reservation::default.help_min_reservation_advance_time',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'max_advance_time' => [
                'label' => 'lang:igniter.reservation::default.label_max_reservation_advance_time',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 30,
                'type' => 'number',
                'span' => 'right',
                'comment' => 'lang:igniter.reservation::default.help_max_reservation_advance_time',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'is_enabled',
                    'condition' => 'checked',
                ],
            ],
            'limit_guests' => [
                'label' => 'lang:igniter.reservation::default.label_limit_guests',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 0,
                'type' => 'switch',
                'span' => 'left',
            ],
            'limit_guests_count' => [
                'label' => 'lang:igniter.reservation::default.label_limit_guests_count',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'default' => 20,
                'type' => 'number',
                'span' => 'right',
                'comment' => 'lang:igniter.reservation::default.help_limit_guests_count',
                'trigger' => [
                    'action' => 'enable',
                    'field' => 'limit_guests',
                    'condition' => 'checked',
                ],
            ],
            'cancellation_timeout' => [
                'label' => 'lang:igniter.reservation::default.label_reservation_cancellation_timeout',
                'accordion' => 'lang:igniter.reservation::default.text_tab_reservation',
                'type' => 'number',
                'span' => 'left',
                'default' => 0,
                'comment' => 'lang:igniter.reservation::default.help_reservation_cancellation_timeout',
            ],
            
--------------------------------------------------------------------------------

File: resources\models\dining_area.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6677 bytes
Content:
<?php

return [
    'list' => [
        'filter' => [],
        'toolbar' => [
            'buttons' => [
                'create' => [
                    'label' => 'lang:admin::lang.button_new',
                    'class' => 'btn btn-primary',
                    'href' => 'dining_areas/create',
                ],
            ],
        ],
        'bulkActions' => [
            'delete' => [
                'label' => 'lang:admin::lang.button_delete',
                'class' => 'btn btn-light text-danger',
                'data-request-confirm' => 'lang:admin::lang.alert_warning_confirm',
            ],
        ],
        'columns' => [
            'edit' => [
                'type' => 'button',
                'iconCssClass' => 'fa fa-pencil',
                'attributes' => [
                    'class' => 'btn btn-edit',
                    'href' => 'dining_areas/edit/{id}',
                ],
            ],
            'duplicate' => [
                'type' => 'button',
                'iconCssClass' => 'fa fa-copy  text-muted',
                'attributes' => [
                    'class' => 'btn shadow-none',
                    'data-request' => 'onDuplicate',
                    'data-request-data' => 'id: {id}',
                ],
            ],
            'name' => [
                'label' => 'lang:admin::lang.label_name',
                'type' => 'text',
                'searchable' => true,
            ],
            'location_name' => [
                'label' => 'lang:admin::lang.column_location',
                'relation' => 'location',
                'select' => 'location_name',
                'searchable' => true,
                'locationAware' => true,
            ],
            'dining_table_count' => [
                'label' => 'lang:igniter.reservation::default.dining_areas.column_tables',
                'type' => 'number',
                'sortable' => false,
            ],
            'updated_at' => [
                'label' => 'lang:admin::lang.column_date_updated',
                'type' => 'timetense',
                'invisible' => true,
            ],
            'created_at' => [
                'label' => 'lang:admin::lang.column_date_added',
                'type' => 'timetense',
                'invisible' => true,
            ],
        ],
    ],
    'form' => [
        'toolbar' => [
            'buttons' => [
                'save' => [
                    'label' => 'lang:admin::lang.button_save',
                    'context' => ['create', 'edit'],
                    'partial' => 'form/toolbar_save_button',
                    'class' => 'btn btn-primary',
                    'data-request' => 'onSave',
                    'data-progress-indicator' => 'admin::lang.text_saving',
                ],
                'delete' => [
                    'label' => 'lang:admin::lang.button_icon_delete',
                    'class' => 'btn btn-danger',
                    'data-request' => 'onDelete',
                    'data-request-data' => "_method:'DELETE'",
                    'data-request-confirm' => 'lang:admin::lang.alert_warning_confirm',
                    'data-progress-indicator' => 'admin::lang.text_deleting',
                    'context' => ['edit'],
                ],
            ],
        ],
        'fields' => [
            'name' => [
                'label' => 'lang:admin::lang.label_name',
                'type' => 'text',
                'span' => 'left',
            ],
            'location_id' => [
                'label' => 'lang:admin::lang.label_location',
                'type' => 'relation',
                'span' => 'right',
                'relationFrom' => 'location',
                'nameFrom' => 'location_name',
                'placeholder' => 'lang:admin::lang.text_please_select',
            ],
        ],
        'tabs' => [
            'fields' => [
                '_dining_sections' => [
                    'label' => 'igniter.reservation::default.dining_areas.label_dining_sections',
                    'tab' => 'igniter.reservation::default.dining_areas.text_tab_tables',
                    'type' => 'recordeditor',
                    'context' => ['edit', 'preview'],
                    'mode' => 'checkbox',
                    'form' => 'dining_section',
                    'modelClass' => \Igniter\Reservation\Models\DiningSection::class,
                    'placeholder' => 'igniter.reservation::default.dining_areas.help_dining_sections',
                    'formName' => 'igniter.reservation::default.dining_areas.text_dining_section',
                ],
                'dining_table_solos' => [
                    'label' => 'igniter.reservation::default.dining_areas.label_tables',
                    'tab' => 'igniter.reservation::default.dining_areas.text_tab_tables',
                    'type' => 'connector',
                    'context' => 'edit',
                    'form' => 'dining_table',
                    'partial' => 'form/dining_table_info',
                    'hideNewButton' => false,
                    'commentAbove' => 'igniter.reservation::default.dining_tables.help_extra_capacity',
                ],

                '_select_dining_tables' => [
                    'label' => 'igniter.reservation::default.dining_areas.label_dining_table_combos',
                    'tab' => 'igniter.reservation::default.dining_areas.text_tab_table_combos',
                    'type' => 'partial',
                    'path' => 'form/select_dining_tables',
                    'context' => ['edit', 'preview'],
                    'valueFrom' => 'dining_tables',
                ],
                'dining_table_combos' => [
                    'label' => 'igniter.reservation::default.dining_areas.label_table_combos',
                    'tab' => 'igniter.reservation::default.dining_areas.text_tab_table_combos',
                    'type' => 'connector',
                    'context' => 'edit',
   
--------------------------------------------------------------------------------

File: resources\models\dining_section.php
Comments: Included
Mime Type: application/octet-stream
Size: 982 bytes
Content:
<?php

return [
    'form' => [
        'fields' => [
            'location_id' => [
                'type' => 'hidden',
            ],
            'name' => [
                'label' => 'lang:admin::lang.label_name',
                'type' => 'text',
            ],
            'priority' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_priority',
                'type' => 'select',
                'default' => 0,
                'comment' => 'lang:igniter.reservation::default.dining_areas.help_section_priority',
            ],
            'description' => [
                'label' => 'lang:admin::lang.label_description',
                'type' => 'textarea',
            ],
            'is_enabled' => [
                'label' => 'lang:igniter.reservation::default.dining_areas.label_is_enabled',
                'type' => 'switch',
                'default' => true,
            ],
        ],
    ],
];

--------------------------------------------------------------------------------

File: resources\models\dining_table.php
Comments: Included
Mime Type: application/octet-stream
Size: 2708 bytes
Content:
<?php

return [
    'form' => [
        'fields' => [
            'id' => [
                'type' => 'hidden',
            ],
            'dining_area_id' => [
                'type' => 'hidden',
            ],
            'name' => [
                'label' => 'lang:admin::lang.label_name',
                'type' => 'text',
                'span' => 'left',
            ],
            'priority' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_priority',
                'type' => 'select',
                'default' => 0,
                'span' => 'right',
                'comment' => 'lang:igniter.reservation::default.dining_tables.help_table_priority',
            ],
            'dining_section_id' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.column_section',
                'type' => 'select',
                'context' => 'edit',
                'placeholder' => 'lang:admin::lang.text_please_select',
            ],
            'min_capacity' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_min_capacity',
                'type' => 'number',
                'span' => 'left',
            ],
            'max_capacity' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_capacity',
                'type' => 'number',
                'span' => 'right',
            ],
            'extra_capacity' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_extra_capacity',
                'type' => 'number',
                'default' => 0,
                'span' => 'left',
                'comment' => 'lang:igniter.reservation::default.dining_tables.help_extra_capacity',
            ],
            'shape' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_table_shape',
                'type' => 'radiotoggle',
                'span' => 'right',
                'default' => 'rectangle',
                'options' => [
                    'rectangle' => 'lang:igniter.reservation::default.dining_tables.text_rectangle',
                    'round' => 'lang:igniter.reservation::default.dining_tables.text_round',
                ],
                'comment' => 'lang:igniter.reservation::default.dining_tables.help_table_shape',
            ],
            'is_enabled' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_is_enabled',
                'type' => 'switch',
                'default' => true,
                'span' => 'left',
            ],
        ],
    ],
];

--------------------------------------------------------------------------------

File: resources\models\dining_table_combo.php
Comments: Included
Mime Type: application/octet-stream
Size: 1699 bytes
Content:
<?php

return [
    'form' => [
        'fields' => [
            'id' => [
                'type' => 'hidden',
            ],
            'priority' => [
                'type' => 'hidden',
            ],
            'name' => [
                'label' => 'lang:admin::lang.label_name',
                'type' => 'text',
                'attributes' => [
                    'readonly' => 'readonly',
                ],
            ],
            'min_capacity' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_min_capacity',
                'type' => 'number',
                'span' => 'left',
            ],
            'max_capacity' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_capacity',
                'type' => 'number',
                'span' => 'right',
            ],
            'shape' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_table_shape',
                'type' => 'radiotoggle',
                'default' => 'rectangle',
                'options' => [
                    'rectangle' => 'lang:igniter.reservation::default.dining_tables.text_rectangle',
                    'round' => 'lang:igniter.reservation::default.dining_tables.text_round',
                ],
                'comment' => 'lang:igniter.reservation::default.dining_tables.help_table_shape',
            ],
            'is_enabled' => [
                'label' => 'lang:igniter.reservation::default.dining_tables.label_is_enabled',
                'type' => 'switch',
                'default' => true,
            ],
        ],
    ],
];

--------------------------------------------------------------------------------

File: resources\models\floor_plan.php
Comments: Included
Mime Type: application/octet-stream
Size: 4415 bytes
Content:
<?php

return [
    'floor_plan' => [
        'filter' => [
            'scopes' => [
                'dining_area' => [
                    'label' => 'lang:igniter.reservation::default.text_filter_dining_area',
                    'type' => 'select',
                    'modelClass' => \Igniter\Reservation\Models\DiningArea::class,
                    'nameFrom' => 'name',
                    'scope' => 'whereHasDiningArea',
                ],
                'reserve_date' => [
                    'label' => 'lang:igniter.reservation::default.text_filter_date',
                    'type' => 'date',
                    'conditions' => "reserve_date = DATE(':filtered')",
                ],
                'reserve_time' => [
                    'label' => 'lang:igniter.reservation::default.text_filter_time',
                    'type' => 'select',
                    'options' => [\Igniter\Reservation\Models\Reservation::class, 'getReserveTimeOptions'],
                    'scope' => 'whereBetweenStayTime',
                ],
                'assignee' => [
                    'label' => 'lang:igniter.reservation::default.text_filter_assignee',
                    'type' => 'select',
                    'scope' => 'filterAssignedTo',
                    'options' => [
                        1 => 'lang:admin::lang.statuses.text_unassigned',
                        2 => 'lang:admin::lang.statuses.text_assigned_to_self',
                        3 => 'lang:admin::lang.statuses.text_assigned_to_others',
                    ],
                ],
                'status' => [
                    'label' => 'lang:admin::lang.text_filter_status',
                    'type' => 'selectlist',
                    'conditions' => 'status_id IN(:filtered)',
                    'modelClass' => \Igniter\Admin\Models\Status::class,
                    'options' => 'getDropdownOptionsForReservation',
                ],
            ],
        ],
        'toolbar' => [
            'context' => 'floor_plan',
            'buttons' => [
                'create' => [
                    'label' => 'lang:admin::lang.button_new',
                    'class' => 'btn btn-primary',
                    'href' => 'reservations/create',
                ],
                'list' => [
                    'label' => 'lang:igniter.reservation::default.text_view_floor_plan',
                    'class' => 'btn btn-default',
                    'type' => 'dropdown',
                    'context' => 'floor_plan',
                    'menuItems' => [
                        'list' => [
                            'label' => 'igniter.reservation::default.text_view_list',
                            'class' => 'dropdown-item',
                            'href' => 'reservations',
                        ],
                        'calendar' => [
                            'label' => 'igniter.reservation::default.text_view_calendar',
                            'class' => 'dropdown-item',
                            'href' => 'reservations/calendar',
                        ],
                        'floor_plan' => [
                            'label' => 'igniter.reservation::default.text_view_floor_plan',
                            'class' => 'dropdown-item',
                            'href' => 'reservations/floor_plan',
                        ],
                    ],
                ],
            ],
        ],
        'columns' => [
            'edit' => [
                'type' => 'button',
                'iconCssClass' => 'fa fa-pencil',
                'attributes' => [
                    'class' => 'btn btn-edit',
                    'href' => 'reservations/edit/{reservation_id}',
                ],
            ],
            'reserve_time' => [
                'label' => '',
                'type' => 'partial',
                'path' => 'reservations/lists/column_floor_plan',
                'sortable' => false,
            ],
            'status_name' => [
                'label' => 'lang:admin::lang.label_status',
                'relation' => 'status',
                'select' => 'status_name',
                'type' => 'partial',
                'path' => 'statuses/status_column',
                'sortable' => false,
            ],
        ],
    ],
];

--------------------------------------------------------------------------------

File: resources\models\reservation.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 12882 bytes
Content:
<?php

$listButtonItems = [
    'index' => [
        'label' => 'igniter.reservation::default.text_view_list',
        'class' => 'dropdown-item',
        'href' => 'reservations',
    ],
    'calendar' => [
        'label' => 'igniter.reservation::default.text_view_calendar',
        'class' => 'dropdown-item',
        'href' => 'reservations/calendar',
    ],
    'floor_plan' => [
        'label' => 'igniter.reservation::default.text_view_floor_plan',
        'class' => 'dropdown-item',
        'href' => 'reservations/floor_plan',
    ],
];

$config['list']['filter'] = [
    'search' => [
        'prompt' => 'lang:igniter.reservation::default.text_filter_search',
        'mode' => 'all',
    ],
    'scopes' => [
        'assignee' => [
            'label' => 'lang:igniter.reservation::default.text_filter_assignee',
            'type' => 'select',
            'scope' => 'filterAssignedTo',
            'options' => [
                1 => 'lang:igniter::admin.statuses.text_unassigned',
                2 => 'lang:igniter::admin.statuses.text_assigned_to_self',
                3 => 'lang:igniter::admin.statuses.text_assigned_to_others',
            ],
        ],
        'status' => [
            'label' => 'lang:igniter::admin.text_filter_status',
            'type' => 'selectlist',
            'conditions' => 'status_id IN(:filtered)',
            'modelClass' => \Igniter\Admin\Models\Status::class,
            'options' => 'getDropdownOptionsForReservation',
        ],
        'date' => [
            'label' => 'lang:igniter::admin.text_filter_date',
            'type' => 'daterange',
            'conditions' => 'reserve_date >= CAST(:filtered_start AS DATE) AND reserve_date <= CAST(:filtered_end AS DATE)',
        ],
    ],
];

$config['list']['toolbar'] = [
    'buttons' => [
        'create' => [
            'label' => 'lang:igniter::admin.button_new',
            'class' => 'btn btn-primary',
            'href' => 'reservations/create',
        ],
        'calendar' => [
            'label' => 'lang:igniter.reservation::default.text_view_list',
            'class' => 'btn btn-default',
            'type' => 'dropdown',
            'menuItems' => $listButtonItems,
            'context' => 'index',
        ],
    ],
];

$config['list']['bulkActions'] = [
    'assign_table' => [
        'label' => 'lang:igniter.reservation::default.button_assign_table',
        'class' => 'btn btn-light',
        'permissions' => 'Admin.AssignTables',
    ],
    'delete' => [
        'label' => 'lang:igniter::admin.button_delete',
        'class' => 'btn btn-light text-danger',
        'data-request-confirm' => 'lang:igniter::admin.alert_warning_confirm',
        'permissions' => 'Admin.DeleteReservations',
    ],
];

$config['list']['columns'] = [
    'edit' => [
        'type' => 'button',
        'iconCssClass' => 'fa fa-pencil',
        'attributes' => [
            'class' => 'btn btn-edit',
            'href' => 'reservations/edit/{reservation_id}',
        ],
    ],
    'reservation_id' => [
        'label' => 'lang:igniter::admin.column_id',
    ],
    'location_name' => [
        'label' => 'lang:igniter.reservation::default.column_location',
        'relation' => 'location',
        'select' => 'location_name',
        'searchable' => true,
        'locationAware' => true,
    ],
    'full_name' => [
        'label' => 'lang:igniter::admin.label_name',
        'select' => "concat(first_name, ' ', last_name)",
        'searchable' => true,
    ],
    'guest_num' => [
        'label' => 'lang:igniter.reservation::default.column_guest',
        'type' => 'number',
        'searchable' => true,
    ],
    'table_name' => [
        'label' => 'lang:igniter.reservation::default.column_table',
        'type' => 'partial',
        'path' => 'reservations/lists/column_table_name',
        'searchable' => true,
        'sortable' => false,
    ],
    'status_name' => [
        'label' => 'lang:igniter::admin.label_status',
        'relation' => 'status',
        'select' => 'status_name',
        'type' => 'partial',
        'path' => 'statuses/status_column',
        'searchable' => true,
    ],
    'assignee_name' => [
        'label' => 'lang:igniter.reservation::default.column_staff',
        'type' => 'text',
        'relation' => 'assignee',
        'select' => 'name',
    ],
    'reserve_time' => [
        'label' => 'lang:igniter.reservation::default.column_time',
        'type' => 'time',
    ],
    'reserve_date' => [
        'label' => 'lang:igniter.reservation::default.column_date',
        'type' => 'date',
    ],
    'comment' => [
        'label' => 'lang:admin::lang.statuses.label_comment',
        'invisible' => true,
    ],
    'telephone' => [
        'label' => 'lang:igniter.cart::default.orders.label_telephone',
        'invisible' => true,
        'searchable' => true,
    ],
    'email' => [
        'label' => 'lang:igniter::admin.label_email',
        'invisible' => true,
        'searchable' => true,
    ],
];

$config['calendar']['toolbar'] = [
    'buttons' => [
        'create' => [
            'label' => 'lang:igniter::admin.button_new',
            'class' => 'btn btn-primary',
            'href' => 'reservations/create',
        ],
        'list' => [
            'label' => 'lang:igniter.reservation::default.text_view_calendar',
            'class' => 'btn btn-default',
            'type' => 'dropdown',
            'context' => 'calendar',
            'menuItems' => $listButtonItems,
        ],
    ],
];

$config['form']['toolbar'] = [
    'buttons' => [
        'save' => [
            'label' => 'lang:igniter::admin.button_save',
            'context' => ['create', 'edit'],
            'partial' => 'form/toolbar_save_button',
            'class' => 'btn btn-primary',
            'data-request' => 'onSave',
            'data-progress-indicator' => 'igniter::admin.text_saving',
        ],
        'delete' => [
            'label' => 'lang:igniter::admin.button_icon_delete',

--------------------------------------------------------------------------------

File: resources\models\reservationsettings.php
Comments: Included
Mime Type: application/octet-stream
Size: 2733 bytes
Content:
<?php

return [
    'form' => [
        'toolbar' => [
            'buttons' => [
                'save' => [
                    'label' => 'lang:igniter::admin.button_save',
                    'class' => 'btn btn-primary',
                    'data-request' => 'onSave',
                    'data-progress-indicator' => 'igniter::admin.text_saving',
                ],
            ],
        ],
        'fields' => [
            'reservation_email' => [
                'label' => 'lang:igniter.reservation::default.label_reservation_email',
                'tab' => 'lang:igniter.reservation::default.text_tab_title_reservation',
                'type' => 'checkboxtoggle',
                'options' => [
                    'customer' => 'lang:igniter::system.settings.text_to_customer',
                    'admin' => 'lang:igniter::system.settings.text_to_admin',
                    'location' => 'lang:igniter::system.settings.text_to_location',
                ],
                'comment' => 'lang:igniter.reservation::default.help_reservation_email',
            ],
            'default_reservation_status' => [
                'label' => 'lang:igniter.reservation::default.label_default_reservation_status',
                'tab' => 'lang:igniter.reservation::default.text_tab_title_reservation',
                'type' => 'selectlist',
                'mode' => 'radio',
                'options' => [\Igniter\Admin\Models\Status::class, 'getDropdownOptionsForReservation'],
                'comment' => 'lang:igniter.reservation::default.help_default_reservation_status',
            ],
            'confirmed_reservation_status' => [
                'label' => 'lang:igniter.reservation::default.label_confirmed_reservation_status',
                'tab' => 'lang:igniter.reservation::default.text_tab_title_reservation',
                'type' => 'selectlist',
                'mode' => 'radio',
                'options' => [\Igniter\Admin\Models\Status::class, 'getDropdownOptionsForReservation'],
                'comment' => 'lang:igniter.reservation::default.help_confirmed_reservation_status',
            ],
            'canceled_reservation_status' => [
                'label' => 'lang:igniter.reservation::default.label_canceled_reservation_status',
                'tab' => 'lang:igniter.reservation::default.text_tab_title_reservation',
                'type' => 'selectlist',
                'mode' => 'radio',
                'options' => [\Igniter\Admin\Models\Status::class, 'getDropdownOptionsForReservation'],
                'comment' => 'lang:igniter.reservation::default.help_canceled_reservation_status',
            ],
        ],
    ],
];

--------------------------------------------------------------------------------

File: resources\models\reservationstatus.php
Comments: Included
Mime Type: application/octet-stream
Size: 2329 bytes
Content:
<?php

return [
    'form' => [
        'fields' => [
            'status_id' => [
                'context' => 'status',
                'label' => 'lang:igniter::admin.label_status',
                'type' => 'select',
                'options' => [\Igniter\Admin\Models\Status::class, 'getDropdownOptionsForReservation'],
                'placeholder' => 'lang:igniter::admin.text_please_select',
                'attributes' => [
                    'data-status-value' => '',
                ],
            ],
            'comment' => [
                'context' => 'status',
                'label' => 'lang:igniter::admin.statuses.label_comment',
                'type' => 'textarea',
                'attributes' => [
                    'data-status-comment' => '',
                ],
            ],
            'notify' => [
                'context' => 'status',
                'label' => 'lang:igniter::admin.statuses.label_notify_customer',
                'type' => 'switch',
                'default' => true,
                'offText' => 'lang:igniter::admin.text_no',
                'onText' => 'lang:igniter::admin.text_yes',
                'comment' => 'lang:igniter::admin.statuses.help_notify_customer',
                'attributes' => [
                    'data-status-notify' => '',
                ],
            ],

            'assignee_group_id' => [
                'context' => 'assignee',
                'label' => 'lang:igniter::admin.statuses.label_assignee_group',
                'type' => 'select',
                'options' => [],
                'comment' => 'lang:igniter::admin.statuses.help_assignee_group',
                'placeholder' => 'lang:igniter::admin.text_please_select',
                'attributes' => [
                    'data-assign-group' => '',
                ],
            ],
            'assignee_id' => [
                'context' => 'assignee',
                'label' => 'lang:igniter::admin.statuses.label_assignee',
                'type' => 'select',
                'placeholder' => 'lang:igniter::admin.text_please_select',
                'options' => [],
                'attributes' => [
                    'data-assign-staff' => '',
                ],
            ],
        ],
    ],
];

--------------------------------------------------------------------------------

File: resources\models\table.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6102 bytes
Content:
<?php

$config['list']['filter'] = [
    'search' => [
        'prompt' => 'lang:igniter.reservation::default.tables.text_filter_search',
        'mode' => 'all', // or any, exact
    ],
    'scopes' => [
        'status' => [
            'label' => 'lang:igniter::admin.text_filter_status',
            'type' => 'switch',
            'conditions' => 'table_status = :filtered',
        ],
    ],
];

$config['list']['toolbar'] = [
    'buttons' => [
        'create' => [
            'label' => 'lang:igniter::admin.button_new',
            'class' => 'btn btn-primary',
            'href' => 'tables/create',
        ],
    ],
];

$config['list']['bulkActions'] = [
    'status' => [
        'label' => 'lang:igniter::admin.list.actions.label_status',
        'type' => 'dropdown',
        'class' => 'btn btn-light',
        'statusColumn' => 'table_status',
        'menuItems' => [
            'enable' => [
                'label' => 'lang:igniter::admin.list.actions.label_enable',
                'type' => 'button',
                'class' => 'dropdown-item',
            ],
            'disable' => [
                'label' => 'lang:igniter::admin.list.actions.label_disable',
                'type' => 'button',
                'class' => 'dropdown-item text-danger',
            ],
        ],
    ],
    'delete' => [
        'label' => 'lang:igniter::admin.button_delete',
        'class' => 'btn btn-light text-danger',
        'data-request-confirm' => 'lang:igniter::admin.alert_warning_confirm',
    ],
];

$config['list']['columns'] = [
    'edit' => [
        'type' => 'button',
        'iconCssClass' => 'fa fa-pencil',
        'attributes' => [
            'class' => 'btn btn-edit',
            'href' => 'tables/edit/{table_id}',
        ],
    ],
    'table_name' => [
        'label' => 'lang:igniter::admin.label_name',
        'type' => 'text',
        'searchable' => true,
    ],
    'min_capacity' => [
        'label' => 'lang:igniter.reservation::default.tables.column_min_capacity',
        'type' => 'text',
        'searchable' => true,
    ],
    'max_capacity' => [
        'label' => 'lang:igniter.reservation::default.tables.column_capacity',
        'type' => 'number',
    ],
    'extra_capacity' => [
        'label' => 'lang:igniter.reservation::default.tables.column_extra_capacity',
        'type' => 'number',
        'invisible' => true,
    ],
    'priority' => [
        'label' => 'lang:igniter.reservation::default.tables.column_priority',
        'type' => 'number',
        'invisible' => true,
    ],
    'location_name' => [
        'label' => 'lang:igniter::admin.column_location',
        'type' => 'text',
        'relation' => 'locations',
        'select' => 'location_name',
        'locationAware' => true,
    ],
    'is_joinable' => [
        'label' => 'lang:igniter.reservation::default.tables.label_joinable',
        'type' => 'switch',
        'onText' => 'lang:igniter::admin.text_yes',
        'offText' => 'lang:igniter::admin.text_no',
    ],
    'table_status' => [
        'label' => 'lang:igniter::admin.label_status',
        'type' => 'switch',
    ],
    'table_id' => [
        'label' => 'lang:igniter::admin.column_id',
        'invisible' => true,
    ],
    'created_at' => [
        'label' => 'lang:igniter::admin.column_date_added',
        'invisible' => true,
        'type' => 'datetime',
    ],
    'updated_at' => [
        'label' => 'lang:igniter::admin.column_date_updated',
        'invisible' => true,
        'type' => 'datetime',
    ],
];

$config['form']['toolbar'] = [
    'buttons' => [
        'save' => [
            'label' => 'lang:igniter::admin.button_save',
            'context' => ['create', 'edit'],
            'partial' => 'form/toolbar_save_button',
            'class' => 'btn btn-primary',
            'data-request' => 'onSave',
            'data-progress-indicator' => 'igniter::admin.text_saving',
        ],
        'delete' => [
            'label' => 'lang:igniter::admin.button_icon_delete',
            'class' => 'btn btn-danger',
            'data-request' => 'onDelete',
            'data-request-data' => "_method:'DELETE'",
            'data-request-confirm' => 'lang:igniter::admin.alert_warning_confirm',
            'data-progress-indicator' => 'igniter::admin.text_deleting',
            'context' => ['edit'],
        ],
    ],
];

$config['form']['fields'] = [
    'table_name' => [
        'label' => 'lang:igniter::admin.label_name',
        'type' => 'text',
        'span' => 'left',
    ],
    'priority' => [
        'label' => 'lang:igniter.reservation::default.tables.label_priority',
        'type' => 'number',
        'span' => 'right',
    ],
    'min_capacity' => [
        'label' => 'lang:igniter.reservation::default.tables.label_min_capacity',
        'type' => 'number',
        'span' => 'left',
    ],
    'max_capacity' => [
        'label' => 'lang:igniter.reservation::default.tables.label_capacity',
        'type' => 'number',
        'span' => 'right',
    ],
    'table_status' => [
        'label' => 'lang:igniter::admin.label_status',
        'type' => 'switch',
        'span' => 'left',
        'default' => 1,
    ],
    'is_joinable' => [
        'label' => 'lang:igniter.reservation::default.tables.label_joinable',
        'type' => 'switch',
        'span' => 'right',
        'default' => 1,
        'on' => 'lang:igniter::admin.text_yes',
        'off' => 'lang:igniter::admin.text_no',
    ],
    'locations' => [
        'label' => 'lang:igniter::admin.label_location',
        'type' => 'relation',
        'valueFrom' => 'locations',
        'nameFrom' => 'location_name',
    ],
    'extra_capacity' => [
        'label' => 'lang:igniter.reservation::default.tables.label_extra_capacity',
        'type' => 'number',
        'comment' => 'lang:igniter.reservation::default.tables.help_extra_capacity',
    ],
];

return $config;

--------------------------------------------------------------------------------

File: resources\views\mail\reservation.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 662 bytes
Content:
subject = "{{$site_name}} reservation confirmation - {{$reservation_number}}"
==
Hi {{$first_name}} {{$last_name}},

Thank you for your reservation!

Your reservation {{$reservation_number}} at {{$location_name}} has been booked for {{$reservation_guest_no}} person(s) on {{$reservation_date}} at {{$reservation_time}}.

Thanks for reserving with us online!
==
Hi {{$first_name}} {{$last_name}},

## Thank you for your reservation!

Your reservation **{{$reservation_number}}** at {{$location_name}} has been booked for {{$reservation_guest_no}} person(s) on {{$reservation_date}} at {{$reservation_time}}.

Thanks for reserving with us online!

--------------------------------------------------------------------------------

File: resources\views\mail\reservation_alert.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 816 bytes
Content:
subject = "New reservation on {{$site_name}}"
==
You received a table reservation from {{$site_name}}.

Customer name: {{$first_name}} {{$last_name}}
Reservation no: {{$reservation_number}}
Restaurant: {{$location_name}}
No of guest(s): {{$reservation_guest_no}} person(s)
Reservation date: {{$reservation_date}}
Reservation time: {{$reservation_time}}
==
## You received a table reservation from {{$site_name}}.

| | |
| -------- | -------- |
| **Customer name**     | {{$first_name}} {{$last_name}}     |
| **Reservation no**     | {{$reservation_number}}     |
| **Restaurant**     | {{$location_name}}     |
| **No of guest(s)**     | {{$reservation_guest_no}} person(s)     |
| **Reservation date**     | {{$reservation_date}}     |
| **Reservation time**     | {{$reservation_time}}     |

--------------------------------------------------------------------------------

File: resources\views\mail\reservation_update.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 758 bytes
Content:
subject = "Your Reservation Update - {{ $reservation_number }}"
==
Reservation Update!

Your reservation {{ $reservation_number }} at {{ $location_name }} has been updated to the following status: {{ $status_name }}

The comments for your reservation are:
{{ $status_comment }}

To view your reservation progress, click the link below
{{ $reservation_view_url }}
==
Hi {{ $first_name }} {{ $last_name }},

Your reservation **{{ $reservation_number }}** at **{{ $location_name }}** has been updated to the following status:
<br>
**{{ $status_name }}**

The comments for your reservation are: <br>
{{ $status_comment }}

@partial('button', ['url' => $reservation_view_url, 'type' => 'primary'])
View your reservation status
@endpartial

--------------------------------------------------------------------------------

File: resources\views\reservations\calendar.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 613 bytes
Content:
<div class="d-flex p-3">
    @if($previousUrl = AdminMenu::getPreviousUrl())
        <a
            class="btn shadow-none border-none ps-0"
            href="{{$previousUrl}}"
        ><i class="fa fa-angle-left fs-4 align-bottom"></i></a>
    @endif
    <h4 class="page-title mb-0 lh-base">
        <span>{!! Template::getHeading() !!}</span>
    </h4>
</div>
<div class="row-fluid">
    <div class="card shadow-sm mx-3">
        <div class="border-bottom">
            {!! $this->renderCalendarToolbar() !!}
        </div>
        {!! $this->renderCalendar(null, true) !!}
    </div>
</div>

--------------------------------------------------------------------------------

File: resources\views\reservations\floor_plan.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 737 bytes
Content:
<div class="d-flex p-3">
    @if($previousUrl = AdminMenu::getPreviousUrl())
        <a
            class="btn shadow-none border-none ps-0"
            href="{{$previousUrl}}"
        ><i class="fa fa-angle-left fs-4 align-bottom"></i></a>
    @endif
    <h4 class="page-title mb-0 lh-base">
        <span>{!! Template::getHeading() !!}</span>
    </h4>
</div>
<div class="row-fluid">
    <div class="card shadow-sm mx-3">
        <div class="border-bottom">
            {!! $this->renderListToolbar('floor_plan') !!}
        </div>
        <div class="border-bottom">
            {!! $this->renderListFilter('floor_plan') !!}
        </div>
        {!! $this->renderList('floor_plan', true) !!}
    </div>
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\diningareas\form\dining_table_info.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 735 bytes
Content:
<div class="small d-flex align-items-center">
    <div class="me-3">
        <i class="fas fa-circle {{ $item->is_enabled ? 'text-success' : 'text-danger' }}"></i>
    </div>
    <span class="font-weight-bold fs-5 me-3">@lang($item->name)</span>
    <div class="border rounded-pill px-2 py-1 d-inline-block me-3">
        {{ $item->min_capacity }} - {{ $item->max_capacity }} ({{ $item->extra_capacity }})
    </div>
    <span class="text-muted">@lang('igniter.reservation::default.dining_tables.column_section'):&nbsp;</span>
    {{ $item->dining_section->name ?? '--' }}&nbsp;&nbsp;
    <span class="text-muted">@lang('igniter.reservation::default.dining_tables.label_priority'):&nbsp;</span>{{ $item->priority }}
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\diningareas\form\form_tabs.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 1813 bytes
Content:
@php
    $activeTab = $activeTab ? $activeTab : '#'.$tabs->section.'tab-1';
@endphp
<div class="tab-heading">
    <ul class="form-nav nav nav-tabs">
        @foreach ($tabs as $name => $fields)
            <li class="nav-item">
                <a
                    class="nav-link{{ (('#'.$tabs->section.'tab-'.$loop->iteration) == $activeTab) ? ' active' : '' }}"
                    href="{{ '#'.$tabs->section.'tab-'.$loop->iteration }}"
                    data-bs-toggle="tab"
                >@lang($name)</a>
            </li>
        @endforeach
    </ul>
</div>

<div class="tab-content">
    @foreach ($tabs as $name => $fields)
        <div
            class="tab-pane p-3 {{ (('#'.$tabs->section.'tab-'.$loop->iteration) == $activeTab) ? 'active' : '' }}"
            id="{{ $tabs->section.'tab-'.$loop->iteration }}">
            <div class="form-fields py-3">
                @if ($name === 'igniter.reservation::default.dining_areas.text_tab_tables')
                    <div class="row w-100">
                        <div class="col-md-4">
                            <h5 class="mb-3">@lang($fields['_dining_sections']->label)</h5>
                            {!! $this->renderFieldElement($fields['_dining_sections']) !!}
                        </div>
                        @isset($fields['dining_table_solos'])
                            <div class="col-md-8">
                                {!! $this->renderFieldElement($fields['dining_table_solos']) !!}
                            </div>
                        @endisset
                    </div>
                @else
                    {!! $this->makePartial('form/form_fields', ['fields' => $fields]) !!}
                @endif
            </div>
        </div>
    @endforeach
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\diningareas\form\new_table_btn.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 130 bytes
Content:
<button
    class="btn btn-light"
    data-request="onNewItem"
>
    <i class="fa fa-plus"></i>&nbsp;&nbsp;New Item
</button>
--------------------------------------------------------------------------------

File: resources\views\_partials\diningareas\form\select_dining_tables.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 1894 bytes
Content:
<div class="input-group">
    <div class="flex-grow-1">
        @php
            $fieldOptions = $formModel->dining_table_solos->pluck('name', 'id');
            $checkedValues = (array)$field->value;
            $enableFilter = (count($fieldOptions) > 20);
        @endphp
        <div class="control-selectlist">
            <select
                    data-control="selectlist"
                    id="{{ $field->getId() }}"
                    name="{{ $field->getName() }}[]"
                    {!! $this->previewMode ? 'disabled="disabled"' : '' !!}
                    multiple="multiple"
                    data-enable-filtering="{{ $enableFilter }}"
                    data-enable-case-insensitive-filtering="{{ $enableFilter }}"
                    {!! $field->getAttributes() !!}
            >
                @foreach ($fieldOptions as $value => $option)
                    @continue($field->disabled && !in_array($value, $checkedValues))
                    @php
                        if (!is_array($option)) $option = [$option];
                    @endphp
                    <option
                            {!! in_array($value, $checkedValues) ? 'selected="selected"' : '' !!}
                            value="{{ $value }}">
                        {{ is_lang_key($option[0]) ? lang($option[0]) : $option[0] }}
                        @isset($option[1])
                            <span>{{ is_lang_key($option[1]) ? lang($option[1]) : $option[1] }}</span>
                        @endisset
                    </option>
                @endforeach
            </select>
        </div>
    </div>
    <button
        type="button"
        class="btn btn-light"
        data-request="onCreateCombo"
    ><i class="fa fa-plus"></i>&nbsp;&nbsp;@lang('igniter.reservation::default.dining_areas.button_new_combo')</button>
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\diningareas\form\table_info_summary.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 295 bytes
Content:
<p class="card-title font-weight-bold mb-0">@lang($item->title)</p>
@if ($item->parent)
    <span class="text-muted">Parent: </span>@lang($item->parent->title)&nbsp;&nbsp;
@endif
<span class="text-muted">Type: </span>{{ $item->type }}
<div data-properties='@json($item->toArray())'></div>

--------------------------------------------------------------------------------

File: resources\views\_partials\formwidgets\floorplanner\floorplanner.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 1140 bytes
Content:
<div
    data-control="floorplanner"
    data-alias="{{ $this->alias }}"
    data-dining-tables='@json($diningTables)'
    data-connector-widget-alias="{{ $connectorWidgetAlias }}"
>
    <div class="floorplanner border border-2 rounded position-relative">
        <div class="toolbar text-right p-2">
            <button
                type="button"
                class="btn btn-light"
                data-floor-planner-control="zoom-out"
            ><i class="fas fa-magnifying-glass-minus"></i></button>
            <button
                type="button"
                class="btn btn-light"
                data-floor-planner-control="zoom-in"
            ><i class="fas fa-magnifying-glass-plus"></i></button>
        </div>
        <div
            class="floorplanner-canvas border-top overflow-auto d-flex flex-wrap"
            data-floor-planner-canvas
        ></div>
    </div>
    @isset($field)
        <input
            type="hidden"
            name="{{ $field->getName() }}"
            value='@json($field->value)'
            data-floor-planner-input
        />
    @endisset
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\form\calendar_popover.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 1679 bytes
Content:
<div class="modal-dialog">
    <div class="modal-content calendar-popover-content">
        <div class="modal-header">
            <h5 class="modal-title">
                <a href="{{ admin_url('reservations/edit') }}/@{{id}}">#@{{id}}</a>
                &nbsp;&nbsp;&nbsp;&nbsp;
                @verbatim
                    <span
                            class="label label-secondary text-white"
                            style="background-color: {{status.status_color}};"
                    >{{status.status_name}}</span>
                @endverbatim
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
            <p>
                <b>@lang('igniter.reservation::default.column_table'):</b>
                @verbatim
                    {{#tables}}<em>{{name}}</em> - {{/tables}}
                    {{^tables}}No Table({{/tables}}
                @endverbatim
            </p>
            <p>
                <b>@lang('igniter.reservation::default.label_guest'):</b>
                @{{guest_num}}
            </p>
            <p>
                <b>@lang('igniter.reservation::default.label_reservation_time'):</b>
                @{{reserve_time}} - @{{reserve_end_time}}
            </p>
            <p>
                <b>@lang('igniter.reservation::default.label_customer_name'):</b>
                @{{first_name}} @{{last_name}}
            </p>
            <p>
                <b>@lang('igniter::admin.label_email'):</b>
                @{{email}}
            </p>
        </div>
    </div>
</div>
--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\form\info.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 590 bytes
Content:
<div class="d-flex">
    <div class="mr-3 flex-fill">
        <label class="form-label">
            @lang('igniter.reservation::default.label_reservation_id')
        </label>
        <h3>#{{ $formModel->reservation_id }}</h3>
    </div>
    <div class="mr-3 flex-fill text-center">
        <label class="form-label">
            @lang('igniter.reservation::default.label_reservation_date_time')
        </label>
        <h3>
            {{ $formModel->reservation_date_time->isoFormat(lang('system::lang.moment.date_time_format_short')) }}
        </h3>
    </div>
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\lists\column_floor_plan.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 394 bytes
Content:
<div>
    {{ $record->reservation_datetime->isoFormat(lang('system::lang.moment.time_format'))
        .' - '.$record->reservation_end_datetime->isoFormat(lang('system::lang.moment.time_format')) }}
</div>
<h5 class="my-1">{{ $record->customer_name }}</h5>
<div>
    <span class="badge border border-default text-wrap">{{ $record->table_name }}</span> ({{ $record->guest_num }})
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\lists\column_table_name.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 236 bytes
Content:
<div class="d-inline-block border rounded py-1 px-2 text-wrap">
        @if($value)
                <b>{{ $value }}</b>
        @else
                {{ lang('igniter.reservation::default.text_no_table') }}
        @endif
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\lists\floor_plan_view.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 1306 bytes
Content:
@isset($diningArea)
    <div
        data-control="floorplanner"
        data-dining-tables='@json($diningArea->getDiningTablesWithReservation($records))'
        data-preview-mode="true"
    >
        <div class="floorplanner border-top border-bottom position-relative">
            <div class="toolbar text-right p-2">
                <button
                    type="button"
                    class="btn btn-light"
                    data-floor-planner-control="zoom-out"
                ><i class="fas fa-magnifying-glass-minus"></i></button>
                <button
                    type="button"
                    class="btn btn-light"
                    data-floor-planner-control="zoom-in"
                ><i class="fas fa-magnifying-glass-plus"></i></button>
            </div>
            <div
                class="floorplanner-canvas border-top overflow-auto d-flex flex-wrap"
                data-floor-planner-canvas
            ></div>
        </div>
        <input
            type="hidden"
            value='@json($diningArea->floor_plan)'
            data-floor-planner-input
        />
    </div>
@else
    <div class="p-5 text-center">
        {{ lang('igniter.reservation::default.alert_no_selected_dining_area') }}
    </div>
@endisset

--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\lists\list.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 1943 bytes
Content:
<div class="floorplan row g-0" id="{{ $this->getId('list') }}">
    @if($this->alias === 'floor_plan')
        <div class="col-md-8 border-end">
            {!! $this->makePartial('lists/floor_plan_view') !!}
        </div>
        <div class="col-md-4">
            @else
                <div class="col-md-12">
                    @endif
                    <div>
                        {!! form_open(['id' => 'list-form', 'role' => 'form', 'method' => 'POST']) !!}
                        <div id="{{ $this->getId() }}" class="list-table table-responsive">
                            <table id="{{ $this->getId('table') }}" class="table table-hover mb-0 border-bottom">
                                <thead>
                                @if ($showCheckboxes)
                                    {!! $this->makePartial('lists/list_actions') !!}
                                @endif
                                {!! $this->makePartial('lists/list_head') !!}
                                </thead>
                                <tbody>
                                @if(count($records))
                                    {!! $this->makePartial('lists/list_body') !!}
                                @else
                                    <tr>
                                        <td colspan="99" class="text-center">{{ $emptyMessage }}</td>
                                    </tr>
                                @endif
                                </tbody>
                            </table>
                        </div>

                        {!! form_close() !!}

                        {!! $this->makePartial('lists/list_pagination') !!}

                        @if ($showSetup)
                            {!! $this->makePartial('lists/list_setup') !!}
                        @endif
                    </div>
                </div>
        </div>
</div>

--------------------------------------------------------------------------------

File: resources\views\_partials\reservations\lists\switch_to_button.blade.php
Comments: Included
Mime Type: application/octet-stream
Size: 929 bytes
Content:
<div class="btn-group">
    <button
        type="button"
        class="{{ $button->cssClass }} dropdown-toggle"
        data-bs-toggle="dropdown"
        data-bs-display="static"
        aria-haspopup="true"
        aria-expanded="false"
        tabindex="0"
        {!! $button->getAttributes() !!}
    >{!! $button->label ?: $button->name !!}</button>
    <ul class="dropdown-menu dropdown-menu-left">
        <li><h6 class="dropdown-header px-2">Switch to</h6></li>
        @foreach (['list', 'calendar', 'floor_plan'] as $context)
            <li>
                <a
                    class="dropdown-item px-2 {{$selectedContext === $context ? 'active' : ''}}"
                    href="{{ admin_url('reservations'. ($context !== 'list' ? '/'.$context : '')) }}"
                >@lang('igniter.reservation::default.text_view_'.$context)</a>
            </li>
        @endforeach
    </ul>
</div>

--------------------------------------------------------------------------------

File: src\AutomationRules\Conditions\ReservationAttribute.php
Comments: Included
Mime Type: application/octet-stream
Size: 3828 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\AutomationRules\Conditions;

use Igniter\Automation\AutomationException;
use Igniter\Automation\Classes\BaseModelAttributesCondition;
use Igniter\Reservation\Models\Reservation;
use Override;

class ReservationAttribute extends BaseModelAttributesCondition
{
    protected $modelClass = Reservation::class;

    protected $modelAttributes;

    #[Override]
    public function conditionDetails(): array
    {
        return [
            'name' => 'Reservation attribute',
            'description' => 'Reservation attributes',
        ];
    }

    #[Override]
    public function defineModelAttributes(): array
    {
        return [
            'first_name' => [
                'label' => 'First Name',
            ],
            'last_name' => [
                'label' => 'Last Name',
            ],
            'email' => [
                'label' => 'Email address',
            ],
            'location_id' => [
                'label' => 'Location ID',
            ],
            'status_id' => [
                'label' => 'Last reservation status ID',
            ],
            'guest_num' => [
                'label' => 'Number of guests',
            ],
            'hours_since' => [
                'label' => 'Hours since reservation time',
            ],
            'hours_until' => [
                'label' => 'Hours until reservation time',
            ],
            'days_since' => [
                'label' => 'Days since reservation time',
            ],
            'days_until' => [
                'label' => 'Days until reservation time',
            ],
            'history_status_id' => [
                'label' => 'Recent reservation status IDs (eg. 1,2,3)',
            ],
        ];
    }

    public function getHoursSinceAttribute($value, $reservation): float|int
    {
        $currentDateTime = now();

        return $currentDateTime->isAfter($reservation->reservation_datetime)
            ? floor($reservation->reservation_datetime->diffInUTCHours($currentDateTime))
            : 0;
    }

    public function getHoursUntilAttribute($value, $reservation)
    {
        $currentDateTime = now();

        return $currentDateTime->isBefore($reservation->reservation_datetime)
            ? $currentDateTime->diffInUTCHours($reservation->reservation_datetime)
            : 0;
    }

    public function getDaysSinceAttribute($value, $reservation): float|int
    {
        $currentDateTime = now();

        return $currentDateTime->isAfter($reservation->reservation_datetime)
            ? floor($reservation->reservation_datetime->diffInDays($currentDateTime))
            : 0;
    }

    public function getDaysUntilAttribute($value, $reservation): float|int
    {
        $currentDateTime = now();

        return $currentDateTime->isBefore($reservation->reservation_datetime)
            ? floor($currentDateTime->diffInDays($reservation->reservation_datetime))
            : 0;
    }

    public function getHistoryStatusIdAttribute($value, $reservation)
    {
        return $reservation->status_history()->pluck('status_id')->implode(',');
    }

    /**
     * Checks whether the condition is TRUE for specified parameters
     * @param array $params Specifies a list of parameters as an associative array.
     * @return bool
     */
    #[Override]
    public function isTrue(&$params)
    {
        if (!$reservation = array_get($params, 'reservation')) {
            throw new AutomationException('Error evaluating the reservation attribute condition: the reservation object is not found in the condition parameters.');
        }

        return $this->evalIsTrue($reservation);
    }
}

--------------------------------------------------------------------------------

File: src\AutomationRules\Conditions\ReservationStatusAttribute.php
Comments: Included
Mime Type: application/octet-stream
Size: 1602 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\AutomationRules\Conditions;

use Igniter\Admin\Models\Status;
use Igniter\Automation\AutomationException;
use Igniter\Automation\Classes\BaseModelAttributesCondition;
use Override;

class ReservationStatusAttribute extends BaseModelAttributesCondition
{
    protected $modelClass = Status::class;

    protected $modelAttributes;

    #[Override]
    public function conditionDetails(): array
    {
        return [
            'name' => 'Reservation status attribute',
            'description' => 'Reservation status attributes',
        ];
    }

    #[Override]
    public function defineModelAttributes(): array
    {
        return [
            'status_id' => [
                'label' => 'Status ID',
            ],
            'status_name' => [
                'label' => 'Status Name',
            ],
            'notify_customer' => [
                'label' => 'Notify Customer',
            ],
        ];
    }

    /**
     * Checks whether the condition is TRUE for specified parameters
     * @param array $params Specifies a list of parameters as an associative array.
     * @return bool
     */
    #[Override]
    public function isTrue(&$params)
    {
        $status = array_get($params, 'status');
        if (!$status instanceof Status) {
            throw new AutomationException('Error evaluating the status attribute condition: the status object is not found in the condition parameters.');
        }

        return $this->evalIsTrue($status);
    }
}

--------------------------------------------------------------------------------

File: src\AutomationRules\Events\NewReservation.php
Comments: Included
Mime Type: application/octet-stream
Size: 880 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\AutomationRules\Events;

use Igniter\Automation\Classes\BaseEvent;
use Igniter\Reservation\Models\Reservation;
use Override;

class NewReservation extends BaseEvent
{
    #[Override]
    public function eventDetails(): array
    {
        return [
            'name' => 'New Reservation Event',
            'description' => 'When a new reservation is created',
            'group' => 'reservation',
        ];
    }

    #[Override]
    public static function makeParamsFromEvent(array $args, $eventName = null)
    {
        $params = [];
        $reservation = array_get($args, 0);
        if ($reservation instanceof Reservation) {
            $params = $reservation->mailGetData();
        }

        $params['status'] = $reservation?->status;

        return $params;
    }
}

--------------------------------------------------------------------------------

File: src\AutomationRules\Events\NewReservationStatus.php
Comments: Included
Mime Type: application/octet-stream
Size: 925 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\AutomationRules\Events;

use Igniter\Automation\Classes\BaseEvent;
use Igniter\Reservation\Models\Reservation;
use Override;

class NewReservationStatus extends BaseEvent
{
    #[Override]
    public function eventDetails(): array
    {
        return [
            'name' => 'Reservation Status Update Event',
            'description' => 'When a reservation status is updated',
            'group' => 'reservation',
        ];
    }

    #[Override]
    public static function makeParamsFromEvent(array $args, $eventName = null)
    {
        $params = [];
        $reservation = array_get($args, 0);
        $status = array_get($args, 1);
        if ($reservation instanceof Reservation) {
            $params = $reservation->mailGetData();
        }

        $params['status'] = $status;

        return $params;
    }
}

--------------------------------------------------------------------------------

File: src\AutomationRules\Events\ReservationAssigned.php
Comments: Included
Mime Type: application/octet-stream
Size: 954 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\AutomationRules\Events;

use Igniter\Automation\Classes\BaseEvent;
use Igniter\Reservation\Models\Reservation;
use Override;

class ReservationAssigned extends BaseEvent
{
    #[Override]
    public function eventDetails(): array
    {
        return [
            'name' => 'Reservation Assigned Event',
            'description' => 'When a reservation is assigned to a staff',
            'group' => 'reservation',
        ];
    }

    #[Override]
    public static function makeParamsFromEvent(array $args, $eventName = null)
    {
        $params = [];
        $reservation = array_get($args, 0);
        if ($reservation instanceof Reservation) {
            $params = $reservation->mailGetData();
        }

        $params['status'] = $reservation?->status;
        $params['assignee'] = $reservation?->assignee;

        return $params;
    }
}

--------------------------------------------------------------------------------

File: src\BulkActionWidgets\AssignTable.php
Comments: Included
Mime Type: application/octet-stream
Size: 1292 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\BulkActionWidgets;

use Igniter\Admin\Classes\BaseBulkActionWidget;
use Igniter\Reservation\Models\Reservation;
use Illuminate\Support\Collection;
use Override;

class AssignTable extends BaseBulkActionWidget
{
    #[Override]
    public function handleAction(array $requestData, Collection $records): void
    {
        $noTablesFound = [];
        $tablesAssigned = [];

        foreach ($records->sortBy('reservation_datetime') as $reservation) {
            /** @var Reservation $reservation */
            if ($reservation->tables->count() > 0) {
                continue;
            }

            if ($reservation->autoAssignTable()) {
                $tablesAssigned[] = $reservation->reservation_id;
            } else {
                $noTablesFound[] = $reservation->reservation_id;
            }
        }

        if ($noTablesFound !== []) {
            flash()->warning(
                lang('igniter.reservation::default.alert_no_assignable_table').' '.implode(', ', $noTablesFound),
            )->important();
        }

        if ($tablesAssigned !== []) {
            flash()->success(lang('igniter.reservation::default.alert_table_assigned'));
        }
    }
}

--------------------------------------------------------------------------------

File: src\Classes\BookingManager.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6214 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Classes;

use Carbon\Carbon;
use DateInterval;
use DateTime;
use Exception;
use Igniter\Admin\Models\Status;
use Igniter\Local\Classes\WorkingSchedule;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Concerns\LocationAction;
use Igniter\Reservation\Models\Reservation;
use Igniter\User\Facades\Auth;
use Igniter\User\Models\Customer;
use Illuminate\Contracts\Auth\Authenticatable;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Event;

class BookingManager
{
    protected Customer|Authenticatable|null $customer;

    protected Location|LocationAction|null $location = null;

    protected $availableTables;

    protected $fullyBookedCache = [];

    public function __construct()
    {
        $this->customer = Auth::customer();
    }

    public function useLocation(Location|LocationAction|null $location): void
    {
        $this->location = $location;
    }

    public function getReservation(): Reservation
    {
        return $this->loadReservation();
    }

    public function loadReservation(): Reservation
    {
        $reservation = new Reservation($this->getRequiredAttributes());

        $reservation->customer()->associate($this->customer);
        $reservation->location()->associate($this->location);

        return $reservation;
    }

    public function getReservationByHash($hash, $customer = null)
    {
        $query = Reservation::query()->whereHash($hash);

        if (!is_null($customer)) {
            $query->where('customer_id', $customer->getKey());
        }

        return $query->first();
    }

    /**
     * @param int $interval
     * @param int $lead
     * @return array|Collection
     * @throws Exception
     */
    public function makeTimeSlots(Carbon $date, $interval = null, $lead = null)
    {
        if ($this->location === null) {
            return [];
        }

        $interval = is_null($interval)
            ? $this->location->getReservationInterval() : $interval;

        $lead = is_null($lead) ? $this->location->getReservationLeadTime() : $lead;
        if ($this->location->getSettings('booking.include_start_time', 1)) {
            $lead = 0;
        }

        $dateInterval = new DateInterval('PT'.$interval.'M');
        $leadTime = new DateInterval('PT'.$lead.'M');

        return $this->getSchedule()
            ->generateTimeslot($date, $dateInterval, $leadTime)
            ->filter(fn($dateTime, $timestamp) => $date->copy()
                ->setTimeFromTimeString($dateTime->format('H:i'))
                ->gte(Carbon::now()->addMinutes($lead)));
    }

    /**
     * @return Reservation
     */
    public function saveReservation($reservation, $data)
    {
        Event::dispatch('igniter.reservation.beforeSaveReservation', [$reservation, $data]);

        $reservation->guest_num = (int)array_get($data, 'guest', 1);
        $reservation->first_name = array_get($data, 'first_name', $reservation->first_name);
        $reservation->last_name = array_get($data, 'last_name', $reservation->last_name);
        $reservation->email = $this->customer->email ?? array_get($data, 'email', $reservation->email);
        $reservation->telephone = array_get($data, 'telephone', $reservation->telephone);
        $reservation->comment = array_get($data, 'comment');

        $dateTime = make_carbon(array_get($data, 'sdateTime'));
        $reservation->reserve_date = $dateTime->format('Y-m-d');
        $reservation->reserve_time = $dateTime->format('H:i:s');
        $reservation->duration = $this->location->getReservationStayTime();
        $reservation->status = setting('default_reservation_status');

        $reservation->save();

        $status = Status::find(setting('default_reservation_status'));
        $reservation->addStatusHistory($status, ['notify' => false]);

        Event::dispatch('igniter.reservation.confirmed', [$reservation]);

        return $reservation;
    }

    //
    //
    //
    /**
     * @param $dateTime
     * @return WorkingSchedule
     */
    public function getSchedule($days = null)
    {
        if (is_null($days)) {
            $days = [
                $this->location->getMinReservationAdvanceTime(),
                $this->location->getMaxReservationAdvanceTime(),
            ];
        }

        return $this->location->newWorkingSchedule('opening', $days);
    }

    public function isFullyBookedOn(DateTime $dateTime, $noOfGuests = null)
    {
        /** @var Carbon $dateTime */
        $index = $dateTime->timestamp.'-'.$noOfGuests;

        if (array_key_exists($index, $this->fullyBookedCache)) {
            return $this->fullyBookedCache[$index];
        }

        /** @var string|array|bool|null $isFullyBooked */
        $isFullyBooked = Event::dispatch('igniter.reservation.isFullyBookedOn', [$dateTime, $noOfGuests], true);
        if (!is_bool($isFullyBooked)) {
            $isFullyBooked = $this->getNextBookableTable($dateTime, $noOfGuests)->isEmpty();
        }

        return $this->fullyBookedCache[$index] = $isFullyBooked;
    }

    /**
     * @param int $noOfGuests
     * @return Collection|null
     */
    public function getNextBookableTable(DateTime $dateTime, $noOfGuests)
    {
        $reservation = $this->getReservation();

        $reservation->reserve_date = $dateTime->format('Y-m-d');
        $reservation->reserve_time = $dateTime->format('H:i:s');
        $reservation->guest_num = $noOfGuests;
        $reservation->duration = $this->location->getReservationStayTime();

        return $reservation->getNextBookableTable();
    }

    protected function getRequiredAttributes(): array
    {
        return [
            'customer_id' => $this->customer->customer_id ?? null,
            'first_name' => $this->customer->first_name ?? null,
            'last_name' => $this->customer->last_name ?? null,
            'email' => $this->customer->email ?? null,
            'telephone' => $this->customer->telephone ?? nu
--------------------------------------------------------------------------------

File: src\Database\Factories\DiningAreaFactory.php
Comments: Included
Mime Type: application/octet-stream
Size: 522 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Database\Factories;

use Igniter\Flame\Database\Factories\Factory;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\DiningArea;
use Override;

class DiningAreaFactory extends Factory
{
    protected $model = DiningArea::class;

    #[Override]
    public function definition()
    {
        return [
            'location_id' => Location::factory(),
            'name' => $this->faker->sentence(2),
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Database\Factories\DiningSectionFactory.php
Comments: Included
Mime Type: application/octet-stream
Size: 765 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Database\Factories;

use Igniter\Flame\Database\Factories\Factory;
use Igniter\Reservation\Models\DiningSection;
use Override;

class DiningSectionFactory extends Factory
{
    protected $model = DiningSection::class;

    #[Override]
    public function definition()
    {
        return [
            'location_id' => $this->faker->numberBetween(1, 10),
            'name' => $this->faker->sentence(2),
            'description' => $this->faker->sentence(5),
            'priority' => $this->faker->randomDigit(),
            'is_enabled' => 1,
            'created_at' => $this->faker->dateTime(),
            'updated_at' => $this->faker->dateTime(),
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Database\Factories\DiningTableFactory.php
Comments: Included
Mime Type: application/octet-stream
Size: 668 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Database\Factories;

use Igniter\Flame\Database\Factories\Factory;
use Igniter\Reservation\Models\DiningTable;
use Override;

class DiningTableFactory extends Factory
{
    protected $model = DiningTable::class;

    #[Override]
    public function definition(): array
    {
        return [
            'name' => $this->faker->sentence(2),
            'min_capacity' => $this->faker->randomDigitNotNull(),
            'max_capacity' => $this->faker->numberBetween(10, 20),
            'priority' => $this->faker->randomDigit(),
            'is_enabled' => 1,
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Database\Factories\ReservationFactory.php
Comments: Included
Mime Type: application/octet-stream
Size: 866 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Database\Factories;

use Igniter\Flame\Database\Factories\Factory;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Reservation;
use Override;

class ReservationFactory extends Factory
{
    protected $model = Reservation::class;

    #[Override]
    public function definition(): array
    {
        return [
            'first_name' => $this->faker->firstName(),
            'last_name' => $this->faker->lastName(),
            'email' => $this->faker->email(),
            'telephone' => $this->faker->phoneNumber(),
            'reserve_date' => $this->faker->date(),
            'reserve_time' => $this->faker->time(),
            'guest_num' => $this->faker->numberBetween(0, 99),
            'location_id' => Location::factory(),
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Events\ReservationCanceledEvent.php
Comments: Included
Mime Type: application/octet-stream
Size: 417 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Events;

use Igniter\Flame\Traits\EventDispatchable;
use Igniter\Reservation\Models\Reservation;

class ReservationCanceledEvent
{
    use EventDispatchable;

    public function __construct(public Reservation $reservation) {}

    public static function eventName(): string
    {
        return 'admin.reservation.canceled';
    }
}

--------------------------------------------------------------------------------

File: src\Extension.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 10833 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation;

use Igniter\Admin\DashboardWidgets\Charts;
use Igniter\Admin\DashboardWidgets\Statistics;
use Igniter\Admin\Models\StatusHistory;
use Igniter\Local\Models\Location;
use Igniter\Local\Models\Location as LocationModel;
use Igniter\Reservation\AutomationRules\Conditions\ReservationAttribute;
use Igniter\Reservation\AutomationRules\Conditions\ReservationStatusAttribute;
use Igniter\Reservation\AutomationRules\Events\NewReservation;
use Igniter\Reservation\AutomationRules\Events\NewReservationStatus;
use Igniter\Reservation\AutomationRules\Events\ReservationAssigned;
use Igniter\Reservation\BulkActionWidgets\AssignTable;
use Igniter\Reservation\Classes\BookingManager;
use Igniter\Reservation\FormWidgets\FloorPlanner;
use Igniter\Reservation\Http\Requests\BookingSettingsRequest;
use Igniter\Reservation\Http\Requests\ReservationSettingsRequest;
use Igniter\Reservation\Listeners\AddsCustomerReservationsTabFields;
use Igniter\Reservation\Listeners\MaxGuestSizePerTimeslotReached;
use Igniter\Reservation\Listeners\RegistersDashboardCards;
use Igniter\Reservation\Listeners\SendReservationConfirmation;
use Igniter\Reservation\Models\Concerns\LocationAction;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Observers\DiningTableObserver;
use Igniter\Reservation\Models\Observers\ReservationObserver;
use Igniter\Reservation\Models\Reservation;
use Igniter\Reservation\Models\Scopes\DiningTableScope;
use Igniter\Reservation\Models\Scopes\ReservationScope;
use Igniter\System\Classes\BaseExtension;
use Igniter\System\Models\Settings;
use Igniter\User\Http\Controllers\Customers;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Support\Facades\Event;
use Override;

class Extension extends BaseExtension
{
    protected $listen = [
        'igniter.reservation.isFullyBookedOn' => [
            MaxGuestSizePerTimeslotReached::class,
        ],
        'igniter.reservation.confirmed' => [
            SendReservationConfirmation::class,
        ],
    ];

    protected $observers = [
        DiningTable::class => DiningTableObserver::class,
        Reservation::class => ReservationObserver::class,
    ];

    protected array $scopes = [
        DiningTable::class => DiningTableScope::class,
        Reservation::class => ReservationScope::class,
    ];

    #[Override]
    public function register(): void
    {
        parent::register();

        $this->app->singleton(BookingManager::class);

        $this->registerSystemSettings();
    }

    #[Override]
    public function boot(): void
    {
        $this->bindReservationEvent();

        Relation::enforceMorphMap([
            'reservations' => Reservation::class,
            'tables' => DiningTable::class,
            'dining_areas' => DiningArea::class,
            'dining_sections' => DiningSection::class,
        ]);

        Customers::extendFormFields(new AddsCustomerReservationsTabFields);

        LocationModel::implement(LocationAction::class);

        Location::extend(function(Location $model): void {
            $model->relation['hasMany']['dining_areas'] = [DiningArea::class, 'delete' => true];
            $model->relation['morphedByMany']['tables'] = [DiningTable::class, 'name' => 'locationable'];
        });

        $this->extendDashboardChartsDatasets();

        Statistics::registerCards(fn(): array => (new RegistersDashboardCards)());
    }

    #[Override]
    public function registerMailTemplates(): array
    {
        return [
            'igniter.reservation::mail.reservation' => 'lang:igniter.reservation::default.text_mail_reservation',
            'igniter.reservation::mail.reservation_alert' => 'lang:igniter.reservation::default.text_mail_reservation_alert',
            'igniter.reservation::mail.reservation_update' => 'lang:igniter.reservation::default.text_mail_reservation_update',
        ];
    }

    public function registerAutomationRules(): array
    {
        return [
            'events' => [
                'igniter.reservation.confirmed' => NewReservation::class,
                'igniter.reservation.statusAdded' => NewReservationStatus::class,
                'igniter.reservation.assigned' => ReservationAssigned::class,
            ],
            'actions' => [],
            'conditions' => [
                ReservationAttribute::class,
                ReservationStatusAttribute::class,
            ],
        ];
    }

    #[Override]
    public function registerPermissions(): array
    {
        return [
            'Admin.Tables' => [
                'label' => 'igniter.reservation::default.text_permission_dining_areas',
                'group' => 'igniter.reservation::default.text_permission_group',
            ],
            'Admin.Reservations' => [
                'label' => 'igniter.reservation::default.text_permission_reservations',
                'group' => 'igniter.reservation::default.text_permission_group',
            ],
            'Admin.DeleteReservations' => [
                'label' => 'igniter.reservation::default.text_permission_delete_reservations',
                'group' => 'igniter.reservation::default.text_permission_group',
            ],
            'Admin.AssignReservations' => [
                'label' => 'igniter.reservation::default.text_permission_assign_reservations',
                'group' => 'igniter.reservation::default.text_permission_group',
            ],
            'Admin.AssignReservationTables' => [
                'label' => 'igniter.reservation::default.text_permission_assign_reservation_tables',
                'group' => 'igniter.reservation::default.text_permission_group',
            ],
        ];
    }

    #[Override]
    public function registerNavigation(): array
    {
        return [
            'reservations' => [
                'priority' => 20,
                'class' =>
--------------------------------------------------------------------------------

File: src\FormWidgets\FloorPlanner.php
Comments: Included
Mime Type: application/octet-stream
Size: 3989 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\FormWidgets;

use Igniter\Admin\Classes\BaseFormWidget;
use Igniter\Admin\Classes\FormField;
use Igniter\Admin\Traits\FormModelWidget;
use Igniter\Admin\Traits\ValidatesForm;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningTable;
use Override;

/**
 * Floor planner
 * Renders a floor planner field.
 *
 * @property DiningArea $model
 */
class FloorPlanner extends BaseFormWidget
{
    use FormModelWidget;
    use ValidatesForm;

    //
    // Configurable properties
    //

    /**
     * @var string Relation name, if this field name does not represents a model relationship.
     */
    public $relationFrom;

    /**
     * @var array Default available colors
     */
    public $sectionColors = [
        '#1abc9c', '#16a085',
        '#9b59b6', '#8e44ad',
        '#34495e', '#2b3e50',
        '#f1c40f', '#f39c12',
        '#e74c3c', '#c0392b',
        '#95a5a6', '#7f8c8d',
    ];

    public $connectorField = 'dining_tables';

    public $formTitle = 'Edit table';

    /**
     * @var string Use a custom scope method for the list query.
     */
    public $scope;

    //
    // Object properties
    //

    protected string $defaultAlias = 'floorplanner';

    #[Override]
    public function initialize(): void
    {
        $this->fillFromConfig([
            'sectionColors',
            'relationFrom',
            'connectorField',
            'formTitle',
            'scope',
        ]);
    }

    #[Override]
    public function render(): string
    {
        $this->prepareVars();

        return $this->makePartial('floorplanner/floorplanner');
    }

    /**
     * Prepares the list data
     */
    public function prepareVars(): void
    {
        $this->vars['field'] = $this->formField;
        $this->vars['sectionColors'] = $this->sectionColors();
        $this->vars['diningTables'] = $this->formField->options();
        $this->vars['connectorWidgetAlias'] = $this->getConnectorWidgetAlias();
    }

    #[Override]
    public function loadAssets(): void
    {
        $this->addJs('https://unpkg.com/konva@8.3.12/konva.min.js', 'konva-js');
        $this->addCss('css/floorplanner.css', 'floorplanner-css');
        $this->addJs('js/floorplanner.js', 'floorplanner-js');
    }

    public function onSaveState(): void
    {
        $state = json_decode((string) input('state'), true);

        $this->validate($state, [
            'stage.x' => ['required', 'numeric'],
            'stage.y' => ['required', 'numeric'],
            'stage.scaleX' => ['required', 'numeric'],
            'stage.scaleY' => ['required', 'numeric'],
            'groups.*.x' => ['required', 'numeric'],
            'groups.*.y' => ['required', 'numeric'],
            'groups.*.rotation' => ['required', 'numeric'],
        ]);

        $this->model->floor_plan = array_only($state, 'stage');
        $this->model->save();

        collect(array_get($state, 'groups'))->each(function($group): void {
            $id = str_after(array_get($group, 'id'), 'group-');
            /** @var DiningTable $table */
            if ($table = $this->model->dining_tables()->find($id)) {
                $table->seat_layout = $group;
                $table->save();
            }
        });
    }

    #[Override]
    public function getSaveValue(mixed $value): int
    {
        return FormField::NO_SAVE_DATA;
    }

    protected function sectionColors()
    {
        $colors = [];
        foreach ($this->sectionColors as $color) {
            $colors[$color] = $color;
        }

        return $colors;
    }

    protected function getConnectorWidgetAlias(): string
    {
        $formAlias = $this->controller->widgets['form']->alias ?? 'form';

        return $formAlias.studly_case(name_to_id($this->connectorField));
    }
}

--------------------------------------------------------------------------------

File: src\Http\Controllers\DiningAreas.php
Comments: Included
Mime Type: application/octet-stream
Size: 4933 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Controllers;

use Igniter\Admin\Classes\AdminController;
use Igniter\Admin\Facades\AdminMenu;
use Igniter\Admin\Http\Actions\FormController;
use Igniter\Admin\Http\Actions\ListController;
use Igniter\Flame\Exception\FlashException;
use Igniter\Local\Http\Actions\LocationAwareController;
use Igniter\Reservation\Http\Requests\DiningAreaRequest;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\DiningTable;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Event;

/**
 * Admin Controller Class Dining Areas
 */
class DiningAreas extends AdminController
{
    public array $implement = [
        ListController::class,
        FormController::class,
        LocationAwareController::class,
    ];

    public array $listConfig = [
        'list' => [
            'model' => DiningArea::class,
            'title' => 'lang:igniter.reservation::default.dining_areas.text_title',
            'emptyMessage' => 'lang:igniter.reservation::default.dining_areas.text_empty',
            'defaultSort' => ['created_at', 'DESC'],
            'configFile' => 'dining_area',
        ],
    ];

    public array $formConfig = [
        'name' => 'lang:igniter.reservation::default.dining_areas.text_form_name',
        'model' => DiningArea::class,
        'request' => DiningAreaRequest::class,
        'create' => [
            'title' => 'lang:admin::lang.form.create_title',
            'redirect' => 'dining_areas/edit/{id}',
            'redirectClose' => 'dining_areas',
            'redirectNew' => 'dining_areas/create',
        ],
        'edit' => [
            'title' => 'lang:admin::lang.form.edit_title',
            'redirect' => 'dining_areas/edit/{id}',
            'redirectClose' => 'dining_areas',
            'redirectNew' => 'dining_areas/create',
        ],
        'preview' => [
            'title' => 'lang:admin::lang.form.preview_title',
            'back' => 'dining_areas',
        ],
        'delete' => [
            'redirect' => 'dining_areas',
        ],
        'configFile' => 'dining_area',
    ];

    protected null|string|array $requiredPermissions = 'Admin.Tables';

    public static function getSlug(): string
    {
        return 'dining_areas';
    }

    public function __construct()
    {
        parent::__construct();

        AdminMenu::setContext('dining_areas', 'restaurant');
    }

    public function edit(string $context, ?string $recordId): void
    {
        Event::listen('admin.form.extendFields', function($form, $fields) use ($recordId): void {
            if (isset($fields['dining_area_id']) && !$fields['dining_area_id']->value) {
                $fields['dining_area_id']->value = $recordId;
            }

            $formModel = $this->asExtension('FormController')->getFormModel();
            if ($form->model instanceof DiningSection && isset($fields['location_id']) && !$fields['location_id']->value) {
                $fields['location_id']->value = $formModel->location_id;
            }
        });

        $this->asExtension('FormController')->edit($context, $recordId);
    }

    public function index_onDuplicate($context): RedirectResponse
    {
        $model = $this->asExtension('FormController')->formFindModelObject(post('id'));

        $duplicate = $model->duplicate();

        flash()->success(sprintf(lang('admin::lang.alert_success'), 'Dining area duplicated'));

        return $this->redirect('dining_areas/edit/'.$duplicate->getKey());
    }

    public function edit_onCreateCombo($context, $recordId): RedirectResponse
    {
        $checked = (array)post('DiningArea._select_dining_tables', []);
        throw_if(!$checked || count($checked) < 2,
            new FlashException(lang('igniter.reservation::default.dining_areas.alert_tables_not_checked')),
        );

        $model = $this->asExtension('FormController')->formFindModelObject($recordId);

        $checkedTables = $model->dining_tables()->whereIn('id', $checked)->get();

        $model->createCombo($checkedTables);

        flash()->success(sprintf(lang('admin::lang.alert_success'), 'Table combo created'));

        return $this->redirectBack();
    }

    public function listExtendQuery($query): void
    {
        $query->with(['available_tables', 'dining_sections']);
    }

    public function formExtendFields($form): void
    {
        if ($form->context != 'create') {
            $form->getField('location_id')->disabled = true;
        }
    }

    public function formBeforeSave($model): void
    {
        $diningTable = resolve(DiningTable::class);
        if ($diningTable->isBroken()) {
            $diningTable->fixBrokenTreeQuietly();
        }
    }
}

--------------------------------------------------------------------------------

File: src\Http\Controllers\Reservations.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 8668 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Controllers;

use Carbon\Carbon;
use DateInterval;
use DatePeriod;
use Igniter\Admin\Classes\AdminController;
use Igniter\Admin\Facades\AdminMenu;
use Igniter\Admin\Http\Actions\CalendarController;
use Igniter\Admin\Http\Actions\FormController;
use Igniter\Admin\Http\Actions\ListController;
use Igniter\Admin\Models\Status;
use Igniter\Admin\Widgets\Filter;
use Igniter\Flame\Exception\FlashException;
use Igniter\Local\Facades\Location as LocationFacade;
use Igniter\Local\Http\Actions\LocationAwareController;
use Igniter\Reservation\Http\Requests\ReservationRequest;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\Reservation;
use Igniter\User\Http\Actions\AssigneeController;
use Illuminate\Http\RedirectResponse;

class Reservations extends AdminController
{
    public array $implement = [
        ListController::class,
        CalendarController::class,
        FormController::class,
        AssigneeController::class,
        LocationAwareController::class,
    ];

    public array $listConfig = [
        'list' => [
            'model' => Reservation::class,
            'title' => 'lang:igniter.reservation::default.text_title',
            'emptyMessage' => 'lang:igniter.reservation::default.text_empty',
            'defaultSort' => ['reservation_id', 'DESC'],
            'configFile' => 'reservation',
        ],
        'floor_plan' => [
            'model' => Reservation::class,
            'title' => 'lang:igniter.reservation::default.text_title',
            'emptyMessage' => 'lang:igniter.reservation::default.text_empty',
            'defaultSort' => ['reservation_id', 'DESC'],
            'showCheckboxes' => false,
            'showSetup' => false,
            'configFile' => 'floor_plan',
        ],
    ];

    public $calendarConfig = [
        'calender' => [
            'title' => 'lang:igniter.reservation::default.text_title',
            'emptyMessage' => 'lang:igniter.reservation::default.text_no_booking',
            'popoverPartial' => 'reservations/form/calendar_popover',
            'configFile' => 'reservation',
        ],
    ];

    public array $formConfig = [
        'name' => 'lang:igniter.reservation::default.text_form_name',
        'model' => Reservation::class,
        'request' => ReservationRequest::class,
        'create' => [
            'title' => 'lang:igniter::admin.form.create_title',
            'redirect' => 'reservations/edit/{reservation_id}',
            'redirectClose' => 'reservations',
            'redirectNew' => 'reservations/create',
        ],
        'edit' => [
            'title' => 'lang:igniter::admin.form.edit_title',
            'redirect' => 'reservations/edit/{reservation_id}',
            'redirectClose' => 'reservations',
            'redirectNew' => 'reservations/create',
        ],
        'preview' => [
            'title' => 'lang:igniter::admin.form.preview_title',
            'back' => 'reservations',
        ],
        'delete' => [
            'redirect' => 'reservations',
        ],
        'configFile' => 'reservation',
    ];

    protected null|string|array $requiredPermissions = [
        'Admin.Reservations',
        'Admin.AssignReservations',
        'Admin.DeleteReservations',
    ];

    public static function getSlug(): string
    {
        return 'reservations';
    }

    public function __construct()
    {
        parent::__construct();

        AdminMenu::setContext('reservations', 'sales');
    }

    public function index(): void
    {
        $this->asExtension('ListController')->index();

        $this->vars['statusesOptions'] = Status::getDropdownOptionsForReservation();
    }

    public function floor_plan(): void
    {
        $this->defaultView = 'floor_plan';

        $this->addJs('https://unpkg.com/konva@8.3.12/konva.min.js', 'konva-js');
        $this->addCss('igniter.reservation::/css/floorplanner.css', 'floorplanner-css');
        $this->addJs('igniter.reservation::/js/floorplanner.js', 'floorplanner-js');

        $this->asExtension('ListController')->index();

        $this->vars['statusesOptions'] = Status::getDropdownOptionsForReservation();
    }

    public function index_onDelete()
    {
        throw_unless($this->authorize('Admin.DeleteReservations'),
            new FlashException(lang('igniter::admin.alert_user_restricted')),
        );

        return $this->asExtension(ListController::class)->index_onDelete();
    }

    public function onUpdateStatus(): ?RedirectResponse
    {
        $recordId = (int)post('recordId');
        $statusId = (int)post('statusId');
        if (!$recordId || !$statusId) {
            return null;
        }

        /** @var Reservation $model */
        throw_unless($model = Reservation::query()->find($recordId),
            new FlashException(lang('igniter.reservation::default.alert_no_reservation_found')),
        );

        /** @var Status $status */
        throw_unless($status = Status::query()->find($statusId),
            new FlashException(lang('igniter.reservation::default.alert_no_status_found')),
        );

        $model->addStatusHistory($status);

        flash()->success(sprintf(lang('igniter::admin.alert_success'), lang('igniter::admin.statuses.text_form_name').' updated'))->now();

        return $this->redirectBack();
    }

    public function edit_onDelete(?string $context = null, mixed $recordId = null)
    {
        throw_unless($this->authorize('Admin.DeleteReservations'),
            new FlashException(lang('igniter::admin.alert_user_restricted')),
        );

        return $this->asExtension(FormController::class)->edit_onDelete($context, $recordId);
    }

    public function calendarGenerateEvents($startAt, $endAt)
    {
        return Reservation::listCalendarEvents(
            $startAt, $endAt, LocationFacade::getId(),
        );
    }

    public function calendarUpdateEvent($eventId, $startAt, $endAt): void
    {
        /** @
--------------------------------------------------------------------------------

File: src\Http\Requests\BookingSettingsRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2194 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class BookingSettingsRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'is_enabled' => lang('igniter.reservation::default.offer_reservation'),
            'limit_guests' => lang('igniter.reservation::default.label_limit_guests'),
            'limit_guests_count' => lang('igniter.reservation::default.label_limit_guests_count'),
            'time_interval' => lang('igniter.reservation::default.label_reservation_time_interval'),
            'stay_time' => lang('igniter.reservation::default.reservation_stay_time'),
            'auto_allocate_table' => lang('igniter.reservation::default.label_auto_allocate_table'),
            'min_guest_count' => lang('igniter.reservation::default.label_min_reservation_guest_num'),
            'max_guest_count' => lang('igniter.reservation::default.label_max_reservation_guest_num'),
            'min_advance_time' => lang('igniter.reservation::default.label_min_reservation_advance_time'),
            'max_advance_time' => lang('igniter.reservation::default.label_max_reservation_advance_time'),
            'cancellation_timeout' => lang('igniter.reservation::default.label_reservation_cancellation_timeout'),
        ];
    }

    public function rules(): array
    {
        return [
            'is_enabled' => ['boolean'],
            'limit_guests' => ['boolean'],
            'limit_guests_count' => ['integer', 'min:1', 'max:999'],
            'time_interval' => ['min:5', 'integer'],
            'stay_time' => ['min:5', 'integer'],
            'auto_allocate_table' => ['integer'],
            'min_guest_count' => ['nullable', 'integer', 'min:0', 'max:999'],
            'max_guest_count' => ['nullable', 'integer', 'min:0', 'max:999'],
            'min_advance_time' => ['nullable', 'integer', 'min:0', 'max:999'],
            'max_advance_time' => ['nullable', 'integer', 'min:0', 'max:999'],
            'cancellation_timeout' => ['nullable', 'integer', 'min:0', 'max:999'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Http\Requests\DiningAreaRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 527 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class DiningAreaRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'name' => lang('igniter::admin.label_name'),
        ];
    }

    public function rules(): array
    {
        return [
            'name' => ['required', 'between:2,128'],
            'location_id' => ['required'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Http\Requests\DiningSectionRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1065 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class DiningSectionRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'location_id' => lang('igniter::admin.label_location'),
            'name' => lang('igniter::admin.label_name'),
            'priority' => lang('igniter.reservation::default.dining_tables.label_priority'),
            'description' => lang('igniter::admin.label_description'),
            'is_enabled' => lang('igniter.reservation::default.dining_tables.label_is_enabled'),
        ];
    }

    public function rules(): array
    {
        return [
            'location_id' => ['required', 'integer'],
            'name' => ['required', 'string'],
            'priority' => ['required', 'integer'],
            'description' => ['string'],
            'is_enabled' => ['is_enabled', 'boolean'],
            'color' => ['nullable', 'string'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Http\Requests\DiningTableRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1749 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class DiningTableRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'name' => lang('igniter::admin.label_name'),
            'shape' => lang('igniter.reservation::default.dining_tables.label_table_shape'),
            'min_capacity' => lang('igniter.reservation::default.tables.label_min_capacity'),
            'max_capacity' => lang('igniter.reservation::default.tables.label_capacity'),
            'extra_capacity' => lang('igniter.reservation::default.tables.label_extra_capacity'),
            'priority' => lang('igniter.reservation::default.tables.label_priority'),
            'is_enabled' => lang('igniter::admin.label_status'),
            'dining_area_id' => lang('igniter.reservation::default.dining_tables.label_dining_areas'),
            'dining_section_id' => lang('igniter.reservation::default.dining_tables.column_section'),
        ];
    }

    public function rules(): array
    {
        return [
            'name' => ['required', 'string', 'between:2,255'],
            'shape' => ['required', 'in:rectangle,round'],
            'min_capacity' => ['required', 'integer', 'min:1', 'lte:max_capacity'],
            'max_capacity' => ['required', 'integer', 'min:1', 'gte:min_capacity'],
            'extra_capacity' => ['sometimes', 'integer'],
            'priority' => ['sometimes', 'integer'],
            'is_enabled' => ['sometimes', 'boolean'],
            'dining_area_id' => ['required', 'integer'],
            'dining_section_id' => ['nullable', 'integer'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Http\Requests\ReservationRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1973 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class ReservationRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'location_id' => lang('igniter.reservation::default.text_restaurant'),
            'first_name' => lang('igniter.reservation::default.label_first_name'),
            'last_name' => lang('igniter.reservation::default.label_last_name'),
            'email' => lang('igniter::admin.label_email'),
            'telephone' => lang('igniter.reservation::default.label_customer_telephone'),
            'reserve_date' => lang('igniter.reservation::default.label_reservation_date'),
            'reserve_time' => lang('igniter.reservation::default.label_reservation_time'),
            'guest_num' => lang('igniter.reservation::default.label_guest'),
            'comment' => lang('igniter.reservation::default.column_comment'),
        ];
    }

    public function rules(): array
    {
        return [
            'location_id' => ['sometimes', 'required', 'integer'],
            'customer_id' => ['nullable', 'integer'],
            'first_name' => ['required_without:customer_id', 'nullable', 'string', 'between:1,48'],
            'last_name' => ['required_without:customer_id', 'nullable', 'string', 'between:1,48'],
            'email' => ['required_without:customer_id', 'nullable', 'email:filter', 'max:96'],
            'telephone' => ['required_without:customer_id', 'nullable', 'sometimes', 'string'],
            'reserve_date' => ['required', 'date_format:Y-m-d'],
            'reserve_time' => ['required', 'date_format:H:i'],
            'guest_num' => ['required', 'integer'],
            'duration' => ['nullable', 'integer', 'min:0'],
            'tables' => ['nullable', 'array'],
            'comment' => ['nullable', 'string'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Http\Requests\ReservationSettingsRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1008 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class ReservationSettingsRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'default_reservation_status' => lang('igniter.reservation::default.label_default_reservation_status'),
            'confirmed_reservation_status' => lang('igniter.reservation::default.label_confirmed_reservation_status'),
            'canceled_reservation_status' => lang('igniter.reservation::default.label_canceled_reservation_status'),
        ];
    }

    public function rules(): array
    {
        return [
            'reservation_email.*' => ['required', 'alpha'],
            'default_reservation_status' => ['required', 'integer'],
            'confirmed_reservation_status' => ['required', 'integer'],
            'canceled_reservation_status' => ['required', 'integer'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Http\Requests\ReservationStatusRequest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1146 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Http\Requests;

use Igniter\System\Classes\FormRequest;
use Override;

class ReservationStatusRequest extends FormRequest
{
    #[Override]
    public function attributes()
    {
        return [
            'status_id' => lang('igniter::admin.label_status'),
            'comment' => lang('igniter::admin.statuses.label_comment'),
            'notify' => lang('igniter::admin.statuses.label_notify'),

            'assignee_group_id' => lang('igniter::admin.statuses.label_assignee_group'),
            'assignee_id' => lang('igniter::admin.statuses.label_assignee'),
        ];
    }

    public function rules(): array
    {
        return [
            'status_id' => ['sometimes', 'required', 'integer', 'exists:statuses'],
            'comment' => ['string', 'max:1500'],
            'notify' => ['sometimes', 'required', 'boolean'],

            'assignee_group_id' => ['sometimes', 'required', 'integer', 'exists:admin_user_groups,user_group_id'],
            'assignee_id' => ['integer', 'exists:admin_users,user_id'],
        ];
    }
}

--------------------------------------------------------------------------------

File: src\Listeners\AddsCustomerReservationsTabFields.php
Comments: Included
Mime Type: application/octet-stream
Size: 1626 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Listeners;

use Igniter\Admin\Widgets\Form;
use Igniter\User\Models\Customer;

class AddsCustomerReservationsTabFields
{
    public function __invoke(Form $form): void
    {
        if (!$form->model instanceof Customer) {
            return;
        }

        $form->addTabFields([
            'reservations' => [
                'tab' => 'lang:igniter.reservation::default.text_tab_reservations',
                'type' => 'datatable',
                'context' => ['edit', 'preview'],
                'useAjax' => true,
                'defaultSort' => ['reservation_id', 'desc'],
                'columns' => [
                    'reservation_id' => [
                        'title' => lang('igniter::admin.column_id'),
                    ],
                    'customer_name' => [
                        'title' => lang('igniter::admin.label_name'),
                    ],
                    'status_name' => [
                        'title' => lang('igniter::admin.label_status'),
                    ],
                    'table_name' => [
                        'title' => lang('igniter.reservation::default.column_table'),
                    ],
                    'reserve_time' => [
                        'title' => lang('igniter.reservation::default.column_time'),
                    ],
                    'reserve_date' => [
                        'title' => lang('igniter.reservation::default.column_date'),
                    ],
                ],
            ],
        ]);
    }
}

--------------------------------------------------------------------------------

File: src\Listeners\MaxGuestSizePerTimeslotReached.php
Comments: Included
Mime Type: application/octet-stream
Size: 1979 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Listeners;

use Carbon\Carbon;
use DateTimeInterface;
use Igniter\Local\Facades\Location as LocationFacade;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Reservation;

class MaxGuestSizePerTimeslotReached
{
    protected static $reservationsCache = [];

    public function handle(DateTimeInterface $timeslot, int|string $guestNum): ?bool
    {
        /** @var Location $locationModel */
        $locationModel = LocationFacade::current();
        if (!(bool)$locationModel->getSettings('booking.limit_guests')) {
            return null;
        }

        if (($limitCount = (int)$locationModel->getSettings('booking.limit_guests_count', 20)) === 0) {
            return null;
        }

        $totalGuestNumOnThisDay = $this->getGuestNum($timeslot);
        if (!$totalGuestNumOnThisDay) {
            return null;
        }

        return ($totalGuestNumOnThisDay + $guestNum) > $limitCount || $totalGuestNumOnThisDay >= $limitCount;
    }

    protected function getGuestNum(DateTimeInterface $timeslot)
    {
        $dateTime = Carbon::parse($timeslot)->toDateTimeString();

        if (array_has(self::$reservationsCache, $dateTime)) {
            return self::$reservationsCache[$dateTime];
        }

        $startTime = Carbon::parse($timeslot)->subMinutes(2);
        $endTime = Carbon::parse($timeslot)->addMinutes(2);

        $guestNum = Reservation::query()
            ->where('location_id', LocationFacade::getId())
            ->where('status_id', '!=', setting('canceled_reservation_status'))
            ->whereBetweenReservationDateTime($startTime->toDateTimeString(), $endTime->toDateTimeString())
            ->sum('guest_num');

        return self::$reservationsCache[$dateTime] = (int)$guestNum;
    }

    public function clearInternalCache(): void
    {
        self::$reservationsCache = [];
    }
}

--------------------------------------------------------------------------------

File: src\Listeners\RegistersDashboardCards.php
Comments: Included
Mime Type: application/octet-stream
Size: 3343 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Listeners;

use Igniter\Reservation\Models\Reservation;
use Igniter\System\Models\Settings;

class RegistersDashboardCards
{
    public function __invoke(): array
    {
        return [
            'reserved_table' => [
                'label' => 'lang:igniter.reservation::default.text_total_reserved_table',
                'icon' => ' text-primary fa fa-4x fa-table',
                'valueFrom' => $this->getValue(...),
            ],
            'reserved_guest' => [
                'label' => 'lang:igniter.reservation::default.text_total_reserved_guest',
                'icon' => ' text-primary fa fa-4x fa-table',
                'valueFrom' => $this->getValue(...),
            ],
            'reservation' => [
                'label' => 'lang:igniter.reservation::default.text_total_reservation',
                'icon' => ' text-success fa fa-4x fa-table',
                'valueFrom' => $this->getValue(...),
            ],
            'completed_reservation' => [
                'label' => 'lang:igniter.reservation::default.text_total_completed_reservation',
                'icon' => ' text-success fa fa-4x fa-table',
                'valueFrom' => $this->getValue(...),
            ],
        ];
    }

    public function getValue($code, $start, $end, callable $callback): int
    {
        return match ($code) {
            'reserved_table' => $this->getTotalReservedTableSum($callback),
            'reserved_guest' => $this->getTotalReservedGuestSum($callback),
            'reservation' => $this->getTotalReservationSum($callback),
            'completed_reservation' => $this->getTotalCompletedReservationSum($callback),
            default => 0,
        };
    }

    /**
     * Return the total number of reserved tables
     */
    protected function getTotalReservedTableSum(callable $callback): int
    {
        $query = Reservation::query()
            ->with('tables')
            ->where('status_id', Settings::get('confirmed_reservation_status'));

        $callback($query);

        $result = $query->get();

        $result->pluck('tables')->flatten();

        return $result->count();
    }

    /**
     * Return the total number of reserved table guests
     */
    protected function getTotalReservedGuestSum(callable $callback): int
    {
        $query = Reservation::query();
        $query->where('status_id', Settings::get('confirmed_reservation_status'));

        $callback($query);

        return (int)$query->sum('guest_num');
    }

    /**
     * Return the total number of reservations
     */
    protected function getTotalReservationSum(callable $callback): int
    {
        $query = Reservation::query();
        $query->where('status_id', '!=', Settings::get('canceled_reservation_status'));

        $callback($query);

        return $query->count();
    }

    /**
     * Return the total number of completed reservations
     */
    protected function getTotalCompletedReservationSum(callable $callback): int
    {
        $query = Reservation::query();
        $query->where('status_id', Settings::get('confirmed_reservation_status'));

        $callback($query);

        return $query->count();
    }
}

--------------------------------------------------------------------------------

File: src\Listeners\SendReservationConfirmation.php
Comments: Included
Mime Type: application/octet-stream
Size: 638 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Listeners;

use Igniter\Reservation\Models\Reservation;
use Igniter\Reservation\Notifications\ReservationCreatedNotification;

class SendReservationConfirmation
{
    public function handle(Reservation $model): void
    {
        ReservationCreatedNotification::make()->subject($model)->broadcast();

        $model->mailSend('igniter.reservation::mail.reservation', 'customer');
        $model->mailSend('igniter.reservation::mail.reservation_alert', 'location');
        $model->mailSend('igniter.reservation::mail.reservation_alert', 'admin');
    }
}

--------------------------------------------------------------------------------

File: src\Models\Concerns\LocationAction.php
Comments: Included
Mime Type: application/octet-stream
Size: 1598 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models\Concerns;

use Igniter\Local\Models\Location;
use Igniter\System\Actions\ModelAction;

/**
 * LocationAction Trait
 *
 * @property Location $model
 */
class LocationAction extends ModelAction
{
    public function getReservationInterval(): int
    {
        return (int)$this->model->getSettings('booking.time_interval', 0);
    }

    public function getReservationLeadTime(): int
    {
        return $this->getReservationStayTime();
    }

    public function getReservationStayTime(): int
    {
        return (int)$this->model->getSettings('booking.stay_time', 0);
    }

    public function getMinReservationGuestCount(): int
    {
        return (int)$this->model->getSettings('booking.min_guest_count', 2);
    }

    public function getMaxReservationGuestCount(): int
    {
        return (int)$this->model->getSettings('booking.max_guest_count', 20);
    }

    public function getMinReservationAdvanceTime(): int
    {
        return (int)$this->model->getSettings('booking.min_advance_time', 2);
    }

    public function getMaxReservationAdvanceTime(): int
    {
        return (int)$this->model->getSettings('booking.max_advance_time', 30);
    }

    public function getReservationCancellationTimeout(): int
    {
        return (int)$this->model->getSettings('booking.cancellation_timeout', 0);
    }

    public function shouldAutoAllocateTable(): bool
    {
        return (bool)$this->model->getSettings('booking.auto_allocate_table', 0);
    }
}

--------------------------------------------------------------------------------

File: src\Models\DiningArea.php
Comments: Included
Mime Type: application/octet-stream
Size: 5657 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models;

use Igniter\Flame\Database\Builder;
use Igniter\Flame\Database\Factories\HasFactory;
use Igniter\Flame\Database\Model;
use Igniter\Flame\Database\Relations\BelongsTo;
use Igniter\Flame\Database\Relations\HasMany;
use Igniter\Flame\Exception\FlashException;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Illuminate\Support\Carbon;
use Illuminate\Support\Collection;

/**
 * DiningArea Model Class
 *
 * @property int $id
 * @property int $location_id
 * @property string $name
 * @property string|null $description
 * @property array|null $floor_plan
 * @property Carbon|null $created_at
 * @property Carbon|null $updated_at
 * @property-read mixed $dining_table_count
 * @property-read Location $location
 * @property-read Collection<int, DiningSection> $dining_sections
 * @property-read Collection<int, DiningTable> $dining_tables
 * @property-read Collection<int, DiningTable> $dining_table_solos
 * @property-read Collection<int, DiningTable> $dining_table_combos
 * @property-read Collection<int, DiningTable> $available_tables
 * @method static Builder<static>|DiningArea query()
 * @method static Builder<static>|DiningArea dropdown(string $column, string $key = null)
 * @method static BelongsTo<static>|DiningArea location()
 * @method static HasMany<static>|DiningArea dining_sections()
 * @method static HasMany<static>|DiningArea dining_tables()
 * @method static HasMany<static>|DiningArea dining_table_solos()
 * @method static HasMany<static>|DiningArea dining_table_combos()
 * @method static HasMany<static>|DiningArea available_tables()
 * @mixin Model
 */
class DiningArea extends Model
{
    use HasFactory;
    use Locationable;

    public $table = 'dining_areas';

    public $timestamps = true;

    protected $casts = [
        'floor_plan' => 'array',
    ];

    /**
     * @var array Relations
     */
    public $relation = [
        'hasMany' => [
            'dining_sections' => [DiningSection::class, 'foreignKey' => 'location_id', 'otherKey' => 'location_id'],
            'dining_tables' => [DiningTable::class, 'delete' => true],
            'dining_table_solos' => [DiningTable::class, 'scope' => 'whereIsNotCombo'],
            'dining_table_combos' => [DiningTable::class, 'scope' => 'whereIsCombo'],
            'available_tables' => [DiningTable::class, 'scope' => 'whereIsRoot'],
        ],
        'belongsTo' => [
            'location' => [Location::class],
        ],
    ];

    public static function getDropdownOptions()
    {
        return static::dropdown('name');
    }

    public function getTablesForFloorPlan()
    {
        return $this->available_tables->map(fn(DiningTable $diningTable, int $key) => $diningTable->toFloorPlanArray());
    }

    public function getDiningTablesWithReservation($reservations)
    {
        return $this->available_tables
            ->map(function(DiningTable $diningTable) use ($reservations) {
                $reservation = $reservations->first(fn(Reservation $reservation): bool => $reservation->tables->where('id', $diningTable->id)->count() > 0);

                return $diningTable->toFloorPlanArray($reservation);
            });
    }

    //
    // Events
    //

    //
    // Accessors & Mutators
    //

    public function getDiningTableCountAttribute($value): int
    {
        return $this->available_tables->count();
    }

    //
    // Helpers
    //

    public function duplicate()
    {
        /** @var DiningTable $newDiningArea */
        $newDiningArea = $this->replicate();
        $newDiningArea->name .= ' (copy)';
        $newDiningArea->save();

        $this->dining_tables
            ->filter(fn(DiningTable $table): bool => !$table->is_combo)
            ->each(function(DiningTable $table) use ($newDiningArea): void {
                /** @var DiningTable $newTable */
                $newTable = $table->replicate();
                $newTable->dining_area_id = $newDiningArea->getKey();
                $newTable->save();
            });

        return $newDiningArea;
    }

    public function createCombo(Collection $tables)
    {
        /** @var DiningTable $firstTable */
        $firstTable = $tables->first();
        $tableNames = $tables->pluck('name')->join('/');

        if ($tables->filter(fn(DiningTable $table): bool => $table->parent !== null)->isNotEmpty()) {
            throw new FlashException(lang('igniter.reservation::default.dining_areas.alert_table_already_combined'));
        }

        if ($tables->pluck('dining_section_id')->unique()->count() > 1) {
            throw new FlashException(lang('igniter.reservation::default.dining_areas.alert_table_combo_section_mismatch'));
        }

        /** @var DiningTable $comboTable */
        $comboTable = $this->dining_tables()->create([
            'name' => $tableNames,
            'shape' => $firstTable->shape,
            'dining_area_id' => $firstTable->dining_area_id,
            'dining_section_id' => $firstTable->dining_section_id,
            'min_capacity' => $tables->sum('min_capacity'),
            'max_capacity' => $tables->sum('max_capacity'),
            'is_combo' => true,
            'is_enabled' => true,
        ]);

        $tables->each(function($table) use ($comboTable): void {
            $table->parent()->associate($comboTable)->saveQuietly();
        });

        $comboTable->fixBrokenTreeQuietly();

        return $comboTable;
    }
}

--------------------------------------------------------------------------------

File: src\Models\DiningSection.php
Comments: Included
Mime Type: application/octet-stream
Size: 2280 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models;

use Igniter\Flame\Database\Builder;
use Igniter\Flame\Database\Factories\HasFactory;
use Igniter\Flame\Database\Model;
use Igniter\Flame\Database\Relations\BelongsTo;
use Igniter\Flame\Database\Relations\HasMany;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Illuminate\Support\Collection;

/**
 * DiningSection Model Class
 *
 * @property int $id
 * @property int $location_id
 * @property string $name
 * @property string|null $description
 * @property string|null $color
 * @property int $priority
 * @property int $is_enabled
 * @property string|null $created_at
 * @property string|null $updated_at
 * @property-read Location $location
 * @property-read Collection<int, DiningArea> $dining_areas
 * @method static Builder<static>|DiningSection query()
 * @method static Builder<static>|DiningSection dropdown(string $column, string $key = null)
 * @method static BelongsTo<static>|DiningSection location()
 * @method static HasMany<static>|DiningSection dining_areas()
 * @method static Builder<static>|DiningSection whereHasLocation(int|string|Model $locationId)
 * @method static Builder<static>|DiningSection whereIsReservable()
 * @mixin Model
 */
class DiningSection extends Model
{
    use HasFactory;
    use Locationable;

    public $table = 'dining_sections';

    /**
     * @var array Relations
     */
    public $relation = [
        'belongsTo' => [
            'location' => [Location::class],
        ],
        'hasMany' => [
            'dining_areas' => [DiningArea::class, 'foreignKey' => 'location_id', 'otherKey' => 'location_id'],
        ],
    ];

    public function getRecordEditorOptions(DiningArea $diningArea)
    {
        return self::query()
            ->whereHasLocation($diningArea->location_id)
            ->dropdown('name');
    }

    public function getPriorityOptions()
    {
        return collect(range(0, 9))->map(fn($priority): string => lang('igniter.reservation::default.dining_tables.text_priority_'.$priority))->all();
    }

    public function scopeWhereIsReservable($query)
    {
        return $query->where('is_enabled', 1);
    }
}

--------------------------------------------------------------------------------

File: src\Models\DiningTable.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6138 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models;

use Igniter\Flame\Database\Builder;
use Igniter\Flame\Database\Factories\HasFactory;
use Igniter\Flame\Database\Model;
use Igniter\Flame\Database\Relations\BelongsTo;
use Igniter\Flame\Database\Relations\BelongsToMany;
use Igniter\Flame\Database\Relations\HasOneThrough;
use Igniter\Flame\Database\Traits\NestedTree;
use Igniter\Flame\Database\Traits\Sortable;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Illuminate\Support\Carbon;
use Illuminate\Support\Collection;
use Kalnoy\Nestedset\Collection as NestedSetCollection;

/**
 * DiningTable Model Class
 *
 * @property int $id
 * @property int $dining_area_id
 * @property int|null $dining_section_id
 * @property int|null $parent_id
 * @property string $name
 * @property string|null $shape
 * @property int $min_capacity
 * @property int $max_capacity
 * @property int $extra_capacity
 * @property bool $is_combo
 * @property bool $is_enabled
 * @property int|null $nest_left
 * @property int|null $nest_right
 * @property int $priority
 * @property array|null $seat_layout
 * @property Carbon|null $created_at
 * @property Carbon|null $updated_at
 * @property-read NestedSetCollection<int, DiningTable> $children
 * @property-read int|null $children_count
 * @property-read mixed $section_name
 * @property-read DiningTable|null $parent
 * @property-read Location|null $location
 * @property-read DiningArea|null $dining_area
 * @property-read DiningSection|null $dining_section
 * @property-read Collection<int, Reservation> $reservations
 * @method static Collection<int, DiningTable> descendants()
 * @method static Builder<static>|DiningTable sync($relations, $deleting = true)
 * @method static Builder<static>|DiningTable query()
 * @method static HasOneThrough<static>|DiningTable location()
 * @method static BelongsTo<static>|DiningTable dining_area()
 * @method static BelongsTo<static>|DiningTable dining_section()
 * @method static BelongsToMany<static>|DiningTable reservations()
 * @method static Builder<static>|DiningTable whereIsReservable()
 * @method static Builder<static>|DiningTable whereIsAvailableOn($dateTime, $duration)
 * @method static Builder<static>|DiningTable whereIsAvailableForDate($date)
 * @method static Builder<static>|DiningTable whereIsAvailableAt($locationId)
 * @method static Builder<static>|DiningTable whereCanAccommodate($guestNumber)
 * @method static Builder<static>|DiningTable whereIsRoot()
 * @method static Builder<static>|DiningTable whereHasLocation(int|string|Model $locationId)
 * @method static Builder<static>|DiningTable reservable(array $options)
 * @mixin Model
 */
class DiningTable extends Model
{
    use HasFactory;
    use Locationable;
    use NestedTree;
    use Sortable;

    public const string SORT_ORDER = 'priority';

    public $table = 'dining_tables';

    public $timestamps = true;

    protected $casts = [
        'min_capacity' => 'integer',
        'max_capacity' => 'integer',
        'extra_capacity' => 'integer',
        'priority' => 'integer',
        'is_combo' => 'boolean',
        'is_enabled' => 'boolean',
        'seat_layout' => 'array',
    ];

    /**
     * @var array Relations
     */
    public $relation = [
        'belongsTo' => [
            'dining_area' => [DiningArea::class],
            'dining_section' => [DiningSection::class],
        ],
        'belongsToMany' => [
            'reservations' => [Reservation::class, 'table' => 'reservation_tables', 'otherKey' => 'reservation_id'],
        ],
        'hasOneThrough' => [
            'location' => [
                Location::class,
                'through' => DiningArea::class,
                'foreignKey' => 'id',
                'throughKey' => 'location_id',
                'otherKey' => 'dining_area_id',
                'secondOtherKey' => 'location_id',
            ],
        ],
    ];

    public $attributes = [
        'priority' => 0,
        'extra_capacity' => 0,
    ];

    public function getDiningSectionIdOptions()
    {
        return $this->exists
            ? DiningSection::query()
                ->whereHasLocation($this->dining_area?->location_id)
                ->dropdown('name')
            : [];
    }

    public function getPriorityOptions()
    {
        return collect(range(0, 9))->map(fn($priority): string => lang('igniter.reservation::default.dining_tables.text_priority_'.$priority))->all();
    }

    //
    // Accessors & Mutators
    //

    public function getSectionNameAttribute(): ?string
    {
        return $this->dining_section?->name;
    }

    public function getSummaryAttribute(): string
    {
        return sprintf(
            '%s / %s - %s (%s+)',
            $this->name,
            $this->min_capacity,
            $this->max_capacity,
            $this->extra_capacity,
        );
    }

    //
    // Helpers
    //

    public function sortWhenCreating(): bool
    {
        return false;
    }

    public function toFloorPlanArray($reservation = null)
    {
        $defaults = [
            'id' => $this->id,
            'name' => $this->name,
            'description' => $this->min_capacity.'-'.$this->max_capacity,
            'capacity' => $this->max_capacity,
            'shape' => $this->shape,
            'seatLayout' => $this->seat_layout,
            'tableColor' => null,
            'seatColor' => null,
            'customerName' => null,
        ];

        if (!is_null($reservation)) {
            $defaults['description'] = $reservation->reservation_datetime->isoFormat(lang('system::lang.moment.time_format'))
                .' - '.$reservation->reservation_end_datetime->isoFormat(lang('system::lang.moment.time_format'));

            $defaults['seatColor'] = $reservation->status->status_color ?? null;
            $defaults['customerName'] = $reservation->customer_name;
        }

        return $defaults;
    }
}

--------------------------------------------------------------------------------

File: src\Models\Observers\DiningTableObserver.php
Comments: Included
Mime Type: application/octet-stream
Size: 1280 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models\Observers;

use Igniter\Flame\Exception\SystemException;
use Igniter\Reservation\Models\DiningTable;

class DiningTableObserver
{
    public function saving(DiningTable $diningTable): void
    {
        if (!$diningTable->getRgt() || !$diningTable->getLft()) {
            $diningTable->fixTree();
        }
    }

    public function saved(DiningTable $diningTable): void
    {
        if (!is_null($diningTable->parent_id) && $diningTable->parent) {
            $diningTable->parent->name = $diningTable->parent->children->pluck('name')->join('/');
            $diningTable->parent->saveQuietly();
        }
    }

    public function deleting(DiningTable $diningTable): void
    {
        if (!is_null($diningTable->parent_id)) {
            throw new SystemException(lang('igniter.reservation::default.dining_tables.error_cannot_delete_has_parent'));
        }

        if ($diningTable->is_combo) {
            $diningTable->descendants()->each(function(DiningTable $descendant): void {
                $descendant->saveAsRoot();
            });

            (new DiningTable)->fixBrokenTreeQuietly();

            $diningTable->refreshNode();
        }
    }
}

--------------------------------------------------------------------------------

File: src\Models\Observers\ReservationObserver.php
Comments: Included
Mime Type: application/octet-stream
Size: 1435 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models\Observers;

use Igniter\Reservation\Models\Reservation;

class ReservationObserver
{
    public function creating(Reservation $reservation): void
    {
        if ($reservation->customer_id) {
            $reservation->first_name = $reservation->first_name ?: $reservation->customer->first_name;
            $reservation->last_name = $reservation->last_name ?: $reservation->customer->last_name;
            $reservation->email = $reservation->email ?: $reservation->customer->email;
            $reservation->telephone = $reservation->telephone ?: $reservation->customer->telephone;
        }

        $reservation->forceFill([
            'hash' => $reservation->generateHash(),
            'ip_address' => request()->getClientIp(),
            'user_agent' => request()->userAgent(),
        ]);
    }

    public function saved(Reservation $reservation): void
    {
        $reservation->restorePurgedValues();

        if (array_key_exists('tables', $attributes = $reservation->getAttributes())) {
            $reservation->addReservationTables((array)array_get($attributes, 'tables', []));
        }

        $reservation->reloadRelations('location');

        if ($reservation->location?->shouldAutoAllocateTable() && !$reservation->tables()->count()) {
            $reservation->autoAssignTable();
        }
    }
}

--------------------------------------------------------------------------------

File: src\Models\Reservation.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 18725 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models;

use Carbon\Carbon;
use Igniter\Admin\Models\Concerns\GeneratesHash;
use Igniter\Admin\Models\Concerns\LogsStatusHistory;
use Igniter\Admin\Models\Status;
use Igniter\Admin\Models\StatusHistory;
use Igniter\Flame\Database\Builder;
use Igniter\Flame\Database\Factories\HasFactory;
use Igniter\Flame\Database\Model;
use Igniter\Flame\Database\Relations\BelongsTo;
use Igniter\Flame\Database\Traits\Purgeable;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Igniter\Main\Classes\MainController;
use Igniter\Reservation\Events\ReservationCanceledEvent;
use Igniter\Reservation\Models\Concerns\LocationAction;
use Igniter\System\Models\Concerns\SendsMailTemplate;
use Igniter\User\Models\Concerns\Assignable;
use Igniter\User\Models\Concerns\HasCustomer;
use Igniter\User\Models\Customer;
use Illuminate\Contracts\Database\Eloquent\Builder as BuilderContract;
use Illuminate\Support\Collection;

/**
 * Reservation Model Class
 *
 * @property int $reservation_id
 * @property int $location_id
 * @property int $table_id
 * @property int $guest_num
 * @property int|null $occasion_id
 * @property int|null $customer_id
 * @property string $first_name
 * @property string $last_name
 * @property string $email
 * @property string $telephone
 * @property string|null $comment
 * @property mixed $reserve_time
 * @property Carbon|string $reserve_date
 * @property Carbon $created_at
 * @property Carbon $updated_at
 * @property int|null $assignee_id
 * @property int|null $assignee_group_id
 * @property bool|null $notify
 * @property string $ip_address
 * @property string $user_agent
 * @property int $status_id
 * @property string|null $hash
 * @property int|null $duration
 * @property bool|null $processed
 * @property \Illuminate\Support\Carbon|null $status_updated_at
 * @property \Illuminate\Support\Carbon|null $assignee_updated_at
 * @property-read mixed $customer_name
 * @property-read mixed $occasion
 * @property-read mixed $reservation_datetime
 * @property-read mixed $reservation_end_datetime
 * @property-read mixed $reserve_end_time
 * @property-read string|null $status_color
 * @property-read string|null $status_name
 * @property-read mixed $table_name
 * @property-read Customer|null $customer
 * @property-read Location|LocationAction|null $location
 * @property-read Status|null $status
 * @property-read Collection<int, DiningTable> $tables
 * @method static Builder<static>|Reservation query()
 * @method static Builder<static>|Reservation with(string|array $with)
 * @method static array pluckDates(string $column, string $keyFormat = 'Y-m', string $valueFormat = 'F Y')
 * @method static BelongsTo|Customer customer()
 * @method static BelongsTo|Location location()
 * @method static BelongsTo|Reservation status()
 * @method static BelongsTo|DiningTable tables()
 * @method static Builder<static>|Reservation whereHash($value)
 * @method static Builder<static>|Reservation whereBetween($column, $values, $boolean = 'and')
 * @method static Builder<static>|Reservation whereHasLocation(int|string|Model $locationId)
 * @method static Builder<static>|Reservation whereBetweenStayTime($dateTime)
 * @method static Builder|Reservation whereBetweenReservationDateTime(string $start, string $end)
 * @mixin Builder
 * @mixin Model
 */
class Reservation extends Model
{
    use Assignable;
    use GeneratesHash;
    use HasCustomer;
    use HasFactory;
    use Locationable;
    use LogsStatusHistory;
    use Purgeable;
    use SendsMailTemplate;

    /**
     * @var string The database table name
     */
    protected $table = 'reservations';

    /**
     * @var string The database table primary key
     */
    protected $primaryKey = 'reservation_id';

    public $timestamps = true;

    /**
     * The storage format of the model's date columns.
     *
     * @var string
     */
    protected $dateFormat = 'Y-m-d';

    protected $timeFormat = 'H:i';

    public $guarded = ['ip_address', 'user_agent', 'hash'];

    protected $casts = [
        'location_id' => 'integer',
        'table_id' => 'integer',
        'guest_num' => 'integer',
        'occasion_id' => 'integer',
        'assignee_id' => 'integer',
        'reserve_time' => 'time',
        'reserve_date' => 'date',
        'notify' => 'boolean',
        'duration' => 'integer',
        'processed' => 'boolean',
    ];

    public $relation = [
        'belongsTo' => [
            'customer' => Customer::class,
            'location' => Location::class,
        ],
        'belongsToMany' => [
            'tables' => [DiningTable::class, 'table' => 'reservation_tables'],
        ],
    ];

    protected $purgeable = ['tables'];

    public $appends = ['customer_name', 'duration', 'table_name', 'reservation_datetime', 'reservation_end_datetime'];

    protected $attributes = [
        'table_id' => 0,
        'status_id' => 0,
    ];

    protected array $queryModifierFilters = [
        'customer' => 'applyCustomer',
        'location' => 'whereHasLocation',
        'status' => 'whereStatus',
        'dateTimeFilter' => 'applyDateTimeFilter',
    ];

    protected array $queryModifierSorts = [
        'reservation_id asc', 'reservation_id desc',
        'reserve_date asc', 'reserve_date desc',
        'created_at asc', 'created_at desc',
    ];

    protected array $queryModifierSearchableFields = ['reservation_id', 'first_name', 'last_name', 'email', 'telephone'];

    //
    // Accessors & Mutators
    //

    public function getCustomerNameAttribute($value): string
    {
        return $this->first_name.' '.$this->last_name;
    }

    public function getDurationAttribute($value)
    {
        if (!is_null($value)) {
            return $value;
        }

        if (!$location = $this->location) {
            return $value;
        }

        return $location->getReservationStayTime();
    }

    public function getReserveEndTimeAttribute($value)
    {
        if 
--------------------------------------------------------------------------------

File: src\Models\Scopes\DiningTableScope.php
Comments: Included
Mime Type: application/octet-stream
Size: 4200 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models\Scopes;

use Igniter\Flame\Database\Scope;
use Igniter\Reservation\Models\DiningTable;
use Illuminate\Contracts\Database\Eloquent\Builder;

class DiningTableScope extends Scope
{
    public function addReservable()
    {
        return function(Builder|DiningTable $builder, $options): Builder|DiningTable {
            $builder->whereIsReservable();

            if ($dateTime = array_get($options, 'dateTime')) {
                // @phpstan-ignore-next-line arguments.count
                $builder->whereIsAvailableOn($dateTime, array_get($options, 'duration', 15));
            }

            if ($date = array_get($options, 'date')) {
                $builder->whereIsAvailableForDate($date);
            }

            if ($locationId = array_get($options, 'locationId')) {
                $builder->whereIsAvailableAt($locationId);
            }

            if ($guestNum = array_get($options, 'guestNum')) {
                $builder->whereCanAccommodate($guestNum);
            }

            $builder
                ->orderBy('dining_sections.priority', 'desc')
                ->orderBy('dining_tables.priority', 'desc');

            $builder->getModel()->fireEvent('model.extendDiningTableReservableQuery', [$builder, $options]);

            return $builder;
        };
    }

    public function addWhereIsReservable()
    {
        return fn(Builder|DiningTable $builder) => $builder
            ->whereIsRoot()
            ->where('dining_tables.is_enabled', 1)
            ->leftJoin('dining_sections', function($join): void {
                $join->on('dining_sections.id', '=', 'dining_tables.dining_section_id')
                    ->where('dining_sections.is_enabled', 1);
            });
    }

    public function addWhereIsCombo()
    {
        return fn(Builder|DiningTable $builder) => $builder->where('is_combo', 1);
    }

    public function addWhereIsNotCombo()
    {
        return fn(Builder|DiningTable $builder) => $builder->where('is_combo', '!=', 1);
    }

    public function addWhereIsAvailableAt()
    {
        return fn(Builder|DiningTable $builder, $locationId) => $builder->join('dining_areas', function($join) use ($locationId): void {
            $join->on('dining_areas.id', '=', 'dining_tables.dining_area_id')
                ->where('dining_areas.location_id', $locationId);
        });
    }

    public function addWhereIsAvailableForDate()
    {
        return fn(Builder|DiningTable $builder, $date) => $builder->whereDoesntHave('reservations', function($builder) use ($date): void {
            $builder->where('reserve_date', $date)
                ->whereNotIn('status_id', [0, setting('canceled_reservation_status')]);
        });
    }

    public function addWhereIsAvailableOn()
    {
        return function(Builder|DiningTable $builder, $dateTime, $duration = 15) {
            if (is_string($dateTime)) {
                $dateTime = make_carbon($dateTime);
            }

            return $builder->whereDoesntHave('reservations', function($builder) use ($dateTime, $duration): void {
                $builder
                    ->where(function($builder) use ($dateTime): void {
                        $builder->whereBetweenStayTime($dateTime->clone()->addMinute());
                    })
                    ->orWhere(function($builder) use ($dateTime, $duration): void {
                        $builder->whereBetweenStayTime($dateTime->clone()->addMinutes($duration - 1));
                    })
                    ->whereNotIn('status_id', [0, setting('canceled_reservation_status')]);
            });
        };
    }

    public function addWhereCanAccommodate()
    {
        return fn(Builder|DiningTable $builder, $guestNumber) => $builder
            ->where('min_capacity', '<=', $guestNumber)
            ->where('max_capacity', '>=', $guestNumber);
    }

    public function addWhereHasReservationLocation()
    {
        return fn(Builder|DiningTable $builder, $model) => $builder->whereHasLocation($model->location_id);
    }
}

--------------------------------------------------------------------------------

File: src\Models\Scopes\ReservationScope.php
Comments: Included
Mime Type: application/octet-stream
Size: 2041 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models\Scopes;

use Carbon\Carbon;
use Igniter\Flame\Database\Scope;
use Igniter\Reservation\Models\Reservation;
use Illuminate\Database\Eloquent\Builder;

class ReservationScope extends Scope
{
    public function addApplyDateTimeFilter()
    {
        return fn(Builder|Reservation $builder, $range) => $builder->whereBetweenReservationDateTime(
            Carbon::parse(array_get($range, 'startAt'))->format('Y-m-d H:i:s'),
            Carbon::parse(array_get($range, 'endAt'))->format('Y-m-d H:i:s'),
        );
    }

    public function addWhereBetweenReservationDateTime()
    {
        return fn(Builder|Reservation $builder, $start, $end) => $builder->whereRaw('ADDTIME(reserve_date, reserve_time) between ? and ?', [$start, $end]);
    }

    public function addWhereBetweenDate()
    {
        return $this->addWhereBetweenStayTime();
    }

    public function addWhereBetweenStayTime()
    {
        return fn(Builder|Reservation $builder, $dateTime) => $builder
            ->whereRaw(
                '? between DATE_SUB(ADDTIME(reserve_date, reserve_time), INTERVAL 2 MINUTE)'.
                ' and DATE_ADD(ADDTIME(reserve_date, reserve_time), INTERVAL duration MINUTE)',
                [$dateTime],
            );
    }

    public function addWhereNotBetweenStayTime()
    {
        return fn(Builder|Reservation $builder, $dateTime) => $builder->whereRaw(
            '? not between DATE_SUB(ADDTIME(reserve_date, reserve_time), INTERVAL (duration - 2) MINUTE)'.
            ' and DATE_ADD(ADDTIME(reserve_date, reserve_time), INTERVAL duration MINUTE)',
            [$dateTime],
        );
    }

    public function addWhereHasDiningArea()
    {
        return fn(Builder|Reservation $builder, $diningAreaId) => $builder->whereHas('tables', function($q) use ($diningAreaId): void {
            $q->where('dining_tables.dining_area_id', $diningAreaId);
        })->orDoesntHave('tables');
    }
}

--------------------------------------------------------------------------------

File: src\Models\Table.php
Comments: Included
Mime Type: application/octet-stream
Size: 1818 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Models;

use Igniter\Flame\Database\Factories\HasFactory;
use Igniter\Flame\Database\Model;
use Igniter\Flame\Database\Traits\Sortable;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Igniter\System\Models\Concerns\Switchable;

/**
 * Tables Model Class
 *
 * @deprecated Use the DiningTable model instead
 */
class Table extends Model
{
    use HasFactory;
    use Locationable;
    use Sortable;
    use Switchable;

    public const LOCATIONABLE_RELATION = 'locations';

    public const SWITCHABLE_COLUMN = 'table_status';

    const SORT_ORDER = 'priority';

    /**
     * @var string The database table name
     */
    protected $table = 'tables';

    /**
     * @var string The database table primary key
     */
    protected $primaryKey = 'table_id';

    protected $casts = [
        'min_capacity' => 'integer',
        'max_capacity' => 'integer',
        'extra_capacity' => 'integer',
        'priority' => 'integer',
        'is_joinable' => 'boolean',
    ];

    public $relation = [
        'morphToMany' => [
            'locations' => [Location::class, 'name' => 'locationable'],
        ],
    ];

    public $timestamps = true;

    // @codeCoverageIgnoreStart
    public static function getDropdownOptions()
    {
        return self::selectRaw('table_id, concat(table_name, " (", min_capacity, " - ", max_capacity, ")") AS display_name')
            ->dropdown('display_name');
    }

    public function scopeWhereBetweenCapacity($query, $noOfGuests)
    {
        return $query->where('min_capacity', '<=', $noOfGuests)
            ->where('max_capacity', '>=', $noOfGuests);
    }

    // @codeCoverageIgnoreEnd
}

--------------------------------------------------------------------------------

File: src\Notifications\ReservationCreatedNotification.php
Comments: Included
Mime Type: application/octet-stream
Size: 1415 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Notifications;

use Igniter\Reservation\Models\Reservation;
use Igniter\User\Classes\Notification;
use Igniter\User\Models\User;
use Override;

/**
 * ReservationCreatedNotification Class
 *
 * @property Reservation|null $subject
 */
class ReservationCreatedNotification extends Notification
{
    #[Override]
    public function getRecipients(): array
    {
        return User::query()->whereIsEnabled()
            ->whereHasOrDoesntHaveLocation($this->subject->location->getKey())
            ->get()->all();
    }

    #[Override]
    public function getTitle(): string
    {
        return lang('igniter.reservation::default.notify_reservation_created_title');
    }

    #[Override]
    public function getUrl(): string
    {
        $url = 'reservations';
        if ($this->subject) {
            $url .= '/edit/'.$this->subject->getKey();
        }

        return admin_url($url);
    }

    #[Override]
    public function getMessage(): string
    {
        return sprintf(lang('igniter.reservation::default.notify_reservation_created'), $this->subject->customer_name);
    }

    #[Override]
    public function getIcon(): ?string
    {
        return 'fa-chair';
    }

    #[Override]
    public function getAlias(): string
    {
        return 'reservation-created';
    }
}

--------------------------------------------------------------------------------

File: tests\AutomationRules\Conditions\ReservationAttributeTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 3100 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\AutomationRules\Conditions;

use Carbon\Carbon;
use Igniter\Automation\AutomationException;
use Igniter\Reservation\AutomationRules\Conditions\ReservationAttribute;
use Igniter\Reservation\Models\Reservation;
use Mockery;

it('returns correct condition details', function(): void {
    $result = (new ReservationAttribute)->conditionDetails();

    expect($result)->toBe([
        'name' => 'Reservation attribute',
        'description' => 'Reservation attributes',
    ]);
});

it('defines model attributes correctly', function(): void {
    $reservationAttribute = new ReservationAttribute;

    $attributes = $reservationAttribute->defineModelAttributes();

    expect($attributes)->toHaveKeys([
        'first_name', 'last_name', 'email', 'location_id', 'status_id',
        'guest_num', 'hours_since', 'hours_until', 'days_since', 'days_until', 'history_status_id',
    ]);
});

it('returns model attribute correctly', function($carbonMethod, $carbonValue, $conditionMethod, $expected): void {
    $this->travelTo(Carbon::now()->setHour(8)->setMinute(0)->setSecond(0));

    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $reservation->shouldReceive('extendableGet')
        ->with('reservation_datetime')
        ->andReturn(now()->$carbonMethod($carbonValue));

    expect((new ReservationAttribute)->$conditionMethod(null, $reservation))->toBe($expected);
})->with([
    ['subHours', 5, 'getHoursSinceAttribute', 5.0],
    ['addHours', 5, 'getHoursSinceAttribute', 0],
    ['addHours', 5, 'getHoursUntilAttribute', 5.0],
    ['subHours', 5, 'getHoursUntilAttribute', 0],
    ['subDays', 3, 'getDaysSinceAttribute', 3.0],
    ['addDays', 3, 'getDaysSinceAttribute', 0],
    ['addDays', 3, 'getDaysUntilAttribute', 3.0],
    ['subDays', 3, 'getDaysUntilAttribute', 0],
]);

it('returns correct history status ids', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $reservation->shouldReceive('status_history->pluck')->with('status_id')->andReturn(collect([1, 2, 3]));

    expect((new ReservationAttribute)->getHistoryStatusIdAttribute(null, $reservation))->toBe('1,2,3');
});

it('throws exception if reservation object is not found in parameters', function(): void {
    $params = [];

    $this->expectException(AutomationException::class);
    $this->expectExceptionMessage('Error evaluating the reservation attribute condition: the reservation object is not found in the condition parameters.');

    (new ReservationAttribute)->isTrue($params);
});

it('evaluates condition as true if reservation attribute condition is met', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $condition = Mockery::mock(ReservationAttribute::class)->makePartial();
    $condition->shouldReceive('evalIsTrue')->with($reservation)->andReturn(true);
    $params = ['reservation' => $reservation];

    expect($condition->isTrue($params))->toBeTrue();
});

--------------------------------------------------------------------------------

File: tests\AutomationRules\Conditions\ReservationStatusAttributeTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2053 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Local\Tests\AutomationRules\Conditions;

use Igniter\Admin\Models\Status;
use Igniter\Automation\AutomationException;
use Igniter\Reservation\AutomationRules\Conditions\ReservationStatusAttribute;
use Mockery;

it('returns correct condition details', function(): void {
    $result = (new ReservationStatusAttribute)->conditionDetails();

    expect($result)->toBe([
        'name' => 'Reservation status attribute',
        'description' => 'Reservation status attributes',
    ]);
});

it('defines model attributes correctly', function(): void {
    $reservationStatusAttribute = new ReservationStatusAttribute;

    $attributes = $reservationStatusAttribute->defineModelAttributes();

    expect($attributes)->toHaveKeys(['status_id', 'status_name', 'notify_customer']);
});

it('returns true if status attribute condition is met', function(): void {
    $status = Mockery::mock(Status::class);
    $condition = Mockery::mock(ReservationStatusAttribute::class)->makePartial();
    $condition->shouldReceive('evalIsTrue')->with($status)->andReturn(true);
    $params = ['status' => $status];

    $result = $condition->isTrue($params);
    expect($result)->toBeTrue();
});

it('throws exception if status object is not found in parameters', function(): void {
    $params = [];

    $this->expectException(AutomationException::class);
    $this->expectExceptionMessage('Error evaluating the status attribute condition: the status object is not found in the condition parameters.');

    (new ReservationStatusAttribute)->isTrue($params);
});

it('returns false if status attribute condition is not met', function(): void {
    $status = Mockery::mock(Status::class);
    $condition = Mockery::mock(ReservationStatusAttribute::class)->makePartial();
    $condition->shouldReceive('evalIsTrue')->with($status)->andReturn(false);
    $params = ['status' => $status];

    expect((new ReservationStatusAttribute)->isTrue($params))->toBeFalse();
});

--------------------------------------------------------------------------------

File: tests\AutomationRules\Events\NewReservationStatusTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1344 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\AutomationRules\Events;

use Igniter\Admin\Models\Status;
use Igniter\Reservation\AutomationRules\Events\NewReservationStatus;
use Igniter\Reservation\Models\Reservation;
use Mockery;

it('returns event details correctly', function(): void {
    $details = (new NewReservationStatus)->eventDetails();

    expect($details['name'])->toBe('Reservation Status Update Event')
        ->and($details['description'])->toBe('When a reservation status is updated')
        ->and($details['group'])->toBe('reservation');
});

it('makes params from event with reservation & status instance', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $reservation->shouldReceive('mailGetData')->andReturn(['customer_name' => 'John Doe']);
    $status = Mockery::mock(Status::class);

    $params = NewReservationStatus::makeParamsFromEvent([$reservation, $status]);

    expect($params['customer_name'])->toBe('John Doe')
        ->and($params['status'])->toBe($status);
});

it('makes params from event without reservation & status instance', function(): void {
    $params = NewReservationStatus::makeParamsFromEvent([]);

    expect($params)->toHaveKey('status')
        ->and($params['status'])->toBeNull();
});

--------------------------------------------------------------------------------

File: tests\AutomationRules\Events\NewReservationTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1310 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\AutomationRules\Events;

use Igniter\Admin\Models\Status;
use Igniter\Reservation\AutomationRules\Events\NewReservation;
use Igniter\Reservation\Models\Reservation;
use Mockery;

it('returns event details correctly', function(): void {
    $details = (new NewReservation)->eventDetails();

    expect($details['name'])->toBe('New Reservation Event')
        ->and($details['description'])->toBe('When a new reservation is created')
        ->and($details['group'])->toBe('reservation');
});

it('makes params from event with reservation instance', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $reservation->shouldReceive('mailGetData')->andReturn(['customer_name' => 'John Doe']);
    $reservation->status = Mockery::mock(Status::class);

    $params = NewReservation::makeParamsFromEvent([$reservation]);

    expect($params['customer_name'])->toBe('John Doe')
        ->and($params['status'])->toBe($reservation->status);
});

it('makes params from event without reservation instance', function(): void {
    $params = NewReservation::makeParamsFromEvent([null]);

    expect($params)->toHaveKey('status')
        ->and($params['status'])->toBeNull();
});

--------------------------------------------------------------------------------

File: tests\AutomationRules\Events\ReservationAssignedTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1631 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\AutomationRules\Events;

use Igniter\Admin\Models\Status;
use Igniter\Reservation\AutomationRules\Events\ReservationAssigned;
use Igniter\Reservation\Models\Reservation;
use Igniter\User\Models\User;
use Mockery;

it('returns event details correctly', function(): void {
    $details = (new ReservationAssigned)->eventDetails();

    expect($details['name'])->toBe('Reservation Assigned Event')
        ->and($details['description'])->toBe('When a reservation is assigned to a staff')
        ->and($details['group'])->toBe('reservation');
});

it('makes params from event with reservation, status & assignee instance', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $reservation->shouldReceive('mailGetData')->andReturn(['customer_name' => 'John Doe']);
    $reservation->status = Mockery::mock(Status::class);
    $reservation->assignee = Mockery::mock(User::class);

    $params = ReservationAssigned::makeParamsFromEvent([$reservation]);

    expect($params['customer_name'])->toBe('John Doe')
        ->and($params['status'])->toBe($reservation->status)
        ->and($params['assignee'])->toBe($reservation->assignee);
});

it('makes params from event without reservation, status & assignee instance', function(): void {
    $params = ReservationAssigned::makeParamsFromEvent([null]);

    expect($params)->toHaveKey('status')
        ->and($params['status'])->toBeNull()
        ->and($params)->toHaveKey('assignee')
        ->and($params['assignee'])->toBeNull();
});

--------------------------------------------------------------------------------

File: tests\BulkActionWidget\AssignTableTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 4143 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\BulkActionWidget;

use Igniter\Admin\Classes\AdminController;
use Igniter\Admin\Classes\ToolbarButton;
use Igniter\Local\Models\Location;
use Igniter\Reservation\BulkActionWidgets\AssignTable;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Reservation;

it('assigns tables to reservations without tables', function(): void {
    $controller = new class extends AdminController {};
    $location = Location::factory()->create();
    DiningTable::factory()
        ->count(2)
        ->for(DiningArea::factory()->for($location, 'location')->create(), 'dining_area')
        ->create([
            'min_capacity' => 40,
            'max_capacity' => 60,
            'priority' => 1,
            'is_enabled' => true,
        ]);
    $reservations = Reservation::factory()->count(2)->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->toDateString(),
        'reserve_time' => now()->toTimeString(),
        'guest_num' => 50,
        'duration' => 120,
        'status_id' => 1,
    ]);

    (new AssignTable($controller, new ToolbarButton('assign_table')))->handleAction([], $reservations);

    expect(flash()->messages()->first())->message->not->toBeNull()->level->toBe('success');
});

it('does not assign tables to reservations with existing tables', function(): void {
    $controller = new class extends AdminController {};
    $location = Location::factory()->create();
    $diningTable = DiningTable::factory()
        ->for(DiningArea::factory()->for($location, 'location')->create(), 'dining_area')
        ->create([
            'min_capacity' => 40,
            'max_capacity' => 60,
            'priority' => 1,
        ]);
    $reservation = Reservation::factory()->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->toDateString(),
        'reserve_time' => now()->toTimeString(),
        'guest_num' => 50,
        'duration' => 120,
        'status_id' => 1,
    ]);
    $reservation->tables()->attach($diningTable);
    $records = collect([$reservation]);

    (new AssignTable($controller, new ToolbarButton('assign_table')))->handleAction([], $records);

    expect(flash()->messages()->isEmpty())->toBeTrue();
});

it('shows warning if no tables can be assigned', function(): void {
    $controller = new class extends AdminController {};
    $location = Location::factory()->create();
    $reservation = Reservation::factory()->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->toDateString(),
        'reserve_time' => now()->toTimeString(),
        'guest_num' => 50,
        'duration' => 120,
        'status_id' => 1,
    ]);

    $records = collect([$reservation]);

    (new AssignTable($controller, new ToolbarButton('assign_table')))->handleAction([], $records);

    expect(flash()->messages()->first())
        ->message->not->toBeNull()
        ->level->toBe('warning');
});

it('assigns tables to reservations in correct order', function(): void {
    $controller = new class extends AdminController {};
    $location = Location::factory()->create();
    DiningTable::factory()
        ->count(2)
        ->for(DiningArea::factory()->for($location, 'location')->create(), 'dining_area')
        ->create([
            'min_capacity' => 40,
            'max_capacity' => 60,
            'priority' => 1,
            'is_enabled' => true,
        ]);
    $reservations = Reservation::factory()->count(2)->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->toDateString(),
        'reserve_time' => now()->toTimeString(),
        'guest_num' => 50,
        'duration' => 120,
        'status_id' => 1,
    ]);

    (new AssignTable($controller, new ToolbarButton('assign_table')))->handleAction([], $reservations);

    expect(flash()->messages()->first())->message->not->toBeNull()->level->toBe('success');
});

--------------------------------------------------------------------------------

File: tests\Classes\BookingManagerTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 7249 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Classes;

use Carbon\Carbon;
use DateTime;
use Igniter\Local\Classes\WorkingSchedule;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Classes\BookingManager;
use Igniter\Reservation\Models\Reservation;
use Igniter\User\Facades\Auth;
use Igniter\User\Models\Customer;
use Illuminate\Support\Facades\Event;
use Mockery;

it('loads reservation with associated customer and location', function(): void {
    $customer = Mockery::mock(Customer::class)->makePartial();
    $location = Mockery::mock(Location::class)->makePartial();
    Auth::shouldReceive('customer')->andReturn($customer);
    Auth::shouldReceive('getUser')->andReturn($customer);

    $manager = new BookingManager;
    $manager->useLocation($location);

    $reservation = $manager->loadReservation();

    expect($reservation->customer)->toBe($customer)
        ->and($reservation->location)->toBe($location);
});

it('returns reservation by hash for specific customer', function(): void {
    $customer = Mockery::mock(Customer::class)->makePartial();
    $customer->customer_id = 1;
    $reservation = Reservation::factory()->create([
        'customer_id' => $customer->customer_id,
    ]);

    expect((new BookingManager)->getReservationByHash($reservation->hash, $customer))->hash->toBe($reservation->hash);
});

it('returns empty collection if location is not set when making time slots', function(): void {
    expect((new BookingManager)->makeTimeSlots(now()))->toBeEmpty();
});

it('returns time slots with default interval and lead time', function(): void {
    $this->travelTo(Carbon::now()->startOfDay());
    $location = Mockery::mock(Location::class)->makePartial();
    $schedule = Mockery::mock(WorkingSchedule::class)->makePartial();

    $location->shouldReceive('getReservationInterval')->andReturn(30);
    $location->shouldReceive('getReservationLeadTime')->andReturn(15);
    $location->shouldReceive('getMinReservationAdvanceTime')->andReturn(2);
    $location->shouldReceive('getMaxReservationAdvanceTime')->andReturn(90);
    $location->shouldReceive('getSettings')->with('booking.include_start_time', 1)->andReturn(1);
    $schedule->shouldReceive('generateTimeslot')->andReturn(collect([Carbon::now()->addMinutes(30)]));
    $location->shouldReceive('newWorkingSchedule')->andReturn($schedule);

    $manager = new BookingManager;
    $manager->useLocation($location);

    expect($manager->makeTimeSlots(now())->count())->toBe(1);
});

it('returns time slots with custom interval and lead time', function(): void {
    $this->travelTo(Carbon::now()->startOfDay());
    $location = Mockery::mock(Location::class)->makePartial();
    $schedule = Mockery::mock(WorkingSchedule::class)->makePartial();

    $location->shouldReceive('getSettings')->with('booking.include_start_time', 1)->andReturn(1);
    $location->shouldReceive('getMinReservationAdvanceTime')->andReturn(2);
    $location->shouldReceive('getMaxReservationAdvanceTime')->andReturn(90);
    $schedule->shouldReceive('generateTimeslot')->andReturn(collect([Carbon::now()->addMinutes(45)]));
    $location->shouldReceive('newWorkingSchedule')->andReturn($schedule);

    $manager = new BookingManager;
    $manager->useLocation($location);

    $result = $manager->makeTimeSlots(Carbon::now(), 45, 10);

    expect($result->count())->toBe(1);
});

it('filters out past time slots based on lead time', function(): void {
    $this->travelTo(Carbon::now()->startOfDay());
    $location = Mockery::mock(Location::class)->makePartial();
    $schedule = Mockery::mock(WorkingSchedule::class)->makePartial();

    $location->shouldReceive('getMaxReservationAdvanceTime')->andReturn(90);
    $location->shouldReceive('getReservationInterval')->andReturn(30);
    $location->shouldReceive('getReservationLeadTime')->andReturn(15);
    $location->shouldReceive('getSettings')->with('booking.include_start_time', 1)->andReturn(1);
    $location->shouldReceive('getMinReservationAdvanceTime')->andReturn(2);
    $location->shouldReceive('getMaxReservationAdvanceTime')->andReturn(90);
    $schedule->shouldReceive('generateTimeslot')->andReturn(collect([Carbon::now()->subMinutes(10), Carbon::now()->addMinutes(30)]));
    $location->shouldReceive('newWorkingSchedule')->andReturn($schedule);

    $manager = new BookingManager;
    $manager->useLocation($location);

    $result = $manager->makeTimeSlots(Carbon::now());

    expect($result->count())->toBe(2);
});

it('saves reservation with provided data', function(): void {
    Event::fake();

    $location = Mockery::mock(Location::class)->makePartial();
    $customer = Mockery::mock(Customer::class)->makePartial();
    $reservation = Mockery::mock(Reservation::class)->makePartial();

    $customer->email = 'john@example.com';
    Auth::shouldReceive('customer')->andReturn($customer);
    $location->shouldReceive('getReservationStayTime')->andReturn(60);
    $manager = new BookingManager;
    $manager->useLocation($location);

    $data = [
        'guest' => 2,
        'first_name' => 'John',
        'last_name' => 'Doe',
        'email' => 'john@example.com',
        'telephone' => '1234567890',
        'comment' => 'Test comment',
        'sdateTime' => now()->toDateTimeString(),
    ];

    $reservation->shouldReceive('save')->once();
    $reservation->shouldReceive('addStatusHistory')->once();
    $result = $manager->saveReservation($reservation, $data);

    expect($result->guest_num)->toBe(2)
        ->and($result->first_name)->toBe('John')
        ->and($result->last_name)->toBe('Doe')
        ->and($result->email)->toBe('john@example.com')
        ->and($result->telephone)->toBe('1234567890')
        ->and($result->comment)->toBe('Test comment');

    Event::assertDispatched('igniter.reservation.confirmed');
});

it('returns false if not fully booked on given date and time', function(): void {
    Event::fake();

    $dateTime = Carbon::now();
    $location = Mockery::mock(Location::
--------------------------------------------------------------------------------

File: tests\ExtensionTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 7253 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests;

use Igniter\Admin\DashboardWidgets\Charts;
use Igniter\Admin\DashboardWidgets\Statistics;
use Igniter\Admin\Http\Controllers\Dashboard;
use Igniter\Admin\Models\StatusHistory;
use Igniter\Admin\Widgets\Form;
use Igniter\Flame\Database\Model;
use Igniter\Reservation\AutomationRules\Conditions\ReservationAttribute;
use Igniter\Reservation\AutomationRules\Conditions\ReservationStatusAttribute;
use Igniter\Reservation\BulkActionWidgets\AssignTable;
use Igniter\Reservation\Extension;
use Igniter\Reservation\FormWidgets\FloorPlanner;
use Igniter\Reservation\Http\Requests\BookingSettingsRequest;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\Reservation;
use Igniter\System\Mail\AnonymousTemplateMailable;
use Igniter\System\Models\Settings;
use Igniter\User\Http\Controllers\Customers;
use Igniter\User\Models\Customer;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Mail;
use Mockery;

beforeEach(function(): void {
    $this->extension = new Extension(app());
});

it('returns correct dining section class', function(): void {
    $this->extension->boot();

    $morphMap = Relation::morphMap();

    expect($morphMap['dining_sections'])->toBe(DiningSection::class);
});

it('binds reservation event correctly', function(): void {
    Event::shouldReceive('listen')->with('admin.statusHistory.beforeAddStatus', Mockery::any())->once();
    Event::shouldReceive('listen')->with('admin.statusHistory.added', Mockery::any())->once();
    Event::shouldReceive('listen')->with('admin.assignable.assigned', Mockery::any())->once();
    Event::shouldReceive('listen')->with('admin.form.extendFields', Mockery::any())->once();
    Event::shouldReceive('listen')->with('igniter.reservation.statusAdded', Mockery::any())->once();

    $this->extension->boot();
});

it('registers correct mail templates', function(): void {
    $mailTemplates = $this->extension->registerMailTemplates();

    expect($mailTemplates)->toHaveKey('igniter.reservation::mail.reservation')
        ->and($mailTemplates)->toHaveKey('igniter.reservation::mail.reservation_alert')
        ->and($mailTemplates)->toHaveKey('igniter.reservation::mail.reservation_update');
});

it('registers correct automation rules', function(): void {
    $automationRules = $this->extension->registerAutomationRules();

    expect($automationRules['events'])->toHaveKey('igniter.reservation.confirmed')
        ->and($automationRules['events'])->toHaveKey('igniter.reservation.statusAdded')
        ->and($automationRules['events'])->toHaveKey('igniter.reservation.assigned')
        ->and($automationRules['conditions'])->toContain(ReservationAttribute::class)
        ->and($automationRules['conditions'])->toContain(ReservationStatusAttribute::class);
});

it('registers correct permissions', function(): void {
    $permissions = $this->extension->registerPermissions();

    expect($permissions)->toHaveKey('Admin.Tables')
        ->and($permissions)->toHaveKey('Admin.Reservations')
        ->and($permissions)->toHaveKey('Admin.DeleteReservations')
        ->and($permissions)->toHaveKey('Admin.AssignReservations')
        ->and($permissions)->toHaveKey('Admin.AssignReservationTables');
});

it('registers correct navigation items', function(): void {
    $navigation = $this->extension->registerNavigation();

    expect($navigation)->toHaveKey('reservations')
        ->and($navigation['reservations']['href'])->toBe(admin_url('reservations'))
        ->and($navigation['restaurant']['child'])->toHaveKey('dining_areas')
        ->and($navigation['restaurant']['child']['dining_areas']['href'])->toBe(admin_url('dining_areas'));
});

it('registers correct form widgets', function(): void {
    $formWidgets = $this->extension->registerFormWidgets();

    expect($formWidgets)->toHaveKey(FloorPlanner::class)
        ->and($formWidgets[FloorPlanner::class]['code'])->toBe('floorplanner');
});

it('registers correct list action widgets', function(): void {
    $listActionWidgets = $this->extension->registerListActionWidgets();

    expect($listActionWidgets)->toHaveKey(AssignTable::class)
        ->and($listActionWidgets[AssignTable::class]['code'])->toBe('assign_table');
});

it('registers correct location settings', function(): void {
    $locationSettings = $this->extension->registerLocationSettings();

    expect($locationSettings)->toHaveKey('booking')
        ->and($locationSettings['booking']['form'])->toBe('igniter.reservation::/models/bookingsettings')
        ->and($locationSettings['booking']['request'])->toBe(BookingSettingsRequest::class);
});

it('does not add reservations tab to customer edit form when model is invalid', function(): void {
    $model = mock(Model::class)->makePartial();
    $form = new Form(resolve(Customers::class), ['model' => $model, 'context' => 'edit']);
    $form->bindToController();

    $fields = $form->getFields();

    expect($fields)->not->toHaveKey('reservations');
});

it('adds reservations tab to customer edit form', function(): void {
    $customer = mock(Customer::class)->makePartial();
    $form = new Form(resolve(Customers::class), ['model' => $customer, 'context' => 'edit']);
    $form->bindToController();

    $fields = $form->getFields();

    expect($fields['reservations']->tab)->toBe('lang:igniter.reservation::default.text_tab_reservations');
});

it('sends reservation update after status is updated', function(): void {
    Mail::fake();
    $reservation = Reservation::factory()->create();
    $statusHistory = StatusHistory::factory()->create([
        'object_id' => $reservation->getKey(),
        'object_type' => 'reservations',
        'notify' => true,
    ]);

    event('igniter.reservation.statusAdded', [$reservation, $statusHistory]);

    Mail::assertQueued(AnonymousTemplateMailable::class, fn($mail): bool => $mail->getTemplateCode() === 'igniter.reservation::m
--------------------------------------------------------------------------------

File: tests\FormWidgets\FloorPlannerTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2617 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\FormWidgets;

use Igniter\Admin\Classes\AdminController;
use Igniter\Admin\Classes\FormField;
use Igniter\Reservation\FormWidgets\FloorPlanner;
use Igniter\Reservation\Models\Reservation;
use Igniter\System\Facades\Assets;
use Mockery;

beforeEach(function(): void {
    $controller = new class extends AdminController {};
    $this->floorPlanner = new FloorPlanner($controller, new FormField('test_field', 'Floor planner'), []);
});

it('initializes with default configuration', function(): void {
    $this->floorPlanner->initialize();

    $colors = [
        '#1abc9c', '#16a085',
        '#9b59b6', '#8e44ad',
        '#34495e', '#2b3e50',
        '#f1c40f', '#f39c12',
        '#e74c3c', '#c0392b',
        '#95a5a6', '#7f8c8d',
    ];
    expect($this->floorPlanner->sectionColors)->toBe($colors)
        ->and($this->floorPlanner->connectorField)->toBe('dining_tables')
        ->and($this->floorPlanner->formTitle)->toBe('Edit table');
});

it('prepares vars', function(): void {
    $this->floorPlanner->prepareVars();

    expect($this->floorPlanner->vars['field'])->toBeInstanceOf(FormField::class)
        ->and($this->floorPlanner->vars)->toHaveKeys(['sectionColors', 'diningTables', 'connectorWidgetAlias']);
});

it('loads assets correctly', function(): void {
    Assets::shouldReceive('addJs')->with('https://unpkg.com/konva@8.3.12/konva.min.js', 'konva-js')->once();
    Assets::shouldReceive('addCss')->with('css/floorplanner.css', 'floorplanner-css')->once();
    Assets::shouldReceive('addJs')->with('js/floorplanner.js', 'floorplanner-js')->once();

    $this->floorPlanner->loadAssets();
});

it('saves state and updates model and tables', function(): void {
    $model = Mockery::mock(Reservation::class)->makePartial();

    $model->shouldReceive('save')->once();
    $model->shouldReceive('dining_tables')->andReturnSelf();
    $model->shouldReceive('find')->with('1')->andReturn($table = Mockery::mock());
    $table->shouldReceive('save')->once();
    $this->floorPlanner->model = $model;

    $state = json_encode([
        'stage' => ['x' => 0, 'y' => 0, 'scaleX' => 1, 'scaleY' => 1],
        'groups' => [['id' => 'group-1', 'x' => 0, 'y' => 0, 'rotation' => 0]],
    ]);
    request()->merge(['state' => $state]);

    $this->floorPlanner->onSaveState();
});

it('returns no save data for getSaveValue', function(): void {
    $result = $this->floorPlanner->getSaveValue('any value');

    expect($result)->toBe(FormField::NO_SAVE_DATA);
});

--------------------------------------------------------------------------------

File: tests\Http\Controllers\DiningAreasTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 12367 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Controllers;

use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\DiningTable;

it('loads dining areas page', function(): void {
    actingAsSuperUser()
        ->get(route('igniter.reservation.dining_areas'))
        ->assertOk();
});

it('loads create dining area page', function(): void {
    actingAsSuperUser()
        ->get(route('igniter.reservation.dining_areas', ['slug' => 'create']))
        ->assertOk();
});

it('loads edit dining area page', function(): void {
    $diningArea = DiningArea::factory()->create();

    actingAsSuperUser()
        ->get(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]))
        ->assertOk();
});

it('loads dining area preview page', function(): void {
    $diningArea = DiningArea::factory()->create();

    actingAsSuperUser()
        ->get(route('igniter.reservation.dining_areas', ['slug' => 'preview/'.$diningArea->getKey()]))
        ->assertOk();
});

it('duplicates dining area', function(): void {
    $diningArea = DiningArea::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas'), [
            'id' => (string)$diningArea->getKey(),
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onDuplicate',
        ])
        ->assertOk();

    expect(DiningArea::where('name', $diningArea->name.' (copy)')->exists())->toBeTrue();
});

it('creates dining area', function(): void {
    $location = Location::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'create']), [
            'DiningArea' => [
                'name' => 'Created Dining Area',
                'location_id' => $location->getKey(),
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onSave',
        ]);

    expect(DiningArea::where('name', 'Created Dining Area')->exists())->toBeTrue();
});

it('creates a dining table combo', function(): void {
    $diningArea = DiningArea::factory()->create();
    $tables = $diningArea->dining_tables()->saveMany(DiningTable::factory(3)->make());

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]), [
            'DiningArea' => [
                '_select_dining_tables' => $tables->pluck('id')->all(),
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onCreateCombo',
        ]);

    $this->assertDatabaseHas('dining_tables', [
        'name' => $tables->pluck('name')->join('/'),
        'is_combo' => 1,
    ]);
});

it('updates dining area', function(): void {
    $diningArea = DiningArea::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]), [
            'DiningArea' => [
                'name' => 'Updated Dining Area',
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onSave',
        ]);

    expect(DiningArea::find($diningArea->getKey()))->name->toBe('Updated Dining Area');
});

it('updates dining area fixes broken tree', function(): void {
    $diningArea = DiningArea::factory()->create();
    $diningTableMock = mock(DiningTable::class)->makePartial();
    $diningTableMock->shouldReceive('isBroken')->andReturnTrue();
    $diningTableMock->shouldReceive('fixBrokenTreeQuietly')->once();
    app()->instance(DiningTable::class, $diningTableMock);

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]), [
            'DiningArea' => [
                'name' => 'Updated Dining Area',
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onSave',
        ])
        ->assertOk();

    expect(DiningArea::find($diningArea->getKey()))->name->toBe('Updated Dining Area');
});

it('deletes dining area', function(): void {
    $diningArea = DiningArea::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]), [], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onDelete',
        ]);

    expect(DiningArea::find($diningArea->getKey()))->toBeNull();
});

it('attaches new dining table', function(): void {
    $diningArea = DiningArea::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]), [], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'formDiningTableSolos::onLoadRecord',
        ])
        ->assertSee('New Record');

    actingAsSuperUser()
        ->post(route('igniter.reservation.dining_areas', ['slug' => 'edit/'.$diningArea->getKey()]), [
            'recordId' => '',
            'DiningArea' => [
                'connectorData' => [
                    'id' => '',
                    'dining_area_id' => $diningArea->getKey(),
                    'name' => 'New Dining Table',
                    'priority' => '9',
                    'min_capacity' => '2',
                    'max_capacity' => '4',
                    'extra_capacity' => '0',
                    'shape' => 'square',
                    'is_enabled' => '0',
                ],
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'formDiningTableSolos::onSaveRecord',
        ]);

    expect(DiningTable::where([
        'name' => 'New Dining Table',
        'dining_ar
--------------------------------------------------------------------------------

File: tests\Http\Controllers\ReservationsTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 7494 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Controllers;

use Igniter\Admin\Models\Status;
use Igniter\Local\Facades\Location as LocationFacade;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Reservation;

it('loads reservations page', function(): void {
    actingAsSuperUser()
        ->get(route('igniter.reservation.reservations'))
        ->assertOk();
});

it('loads reservation floor plan page', function(): void {
    actingAsSuperUser()
        ->get(route('igniter.reservation.reservations', ['slug' => 'floor_plan']))
        ->assertOk();
});

it('loads reservation calender page', function(): void {
    actingAsSuperUser()
        ->get(route('igniter.reservation.reservations', ['slug' => 'calendar']))
        ->assertOk();
});

it('generates events on reservation calender page', function(): void {
    $location = Location::factory()->create();
    $status = Status::factory()->create();
    LocationFacade::shouldReceive('current')->andReturn($location);
    LocationFacade::shouldReceive('getId')->andReturn($location->getKey());
    $this->travelTo('2021-04-01');

    Reservation::factory()->for($location, 'location')->for($status, 'status')->count(5)->create([
        'reserve_date' => '2021-04-01',
    ]);
    Reservation::factory()->for($location, 'location')->for($status, 'status')->count(3)->create([
        'reserve_date' => '2021-04-10',
    ]);

    actingAsSuperUser()
        ->post(route('igniter.reservation.reservations', ['slug' => 'calendar']), [
            'start' => '2021-03-29T00:00:00.000Z',
            'end' => '2021-04-09T00:00:00.000Z',
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'calender::onGenerateEvents',
        ])
        ->assertJsonCount(5, 'generatedEvents');
});

it('updates events on reservation calender page', function(): void {
    $this->travelTo('2021-04-01');

    $reservation = Reservation::factory()->create(['reserve_date' => '2021-04-01']);

    actingAsSuperUser()
        ->post(route('igniter.reservation.reservations', ['slug' => 'calendar']), [
            'eventId' => $reservation->getKey(),
            'start' => '2021-04-09T00:00:00.000Z',
            'end' => '2021-04-09T00:30:00.000Z',
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'calender::onUpdateEvent',
        ])
        ->assertOk();

    $reservation = Reservation::find($reservation->getKey());
    expect($reservation->duration)->toBe(30)
        ->and($reservation->reserve_date->toDateString())->toBe('2021-04-09');
});

it('loads create reservation page', function(): void {
    actingAsSuperUser()
        ->get(route('igniter.reservation.reservations', ['slug' => 'create']))
        ->assertOk();
});

it('loads edit reservation page', function(): void {
    $reservation = Reservation::factory()->create();

    actingAsSuperUser()
        ->get(route('igniter.reservation.reservations', ['slug' => 'edit/'.$reservation->getKey()]))
        ->assertOk();
});

it('loads reservation preview page', function(): void {
    $reservation = Reservation::factory()->create();

    actingAsSuperUser()
        ->get(route('igniter.reservation.reservations', ['slug' => 'preview/'.$reservation->getKey()]))
        ->assertOk();
});

it('creates reservation', function(): void {
    actingAsSuperUser()
        ->post(route('igniter.reservation.reservations', ['slug' => 'create']), [
            'Reservation' => [
                'location_id' => 1,
                'first_name' => 'John',
                'last_name' => 'Doe',
                'email' => 'john@example.com',
                'telephone' => '1234567890',
                'reserve_date' => '2021-01-01',
                'reserve_time' => '12:00',
                'guest_num' => 2,
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onSave',
        ]);

    $this->assertDatabaseHas('reservations', [
        'first_name' => 'John',
        'last_name' => 'Doe',
        'email' => 'john@example.com',
        'telephone' => '1234567890',
        'reserve_date' => '2021-01-01',
        'reserve_time' => '12:00',
        'guest_num' => 2,
    ]);
});

it('updates reservation', function(): void {
    $reservation = Reservation::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.reservations', ['slug' => 'edit/'.$reservation->getKey()]), [
            'Reservation' => [
                'location_id' => 1,
                'first_name' => 'Jane',
                'last_name' => 'Doe',
                'email' => 'john@example.com',
                'telephone' => '1234567890',
                'reserve_date' => '2025-05-05',
                'reserve_time' => '16:00',
                'guest_num' => 2,
            ],
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onSave',
        ]);

    $this->assertDatabaseHas('reservations', [
        'first_name' => 'Jane',
        'reserve_date' => '2025-05-05',
        'reserve_time' => '16:00',
        'guest_num' => 2,
    ]);
});

it('updates reservation status', function(): void {
    $reservation = Reservation::factory()->create();
    $status = Status::factory()->create();

    actingAsSuperUser()
        ->post(route('igniter.reservation.reservations'), [
            'recordId' => $reservation->getKey(),
            'statusId' => $status->getKey(),
        ], [
            'X-Requested-With' => 'XMLHttpRequest',
            'X-IGNITER-REQUEST-HANDLER' => 'onUpdateStatus',
        ]);

    $this->assertDatabaseHas('reservations', [
        'reservation_id' => $reservation->getKey(),
        'status_id' => $status->getKey(),
    ]);
});

it('does not update reservation status when missing status id', function(): void {
    $reservation = Reservation::factory()->create();
--------------------------------------------------------------------------------

File: tests\Http\Requests\BookingSettingsRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2576 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\BookingSettingsRequest;

it('returns correct attribute labels', function(): void {
    $attributes = (new BookingSettingsRequest)->attributes();

    expect($attributes['is_enabled'])->toBe(lang('igniter.reservation::default.offer_reservation'))
        ->and($attributes['limit_guests'])->toBe(lang('igniter.reservation::default.label_limit_guests'))
        ->and($attributes['limit_guests_count'])->toBe(lang('igniter.reservation::default.label_limit_guests_count'))
        ->and($attributes['time_interval'])->toBe(lang('igniter.reservation::default.label_reservation_time_interval'))
        ->and($attributes['stay_time'])->toBe(lang('igniter.reservation::default.reservation_stay_time'))
        ->and($attributes['auto_allocate_table'])->toBe(lang('igniter.reservation::default.label_auto_allocate_table'))
        ->and($attributes['min_guest_count'])->toBe(lang('igniter.reservation::default.label_min_reservation_guest_num'))
        ->and($attributes['max_guest_count'])->toBe(lang('igniter.reservation::default.label_max_reservation_guest_num'))
        ->and($attributes['min_advance_time'])->toBe(lang('igniter.reservation::default.label_min_reservation_advance_time'))
        ->and($attributes['max_advance_time'])->toBe(lang('igniter.reservation::default.label_max_reservation_advance_time'))
        ->and($attributes['cancellation_timeout'])->toBe(lang('igniter.reservation::default.label_reservation_cancellation_timeout'));
});

it('validates rules correctly', function(): void {
    $rules = (new BookingSettingsRequest)->rules();

    expect($rules['is_enabled'])->toBe(['boolean'])
        ->and($rules['limit_guests'])->toBe(['boolean'])
        ->and($rules['limit_guests_count'])->toBe(['integer', 'min:1', 'max:999'])
        ->and($rules['time_interval'])->toBe(['min:5', 'integer'])
        ->and($rules['stay_time'])->toBe(['min:5', 'integer'])
        ->and($rules['auto_allocate_table'])->toBe(['integer'])
        ->and($rules['min_guest_count'])->toBe(['nullable', 'integer', 'min:0', 'max:999'])
        ->and($rules['max_guest_count'])->toBe(['nullable', 'integer', 'min:0', 'max:999'])
        ->and($rules['min_advance_time'])->toBe(['nullable', 'integer', 'min:0', 'max:999'])
        ->and($rules['max_advance_time'])->toBe(['nullable', 'integer', 'min:0', 'max:999'])
        ->and($rules['cancellation_timeout'])->toBe(['nullable', 'integer', 'min:0', 'max:999']);
});

--------------------------------------------------------------------------------

File: tests\Http\Requests\DiningAreaRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 557 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\DiningAreaRequest;

it('returns correct attribute labels for dining area', function(): void {
    $attributes = (new DiningAreaRequest)->attributes();

    expect($attributes['name'])->toBe(lang('igniter::admin.label_name'));
});

it('validates rules correctly for dining area', function(): void {
    $rules = (new DiningAreaRequest)->rules();

    expect($rules['name'])->toBe(['required', 'between:2,128']);
});

--------------------------------------------------------------------------------

File: tests\Http\Requests\DiningSectionRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1297 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\DiningSectionRequest;

it('returns correct attribute labels for dining section', function(): void {
    $attributes = (new DiningSectionRequest)->attributes();

    expect($attributes['location_id'])->toBe(lang('igniter::admin.label_location'))
        ->and($attributes['name'])->toBe(lang('igniter::admin.label_name'))
        ->and($attributes['priority'])->toBe(lang('igniter.reservation::default.dining_tables.label_priority'))
        ->and($attributes['description'])->toBe(lang('igniter::admin.label_description'))
        ->and($attributes['is_enabled'])->toBe(lang('igniter.reservation::default.dining_tables.label_is_enabled'));
});

it('validates rules correctly for dining section', function(): void {
    $rules = (new DiningSectionRequest)->rules();

    expect($rules['location_id'])->toBe(['required', 'integer'])
        ->and($rules['name'])->toBe(['required', 'string'])
        ->and($rules['priority'])->toBe(['required', 'integer'])
        ->and($rules['description'])->toBe(['string'])
        ->and($rules['is_enabled'])->toBe(['is_enabled', 'boolean'])
        ->and($rules['color'])->toBe(['nullable', 'string']);
});

--------------------------------------------------------------------------------

File: tests\Http\Requests\DiningTableRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2091 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\DiningTableRequest;

it('returns correct attribute labels for dining table', function(): void {
    $attributes = (new DiningTableRequest)->attributes();

    expect($attributes['name'])->toBe(lang('igniter::admin.label_name'))
        ->and($attributes['shape'])->toBe(lang('igniter.reservation::default.dining_tables.label_table_shape'))
        ->and($attributes['min_capacity'])->toBe(lang('igniter.reservation::default.tables.label_min_capacity'))
        ->and($attributes['max_capacity'])->toBe(lang('igniter.reservation::default.tables.label_capacity'))
        ->and($attributes['extra_capacity'])->toBe(lang('igniter.reservation::default.tables.label_extra_capacity'))
        ->and($attributes['priority'])->toBe(lang('igniter.reservation::default.tables.label_priority'))
        ->and($attributes['is_enabled'])->toBe(lang('igniter::admin.label_status'))
        ->and($attributes['dining_area_id'])->toBe(lang('igniter.reservation::default.dining_tables.label_dining_areas'))
        ->and($attributes['dining_section_id'])->toBe(lang('igniter.reservation::default.dining_tables.column_section'));
});

it('validates rules correctly for dining table', function(): void {
    $rules = (new DiningTableRequest)->rules();

    expect($rules['name'])->toBe(['required', 'string', 'between:2,255'])
        ->and($rules['shape'])->toBe(['required', 'in:rectangle,round'])
        ->and($rules['min_capacity'])->toBe(['required', 'integer', 'min:1', 'lte:max_capacity'])
        ->and($rules['max_capacity'])->toBe(['required', 'integer', 'min:1', 'gte:min_capacity'])
        ->and($rules['extra_capacity'])->toBe(['sometimes', 'integer'])
        ->and($rules['priority'])->toBe(['sometimes', 'integer'])
        ->and($rules['is_enabled'])->toBe(['sometimes', 'boolean'])
        ->and($rules['dining_area_id'])->toBe(['required', 'integer'])
        ->and($rules['dining_section_id'])->toBe(['nullable', 'integer']);
});

--------------------------------------------------------------------------------

File: tests\Http\Requests\ReservationRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2355 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\ReservationRequest;

it('returns correct attribute labels for reservation', function(): void {
    $attributes = (new ReservationRequest)->attributes();

    expect($attributes['location_id'])->toBe(lang('igniter.reservation::default.text_restaurant'))
        ->and($attributes['first_name'])->toBe(lang('igniter.reservation::default.label_first_name'))
        ->and($attributes['last_name'])->toBe(lang('igniter.reservation::default.label_last_name'))
        ->and($attributes['email'])->toBe(lang('igniter::admin.label_email'))
        ->and($attributes['telephone'])->toBe(lang('igniter.reservation::default.label_customer_telephone'))
        ->and($attributes['reserve_date'])->toBe(lang('igniter.reservation::default.label_reservation_date'))
        ->and($attributes['reserve_time'])->toBe(lang('igniter.reservation::default.label_reservation_time'))
        ->and($attributes['guest_num'])->toBe(lang('igniter.reservation::default.label_guest'))
        ->and($attributes['comment'])->toBe(lang('igniter.reservation::default.column_comment'));
});

it('validates rules correctly for reservation', function(): void {
    $rules = (new ReservationRequest)->rules();

    expect($rules['location_id'])->toBe(['sometimes', 'required', 'integer'])
        ->and($rules['customer_id'])->toBe(['nullable', 'integer'])
        ->and($rules['first_name'])->toBe(['required_without:customer_id', 'nullable', 'string', 'between:1,48'])
        ->and($rules['last_name'])->toBe(['required_without:customer_id', 'nullable', 'string', 'between:1,48'])
        ->and($rules['email'])->toBe(['required_without:customer_id', 'nullable', 'email:filter', 'max:96'])
        ->and($rules['telephone'])->toBe(['required_without:customer_id', 'nullable', 'sometimes', 'string'])
        ->and($rules['reserve_date'])->toBe(['required', 'date_format:Y-m-d'])
        ->and($rules['reserve_time'])->toBe(['required', 'date_format:H:i'])
        ->and($rules['guest_num'])->toBe(['required', 'integer'])
        ->and($rules['duration'])->toBe(['nullable', 'integer', 'min:0'])
        ->and($rules['tables'])->toBe(['nullable', 'array'])
        ->and($rules['comment'])->toBe(['nullable', 'string']);
});

--------------------------------------------------------------------------------

File: tests\Http\Requests\ReservationSettingsRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1198 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\ReservationSettingsRequest;

it('returns correct attribute labels for reservation settings', function(): void {
    $attributes = (new ReservationSettingsRequest)->attributes();

    expect($attributes['default_reservation_status'])->toBe(lang('igniter.reservation::default.label_default_reservation_status'))
        ->and($attributes['confirmed_reservation_status'])->toBe(lang('igniter.reservation::default.label_confirmed_reservation_status'))
        ->and($attributes['canceled_reservation_status'])->toBe(lang('igniter.reservation::default.label_canceled_reservation_status'));
});

it('validates rules correctly for reservation settings', function(): void {
    $rules = (new ReservationSettingsRequest)->rules();

    expect($rules['reservation_email.*'])->toBe(['required', 'alpha'])
        ->and($rules['default_reservation_status'])->toBe(['required', 'integer'])
        ->and($rules['confirmed_reservation_status'])->toBe(['required', 'integer'])
        ->and($rules['canceled_reservation_status'])->toBe(['required', 'integer']);
});

--------------------------------------------------------------------------------

File: tests\Http\Requests\ReservationStatusRequestTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1376 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Http\Requests;

use Igniter\Reservation\Http\Requests\ReservationStatusRequest;

it('returns correct attribute labels for reservation status', function(): void {
    $attributes = (new ReservationStatusRequest)->attributes();

    expect($attributes['status_id'])->toBe(lang('igniter::admin.label_status'))
        ->and($attributes['comment'])->toBe(lang('igniter::admin.statuses.label_comment'))
        ->and($attributes['notify'])->toBe(lang('igniter::admin.statuses.label_notify'))
        ->and($attributes['assignee_group_id'])->toBe(lang('igniter::admin.statuses.label_assignee_group'))
        ->and($attributes['assignee_id'])->toBe(lang('igniter::admin.statuses.label_assignee'));
});

it('validates rules correctly for reservation status', function(): void {
    $rules = (new ReservationStatusRequest)->rules();

    expect($rules['status_id'])->toBe(['sometimes', 'required', 'integer', 'exists:statuses'])
        ->and($rules['comment'])->toBe(['string', 'max:1500'])
        ->and($rules['notify'])->toBe(['sometimes', 'required', 'boolean'])
        ->and($rules['assignee_group_id'])->toBe(['sometimes', 'required', 'integer', 'exists:admin_user_groups,user_group_id'])
        ->and($rules['assignee_id'])->toBe(['integer', 'exists:admin_users,user_id']);
});

--------------------------------------------------------------------------------

File: tests\Listeners\MaxGuestSizePerTimeslotReachedTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 3011 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Listeners;

use Igniter\Local\Facades\Location as LocationFacade;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Listeners\MaxGuestSizePerTimeslotReached;
use Igniter\Reservation\Models\Reservation;
use Illuminate\Support\Carbon;

beforeEach(function(): void {
    (new MaxGuestSizePerTimeslotReached)->clearInternalCache();
});

it('returns null when guest limit setting is disabled', function(): void {
    $timeslot = new Carbon('2023-12-01 18:00:00');
    $this->travelTo($timeslot);
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => [
            'limit_guests' => 0,
        ],
    ]);
    LocationFacade::setModel($location);

    expect((new MaxGuestSizePerTimeslotReached)->handle($timeslot, 5))->toBeNull();
});

it('returns null when guest limit count is zero', function(): void {
    $timeslot = new Carbon('2023-12-01 18:00:00');
    $this->travelTo($timeslot);
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => [
            'limit_guests' => 1,
            'limit_guests_count' => 0,
        ],
    ]);
    LocationFacade::setModel($location);

    expect((new MaxGuestSizePerTimeslotReached)->handle($timeslot, 5))->toBeNull();
});

it('returns null when guest limit is not exceeded', function(): void {
    $timeslot = new Carbon('2023-12-01 18:00:00');
    $this->travelTo($timeslot);
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => [
            'limit_guests' => 1,
            'limit_guests_count' => 20,
        ],
    ]);
    LocationFacade::setModel($location);

    Reservation::factory()->create([
        'location_id' => 1,
        'reserve_date' => '2023-12-01',
        'reserve_time' => '18:00',
        'guest_num' => 10,
    ]);

    expect((new MaxGuestSizePerTimeslotReached)->handle($timeslot, 5))->toBeNull();
});

it('returns true when guest limit is exceeded', function(): void {
    $timeslot = new Carbon('2023-12-01 18:00:00');
    $this->travelTo($timeslot);
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => [
            'auto_allocate_table' => 0,
            'limit_guests' => 1,
            'limit_guests_count' => 5,
        ],
    ]);
    LocationFacade::setModel($location);

    Reservation::factory()->create([
        'location_id' => $location->getKey(),
        'reserve_date' => '2023-12-01',
        'reserve_time' => '18:00',
        'guest_num' => 5,
    ]);

    $listener = new MaxGuestSizePerTimeslotReached;
    expect($listener->handle($timeslot, 5))->toBeTrue()
        ->and($listener->handle($timeslot, 5))->toBeTrue(); // test cache result
});

--------------------------------------------------------------------------------

File: tests\Listeners\RegistersDashboardCardsTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2400 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Listeners;

use Igniter\Reservation\Listeners\RegistersDashboardCards;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Reservation;

it('returns correct dashboard cards configuration', function(): void {
    $cards = (new RegistersDashboardCards)();

    expect($cards)->toHaveKeys(['reserved_table', 'reserved_guest', 'reservation', 'completed_reservation'])
        ->and($cards['reserved_table']['label'])->toBe('lang:igniter.reservation::default.text_total_reserved_table')
        ->and($cards['reserved_guest']['label'])->toBe('lang:igniter.reservation::default.text_total_reserved_guest')
        ->and($cards['reservation']['label'])->toBe('lang:igniter.reservation::default.text_total_reservation')
        ->and($cards['completed_reservation']['label'])->toBe('lang:igniter.reservation::default.text_total_completed_reservation');
});

it('returns total reserved table sum', function(): void {
    setting()->set(['confirmed_reservation_status' => 1]);

    Reservation::factory()
        ->count(5)
        ->has(DiningTable::factory()->count(5), 'tables')
        ->create([
            'status_id' => 1,
        ]);

    $result = (new RegistersDashboardCards)->getValue('reserved_table', null, null, fn($query) => $query);

    expect($result)->toBe(5);
});

it('returns total reserved guest sum', function(): void {
    setting()->set(['confirmed_reservation_status' => 1]);

    Reservation::factory()->create([
        'status_id' => 1,
        'guest_num' => 20,
    ]);

    $result = (new RegistersDashboardCards)->getValue('reserved_guest', null, null, fn($query) => $query);

    expect($result)->toBe(20);
});

it('returns total reservation sum', function(): void {
    Reservation::factory()->count(10)->create(['status_id' => 1]);

    $result = (new RegistersDashboardCards)->getValue('reservation', null, null, fn($query) => $query);

    expect($result)->toBe(10);
});

it('returns total completed reservation sum', function(): void {
    setting()->set(['confirmed_reservation_status' => 1]);

    Reservation::factory()->count(8)->create(['status_id' => 1]);

    $result = (new RegistersDashboardCards)->getValue('completed_reservation', null, null, fn($query) => $query);

    expect($result)->toBe(8);
});

--------------------------------------------------------------------------------

File: tests\Listeners\SendReservationConfirmationTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 1183 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Listeners;

use Igniter\Reservation\Listeners\SendReservationConfirmation;
use Igniter\Reservation\Models\Reservation;
use Igniter\Reservation\Notifications\ReservationCreatedNotification;
use Mockery;

it('sends reservation confirmation emails to customer, location, and admin', function(): void {
    $model = Mockery::mock(Reservation::class)->makePartial();
    $model->shouldReceive('mailSend')->with('igniter.reservation::mail.reservation', 'customer')->once();
    $model->shouldReceive('mailSend')->with('igniter.reservation::mail.reservation_alert', 'location')->once();
    $model->shouldReceive('mailSend')->with('igniter.reservation::mail.reservation_alert', 'admin')->once();

    $notification = Mockery::mock(ReservationCreatedNotification::class);
    $notification->shouldReceive('make')->andReturnSelf();
    $notification->shouldReceive('subject')->with($model)->andReturnSelf();
    $notification->shouldReceive('broadcast')->once();
    app()->instance(ReservationCreatedNotification::class, $notification);

    (new SendReservationConfirmation)->handle($model);
});

--------------------------------------------------------------------------------

File: tests\Models\Concerns\LocationActionTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 3480 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models\Concerns;

use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Concerns\LocationAction;
use Mockery;

it('returns correct reservation interval', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.time_interval', 0)->andReturn(15);

    expect((new LocationAction($location))->getReservationInterval())->toBe(15);
});

it('returns correct reservation lead time', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.stay_time', 0)->andReturn(60);

    expect((new LocationAction($location))->getReservationLeadTime())->toBe(60);
});

it('returns correct reservation stay time', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.stay_time', 0)->andReturn(90);

    expect((new LocationAction($location))->getReservationStayTime())->toBe(90);
});

it('returns correct minimum reservation guest count', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.min_guest_count', 2)->andReturn(4);

    expect((new LocationAction($location))->getMinReservationGuestCount())->toBe(4);
});

it('returns correct maximum reservation guest count', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.max_guest_count', 20)->andReturn(10);

    expect((new LocationAction($location))->getMaxReservationGuestCount())->toBe(10);
});

it('returns correct minimum reservation advance time', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.min_advance_time', 2)->andReturn(3);

    expect((new LocationAction($location))->getMinReservationAdvanceTime())->toBe(3);
});

it('returns correct maximum reservation advance time', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.max_advance_time', 30)->andReturn(45);

    expect((new LocationAction($location))->getMaxReservationAdvanceTime())->toBe(45);
});

it('returns correct reservation cancellation timeout', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.cancellation_timeout', 0)->andReturn(10);

    expect((new LocationAction($location))->getReservationCancellationTimeout())->toBe(10);
});

it('returns true when auto allocate table is enabled', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.auto_allocate_table', 0)->andReturn(true);

    expect((new LocationAction($location))->shouldAutoAllocateTable())->toBeTrue();
});

it('returns false when auto allocate table is disabled', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $location->shouldReceive('getSettings')->with('booking.auto_allocate_table', 1)->andReturn(false);

    expect((new LocationAction($location))->shouldAutoAllocateTable())->toBeFalse();
});

--------------------------------------------------------------------------------

File: tests\Models\DiningAreaTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6231 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models;

use Igniter\Flame\Exception\FlashException;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Reservation;
use Mockery;

it('returns dropdown options with names', function(): void {
    $diningArea = DiningArea::factory()->create();

    $options = DiningArea::getDropdownOptions()->all();

    expect($options)->toBeArray()
        ->and($options)->toHaveKey($diningArea->id, $diningArea->name);
});

it('returns tables for floor plan', function(): void {
    $diningArea = DiningArea::factory()->create();
    $diningArea->available_tables()->save($diningTable = DiningTable::factory()->create());

    $tables = $diningArea->getTablesForFloorPlan()->all();

    expect($tables)->toBeArray()
        ->and($tables[0])->toHaveKey('id', $diningTable->id);
});

it('returns dining tables with reservation', function(): void {
    $diningArea = DiningArea::factory()->create();
    $diningArea->available_tables()->save($diningTable = DiningTable::factory()->create());
    $reservation = Reservation::factory()->create();
    $reservation->tables()->attach($diningTable);

    $reservations = collect([$reservation]);
    $tables = $diningArea->getDiningTablesWithReservation($reservations)->all();

    expect($tables)->toBeArray()
        ->and($tables[0])->toHaveKey('id', $diningTable->id);
});

it('returns correct dining table count', function(): void {
    $diningArea = Mockery::mock(DiningArea::class)->makePartial();
    $diningArea->shouldReceive('getAttribute')->with('available_tables')->andReturn(collect([1, 2, 3]));

    expect($diningArea->dining_table_count)->toBe(3);
});

it('duplicates dining area with tables', function(): void {
    $diningArea = Mockery::mock(DiningArea::class)->makePartial();
    $diningArea->name = 'Original';
    $diningArea->shouldReceive('replicate')->andReturnSelf();
    $diningArea->shouldReceive('save')->once();
    $diningArea->shouldReceive('getKey')->andReturn(2);

    $table = Mockery::mock(DiningTable::class)->makePartial();
    $table->is_combo = false;
    $table->shouldReceive('replicate')->andReturnSelf();
    $table->shouldReceive('save')->once();
    $table->shouldReceive('setAttribute')->with('dining_area_id', 2)->once();

    $diningArea->shouldReceive('getAttribute')->with('dining_tables')->andReturn(collect([$table]));

    $newDiningArea = $diningArea->duplicate();

    expect($newDiningArea->name)->toBe('Original (copy)');
});

it('creates combo dining table', function(): void {
    $diningArea = DiningArea::factory()->create();
    $table1 = DiningTable::factory()->create([
        'shape' => 'square',
        'dining_area_id' => $diningArea->id,
        'dining_section_id' => 1,
        'min_capacity' => 2,
        'max_capacity' => 4,
    ]);
    $table2 = DiningTable::factory()->create([
        'shape' => 'square',
        'dining_area_id' => $diningArea->id,
        'dining_section_id' => 1,
        'min_capacity' => 2,
        'max_capacity' => 4,
    ]);

    $tables = collect([$table1, $table2]);

    $comboTable = $diningArea->createCombo($tables);

    expect($comboTable->name)->toBe($table1->name.'/'.$table2->name)
        ->and($comboTable->shape)->toBe('square')
        ->and($comboTable->dining_area_id)->toBe($diningArea->id)
        ->and($comboTable->dining_section_id)->toBe(1)
        ->and($comboTable->min_capacity)->toBe(4)
        ->and($comboTable->max_capacity)->toBe(8)
        ->and($comboTable->is_combo)->toBeTrue()
        ->and($comboTable->is_enabled)->toBeTrue()
        ->and($table1->fresh()->parent_id)->toBe($comboTable->id)
        ->and($table2->fresh()->parent_id)->toBe($comboTable->id);
});

it('throws an exception when table already combined', function(): void {
    $diningArea = DiningArea::factory()->create();
    $table1 = DiningTable::factory()->create();
    $table2 = DiningTable::factory()->create();
    $table2->parent()->associate($table1)->save();

    $tables = collect([$table1, $table2]);

    expect(fn() => $diningArea->createCombo($tables))
        ->toThrow(new FlashException(lang('igniter.reservation::default.dining_areas.alert_table_already_combined')));
});

it('throws an exception when combining tables from different sections', function(): void {
    $diningArea = DiningArea::factory()->create();
    $table1 = DiningTable::factory()->create(['dining_section_id' => 1]);
    $table2 = DiningTable::factory()->create(['dining_section_id' => 2]);

    $tables = collect([$table1, $table2]);

    expect(fn() => $diningArea->createCombo($tables))
        ->toThrow(new FlashException(lang('igniter.reservation::default.dining_areas.alert_table_combo_section_mismatch')));
});

it('configures dining area model correctly', function(): void {
    $diningArea = new DiningArea;

    expect(class_uses_recursive($diningArea))
        ->toContain(Locationable::class)
        ->and($diningArea->getTable())->toBe('dining_areas')
        ->and($diningArea->timestamps)->toBeTrue()
        ->and($diningArea->getCasts()['floor_plan'])->toBe('array')
        ->and($diningArea->getMorphClass())->toBe('dining_areas')
        ->and($diningArea->relation['hasMany']['dining_sections'])->toBe([DiningSection::class, 'foreignKey' => 'location_id', 'otherKey' => 'location_id'])
        ->and($diningArea->relation['hasMany']['dining_tables'])->toBe([DiningTable::class, 'delete' => true])
        ->and($diningArea->relation['hasMany']['dining_table_solos'])->toBe([DiningTable::class, 'scope' => 'whereIsNotCombo'])
        ->and($diningArea->relation['hasMany']['dining_table_combos'])->toBe([DiningTable::class, 'scope' => 'whereIsCombo'])
        ->and($diningArea->relation['hasMany']['available_tables'])->toBe([DiningTable::class, 'scope' => 'whereIsRoot'])
       
--------------------------------------------------------------------------------

File: tests\Models\DiningSectionTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2580 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models;

use Igniter\Flame\Database\Builder;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Mockery;

it('returns correct record editor options', function(): void {
    $diningArea = DiningArea::factory()->create();
    DiningSection::factory()->count(5)->create([
        'location_id' => $diningArea->location_id,
    ]);

    expect(DiningSection::make()->getRecordEditorOptions($diningArea)->count())->toBe(5);
});

it('returns correct priority options', function(): void {
    $diningSection = new DiningSection;
    $expectedOptions = [
        lang('igniter.reservation::default.dining_tables.text_priority_0'),
        lang('igniter.reservation::default.dining_tables.text_priority_1'),
        lang('igniter.reservation::default.dining_tables.text_priority_2'),
        lang('igniter.reservation::default.dining_tables.text_priority_3'),
        lang('igniter.reservation::default.dining_tables.text_priority_4'),
        lang('igniter.reservation::default.dining_tables.text_priority_5'),
        lang('igniter.reservation::default.dining_tables.text_priority_6'),
        lang('igniter.reservation::default.dining_tables.text_priority_7'),
        lang('igniter.reservation::default.dining_tables.text_priority_8'),
        lang('igniter.reservation::default.dining_tables.text_priority_9'),
    ];

    expect($diningSection->getPriorityOptions())->toBe($expectedOptions);
});

it('applies where is reservable scope', function(): void {
    $builder = Mockery::mock(Builder::class);
    $builder->shouldReceive('where')->with('is_enabled', 1)->once()->andReturnSelf();

    $diningSection = new DiningSection;
    $diningSection->scopeWhereIsReservable($builder);
});

it('configures dining section model correctly', function(): void {
    $diningSection = new DiningSection;

    expect(class_uses_recursive($diningSection))
        ->toContain(Locationable::class)
        ->and($diningSection->getTable())->toBe('dining_sections')
        ->and($diningSection->timestamps)->toBeFalse()
        ->and($diningSection->relation)->toEqual([
            'belongsTo' => [
                'location' => [Location::class],
            ],
            'hasMany' => [
                'dining_areas' => [DiningArea::class, 'foreignKey' => 'location_id', 'otherKey' => 'location_id'],
            ],
        ]);
});

--------------------------------------------------------------------------------

File: tests\Models\DiningTableTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 5665 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models;

use Igniter\Admin\Models\Status;
use Igniter\Flame\Database\Traits\NestedTree;
use Igniter\Flame\Database\Traits\Sortable;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Reservation;
use Mockery;

it('returns correct dining section id options when dining area exists', function(): void {
    $location = Location::factory()->create();
    $diningArea = DiningArea::factory()->create(['location_id' => $location->getKey()]);
    $diningTable = DiningTable::factory()->create(['dining_area_id' => $diningArea->getKey()]);
    DiningSection::factory()->count(5)->create(['location_id' => $location->getKey()]);

    expect($diningTable->getDiningSectionIdOptions()->count())->toBe(5);
});

it('returns empty dining section id options when dining area does not exist', function(): void {
    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $diningTable->shouldReceive('exists')->andReturn(false);

    expect($diningTable->getDiningSectionIdOptions())->toBe([]);
});

it('returns priority options as an array of strings', function(): void {
    $diningTable = new DiningTable;

    $options = $diningTable->getPriorityOptions();

    expect($options)->toBeArray()
        ->and($options)->toHaveCount(10)
        ->and($options[0])->toBeString();
});

it('returns correct section name attribute', function(): void {
    $diningSection = Mockery::mock(DiningSection::class)->makePartial();
    $diningSection->shouldReceive('getAttribute')->with('name')->andReturn('Main Section');

    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $diningTable->shouldReceive('extendableGet')->with('dining_section')->andReturn($diningSection);

    expect($diningTable->section_name)->toBe('Main Section');
});

it('returns null section name attribute when dining section is null', function(): void {
    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $diningTable->shouldReceive('getAttribute')->with('dining_section')->andReturn(null);

    expect($diningTable->section_name)->toBeNull();
});

it('returns correct floor plan array without reservation', function(): void {
    $diningTable = new DiningTable;
    $diningTable->id = 1;
    $diningTable->name = 'Table1';
    $diningTable->min_capacity = 2;
    $diningTable->max_capacity = 4;
    $diningTable->shape = 'square';
    $diningTable->seat_layout = ['layout'];

    $expectedArray = [
        'id' => 1,
        'name' => 'Table1',
        'description' => '2-4',
        'capacity' => 4,
        'shape' => 'square',
        'seatLayout' => ['layout'],
        'tableColor' => null,
        'seatColor' => null,
        'customerName' => null,
    ];

    expect($diningTable->toFloorPlanArray())->toBe($expectedArray);
});

it('returns correct floor plan array with reservation', function(): void {
    $reservation = new Reservation;
    $reservation->reserve_date = '2023-10-10';
    $reservation->reserve_time = '12:00:00';
    $reservation->duration = 120;
    $reservation->first_name = 'John';
    $reservation->last_name = 'Doe';
    $reservation->setRelation('status', new Status(['status_color' => 'red']));

    $diningTable = new DiningTable;
    $diningTable->id = 1;
    $diningTable->name = 'Table1';
    $diningTable->min_capacity = 2;
    $diningTable->max_capacity = 4;
    $diningTable->shape = 'square';
    $diningTable->seat_layout = ['layout'];

    $expectedArray = [
        'id' => 1,
        'name' => 'Table1',
        'description' => '12:00 pm - 02:00 pm',
        'capacity' => 4,
        'shape' => 'square',
        'seatLayout' => ['layout'],
        'tableColor' => null,
        'seatColor' => 'red',
        'customerName' => 'John Doe',
    ];

    expect($diningTable->toFloorPlanArray($reservation))->toBe($expectedArray);
});

it('configures dining table model correctly', function(): void {
    $diningTable = new DiningTable;

    expect(class_uses_recursive($diningTable))
        ->toContain(Locationable::class)
        ->toContain(NestedTree::class)
        ->toContain(Sortable::class)
        ->and(DiningTable::SORT_ORDER)->toBe('priority')
        ->and($diningTable->getTable())->toBe('dining_tables')
        ->and($diningTable->timestamps)->toBeTrue()
        ->and($diningTable->getMorphClass())->toBe('tables')
        ->and($diningTable->getCasts())->toHaveKeys([
            'min_capacity', 'max_capacity', 'extra_capacity', 'priority', 'is_combo', 'is_enabled', 'seat_layout',
        ])
        ->and($diningTable->relation)->toEqual([
            'belongsTo' => [
                'dining_area' => [DiningArea::class],
                'dining_section' => [DiningSection::class],
            ],
            'belongsToMany' => [
                'reservations' => [Reservation::class, 'table' => 'reservation_tables', 'otherKey' => 'reservation_id'],
            ],
            'hasOneThrough' => [
                'location' => [
                    Location::class,
                    'through' => DiningArea::class,
                    'foreignKey' => 'id',
                    'throughKey' => 'location_id',
                    'otherKey' => 'dining_area_id',
                    'secondOtherKey' => 'location_id',
                ],
            ],
        ]);
});

--------------------------------------------------------------------------------

File: tests\Models\Observers\DiningTableObserverTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2404 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models\Observers;

use Igniter\Flame\Exception\SystemException;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Observers\DiningTableObserver;
use Mockery;

it('fixes tree when saving dining table without left or right values', function(): void {
    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $diningTable->shouldReceive('getRgt')->andReturn(null);
    $diningTable->shouldReceive('getLft')->andReturn(null);
    $diningTable->shouldReceive('fixTree')->once();

    (new DiningTableObserver)->saving($diningTable);
});

it('updates parent name when dining table is saved', function(): void {
    $children = collect([
        Mockery::mock(DiningTable::class)->makePartial(['name' => 'Child1']),
        Mockery::mock(DiningTable::class)->makePartial(['name' => 'Child2']),
    ]);
    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $parent = Mockery::mock(DiningTable::class)->makePartial();
    $parent->children = $children;
    $parent->shouldReceive('saveQuietly')->once();
    $diningTable->shouldReceive('extendableGet')->with('parent_id')->andReturn(1);
    $diningTable->shouldReceive('extendableGet')->with('parent')->andReturn($parent);

    (new DiningTableObserver)->saved($diningTable);
});

it('throws exception when deleting dining table with parent', function(): void {
    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $diningTable->shouldReceive('extendableGet')->with('parent_id')->andReturn(1);

    expect(fn() => (new DiningTableObserver)->deleting($diningTable))
        ->toThrow(SystemException::class);
});

it('saves descendants as root and fixes tree when deleting combo dining table', function(): void {
    $diningTable = Mockery::mock(DiningTable::class)->makePartial();
    $descendant = Mockery::mock(DiningTable::class)->makePartial();
    $diningTable->shouldReceive('extendableGet')->with('is_combo')->andReturnTrue();
    $diningTable->shouldReceive('descendants->each')->andReturnUsing(function($callback) use ($descendant): void {
        $callback($descendant);
    });
    $descendant->shouldReceive('saveAsRoot')->once();
    $diningTable->shouldReceive('refreshNode')->once();

    (new DiningTableObserver)->deleting($diningTable);
});

--------------------------------------------------------------------------------

File: tests\Models\Observers\ReservationObserverTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 4386 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models\Observers;

use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Observers\ReservationObserver;
use Igniter\Reservation\Models\Reservation;
use Igniter\User\Models\Customer;
use Mockery;

it('fills customer details when creating reservation with customer_id', function(): void {
    $customer = Mockery::mock(Customer::class)->makePartial();
    $reservation = Mockery::mock(Reservation::class)->makePartial();

    $customer->shouldReceive('extendableGet')->with('first_name')->andReturn('John');
    $customer->shouldReceive('extendableGet')->with('last_name')->andReturn('Doe');
    $customer->shouldReceive('extendableGet')->with('email')->andReturn('john.doe@example.com');
    $customer->shouldReceive('extendableGet')->with('telephone')->andReturn('1234567890');
    $reservation->shouldReceive('extendableGet')->with('customer_id')->andReturn(1);
    $reservation->shouldReceive('extendableGet')->with('customer')->andReturn($customer);
    $reservation->shouldReceive('generateHash')->andReturn('hash');
    $reservation->shouldReceive('forceFill')->with([
        'hash' => 'hash',
        'ip_address' => '127.0.0.1',
        'user_agent' => 'Mozilla/5.0',
    ])->once();

    request()->headers->set('user-agent', 'Mozilla/5.0');
    request()->headers->set('REMOTE_ADDR', '127.0.0.1');

    (new ReservationObserver)->creating($reservation);

    expect($reservation->first_name)->toBe('John')
        ->and($reservation->last_name)->toBe('Doe')
        ->and($reservation->email)->toBe('john.doe@example.com')
        ->and($reservation->telephone)->toBe('1234567890');
});

it('fills default values when creating reservation without customer_id', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $reservation->shouldReceive('extendableGet')->with('customer_id')->andReturnNull();
    $reservation->shouldReceive('generateHash')->andReturn('hash');
    $reservation->shouldReceive('forceFill')->with([
        'hash' => 'hash',
        'ip_address' => '127.0.0.1',
        'user_agent' => 'Mozilla/5.0',
    ])->once();

    request()->headers->set('user-agent', 'Mozilla/5.0');
    request()->headers->set('REMOTE_ADDR', '127.0.0.1');

    (new ReservationObserver)->creating($reservation);

    expect($reservation->first_name)->toBeNull()
        ->and($reservation->last_name)->toBeNull()
        ->and($reservation->email)->toBeNull()
        ->and($reservation->telephone)->toBeNull();
});

it('restores purged values and adds reservation tables when saved', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $location = Mockery::mock(Location::class);

    $reservation->shouldReceive('restorePurgedValues')->once();
    $reservation->shouldReceive('getAttributes')->andReturn(['tables' => ['table1', 'table2']]);
    $reservation->shouldReceive('addReservationTables')->with(['table1', 'table2'])->once();
    $reservation->shouldReceive('reloadRelations')->with('location')->once();
    $reservation->shouldReceive('tables->count')->andReturn(0);
    $reservation->shouldReceive('autoAssignTable')->once();
    $reservation->shouldReceive('extendableGet')->with('location')->andReturn($location);
    $location->shouldReceive('shouldAutoAllocateTable')->andReturn(true);

    (new ReservationObserver)->saved($reservation);
});

it('does not assign table if auto allocate is disabled', function(): void {
    $reservation = Mockery::mock(Reservation::class)->makePartial();
    $location = Mockery::mock(Location::class);

    $reservation->shouldReceive('restorePurgedValues')->once();
    $reservation->shouldReceive('getAttributes')->andReturn(['tables' => ['table1', 'table2']]);
    $reservation->shouldReceive('addReservationTables')->with(['table1', 'table2'])->once();
    $reservation->shouldReceive('reloadRelations')->with('location')->once();
    $reservation->shouldReceive('tables->count')->andReturn(0);
    $reservation->shouldNotReceive('autoAssignTable');
    $location->shouldReceive('shouldAutoAllocateTable')->andReturn(false);
    $reservation->shouldReceive('extendableGet')->with('location')->andReturn($location);

    (new ReservationObserver)->saved($reservation);
});

--------------------------------------------------------------------------------

File: tests\Models\ReservationTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 22409 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models;

use Carbon\Carbon;
use Igniter\Admin\Models\Concerns\GeneratesHash;
use Igniter\Admin\Models\Concerns\LogsStatusHistory;
use Igniter\Admin\Models\Status;
use Igniter\Flame\Database\Traits\Purgeable;
use Igniter\Local\Models\Concerns\Locationable;
use Igniter\Local\Models\Location;
use Igniter\Reservation\Events\ReservationCanceledEvent;
use Igniter\Reservation\Models\DiningArea;
use Igniter\Reservation\Models\DiningSection;
use Igniter\Reservation\Models\DiningTable;
use Igniter\Reservation\Models\Reservation;
use Igniter\System\Models\Concerns\SendsMailTemplate;
use Igniter\User\Models\Concerns\Assignable;
use Igniter\User\Models\Customer;
use Igniter\User\Models\User;
use Igniter\User\Models\UserGroup;
use Illuminate\Support\Facades\Event;
use Mockery;

it('returns correct customer name', function(): void {
    $reservation = new Reservation([
        'first_name' => 'John',
        'last_name' => 'Doe',
    ]);

    expect($reservation->customer_name)->toBe('John Doe');
});

it('calculates correct reservation end time with duration', function(): void {
    $reservation = new Reservation([
        'reserve_date' => '2023-10-10',
        'reserve_time' => '12:00:00',
    ]);
    $reservation->duration = 120;

    expect($reservation->reservation_end_datetime->toDateTimeString())->toBe('2023-10-10 14:00:00');
});

it('calculates correct reservation end time without duration', function(): void {
    $reservation = new Reservation([
        'reserve_date' => '2023-10-10',
        'reserve_time' => '12:00:00',
    ]);

    expect($reservation->reservation_end_datetime->toDateTimeString())->toBe('2023-10-10 23:59:59');
});

it('returns null reservation end time when missing date time', function(): void {
    $reservation = new Reservation([
        'reserve_date' => null,
        'reserve_time' => null,
    ]);

    expect($reservation->reservation_end_datetime)->toBeNull();
});

it('returns correct table name when tables are assigned', function(): void {
    $table1 = Mockery::mock(DiningTable::class)->makePartial();
    $table2 = Mockery::mock(DiningTable::class)->makePartial();
    $table1->name = 'Table1';
    $table1->min_capacity = 2;
    $table1->max_capacity = 4;
    $table1->extra_capacity = 0;
    $table2->name = 'Table2';
    $table2->min_capacity = 4;
    $table2->max_capacity = 8;
    $table2->extra_capacity = 2;

    $reservation = new Reservation;
    $reservation->setRelation('tables', collect([$table1, $table2]));

    expect($reservation->table_name)->toBe('Table1 / 2 - 4 (0+), Table2 / 4 - 8 (2+)');
});

it('returns empty table name when no tables are assigned', function(): void {
    $reservation = new Reservation;
    $reservation->setRelation('tables', collect());

    expect($reservation->table_name)->toBe('');
});

it('sets location stay time as default duration when null', function(): void {
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => ['stay_time' => 120],
    ]);
    $reservation = Reservation::factory()->create([
        'location_id' => $location->getKey(),
    ]);

    $reservation->duration = null;

    expect($reservation->duration)->toBe(120);
});

it('returns correct occasion attribute', function(): void {
    $reservation = new Reservation;
    $reservation->occasion_id = 1;

    expect($reservation->occasion)->toBe('birthday');
});

it('returns true if reservation is completed', function(): void {
    $reservation = Reservation::factory()->create();
    $reservation->addStatusHistory(setting('confirmed_reservation_status'));

    $result = $reservation->isCompleted();

    expect($result)->toBeTrue();
});

it('returns true if reservation is canceled', function(): void {
    $reservation = Reservation::factory()->create();
    $reservation->addStatusHistory(setting('canceled_reservation_status'));

    $result = $reservation->isCanceled();

    expect($result)->toBeTrue();
});

it('returns true if reservation is cancelable', function(): void {
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => ['cancellation_timeout' => 60],
    ]);
    $reservation = Reservation::factory()->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->addDay(),
        'reserve_time' => now()->addDay()->toTimeString(),
    ]);

    $result = $reservation->isCancelable();

    expect($result)->toBeTrue();
});

it('returns false if reservation is not cancelable due to timeout', function(): void {
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => ['cancellation_timeout' => 0],
    ]);
    $reservation = Reservation::factory()->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->addMinutes(30),
        'reserve_time' => now()->addMinutes(30)->toTimeString(),
    ]);

    $result = $reservation->isCancelable();

    expect($result)->toBeFalse();
});

it('returns false if reservation is not cancelable due to past date', function(): void {
    $location = Location::factory()->create();
    $location->settings()->create([
        'item' => 'booking',
        'data' => ['cancellation_timeout' => 60],
    ]);
    $reservation = Reservation::factory()->create([
        'location_id' => $location->getKey(),
        'reserve_date' => now()->subDay(),
        'reserve_time' => now()->subDay()->toTimeString(),
    ]);

    $result = $reservation->isCancelable();

    expect($result)->toBeFalse();
});

it('marks reservation as canceled and dispatches event', function(): void {
    Event::fake();
    $reservation = Reservation::factory()->create(['status_id' => 1]);

    $result = $reservation->markAsCanceled();

    expect($result)->toBeTrue()
        ->and($reservation->fresh()->status_id)->toBe((int)setting('c
--------------------------------------------------------------------------------

File: tests\Models\Scopes\DiningTableScopeTest.php
Comments: Truncated to 6000 bytes due to size > 6000
Mime Type: application/octet-stream
Size: 6676 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models\Scopes;

use Carbon\Carbon;
use Igniter\Flame\Database\Builder;
use Igniter\Reservation\Models\Reservation;
use Igniter\Reservation\Models\Scopes\DiningTableScope;
use Mockery;

beforeEach(function(): void {
    $this->scope = new DiningTableScope;
    $this->builder = Mockery::mock(Builder::class);
});

it('adds reservable scope with all options', function(): void {
    $options = [
        'dateTime' => '2023-10-10 12:00:00',
        'date' => '2023-10-10',
        'locationId' => 1,
        'guestNum' => 4,
    ];
    $this->builder->shouldReceive('whereIsReservable')->once()->andReturnSelf();
    $this->builder->shouldReceive('whereIsAvailableOn')->with('2023-10-10 12:00:00', 15)->once()->andReturnSelf();
    $this->builder->shouldReceive('whereIsAvailableForDate')->with('2023-10-10')->once()->andReturnSelf();
    $this->builder->shouldReceive('whereIsAvailableAt')->with(1)->once()->andReturnSelf();
    $this->builder->shouldReceive('whereCanAccommodate')->with(4)->once()->andReturnSelf();
    $this->builder->shouldReceive('orderBy')->with('dining_sections.priority', 'desc')->once()->andReturnSelf();
    $this->builder->shouldReceive('orderBy')->with('dining_tables.priority', 'desc')->once()->andReturnSelf();
    $this->builder->shouldReceive('getModel->fireEvent')->with('model.extendDiningTableReservableQuery', [$this->builder, $options])->once();

    $addReservable = $this->scope->addReservable();
    $addReservable($this->builder, $options);
});

it('adds where is reservable scope', function(): void {
    $this->builder->shouldReceive('whereIsRoot')->once()->andReturnSelf();
    $this->builder->shouldReceive('where')->with('dining_tables.is_enabled', 1)->once()->andReturnSelf();
    $this->builder->shouldReceive('leftJoin')->with('dining_sections', Mockery::on(function($callback): true {
        $join = Mockery::mock('alias:JoinClause');
        $join->shouldReceive('on')->with('dining_sections.id', '=', 'dining_tables.dining_section_id')->once()->andReturnSelf();
        $join->shouldReceive('where')->with('dining_sections.is_enabled', 1)->once();
        $callback($join);

        return true;
    }))->once()->andReturnSelf();

    $addWhereIsReservable = $this->scope->addWhereIsReservable();
    $addWhereIsReservable($this->builder);
});

it('adds where is combo scope', function(): void {
    $this->builder->shouldReceive('where')->with('is_combo', 1)->once()->andReturnSelf();

    $addWhereIsCombo = $this->scope->addWhereIsCombo();
    $addWhereIsCombo($this->builder);
});

it('adds where is not combo scope', function(): void {
    $this->builder->shouldReceive('where')->with('is_combo', '!=', 1)->once()->andReturnSelf();

    $addWhereIsNotCombo = $this->scope->addWhereIsNotCombo();
    $addWhereIsNotCombo($this->builder);
});

it('adds where is available at scope', function(): void {
    $this->builder->shouldReceive('join')->with('dining_areas', Mockery::on(function($callback): true {
        $join = Mockery::mock('alias:JoinClause');
        $join->shouldReceive('on')->with('dining_areas.id', '=', 'dining_tables.dining_area_id')->once()->andReturnSelf();
        $join->shouldReceive('where')->with('dining_areas.location_id', 1)->once();
        $callback($join);

        return true;
    }))->once()->andReturnSelf();

    $addWhereIsAvailableAt = $this->scope->addWhereIsAvailableAt();
    $addWhereIsAvailableAt($this->builder, 1);
});

it('adds where is available for date scope', function(): void {
    $this->builder->shouldReceive('whereDoesntHave')->with('reservations', Mockery::on(function($callback): true {
        $subBuilder = Mockery::mock(Builder::class);
        $subBuilder->shouldReceive('where')->with('reserve_date', '2023-10-10')->once()->andReturnSelf();
        $subBuilder->shouldReceive('whereNotIn')->with('status_id', [0, setting('canceled_reservation_status')])->once();
        $callback($subBuilder);

        return true;
    }))->once()->andReturnSelf();

    $addWhereIsAvailableForDate = $this->scope->addWhereIsAvailableForDate();
    $addWhereIsAvailableForDate($this->builder, '2023-10-10');
});

it('adds where is available on scope', function(): void {
    $duration = 15;
    $dateTime = Carbon::parse('2023-10-10 12:30:00')->toDateTimeString();
    $this->builder->shouldReceive('whereDoesntHave')->with('reservations', Mockery::on(function($callback) use ($dateTime): true {
        $subBuilder = Mockery::mock(Builder::class);
        $subBuilder->shouldReceive('where')->with(Mockery::on(function($callback) use ($dateTime): true {
            $subBuilder = Mockery::mock(Builder::class);
            $subBuilder->shouldReceive('whereBetweenStayTime')->with(Mockery::on(fn($dateTime) => $dateTime->eq('2023-10-10 12:31:00')))->once()->andReturnSelf();
            $callback($subBuilder);

            return true;
        }))->andReturnSelf();
        $subBuilder->shouldReceive('orWhere')->with(Mockery::on(function($callback) use ($dateTime): true {
            $subBuilder = Mockery::mock(Builder::class);
            $subBuilder->shouldReceive('whereBetweenStayTime')->with(Mockery::on(fn($dateTime) => $dateTime->eq('2023-10-10 12:44:00')))->andReturnSelf();
            $callback($subBuilder);

            return true;
        }))->andReturnSelf();
        $subBuilder->shouldReceive('whereNotIn')->with('status_id', [0, setting('canceled_reservation_status')])->once();
        $callback($subBuilder);

        return true;
    }))->once()->andReturnSelf();

    $addWhereIsAvailableOn = $this->scope->addWhereIsAvailableOn();
    $addWhereIsAvailableOn($this->builder, $dateTime, $duration);
});

it('adds where can accommodate scope', function(): void {
    $this->builder->shouldReceive('where')->with('min_capacity', '<=', 4)->once()->andReturnSelf();
    $this->builder->shouldReceive('where')->with('max_capacity', '>=', 4)->once()->andReturnSelf();

    $addWhereCanAccommodate = $this->sco
--------------------------------------------------------------------------------

File: tests\Models\Scopes\ReservationScopeTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 3889 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Models\Scopes;

use Igniter\Flame\Database\Builder;
use Igniter\Reservation\Models\Scopes\ReservationScope;
use Mockery;

beforeEach(function(): void {
    $this->scope = new ReservationScope;
    $this->builder = Mockery::mock(Builder::class);
});

it('applies date time filter with valid range', function(): void {
    $this->builder->shouldReceive('whereBetweenReservationDateTime')
        ->with('2023-10-10 12:00:00', '2023-10-10 14:00:00')
        ->once()
        ->andReturnSelf();

    $applyDateTimeFilter = $this->scope->addApplyDateTimeFilter();
    $applyDateTimeFilter($this->builder, ['startAt' => '2023-10-10 12:00:00', 'endAt' => '2023-10-10 14:00:00']);
});

it('applies date time filter with missing range', function(): void {
    $this->travelTo('2023-10-10 12:00:00');

    $this->builder->shouldReceive('whereBetweenReservationDateTime')
        ->with('2023-10-10 12:00:00', '2023-10-10 12:00:00')
        ->once()
        ->andReturnSelf();

    $applyDateTimeFilter = $this->scope->addApplyDateTimeFilter();
    $applyDateTimeFilter($this->builder, []);
});

it('applies where between reservation date time', function(): void {
    $this->builder->shouldReceive('whereRaw')
        ->with('ADDTIME(reserve_date, reserve_time) between ? and ?', ['2023-10-10 12:00:00', '2023-10-10 14:00:00'])
        ->once()
        ->andReturnSelf();

    $whereBetweenReservationDateTime = $this->scope->addWhereBetweenReservationDateTime();
    $whereBetweenReservationDateTime($this->builder, '2023-10-10 12:00:00', '2023-10-10 14:00:00');
});

it('applies where between date time', function(): void {
    $this->builder->shouldReceive('whereRaw')
        ->with('? between DATE_SUB(ADDTIME(reserve_date, reserve_time), INTERVAL 2 MINUTE) and DATE_ADD(ADDTIME(reserve_date, reserve_time), INTERVAL duration MINUTE)', ['2023-10-10 12:00:00'])
        ->once()
        ->andReturnSelf();

    $whereBetweenStayTime = $this->scope->addWhereBetweenDate();
    $whereBetweenStayTime($this->builder, '2023-10-10 12:00:00');
});

it('applies where between stay time', function(): void {
    $this->builder->shouldReceive('whereRaw')
        ->with('? between DATE_SUB(ADDTIME(reserve_date, reserve_time), INTERVAL 2 MINUTE) and DATE_ADD(ADDTIME(reserve_date, reserve_time), INTERVAL duration MINUTE)', ['2023-10-10 12:00:00'])
        ->once()
        ->andReturnSelf();

    $whereBetweenStayTime = $this->scope->addWhereBetweenStayTime();
    $whereBetweenStayTime($this->builder, '2023-10-10 12:00:00');
});

it('applies where not between stay time', function(): void {
    $this->builder->shouldReceive('whereRaw')
        ->with('? not between DATE_SUB(ADDTIME(reserve_date, reserve_time), INTERVAL (duration - 2) MINUTE) and DATE_ADD(ADDTIME(reserve_date, reserve_time), INTERVAL duration MINUTE)', ['2023-10-10 12:00:00'])
        ->once()
        ->andReturnSelf();

    $whereNotBetweenStayTime = $this->scope->addWhereNotBetweenStayTime();
    $whereNotBetweenStayTime($this->builder, '2023-10-10 12:00:00');
});

it('applies where has dining area', function(): void {
    $this->builder->shouldReceive('whereHas')
        ->with('tables', Mockery::on(function($callback): true {
            $query = Mockery::mock(Builder::class);
            $query->shouldReceive('where')
                ->with('dining_tables.dining_area_id', 1)
                ->once();
            $callback($query);

            return true;
        }))
        ->once()
        ->andReturnSelf();
    $this->builder->shouldReceive('orDoesntHave')
        ->with('tables')
        ->once()
        ->andReturnSelf();

    $whereHasDiningArea = $this->scope->addWhereHasDiningArea();
    $whereHasDiningArea($this->builder, 1);
});

--------------------------------------------------------------------------------

File: tests\Notifications\ReservationCreatedNotificationTest.php
Comments: Included
Mime Type: application/octet-stream
Size: 2560 bytes
Content:
<?php

declare(strict_types=1);

namespace Igniter\Reservation\Tests\Notifications;

use Igniter\Local\Models\Location;
use Igniter\Reservation\Models\Reservation;
use Igniter\Reservation\Notifications\ReservationCreatedNotification;
use Igniter\User\Models\User;
use Mockery;

it('returns enabled users with location', function(): void {
    $location = Mockery::mock(Location::class)->makePartial();
    $subject = Mockery::mock(Reservation::class)->makePartial();
    $notification = Mockery::mock(ReservationCreatedNotification::class)->makePartial();

    $location->shouldReceive('getKey')->andReturn(1);
    $subject->location = $location;
    $notification->subject($subject);

    User::factory()->count(2)->create(['status' => true]);

    expect(count($notification->getRecipients()))->toBe(2);
});

it('returns correct notification title', function(): void {
    $notification = new ReservationCreatedNotification;

    expect($notification->getTitle())->toBe(lang('igniter.reservation::default.notify_reservation_created_title'));
});

it('returns correct notification URL with subject', function(): void {
    $subject = Mockery::mock(Reservation::class);
    $notification = Mockery::mock(ReservationCreatedNotification::class)->makePartial();

    $subject->shouldReceive('getKey')->andReturn(1);
    $notification->subject($subject);

    expect($notification->getUrl())->toBe(admin_url('reservations/edit/1'));
});

it('returns correct notification URL without subject', function(): void {
    $notification = new ReservationCreatedNotification;

    expect($notification->getUrl())->toBe(admin_url('reservations'));
});

it('returns correct notification message', function(): void {
    $subject = Mockery::mock(Reservation::class)->makePartial();
    $notification = Mockery::mock(ReservationCreatedNotification::class)->makePartial();

    $subject->shouldReceive('getAttribute')->with('customer_name')->andReturn('John Doe');
    $notification->subject($subject);

    expect($notification->getMessage())->toBe(sprintf(lang('igniter.reservation::default.notify_reservation_created'), 'John Doe'));
});

it('returns correct notification icon', function(): void {
    $notification = new ReservationCreatedNotification;

    expect($notification->getIcon())->toBe('fa-chair');
});

it('returns correct notification alias', function(): void {
    $notification = new ReservationCreatedNotification;

    expect($notification->getAlias())->toBe('reservation-created');
});

--------------------------------------------------------------------------------

File: tests\Pest.php
Comments: Included
Mime Type: application/octet-stream
Size: 267 bytes
Content:
<?php

declare(strict_types=1);

use Igniter\User\Models\User;
use SamPoyigi\Testbench\TestCase;

uses(TestCase::class)->in(__DIR__);

function actingAsSuperUser()
{
    return test()->actingAs(User::factory()->superUser()->create(), 'igniter-admin');
}

--------------------------------------------------------------------------------

